<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::io::MessageIterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="namespacevg_1_1io.html">io</a></li><li class="navelem"><a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1io_1_1MessageIterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::io::MessageIterator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;message_iterator.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ac914a651c928eedea34171366c9f62e8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#ac914a651c928eedea34171366c9f62e8">TaggedMessage</a> = pair&lt; string, unique_ptr&lt; string &gt; &gt;</td></tr>
<tr class="separator:ac914a651c928eedea34171366c9f62e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a44eabe49bb3f28067f8ba3396915ee64"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a44eabe49bb3f28067f8ba3396915ee64">MessageIterator</a> (istream &amp;in, bool <a class="el" href="classvg_1_1io_1_1MessageIterator.html#af3f1540514c644f1d01212d515f603e6">verbose</a>=false, size_t thread_count=0)</td></tr>
<tr class="separator:a44eabe49bb3f28067f8ba3396915ee64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ddb87951881f58221acd0a1beeb32f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#ae7ddb87951881f58221acd0a1beeb32f">MessageIterator</a> (unique_ptr&lt; <a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a> &gt; &amp;&amp;bgzf, bool <a class="el" href="classvg_1_1io_1_1MessageIterator.html#af3f1540514c644f1d01212d515f603e6">verbose</a>=false)</td></tr>
<tr class="memdesc:ae7ddb87951881f58221acd0a1beeb32f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvg_1_1Constructor.html">Constructor</a> to wrap an existing BGZF.  <a href="classvg_1_1io_1_1MessageIterator.html#ae7ddb87951881f58221acd0a1beeb32f">More...</a><br /></td></tr>
<tr class="separator:ae7ddb87951881f58221acd0a1beeb32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b16972d489742f42922fd9cb9b85af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a46b16972d489742f42922fd9cb9b85af">MessageIterator</a> ()=default</td></tr>
<tr class="memdesc:a46b16972d489742f42922fd9cb9b85af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for an end iterator.  <a href="classvg_1_1io_1_1MessageIterator.html#a46b16972d489742f42922fd9cb9b85af">More...</a><br /></td></tr>
<tr class="separator:a46b16972d489742f42922fd9cb9b85af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bd6f7d8acd6b65d86ace13aae12a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#ac914a651c928eedea34171366c9f62e8">TaggedMessage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#af9bd6f7d8acd6b65d86ace13aae12a49">operator*</a> ()</td></tr>
<tr class="separator:af9bd6f7d8acd6b65d86ace13aae12a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bde69631cd194d596192908e5a70f0a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1io_1_1MessageIterator.html#ac914a651c928eedea34171366c9f62e8">TaggedMessage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a1bde69631cd194d596192908e5a70f0a">operator*</a> () const</td></tr>
<tr class="separator:a1bde69631cd194d596192908e5a70f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89872d57d9e7d9e49f38b6700e40c99d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a89872d57d9e7d9e49f38b6700e40c99d">operator++</a> ()</td></tr>
<tr class="memdesc:a89872d57d9e7d9e49f38b6700e40c99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place pre-increment to advance the iterator.  <a href="classvg_1_1io_1_1MessageIterator.html#a89872d57d9e7d9e49f38b6700e40c99d">More...</a><br /></td></tr>
<tr class="separator:a89872d57d9e7d9e49f38b6700e40c99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870adfdc044f57202d26d5fb2109b425"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a870adfdc044f57202d26d5fb2109b425">operator==</a> (const <a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> &amp;other) const</td></tr>
<tr class="separator:a870adfdc044f57202d26d5fb2109b425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a23c45ab954ce158faec0b8935cd90"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#ad6a23c45ab954ce158faec0b8935cd90">operator!=</a> (const <a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> &amp;other) const</td></tr>
<tr class="separator:ad6a23c45ab954ce158faec0b8935cd90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbec4e2b7376ae5ca8bbd4e05d9103a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#abcbec4e2b7376ae5ca8bbd4e05d9103a">has_current</a> () const</td></tr>
<tr class="memdesc:abcbec4e2b7376ae5ca8bbd4e05d9103a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if dereferencing the iterator will produce a valid value, and false otherwise.  <a href="classvg_1_1io_1_1MessageIterator.html#abcbec4e2b7376ae5ca8bbd4e05d9103a">More...</a><br /></td></tr>
<tr class="separator:abcbec4e2b7376ae5ca8bbd4e05d9103a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ccacd8648e7517083bfccc4676ba9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#ab4ccacd8648e7517083bfccc4676ba9a">advance</a> ()</td></tr>
<tr class="separator:ab4ccacd8648e7517083bfccc4676ba9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97d50a333e4f27419f0d661e8669774"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#ac914a651c928eedea34171366c9f62e8">TaggedMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#ab97d50a333e4f27419f0d661e8669774">take</a> ()</td></tr>
<tr class="memdesc:ab97d50a333e4f27419f0d661e8669774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the current item, which must exist, and advance the iterator to the next one.  <a href="classvg_1_1io_1_1MessageIterator.html#ab97d50a333e4f27419f0d661e8669774">More...</a><br /></td></tr>
<tr class="separator:ab97d50a333e4f27419f0d661e8669774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc6ab71583004ebdeb7aa24553817936"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#afc6ab71583004ebdeb7aa24553817936">tell_group</a> () const</td></tr>
<tr class="separator:afc6ab71583004ebdeb7aa24553817936"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a1561c82f55827a208b2bea5e8da71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a97a1561c82f55827a208b2bea5e8da71">seek_group</a> (int64_t virtual_offset)</td></tr>
<tr class="separator:a97a1561c82f55827a208b2bea5e8da71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac9b3fff8dbbff744fe1ff60805af1c20"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#ac9b3fff8dbbff744fe1ff60805af1c20">sniff_tag</a> (istream &amp;stream)</td></tr>
<tr class="separator:ac9b3fff8dbbff744fe1ff60805af1c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aabd024a7358bae988de897aebff39645"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#aabd024a7358bae988de897aebff39645">sniff_tag</a> (::google::protobuf::io::ZeroCopyInputStream &amp;stream)</td></tr>
<tr class="separator:aabd024a7358bae988de897aebff39645"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88ac04ab7cbb8245a86d21a71a5dd76"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; <a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a>, <a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#af88ac04ab7cbb8245a86d21a71a5dd76">range</a> (istream &amp;in)</td></tr>
<tr class="memdesc:af88ac04ab7cbb8245a86d21a71a5dd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterators that act like begin() and end() for a stream containing messages.  <a href="classvg_1_1io_1_1MessageIterator.html#af88ac04ab7cbb8245a86d21a71a5dd76">More...</a><br /></td></tr>
<tr class="separator:af88ac04ab7cbb8245a86d21a71a5dd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5b2b881e4032fb2ecfa8da35ad13e602"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a5b2b881e4032fb2ecfa8da35ad13e602">MAX_MESSAGE_SIZE</a> = 1000000000</td></tr>
<tr class="memdesc:a5b2b881e4032fb2ecfa8da35ad13e602"><td class="mdescLeft">&#160;</td><td class="mdescRight">We refuse to serialize individual messages longer than this size.  <a href="classvg_1_1io_1_1MessageIterator.html#a5b2b881e4032fb2ecfa8da35ad13e602">More...</a><br /></td></tr>
<tr class="separator:a5b2b881e4032fb2ecfa8da35ad13e602"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a4b3ba16717c1900a0638518bd33a4a59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a4b3ba16717c1900a0638518bd33a4a59">handle</a> (bool ok, int64_t group_virtual_offset=0, int64_t message_virtual_offset=0)</td></tr>
<tr class="separator:a4b3ba16717c1900a0638518bd33a4a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a698864a67e1e721c06a97875f6cbcbde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#ac914a651c928eedea34171366c9f62e8">TaggedMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a698864a67e1e721c06a97875f6cbcbde">value</a></td></tr>
<tr class="separator:a698864a67e1e721c06a97875f6cbcbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc663d4448fe1b213d1c2e9ec64b3bb"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#affc663d4448fe1b213d1c2e9ec64b3bb">previous_tag</a></td></tr>
<tr class="separator:affc663d4448fe1b213d1c2e9ec64b3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34611c431fac53c556d57036cee7e4fe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a34611c431fac53c556d57036cee7e4fe">group_count</a></td></tr>
<tr class="separator:a34611c431fac53c556d57036cee7e4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a47479856b6bb8d6fe3c943519d83d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#ab2a47479856b6bb8d6fe3c943519d83d">group_idx</a></td></tr>
<tr class="separator:ab2a47479856b6bb8d6fe3c943519d83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae569fd7dc6129edc5e5dac52b1a67f84"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#ae569fd7dc6129edc5e5dac52b1a67f84">group_vo</a></td></tr>
<tr class="separator:ae569fd7dc6129edc5e5dac52b1a67f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f58abce5de3c8f71a82e689c0170c49"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a1f58abce5de3c8f71a82e689c0170c49">item_vo</a></td></tr>
<tr class="separator:a1f58abce5de3c8f71a82e689c0170c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7102e7dfdf1fbcfcd0b037eb39b8d21f"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; <a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a7102e7dfdf1fbcfcd0b037eb39b8d21f">bgzip_in</a></td></tr>
<tr class="memdesc:a7102e7dfdf1fbcfcd0b037eb39b8d21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since these streams can't be copied or moved, we wrap ours in a uniqueptr_t so we can be moved.  <a href="classvg_1_1io_1_1MessageIterator.html#a7102e7dfdf1fbcfcd0b037eb39b8d21f">More...</a><br /></td></tr>
<tr class="separator:a7102e7dfdf1fbcfcd0b037eb39b8d21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f1540514c644f1d01212d515f603e6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#af3f1540514c644f1d01212d515f603e6">verbose</a> = false</td></tr>
<tr class="memdesc:af3f1540514c644f1d01212d515f603e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set this to true to print messages about what is being decoded.  <a href="classvg_1_1io_1_1MessageIterator.html#af3f1540514c644f1d01212d515f603e6">More...</a><br /></td></tr>
<tr class="separator:af3f1540514c644f1d01212d515f603e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Iterator over messages in VG-format files. Yields pairs of string tag and message data. Also supports seeking and telling at the group level in bgzip files. Cannot be copied, but can be moved.</p>
<p>TODO: Right now we always copy all messages into an internal buffer. We should only do that if the message contents are actually accessed, with some kind of lazy fake string that evaluates on string conversion. Then we could more efficiently skip stuff with the wrong tag. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="ac914a651c928eedea34171366c9f62e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac914a651c928eedea34171366c9f62e8">&#9670;&nbsp;</a></span>TaggedMessage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1io_1_1MessageIterator.html#ac914a651c928eedea34171366c9f62e8">vg::io::MessageIterator::TaggedMessage</a> =  pair&lt;string, unique_ptr&lt;string&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents a pair of a tag value and some message data. If there is no valid tag for a group, as given in the <a class="el" href="classvg_1_1io_1_1Registry.html">Registry</a>, the tag will be "". If there is a tag but no messages in its group, the data pointer will be null. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a44eabe49bb3f28067f8ba3396915ee64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44eabe49bb3f28067f8ba3396915ee64">&#9670;&nbsp;</a></span>MessageIterator() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::io::MessageIterator::MessageIterator </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thread_count</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classvg_1_1Constructor.html">Constructor</a> to wrap a stream. If thread_count is more than 1, enables multi-threaded BGZF decoding, in which case no method on the stream may be called by anyone else until the <a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> is destroyed! </p>

</div>
</div>
<a id="ae7ddb87951881f58221acd0a1beeb32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7ddb87951881f58221acd0a1beeb32f">&#9670;&nbsp;</a></span>MessageIterator() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::io::MessageIterator::MessageIterator </td>
          <td>(</td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>bgzf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classvg_1_1Constructor.html">Constructor</a> to wrap an existing BGZF. </p>

</div>
</div>
<a id="a46b16972d489742f42922fd9cb9b85af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46b16972d489742f42922fd9cb9b85af">&#9670;&nbsp;</a></span>MessageIterator() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::io::MessageIterator::MessageIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor for an end iterator. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab4ccacd8648e7517083bfccc4676ba9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ccacd8648e7517083bfccc4676ba9a">&#9670;&nbsp;</a></span>advance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::advance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advance the iterator to the next message, or the end if this was the last message. Basically the same as ++. </p>

</div>
</div>
<a id="a4b3ba16717c1900a0638518bd33a4a59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b3ba16717c1900a0638518bd33a4a59">&#9670;&nbsp;</a></span>handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::handle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>group_virtual_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>message_virtual_offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make sure the given Protobuf-library bool return value is true, and fail otherwise with a message. Reports the virtual offset of the invalid group and/or message </p>

</div>
</div>
<a id="abcbec4e2b7376ae5ca8bbd4e05d9103a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcbec4e2b7376ae5ca8bbd4e05d9103a">&#9670;&nbsp;</a></span>has_current()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::has_current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if dereferencing the iterator will produce a valid value, and false otherwise. </p>

</div>
</div>
<a id="ad6a23c45ab954ce158faec0b8935cd90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a23c45ab954ce158faec0b8935cd90">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if two iterators are not equal. Since you can only have one on a stream, this only has two equality classes: iterators that have hit the end, and iterators that haven't. </p>

</div>
</div>
<a id="af9bd6f7d8acd6b65d86ace13aae12a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9bd6f7d8acd6b65d86ace13aae12a49">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current item. Caller may move it away. Only legal to call if we are not an end iterator. </p>

</div>
</div>
<a id="a1bde69631cd194d596192908e5a70f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bde69631cd194d596192908e5a70f0a">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvg_1_1io_1_1MessageIterator.html#ac914a651c928eedea34171366c9f62e8">TaggedMessage</a>&amp; vg::io::MessageIterator::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current item when we are const. Only legal to call if we are not an end iterator. </p>

</div>
</div>
<a id="a89872d57d9e7d9e49f38b6700e40c99d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89872d57d9e7d9e49f38b6700e40c99d">&#9670;&nbsp;</a></span>operator++()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In-place pre-increment to advance the iterator. </p>

</div>
</div>
<a id="a870adfdc044f57202d26d5fb2109b425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a870adfdc044f57202d26d5fb2109b425">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if two iterators are equal. Since you can only have one on a stream, this only has two equality classes: iterators that have hit the end, and iterators that haven't. </p>

</div>
</div>
<a id="af88ac04ab7cbb8245a86d21a71a5dd76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af88ac04ab7cbb8245a86d21a71a5dd76">&#9670;&nbsp;</a></span>range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::range </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns iterators that act like begin() and end() for a stream containing messages. </p>

</div>
</div>
<a id="a97a1561c82f55827a208b2bea5e8da71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97a1561c82f55827a208b2bea5e8da71">&#9670;&nbsp;</a></span>seek_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::seek_group </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>virtual_offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Seek to the given virtual offset and start reading the group that is there. The next value produced will be the first value in that group. If already at the start of the group at the given virtual offset, does nothing. Return false if seeking is unsupported or the seek fails. </p>

</div>
</div>
<a id="aabd024a7358bae988de897aebff39645"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aabd024a7358bae988de897aebff39645">&#9670;&nbsp;</a></span>sniff_tag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::io::MessageIterator::sniff_tag </td>
          <td>(</td>
          <td class="paramtype">::google::protobuf::io::ZeroCopyInputStream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sniffing function to identify if data in a ZeroCopyInputStream appears to be <em>uncompressed</em> type-tagged message data, and, if so, what the tag is. Returns the tag if it could be sniffed, or the empty string if the tag could not be read, if the tag actually is an (illegal) empty string, or if the tag is not valid according to the <a class="el" href="classvg_1_1io_1_1Registry.html">Registry</a>.</p>
<p>BackUps the stream up to where it was before the sniffing read. </p>

</div>
</div>
<a id="ac9b3fff8dbbff744fe1ff60805af1c20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9b3fff8dbbff744fe1ff60805af1c20">&#9670;&nbsp;</a></span>sniff_tag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::io::MessageIterator::sniff_tag </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sniffing function to identify if data in a C++ stream appears to be <em>uncompressed</em> type-tagged message data, and, if so, what the tag is. Returns the tag if it could be sniffed, or the empty string if the tag could not be read, if the tag actually is an (illegal) empty string, or if the tag is not valid according to the <a class="el" href="classvg_1_1io_1_1Registry.html">Registry</a>.</p>
<p>Ungets the stream up to where it was before the sniffing read.</p>
<p>Fails with an exception if the sniffed data cannot be ungotten, so not safe to run on streams that aren't seekable and don't have buffering to support this. </p>

</div>
</div>
<a id="ab97d50a333e4f27419f0d661e8669774"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab97d50a333e4f27419f0d661e8669774">&#9670;&nbsp;</a></span>take()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::take </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take the current item, which must exist, and advance the iterator to the next one. </p>

</div>
</div>
<a id="afc6ab71583004ebdeb7aa24553817936"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc6ab71583004ebdeb7aa24553817936">&#9670;&nbsp;</a></span>tell_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::tell_group </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the virtual offset of the group being currently read (i.e. the group to which the current message belongs), to seek back to. You can't seek back to the current message, just to the start of the group. Returns -1 instead if the underlying file doesn't support seek/tell. Returns the past-the-end virtual offset of the file if EOF is reached. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7102e7dfdf1fbcfcd0b037eb39b8d21f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7102e7dfdf1fbcfcd0b037eb39b8d21f">&#9670;&nbsp;</a></span>bgzip_in</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;<a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a>&gt; vg::io::MessageIterator::bgzip_in</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Since these streams can't be copied or moved, we wrap ours in a uniqueptr_t so we can be moved. </p>

</div>
</div>
<a id="a34611c431fac53c556d57036cee7e4fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34611c431fac53c556d57036cee7e4fe">&#9670;&nbsp;</a></span>group_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::MessageIterator::group_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This holds the number of messages that exist in the current group. <a class="el" href="structvg_1_1Counts.html">Counts</a> the tag, if present. </p>

</div>
</div>
<a id="ab2a47479856b6bb8d6fe3c943519d83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2a47479856b6bb8d6fe3c943519d83d">&#9670;&nbsp;</a></span>group_idx</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::MessageIterator::group_idx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This holds the number of messages read in the current group. <a class="el" href="structvg_1_1Counts.html">Counts</a> the tag, if present. </p>

</div>
</div>
<a id="ae569fd7dc6129edc5e5dac52b1a67f84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae569fd7dc6129edc5e5dac52b1a67f84">&#9670;&nbsp;</a></span>group_vo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::io::MessageIterator::group_vo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This holds the virtual offset of the current group's start, or the number of the current group if seeking is not available. If the iterator is the end iterator, this is -1. </p>

</div>
</div>
<a id="a1f58abce5de3c8f71a82e689c0170c49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f58abce5de3c8f71a82e689c0170c49">&#9670;&nbsp;</a></span>item_vo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::io::MessageIterator::item_vo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This holds the virtual offset of the current item, or counts up through the group if seeking is not possible. Useful for seeking back to the item later, although you will have to seek to a group to iterate, after that. </p>

</div>
</div>
<a id="a5b2b881e4032fb2ecfa8da35ad13e602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b2b881e4032fb2ecfa8da35ad13e602">&#9670;&nbsp;</a></span>MAX_MESSAGE_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::io::MessageIterator::MAX_MESSAGE_SIZE = 1000000000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We refuse to serialize individual messages longer than this size. </p>

</div>
</div>
<a id="affc663d4448fe1b213d1c2e9ec64b3bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc663d4448fe1b213d1c2e9ec64b3bb">&#9670;&nbsp;</a></span>previous_tag</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::io::MessageIterator::previous_tag</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Because the whole value pair may get moved away, we keep a previous copy of the tag and replace it. TODO: This is a bit of a hack. </p>

</div>
</div>
<a id="a698864a67e1e721c06a97875f6cbcbde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698864a67e1e721c06a97875f6cbcbde">&#9670;&nbsp;</a></span>value</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#ac914a651c928eedea34171366c9f62e8">TaggedMessage</a> vg::io::MessageIterator::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Holds the most recently pulled-out message tag and value. May get moved away. </p>

</div>
</div>
<a id="af3f1540514c644f1d01212d515f603e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f1540514c644f1d01212d515f603e6">&#9670;&nbsp;</a></span>verbose</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::MessageIterator::verbose = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set this to true to print messages about what is being decoded. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deps/libvgio/include/vg/io/<a class="el" href="message__iterator_8hpp.html">message_iterator.hpp</a></li>
<li>deps/libvgio/src/<a class="el" href="message__iterator_8cpp.html">message_iterator.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
