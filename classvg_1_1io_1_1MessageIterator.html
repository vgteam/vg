<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::io::MessageIterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="namespacevg_1_1io.html">io</a></li><li class="navelem"><a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1io_1_1MessageIterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::io::MessageIterator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;message_iterator.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1e86fc0b955189290815ea5234a39ebe"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a1e86fc0b955189290815ea5234a39ebe">TaggedMessage</a> = pair&lt; string, unique_ptr&lt; string &gt;&gt;</td></tr>
<tr class="separator:a1e86fc0b955189290815ea5234a39ebe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2b3979320816e1c893413a2b5a643be5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a2b3979320816e1c893413a2b5a643be5">MessageIterator</a> (istream &amp;in)</td></tr>
<tr class="memdesc:a2b3979320816e1c893413a2b5a643be5"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvg_1_1Constructor.html">Constructor</a> to wrap a stream.  <a href="#a2b3979320816e1c893413a2b5a643be5">More...</a><br/></td></tr>
<tr class="separator:a2b3979320816e1c893413a2b5a643be5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a554b82ddcc5f26bbc48afa0a7784f493"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a554b82ddcc5f26bbc48afa0a7784f493">MessageIterator</a> (unique_ptr&lt; <a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a> &gt; &amp;&amp;bgzf)</td></tr>
<tr class="memdesc:a554b82ddcc5f26bbc48afa0a7784f493"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvg_1_1Constructor.html">Constructor</a> to wrap an existing BGZF.  <a href="#a554b82ddcc5f26bbc48afa0a7784f493">More...</a><br/></td></tr>
<tr class="separator:a554b82ddcc5f26bbc48afa0a7784f493"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46b16972d489742f42922fd9cb9b85af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a46b16972d489742f42922fd9cb9b85af">MessageIterator</a> ()=default</td></tr>
<tr class="memdesc:a46b16972d489742f42922fd9cb9b85af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for an end iterator.  <a href="#a46b16972d489742f42922fd9cb9b85af">More...</a><br/></td></tr>
<tr class="separator:a46b16972d489742f42922fd9cb9b85af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9bd6f7d8acd6b65d86ace13aae12a49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a1e86fc0b955189290815ea5234a39ebe">TaggedMessage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#af9bd6f7d8acd6b65d86ace13aae12a49">operator*</a> ()</td></tr>
<tr class="separator:af9bd6f7d8acd6b65d86ace13aae12a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aede4a9c1477c0356b4d021c1aa42a470"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1io_1_1MessageIterator.html#a1e86fc0b955189290815ea5234a39ebe">TaggedMessage</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#aede4a9c1477c0356b4d021c1aa42a470">operator*</a> () const </td></tr>
<tr class="separator:aede4a9c1477c0356b4d021c1aa42a470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89872d57d9e7d9e49f38b6700e40c99d"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a89872d57d9e7d9e49f38b6700e40c99d">operator++</a> ()</td></tr>
<tr class="memdesc:a89872d57d9e7d9e49f38b6700e40c99d"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place pre-increment to advance the iterator.  <a href="#a89872d57d9e7d9e49f38b6700e40c99d">More...</a><br/></td></tr>
<tr class="separator:a89872d57d9e7d9e49f38b6700e40c99d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3e2283b8d98c77bf1413de14cd501c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a3b3e2283b8d98c77bf1413de14cd501c">operator==</a> (const <a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> &amp;other) const </td></tr>
<tr class="separator:a3b3e2283b8d98c77bf1413de14cd501c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb076c65aca733bf26490ac8b1a490a1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#afb076c65aca733bf26490ac8b1a490a1">operator!=</a> (const <a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> &amp;other) const </td></tr>
<tr class="separator:afb076c65aca733bf26490ac8b1a490a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0d2c8bf2efe7259fed5b9040a92112"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a8a0d2c8bf2efe7259fed5b9040a92112">has_current</a> () const </td></tr>
<tr class="memdesc:a8a0d2c8bf2efe7259fed5b9040a92112"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if dereferencing the iterator will produce a valid value, and false otherwise.  <a href="#a8a0d2c8bf2efe7259fed5b9040a92112">More...</a><br/></td></tr>
<tr class="separator:a8a0d2c8bf2efe7259fed5b9040a92112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ccacd8648e7517083bfccc4676ba9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#ab4ccacd8648e7517083bfccc4676ba9a">advance</a> ()</td></tr>
<tr class="separator:ab4ccacd8648e7517083bfccc4676ba9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab97d50a333e4f27419f0d661e8669774"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a1e86fc0b955189290815ea5234a39ebe">TaggedMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#ab97d50a333e4f27419f0d661e8669774">take</a> ()</td></tr>
<tr class="memdesc:ab97d50a333e4f27419f0d661e8669774"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the current item, which must exist, and advance the iterator to the next one.  <a href="#ab97d50a333e4f27419f0d661e8669774">More...</a><br/></td></tr>
<tr class="separator:ab97d50a333e4f27419f0d661e8669774"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93357bb3b11b5a1cbb6d09bd712e7991"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a93357bb3b11b5a1cbb6d09bd712e7991">tell_group</a> () const </td></tr>
<tr class="separator:a93357bb3b11b5a1cbb6d09bd712e7991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97a1561c82f55827a208b2bea5e8da71"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a97a1561c82f55827a208b2bea5e8da71">seek_group</a> (int64_t virtual_offset)</td></tr>
<tr class="separator:a97a1561c82f55827a208b2bea5e8da71"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac9b3fff8dbbff744fe1ff60805af1c20"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#ac9b3fff8dbbff744fe1ff60805af1c20">sniff_tag</a> (istream &amp;stream)</td></tr>
<tr class="separator:ac9b3fff8dbbff744fe1ff60805af1c20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af88ac04ab7cbb8245a86d21a71a5dd76"><td class="memItemLeft" align="right" valign="top">static std::pair<br class="typebreak"/>
&lt; <a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a>, <br class="typebreak"/>
<a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#af88ac04ab7cbb8245a86d21a71a5dd76">range</a> (istream &amp;in)</td></tr>
<tr class="memdesc:af88ac04ab7cbb8245a86d21a71a5dd76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterators that act like begin() and end() for a stream containing messages.  <a href="#af88ac04ab7cbb8245a86d21a71a5dd76">More...</a><br/></td></tr>
<tr class="separator:af88ac04ab7cbb8245a86d21a71a5dd76"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a5b2b881e4032fb2ecfa8da35ad13e602"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a5b2b881e4032fb2ecfa8da35ad13e602">MAX_MESSAGE_SIZE</a> = 1000000000</td></tr>
<tr class="memdesc:a5b2b881e4032fb2ecfa8da35ad13e602"><td class="mdescLeft">&#160;</td><td class="mdescRight">We refuse to serialize individual messages longer than this size.  <a href="#a5b2b881e4032fb2ecfa8da35ad13e602">More...</a><br/></td></tr>
<tr class="separator:a5b2b881e4032fb2ecfa8da35ad13e602"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a4b3ba16717c1900a0638518bd33a4a59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a4b3ba16717c1900a0638518bd33a4a59">handle</a> (bool ok, int64_t group_virtual_offset=0, int64_t message_virtual_offset=0)</td></tr>
<tr class="separator:a4b3ba16717c1900a0638518bd33a4a59"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a698864a67e1e721c06a97875f6cbcbde"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a1e86fc0b955189290815ea5234a39ebe">TaggedMessage</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a698864a67e1e721c06a97875f6cbcbde">value</a></td></tr>
<tr class="separator:a698864a67e1e721c06a97875f6cbcbde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc663d4448fe1b213d1c2e9ec64b3bb"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#affc663d4448fe1b213d1c2e9ec64b3bb">previous_tag</a></td></tr>
<tr class="separator:affc663d4448fe1b213d1c2e9ec64b3bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34611c431fac53c556d57036cee7e4fe"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a34611c431fac53c556d57036cee7e4fe">group_count</a></td></tr>
<tr class="separator:a34611c431fac53c556d57036cee7e4fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2a47479856b6bb8d6fe3c943519d83d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#ab2a47479856b6bb8d6fe3c943519d83d">group_idx</a></td></tr>
<tr class="separator:ab2a47479856b6bb8d6fe3c943519d83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae569fd7dc6129edc5e5dac52b1a67f84"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#ae569fd7dc6129edc5e5dac52b1a67f84">group_vo</a></td></tr>
<tr class="separator:ae569fd7dc6129edc5e5dac52b1a67f84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f58abce5de3c8f71a82e689c0170c49"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a1f58abce5de3c8f71a82e689c0170c49">item_vo</a></td></tr>
<tr class="separator:a1f58abce5de3c8f71a82e689c0170c49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7102e7dfdf1fbcfcd0b037eb39b8d21f"><td class="memItemLeft" align="right" valign="top">unique_ptr<br class="typebreak"/>
&lt; <a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a7102e7dfdf1fbcfcd0b037eb39b8d21f">bgzip_in</a></td></tr>
<tr class="memdesc:a7102e7dfdf1fbcfcd0b037eb39b8d21f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Since these streams can't be copied or moved, we wrap ours in a uniqueptr_t so we can be moved.  <a href="#a7102e7dfdf1fbcfcd0b037eb39b8d21f">More...</a><br/></td></tr>
<tr class="separator:a7102e7dfdf1fbcfcd0b037eb39b8d21f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Iterator over messages in VG-format files. Yields pairs of string tag and message data. Also supports seeking and telling at the group level in bgzip files. Cannot be copied, but can be moved.</p>
<p>TODO: Right now we always copy all messages into an internal buffer. We should only do that if the message contents are actually accessed, with some kind of lazy fake string that evaluates on string conversion. Then we could more efficiently skip stuff with the wrong tag. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="a1e86fc0b955189290815ea5234a39ebe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1io_1_1MessageIterator.html#a1e86fc0b955189290815ea5234a39ebe">vg::io::MessageIterator::TaggedMessage</a> =  pair&lt;string, unique_ptr&lt;string&gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents a pair of a tag value and some message data. If there is no valid tag for a group, as given in the <a class="el" href="classvg_1_1io_1_1Registry.html">Registry</a>, the tag will be "". If there is a tag but no messages in its group, the data pointer will be null. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2b3979320816e1c893413a2b5a643be5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::io::MessageIterator::MessageIterator </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classvg_1_1Constructor.html">Constructor</a> to wrap a stream. </p>

</div>
</div>
<a class="anchor" id="a554b82ddcc5f26bbc48afa0a7784f493"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::io::MessageIterator::MessageIterator </td>
          <td>(</td>
          <td class="paramtype">unique_ptr&lt; <a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a> &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>bgzf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classvg_1_1Constructor.html">Constructor</a> to wrap an existing BGZF. </p>

</div>
</div>
<a class="anchor" id="a46b16972d489742f42922fd9cb9b85af"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::io::MessageIterator::MessageIterator </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor for an end iterator. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="ab4ccacd8648e7517083bfccc4676ba9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::advance </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advance the iterator to the next message, or the end if this was the last message. Basically the same as ++. </p>

</div>
</div>
<a class="anchor" id="a4b3ba16717c1900a0638518bd33a4a59"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::handle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>group_virtual_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>message_virtual_offset</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make sure the given Protobuf-library bool return value is true, and fail otherwise with a message. Reports the virtual offset of the invalid group and/or message </p>

</div>
</div>
<a class="anchor" id="a8a0d2c8bf2efe7259fed5b9040a92112"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::has_current </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if dereferencing the iterator will produce a valid value, and false otherwise. </p>

</div>
</div>
<a class="anchor" id="afb076c65aca733bf26490ac8b1a490a1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if two iterators are not equal. Since you can only have one on a stream, this only has two equality classes: iterators that have hit the end, and iterators that haven't. </p>

</div>
</div>
<a class="anchor" id="af9bd6f7d8acd6b65d86ace13aae12a49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current item. Caller may move it away. Only legal to call if we are not an end iterator. </p>

</div>
</div>
<a class="anchor" id="aede4a9c1477c0356b4d021c1aa42a470"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current item when we are const. Only legal to call if we are not an end iterator. </p>

</div>
</div>
<a class="anchor" id="a89872d57d9e7d9e49f38b6700e40c99d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In-place pre-increment to advance the iterator. </p>

</div>
</div>
<a class="anchor" id="a3b3e2283b8d98c77bf1413de14cd501c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if two iterators are equal. Since you can only have one on a stream, this only has two equality classes: iterators that have hit the end, and iterators that haven't. </p>

</div>
</div>
<a class="anchor" id="af88ac04ab7cbb8245a86d21a71a5dd76"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::range </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns iterators that act like begin() and end() for a stream containing messages. </p>

</div>
</div>
<a class="anchor" id="a97a1561c82f55827a208b2bea5e8da71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::seek_group </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>virtual_offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Seek to the given virtual offset and start reading the group that is there. The next value produced will be the first value in that group. If already at the start of the group at the given virtual offset, does nothing. Return false if seeking is unsupported or the seek fails. </p>

</div>
</div>
<a class="anchor" id="ac9b3fff8dbbff744fe1ff60805af1c20"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::io::MessageIterator::sniff_tag </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sniffing function to identify if data in a C++ stream appears to be <em>uncompressed</em> type-tagged message data, and, if so, what the tag is. Returns the tag if it could be sniffed, or the empty string if the tag could not be read, if the tag actually is an (illegal) empty string, or if the tag is not valid according to the <a class="el" href="classvg_1_1io_1_1Registry.html">Registry</a>.</p>
<p>Ungets the stream up to where it was before the sniffing read.</p>
<p>Fails with an exception if the sniffed data cannot be ungotten, so not safe to run on streams that aren't seekable and don't have buffering to support this. </p>

</div>
</div>
<a class="anchor" id="ab97d50a333e4f27419f0d661e8669774"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::take </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take the current item, which must exist, and advance the iterator to the next one. </p>

</div>
</div>
<a class="anchor" id="a93357bb3b11b5a1cbb6d09bd712e7991"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::MessageIterator::tell_group </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the virtual offset of the group being currently read (i.e. the group to which the current message belongs), to seek back to. You can't seek back to the current message, just to the start of the group. Returns -1 instead if the underlying file doesn't support seek/tell. Returns the past-the-end virtual offset of the file if EOF is reached. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a7102e7dfdf1fbcfcd0b037eb39b8d21f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;<a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a>&gt; vg::io::MessageIterator::bgzip_in</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Since these streams can't be copied or moved, we wrap ours in a uniqueptr_t so we can be moved. </p>

</div>
</div>
<a class="anchor" id="a34611c431fac53c556d57036cee7e4fe"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::MessageIterator::group_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This holds the number of messages that exist in the current group. Counts the tag, if present. </p>

</div>
</div>
<a class="anchor" id="ab2a47479856b6bb8d6fe3c943519d83d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::MessageIterator::group_idx</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This holds the number of messages read in the current group. Counts the tag, if present. </p>

</div>
</div>
<a class="anchor" id="ae569fd7dc6129edc5e5dac52b1a67f84"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::io::MessageIterator::group_vo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This holds the virtual offset of the current group's start, or the number of the current group if seeking is not available. If the iterator is the end iterator, this is -1. </p>

</div>
</div>
<a class="anchor" id="a1f58abce5de3c8f71a82e689c0170c49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::io::MessageIterator::item_vo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This holds the virtual offset of the current item, or counts up through the group if seeking is not possible. Useful for seeking back to the item later, although you will have to seek to a group to iterate, after that. </p>

</div>
</div>
<a class="anchor" id="a5b2b881e4032fb2ecfa8da35ad13e602"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::io::MessageIterator::MAX_MESSAGE_SIZE = 1000000000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We refuse to serialize individual messages longer than this size. </p>

</div>
</div>
<a class="anchor" id="affc663d4448fe1b213d1c2e9ec64b3bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::io::MessageIterator::previous_tag</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Because the whole value pair may get moved away, we keep a previous copy of the tag and replace it. TODO: This is a bit of a hack. </p>

</div>
</div>
<a class="anchor" id="a698864a67e1e721c06a97875f6cbcbde"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1io_1_1MessageIterator.html#a1e86fc0b955189290815ea5234a39ebe">TaggedMessage</a> vg::io::MessageIterator::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Holds the most recently pulled-out message tag and value. May get moved away. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deps/libvgio/include/vg/io/<a class="el" href="message__iterator_8hpp.html">message_iterator.hpp</a></li>
<li>deps/libvgio/src/<a class="el" href="message__iterator_8cpp.html">message_iterator.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
