<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::Constructor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1Constructor.html">Constructor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1Constructor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::Constructor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;constructor.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::Constructor:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1Constructor.png" usemap="#vg::Constructor_map" alt=""/>
  <map id="vg::Constructor_map" name="vg::Constructor_map">
<area href="classvg_1_1Progressive.html" alt="vg::Progressive" shape="rect" coords="0,0,108,24"/>
<area href="classvg_1_1NameMapper.html" alt="vg::NameMapper" shape="rect" coords="118,0,226,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:aab2b25c3b99fabdb0f382e2698ca3a52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ConstructedChunk.html">ConstructedChunk</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#aab2b25c3b99fabdb0f382e2698ca3a52">construct_chunk</a> (string reference_sequence, string reference_path_name, vector&lt; vcflib::Variant &gt; variants, size_t chunk_offset) const</td></tr>
<tr class="separator:aab2b25c3b99fabdb0f382e2698ca3a52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a87f468f65b2cacc3a47060378de7a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a0a87f468f65b2cacc3a47060378de7a3">construct_graph</a> (string vcf_contig, FastaReference &amp;reference, <a class="el" href="classvg_1_1VcfBuffer.html">VcfBuffer</a> &amp;variant_source, const vector&lt; FastaReference * &gt; &amp;insertion, const function&lt; void(<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;)&gt; &amp;callback)</td></tr>
<tr class="separator:a0a87f468f65b2cacc3a47060378de7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d69f28be35ff23ef4d0f80e645bdbc2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a2d69f28be35ff23ef4d0f80e645bdbc2">construct_graph</a> (const vector&lt; FastaReference * &gt; &amp;references, const vector&lt; vcflib::VariantCallFile * &gt; &amp;variant_files, const vector&lt; FastaReference * &gt; &amp;insertions, const function&lt; void(<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;)&gt; &amp;callback)</td></tr>
<tr class="separator:a2d69f28be35ff23ef4d0f80e645bdbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100345d3fca726262c98ab83768f0f0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a100345d3fca726262c98ab83768f0f0c">construct_graph</a> (const vector&lt; string &gt; &amp;reference_filenames, const vector&lt; string &gt; &amp;variant_filenames, const vector&lt; string &gt; &amp;insertion_filenames, const function&lt; void(<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;)&gt; &amp;callback)</td></tr>
<tr class="separator:a100345d3fca726262c98ab83768f0f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dbf56a3eee98b1f678dafc69bb35e97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a5dbf56a3eee98b1f678dafc69bb35e97">construct_graph</a> (const vector&lt; FastaReference * &gt; &amp;references, const vector&lt; vcflib::VariantCallFile * &gt; &amp;variant_files, const vector&lt; FastaReference * &gt; &amp;insertions, <a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *destination)</td></tr>
<tr class="separator:a5dbf56a3eee98b1f678dafc69bb35e97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c9a9c3adb2ddafc4d4434c689bb42ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a5c9a9c3adb2ddafc4d4434c689bb42ad">construct_graph</a> (const vector&lt; string &gt; &amp;reference_filenames, const vector&lt; string &gt; &amp;variant_filenames, const vector&lt; string &gt; &amp;insertion_filenames, <a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *destination)</td></tr>
<tr class="separator:a5c9a9c3adb2ddafc4d4434c689bb42ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1Progressive"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1Progressive')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1Progressive.html">vg::Progressive</a></td></tr>
<tr class="memitem:a4eb5050eb36ed519cbfa398748ef183b inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a4eb5050eb36ed519cbfa398748ef183b">preload_progress</a> (const string &amp;message)</td></tr>
<tr class="separator:a4eb5050eb36ed519cbfa398748ef183b inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cce3f715516ed2bbb4ce3a312b01e02 inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a1cce3f715516ed2bbb4ce3a312b01e02">create_progress</a> (const string &amp;message, long count)</td></tr>
<tr class="separator:a1cce3f715516ed2bbb4ce3a312b01e02 inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d4e92a36a277be5bc0cee5d01f5ca1 inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a75d4e92a36a277be5bc0cee5d01f5ca1">create_progress</a> (long count)</td></tr>
<tr class="separator:a75d4e92a36a277be5bc0cee5d01f5ca1 inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab723d3c5d61a8abe560b501c92d5bb1c inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#ab723d3c5d61a8abe560b501c92d5bb1c">ensure_progress</a> (long count)</td></tr>
<tr class="separator:ab723d3c5d61a8abe560b501c92d5bb1c inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d64e6aa69bc094c163f4827602a302c inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a0d64e6aa69bc094c163f4827602a302c">update_progress</a> (long i)</td></tr>
<tr class="separator:a0d64e6aa69bc094c163f4827602a302c inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1de11917caf25974a02e2f5c3946280 inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#ab1de11917caf25974a02e2f5c3946280">increment_progress</a> ()</td></tr>
<tr class="separator:ab1de11917caf25974a02e2f5c3946280 inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab8c6ae92870077bb59f86a15c8d18f inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#aaab8c6ae92870077bb59f86a15c8d18f">destroy_progress</a> (void)</td></tr>
<tr class="separator:aaab8c6ae92870077bb59f86a15c8d18f inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1NameMapper"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1NameMapper')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1NameMapper.html">vg::NameMapper</a></td></tr>
<tr class="memitem:ac2e2d25ef0f36649f33bb3386f0150b5 inherit pub_methods_classvg_1_1NameMapper"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NameMapper.html#ac2e2d25ef0f36649f33bb3386f0150b5">add_name_mapping</a> (const string &amp;vcf_name, const string &amp;fasta_name)</td></tr>
<tr class="separator:ac2e2d25ef0f36649f33bb3386f0150b5 inherit pub_methods_classvg_1_1NameMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e8c36e6207dbc905170bde6a5c396b3 inherit pub_methods_classvg_1_1NameMapper"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NameMapper.html#a6e8c36e6207dbc905170bde6a5c396b3">vcf_to_fasta</a> (const string &amp;vcf_name) const</td></tr>
<tr class="separator:a6e8c36e6207dbc905170bde6a5c396b3 inherit pub_methods_classvg_1_1NameMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73bd759074f9643a838c020f17120432 inherit pub_methods_classvg_1_1NameMapper"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NameMapper.html#a73bd759074f9643a838c020f17120432">fasta_to_vcf</a> (const string &amp;fasta_name) const</td></tr>
<tr class="separator:a73bd759074f9643a838c020f17120432 inherit pub_methods_classvg_1_1NameMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a2def54af1f72ad07cf84ff26fbbcc398"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a2def54af1f72ad07cf84ff26fbbcc398">flat</a> = false</td></tr>
<tr class="separator:a2def54af1f72ad07cf84ff26fbbcc398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2725e8e6876deb0ca0ccf597955163c2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a2725e8e6876deb0ca0ccf597955163c2">max_parsed_variant_size</a> = 100</td></tr>
<tr class="separator:a2725e8e6876deb0ca0ccf597955163c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19deb52667c009bcb73cd27e7ba2a5ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a19deb52667c009bcb73cd27e7ba2a5ac">alt_paths</a> = false</td></tr>
<tr class="separator:a19deb52667c009bcb73cd27e7ba2a5ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afafc25fc7021c48463894db9abce2f66"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#afafc25fc7021c48463894db9abce2f66">sha1_variant_name</a> = true</td></tr>
<tr class="separator:afafc25fc7021c48463894db9abce2f66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e48ae756193c44a889202591a562d18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a2e48ae756193c44a889202591a562d18">do_svs</a> = false</td></tr>
<tr class="separator:a2e48ae756193c44a889202591a562d18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a130c318e05428ee7973135ac5ea26b50"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a130c318e05428ee7973135ac5ea26b50">trim_indels</a> = true</td></tr>
<tr class="separator:a130c318e05428ee7973135ac5ea26b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedef6d593704f6739abcb116369935f7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#aedef6d593704f6739abcb116369935f7">alts_as_loci</a> = false</td></tr>
<tr class="separator:aedef6d593704f6739abcb116369935f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4dce51a25e5f773a0c53e8cd9f07628"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#ac4dce51a25e5f773a0c53e8cd9f07628">greedy_pieces</a> = false</td></tr>
<tr class="separator:ac4dce51a25e5f773a0c53e8cd9f07628"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57a532cd2bab1d857bee058633ffa525"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a57a532cd2bab1d857bee058633ffa525">chain_deletions</a> = true</td></tr>
<tr class="separator:a57a532cd2bab1d857bee058633ffa525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9da8d803e6e0c0be942ca2ecc35e9267"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a9da8d803e6e0c0be942ca2ecc35e9267">warn_on_lowercase</a> = true</td></tr>
<tr class="separator:a9da8d803e6e0c0be942ca2ecc35e9267"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e663d6eee52a9f723faf398cf720fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a24e663d6eee52a9f723faf398cf720fa">warn_on_ambiguous</a> = true</td></tr>
<tr class="separator:a24e663d6eee52a9f723faf398cf720fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ca9a0b7785c1c9c6e859cc75ea2a2f4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a6ca9a0b7785c1c9c6e859cc75ea2a2f4">max_node_size</a> = 1000</td></tr>
<tr class="separator:a6ca9a0b7785c1c9c6e859cc75ea2a2f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc8ae0e38492082ba8e886ea174944f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a7cc8ae0e38492082ba8e886ea174944f">vars_per_chunk</a> = 1024</td></tr>
<tr class="separator:a7cc8ae0e38492082ba8e886ea174944f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae525487466a66456d7169cc5047abf90"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#ae525487466a66456d7169cc5047abf90">bases_per_chunk</a> = 1024 * 1024</td></tr>
<tr class="separator:ae525487466a66456d7169cc5047abf90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a792c656b37e8b8836cd223751749d401"><td class="memItemLeft" align="right" valign="top">set&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a792c656b37e8b8836cd223751749d401">allowed_vcf_names</a></td></tr>
<tr class="separator:a792c656b37e8b8836cd223751749d401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac152e7a5407ef743f41e301700203129"><td class="memItemLeft" align="right" valign="top">map&lt; string, pair&lt; size_t, size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#ac152e7a5407ef743f41e301700203129">allowed_vcf_regions</a></td></tr>
<tr class="separator:ac152e7a5407ef743f41e301700203129"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classvg_1_1Progressive"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classvg_1_1Progressive')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classvg_1_1Progressive.html">vg::Progressive</a></td></tr>
<tr class="memitem:a6653625f496832c4cb8711185d5e04cb inherit pub_attribs_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a6653625f496832c4cb8711185d5e04cb">show_progress</a> = false</td></tr>
<tr class="separator:a6653625f496832c4cb8711185d5e04cb inherit pub_attribs_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a245d775942ede32387b95497803e114c"><td class="memItemLeft" align="right" valign="top">set&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a245d775942ede32387b95497803e114c">symbolic_allele_warnings</a></td></tr>
<tr class="separator:a245d775942ede32387b95497803e114c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8466741ece82babe9e892a50bd06a1d9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a8466741ece82babe9e892a50bd06a1d9">max_id</a> = 0</td></tr>
<tr class="separator:a8466741ece82babe9e892a50bd06a1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classvg_1_1NameMapper"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classvg_1_1NameMapper')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classvg_1_1NameMapper.html">vg::NameMapper</a></td></tr>
<tr class="memitem:afd130381fc9ad1a930932e672fda80d1 inherit pro_attribs_classvg_1_1NameMapper"><td class="memItemLeft" align="right" valign="top">map&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NameMapper.html#afd130381fc9ad1a930932e672fda80d1">vcf_to_fasta_renames</a></td></tr>
<tr class="separator:afd130381fc9ad1a930932e672fda80d1 inherit pro_attribs_classvg_1_1NameMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad908156325375d8008c9ac68790b71e8 inherit pro_attribs_classvg_1_1NameMapper"><td class="memItemLeft" align="right" valign="top">map&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NameMapper.html#ad908156325375d8008c9ac68790b71e8">fasta_to_vcf_renames</a></td></tr>
<tr class="memdesc:ad908156325375d8008c9ac68790b71e8 inherit pro_attribs_classvg_1_1NameMapper"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the reverse map from FASTA sequence name to VCF sequence name.  <a href="classvg_1_1NameMapper.html#ad908156325375d8008c9ac68790b71e8">More...</a><br /></td></tr>
<tr class="separator:ad908156325375d8008c9ac68790b71e8 inherit pro_attribs_classvg_1_1NameMapper"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a1d90ed36989b851bb3c072f4d67b52dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a1d90ed36989b851bb3c072f4d67b52dd">sanitize_sequence_in_place</a> (string &amp;sequence, const string *sequence_name=nullptr, size_t sequence_start_offset=0, const vcflib::Variant *variant=nullptr) const</td></tr>
<tr class="separator:a1d90ed36989b851bb3c072f4d67b52dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:a428cf1b27e402a304c18e40f87e9dc02"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a428cf1b27e402a304c18e40f87e9dc02">trim_to_variable</a> (vector&lt; list&lt; vcflib::VariantAllele &gt;&gt; &amp;parsed_alleles)</td></tr>
<tr class="separator:a428cf1b27e402a304c18e40f87e9dc02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b13ae925876f9f7617850ab4e2ad355"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a1b13ae925876f9f7617850ab4e2ad355">condense_edits</a> (list&lt; vcflib::VariantAllele &gt; &amp;parsed_allele)</td></tr>
<tr class="separator:a1b13ae925876f9f7617850ab4e2ad355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06078b6af1dc190c74806b30b669daae"><td class="memItemLeft" align="right" valign="top">static pair&lt; int64_t, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a06078b6af1dc190c74806b30b669daae">get_bounds</a> (const vector&lt; list&lt; vcflib::VariantAllele &gt;&gt; &amp;trimmed_variant)</td></tr>
<tr class="separator:a06078b6af1dc190c74806b30b669daae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a7837804bd45819ab249687a858fbb"><td class="memItemLeft" align="right" valign="top">static pair&lt; int64_t, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a31a7837804bd45819ab249687a858fbb">get_symbolic_bounds</a> (vcflib::Variant <a class="el" href="namespacevg.html#afe7fae89b379b5411189ac0ac74b2dd4">var</a>)</td></tr>
<tr class="separator:a31a7837804bd45819ab249687a858fbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a4a5f08f7d9c8e7bc821a7618e019289d"><td class="memItemLeft" align="right" valign="top">unordered_set&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#a4a5f08f7d9c8e7bc821a7618e019289d">lowercase_warned_sequences</a></td></tr>
<tr class="memdesc:a4a5f08f7d9c8e7bc821a7618e019289d"><td class="mdescLeft">&#160;</td><td class="mdescRight">What sequences have we warned about containing lowercase characters?  <a href="classvg_1_1Constructor.html#a4a5f08f7d9c8e7bc821a7618e019289d">More...</a><br /></td></tr>
<tr class="separator:a4a5f08f7d9c8e7bc821a7618e019289d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af296f5e32632a4fee39ac4bc11589c09"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#af296f5e32632a4fee39ac4bc11589c09">lowercase_warned_alt</a> = false</td></tr>
<tr class="memdesc:af296f5e32632a4fee39ac4bc11589c09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Have we given a warning yet about lowercase alt alleles?  <a href="classvg_1_1Constructor.html#af296f5e32632a4fee39ac4bc11589c09">More...</a><br /></td></tr>
<tr class="separator:af296f5e32632a4fee39ac4bc11589c09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a4e56154c62990a784f7e51e7368cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#ad4a4e56154c62990a784f7e51e7368cd">multiallelic_sv_warned</a> = false</td></tr>
<tr class="memdesc:ad4a4e56154c62990a784f7e51e7368cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Have we given a warning yet about multiallelic SVs?  <a href="classvg_1_1Constructor.html#ad4a4e56154c62990a784f7e51e7368cd">More...</a><br /></td></tr>
<tr class="separator:ad4a4e56154c62990a784f7e51e7368cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7747658550e74b383a491a06e04ea99"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#ac7747658550e74b383a491a06e04ea99">uncanonicalizable_sv_warned</a> = false</td></tr>
<tr class="memdesc:ac7747658550e74b383a491a06e04ea99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Have we given a warning yet about uncanonicalizable SVs?  <a href="classvg_1_1Constructor.html#ac7747658550e74b383a491a06e04ea99">More...</a><br /></td></tr>
<tr class="separator:ac7747658550e74b383a491a06e04ea99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4733354328ad88166206d95680570f1"><td class="memItemLeft" align="right" valign="top">unordered_set&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html#ab4733354328ad88166206d95680570f1">ambiguous_warned_sequences</a></td></tr>
<tr class="memdesc:ab4733354328ad88166206d95680570f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">What sequences have we warned about containing unsupported ambiguity codes?  <a href="classvg_1_1Constructor.html#ab4733354328ad88166206d95680570f1">More...</a><br /></td></tr>
<tr class="separator:ab4733354328ad88166206d95680570f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classvg_1_1Progressive"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classvg_1_1Progressive')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classvg_1_1Progressive.html">vg::Progressive</a></td></tr>
<tr class="memitem:ab44ff020fc951b95dfcd1252c015a020 inherit pub_static_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#ab44ff020fc951b95dfcd1252c015a020">with_progress</a> (bool <a class="el" href="classvg_1_1Progressive.html#a6653625f496832c4cb8711185d5e04cb">show_progress</a>, const std::string &amp;task, const std::function&lt; void(const std::function&lt; void(size_t, size_t)&gt; &amp;<a class="el" href="classvg_1_1Progressive.html#af78e64e28b252828a0ba86439125fea4">progress</a>)&gt; &amp;callback)</td></tr>
<tr class="separator:ab44ff020fc951b95dfcd1252c015a020 inherit pub_static_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a1b13ae925876f9f7617850ab4e2ad355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b13ae925876f9f7617850ab4e2ad355">&#9670;&nbsp;</a></span>condense_edits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Constructor::condense_edits </td>
          <td>(</td>
          <td class="paramtype">list&lt; vcflib::VariantAllele &gt; &amp;&#160;</td>
          <td class="paramname"><em>parsed_allele</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a list of VariantAllele edits, condense adjacent perfect match edits to be maximally long. </p>

</div>
</div>
<a id="aab2b25c3b99fabdb0f382e2698ca3a52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab2b25c3b99fabdb0f382e2698ca3a52">&#9670;&nbsp;</a></span>construct_chunk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ConstructedChunk.html">ConstructedChunk</a> vg::Constructor::construct_chunk </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>reference_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>reference_path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vcflib::Variant &gt;&#160;</td>
          <td class="paramname"><em>variants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chunk_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a <a class="el" href="structvg_1_1ConstructedChunk.html">ConstructedChunk</a> of graph from the given piece of sequence, with the given name, applying the given variants. The variants need to be sorted by start position, and have their start positions set to be ZERO- BASED. However, they also need to have their start positions relative to the global start of the contig, so that hash-based names come out right for them. They also need to not overlap with any variants not in the vector we have (i.e. we need access to all overlapping variants for this region). The variants must not extend beyond the given sequence, though they can abut its edges.</p>
<p>Variants in the vector may not use symbolic alleles.</p>
<p>All variants must have has their canonical field set, either manually to false or by canonicalize() to true.</p>
<p>chunk_offset gives the global 0-based position at which this chunk starts in the reference contig it is part of, which is used to correctly place variants. </p>
<p>Find the next breakpoint.</p>
<p>Takes in the search position, like the position of the next un-made reference base. So searches from the left edge of the passed inclusive position.</p>
<p>Finds the next required breakpoint within this clump, after the given position, given created nodes and deletions that already exist.</p>
<p>Returns the inclusive position of the base to the left of this breakpoint, so the breakpoint is immediately to the right of the base at the returned position. This means that sometimes, such as if the next piece of the reference would be 1 bp long, this function will return the same value it was passed.</p>

</div>
</div>
<a id="a2d69f28be35ff23ef4d0f80e645bdbc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d69f28be35ff23ef4d0f80e645bdbc2">&#9670;&nbsp;</a></span>construct_graph() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Constructor::construct_graph </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; FastaReference * &gt; &amp;&#160;</td>
          <td class="paramname"><em>references</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vcflib::VariantCallFile * &gt; &amp;&#160;</td>
          <td class="paramname"><em>variant_files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; FastaReference * &gt; &amp;&#160;</td>
          <td class="paramname"><em>insertions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a graph using the given FASTA references and VCFlib VCF files. The VCF files are assumed to be grouped by contig and then sorted by position within the contig, such that each contig is present in only one file. If multiple FASTAs are used, each contig must be present in only one FASTA file. Reference and VCF vectors may not contain nulls.</p>
<p>insertions contains FASTAs containing serquences for resolving symbolic insert alleles in the VCFs.</p>
<p>Calls the given callback with constructed graph chunks, eventually (hopefully) in multiple threads. Chunks may contain dangling edges into the next chunk. </p>

</div>
</div>
<a id="a5dbf56a3eee98b1f678dafc69bb35e97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dbf56a3eee98b1f678dafc69bb35e97">&#9670;&nbsp;</a></span>construct_graph() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Constructor::construct_graph </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; FastaReference * &gt; &amp;&#160;</td>
          <td class="paramname"><em>references</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vcflib::VariantCallFile * &gt; &amp;&#160;</td>
          <td class="paramname"><em>variant_files</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; FastaReference * &gt; &amp;&#160;</td>
          <td class="paramname"><em>insertions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a graph using the given FASTA references and VCFlib VCF files. The VCF files are assumed to be grouped by contig and then sorted by position within the contig, such that each contig is present in only one file. If multiple FASTAs are used, each contig must be present in only one FASTA file. Reference and VCF vectors may not contain nulls.</p>
<p>insertions contains FASTAs containing serquences for resolving symbolic insert alleles in the VCFs.</p>
<p>Builds the graph into the given mutable graph object, which may not be thread safe. </p>

</div>
</div>
<a id="a100345d3fca726262c98ab83768f0f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100345d3fca726262c98ab83768f0f0c">&#9670;&nbsp;</a></span>construct_graph() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Constructor::construct_graph </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>reference_filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>variant_filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>insertion_filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a graph using the given FASTA references and VCF files on disk. The VCF files are assumed to be grouped by contig and then sorted by position within the contig, such that each contig is present in only one file. If multiple FASTAs are used, each contig must be present in only one FASTA file.</p>
<p>insertions contains FASTA filenames containing serquences for resolving symbolic insert alleles in the VCFs.</p>
<p>Calls the given callback with constructed graph chunks, eventually (hopefully) in multiple threads. Chunks may contain dangling edges into the next chunk. </p>

</div>
</div>
<a id="a5c9a9c3adb2ddafc4d4434c689bb42ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c9a9c3adb2ddafc4d4434c689bb42ad">&#9670;&nbsp;</a></span>construct_graph() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Constructor::construct_graph </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>reference_filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>variant_filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>insertion_filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>destination</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a graph using the given FASTA references and VCF files on disk. The VCF files are assumed to be grouped by contig and then sorted by position within the contig, such that each contig is present in only one file. If multiple FASTAs are used, each contig must be present in only one FASTA file.</p>
<p>insertions contains FASTA filenames containing serquences for resolving symbolic insert alleles in the VCFs.</p>
<p>Builds the graph into the given mutable graph object, which may not be thread safe. </p>

</div>
</div>
<a id="a0a87f468f65b2cacc3a47060378de7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a87f468f65b2cacc3a47060378de7a3">&#9670;&nbsp;</a></span>construct_graph() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Constructor::construct_graph </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>vcf_contig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FastaReference &amp;&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1VcfBuffer.html">VcfBuffer</a> &amp;&#160;</td>
          <td class="paramname"><em>variant_source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; FastaReference * &gt; &amp;&#160;</td>
          <td class="paramname"><em>insertion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a graph for the given VCF contig name, using the given reference and the variants from the given buffered VCF file. Emits a sequence of <a class="el" href="structvg_1_1Graph.html">Graph</a> chunks, which may be too big to serealize directly.</p>
<p>Doesn't handle any of the setup for VCF indexing. Just scans all the variants that can come out of the buffer, so make sure indexing is set on the file first before passing it in.</p>
<p>insertion contains FASTAs containing serquences for resolving symbolic insert alleles in the VCF.</p>
<p>Calls the given callback with constructed graph chunks, in a single thread. Chunks may contain dangling edges into the next chunk. </p>

</div>
</div>
<a id="a06078b6af1dc190c74806b30b669daae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06078b6af1dc190c74806b30b669daae">&#9670;&nbsp;</a></span>get_bounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; int64_t, int64_t &gt; vg::Constructor::get_bounds </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; list&lt; vcflib::VariantAllele &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>trimmed_variant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a vector of lists of VariantAllele edits that have been trimmed with <a class="el" href="classvg_1_1Constructor.html#a428cf1b27e402a304c18e40f87e9dc02">trim_to_variable()</a> above, one per non-reference alt for a variant, return the position of the first varaible base, and the position of the last variable base. If there's no variable-region, the result is max int64_t and -1, and if there's a 0-length variable region, the result is the base after it and the base before it. </p>

</div>
</div>
<a id="a31a7837804bd45819ab249687a858fbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a7837804bd45819ab249687a858fbb">&#9670;&nbsp;</a></span>get_symbolic_bounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; int64_t, int64_t &gt; vg::Constructor::get_symbolic_bounds </td>
          <td>(</td>
          <td class="paramtype">vcflib::Variant&#160;</td>
          <td class="paramname"><em>var</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a symbolic variant, check its bounds and return them. This function is needed to handle SVs properly, since they won't always have their ref and alt fields put in. Note that insertions may have an end bound before their start, because the anchoring base isn't included. </p>

</div>
</div>
<a id="a1d90ed36989b851bb3c072f4d67b52dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d90ed36989b851bb3c072f4d67b52dd">&#9670;&nbsp;</a></span>sanitize_sequence_in_place()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Constructor::sanitize_sequence_in_place </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string *&#160;</td>
          <td class="paramname"><em>sequence_name</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sequence_start_offset</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vcflib::Variant *&#160;</td>
          <td class="paramname"><em>variant</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a sequence, get rid of all the lowercase characters and all the ambiguity codes. Warn if configured, and the sequence has a name assigned, and no warning has yet been issued for that name, or if a variant is specified.</p>
<p>Will error if this results in a string with anything other than A, C, G, T, and N.</p>
<p>sequence_start_offset can be set to produce useful messages if the sequence we are looking at is an excerpt from a longer sequence.</p>
<p>Santitizing may move the stored string data in memory.</p>
<p>Returns true if the string was modified.</p>
<p>We need this as a function because vcflib reaches back and reads the FASTA files directly, so we can't <em>just</em> preprocess the reference and we need to constantly clean up the variants. </p>

</div>
</div>
<a id="a428cf1b27e402a304c18e40f87e9dc02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a428cf1b27e402a304c18e40f87e9dc02">&#9670;&nbsp;</a></span>trim_to_variable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Constructor::trim_to_variable </td>
          <td>(</td>
          <td class="paramtype">vector&lt; list&lt; vcflib::VariantAllele &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>parsed_alleles</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a vector of lists of VariantAllele edits, trim in from the left and right, leaving a core of edits bounded by edits that actually change the reference in at least one allele.</p>
<p>Postcondition: either all lists of VariantAlleles are empty, or at least one begins with a non-match and at least one ends with a non-match. Adjacent edits in the list abut; there are no uncovered gaps in the edits. This means that <em>internal</em> perfect match edits will be preserved. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a792c656b37e8b8836cd223751749d401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a792c656b37e8b8836cd223751749d401">&#9670;&nbsp;</a></span>allowed_vcf_names</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt;string&gt; vg::Constructor::allowed_vcf_names</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac152e7a5407ef743f41e301700203129"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac152e7a5407ef743f41e301700203129">&#9670;&nbsp;</a></span>allowed_vcf_regions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;string, pair&lt;size_t, size_t&gt; &gt; vg::Constructor::allowed_vcf_regions</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a19deb52667c009bcb73cd27e7ba2a5ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19deb52667c009bcb73cd27e7ba2a5ac">&#9670;&nbsp;</a></span>alt_paths</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Constructor::alt_paths = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aedef6d593704f6739abcb116369935f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedef6d593704f6739abcb116369935f7">&#9670;&nbsp;</a></span>alts_as_loci</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Constructor::alts_as_loci = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab4733354328ad88166206d95680570f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4733354328ad88166206d95680570f1">&#9670;&nbsp;</a></span>ambiguous_warned_sequences</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_set&lt;string&gt; vg::Constructor::ambiguous_warned_sequences</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What sequences have we warned about containing unsupported ambiguity codes? </p>

</div>
</div>
<a id="ae525487466a66456d7169cc5047abf90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae525487466a66456d7169cc5047abf90">&#9670;&nbsp;</a></span>bases_per_chunk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::Constructor::bases_per_chunk = 1024 * 1024</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a57a532cd2bab1d857bee058633ffa525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57a532cd2bab1d857bee058633ffa525">&#9670;&nbsp;</a></span>chain_deletions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Constructor::chain_deletions = true</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e48ae756193c44a889202591a562d18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e48ae756193c44a889202591a562d18">&#9670;&nbsp;</a></span>do_svs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Constructor::do_svs = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2def54af1f72ad07cf84ff26fbbcc398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2def54af1f72ad07cf84ff26fbbcc398">&#9670;&nbsp;</a></span>flat</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Constructor::flat = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac4dce51a25e5f773a0c53e8cd9f07628"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4dce51a25e5f773a0c53e8cd9f07628">&#9670;&nbsp;</a></span>greedy_pieces</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Constructor::greedy_pieces = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af296f5e32632a4fee39ac4bc11589c09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af296f5e32632a4fee39ac4bc11589c09">&#9670;&nbsp;</a></span>lowercase_warned_alt</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Constructor::lowercase_warned_alt = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Have we given a warning yet about lowercase alt alleles? </p>

</div>
</div>
<a id="a4a5f08f7d9c8e7bc821a7618e019289d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a5f08f7d9c8e7bc821a7618e019289d">&#9670;&nbsp;</a></span>lowercase_warned_sequences</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_set&lt;string&gt; vg::Constructor::lowercase_warned_sequences</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What sequences have we warned about containing lowercase characters? </p>

</div>
</div>
<a id="a8466741ece82babe9e892a50bd06a1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8466741ece82babe9e892a50bd06a1d9">&#9670;&nbsp;</a></span>max_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::Constructor::max_id = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>All chunks are generated with IDs starting at 1, but graphs emitted from construct_graph need to have the IDs rewritten so they don't overlap. Moreover, multiple calls to construct_graph need to not have conflicting IDs, because some construct_graph implementations call other ones. What we do for now is globally track the max ID already used, so all calls to construct_graph follow a single ID ordering. </p>

</div>
</div>
<a id="a6ca9a0b7785c1c9c6e859cc75ea2a2f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ca9a0b7785c1c9c6e859cc75ea2a2f4">&#9670;&nbsp;</a></span>max_node_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::Constructor::max_node_size = 1000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2725e8e6876deb0ca0ccf597955163c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2725e8e6876deb0ca0ccf597955163c2">&#9670;&nbsp;</a></span>max_parsed_variant_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::Constructor::max_parsed_variant_size = 100</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4a4e56154c62990a784f7e51e7368cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a4e56154c62990a784f7e51e7368cd">&#9670;&nbsp;</a></span>multiallelic_sv_warned</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Constructor::multiallelic_sv_warned = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Have we given a warning yet about multiallelic SVs? </p>

</div>
</div>
<a id="afafc25fc7021c48463894db9abce2f66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afafc25fc7021c48463894db9abce2f66">&#9670;&nbsp;</a></span>sha1_variant_name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Constructor::sha1_variant_name = true</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a245d775942ede32387b95497803e114c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a245d775942ede32387b95497803e114c">&#9670;&nbsp;</a></span>symbolic_allele_warnings</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">set&lt;string&gt; vg::Constructor::symbolic_allele_warnings</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remembers which unusable symbolic alleles we've already emitted a warning about during construction. </p>

</div>
</div>
<a id="a130c318e05428ee7973135ac5ea26b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a130c318e05428ee7973135ac5ea26b50">&#9670;&nbsp;</a></span>trim_indels</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Constructor::trim_indels = true</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7747658550e74b383a491a06e04ea99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7747658550e74b383a491a06e04ea99">&#9670;&nbsp;</a></span>uncanonicalizable_sv_warned</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Constructor::uncanonicalizable_sv_warned = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Have we given a warning yet about uncanonicalizable SVs? </p>

</div>
</div>
<a id="a7cc8ae0e38492082ba8e886ea174944f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc8ae0e38492082ba8e886ea174944f">&#9670;&nbsp;</a></span>vars_per_chunk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::Constructor::vars_per_chunk = 1024</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24e663d6eee52a9f723faf398cf720fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e663d6eee52a9f723faf398cf720fa">&#9670;&nbsp;</a></span>warn_on_ambiguous</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Constructor::warn_on_ambiguous = true</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9da8d803e6e0c0be942ca2ecc35e9267"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9da8d803e6e0c0be942ca2ecc35e9267">&#9670;&nbsp;</a></span>warn_on_lowercase</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Constructor::warn_on_lowercase = true</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="constructor_8hpp.html">constructor.hpp</a></li>
<li>src/<a class="el" href="constructor_8cpp.html">constructor.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
