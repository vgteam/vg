<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::ZipCodeTree::distance_iterator Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1ZipCodeTree.html">ZipCodeTree</a></li><li class="navelem"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1ZipCodeTree_1_1distance__iterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::ZipCodeTree::distance_iterator Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;zip_code_tree.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ZipCodeTree_1_1distance__iterator_1_1iteration__position.html">iteration_position</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:aa62eb94739c4b9145d7d72c0818fdb9b"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#aa62eb94739c4b9145d7d72c0818fdb9b">State</a> { <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#aa62eb94739c4b9145d7d72c0818fdb9babbcfa4a338d4b3f9dd2b254360e4c2f2">S_START</a>
, <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#aa62eb94739c4b9145d7d72c0818fdb9baadbd2e2b41af1343c217a8121d252c45">S_SCAN_CHAIN</a>
, <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#aa62eb94739c4b9145d7d72c0818fdb9ba8511e4711c1e15ee3afbc973020c5faf">S_SCAN_DAG_SNARL</a>
, <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#aa62eb94739c4b9145d7d72c0818fdb9ba8e59dd53e13591f259102bf4d286fbcc">S_SCAN_CYCLIC_SNARL</a>
 }</td></tr>
<tr class="separator:aa62eb94739c4b9145d7d72c0818fdb9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a5f0c90085f4f13c3f4fa55b990c6a62c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a5f0c90085f4f13c3f4fa55b990c6a62c">distance_iterator</a> (size_t start_index, const vector&lt; <a class="el" href="structvg_1_1ZipCodeTree_1_1tree__item__t.html">tree_item_t</a> &gt; &amp;<a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#ac158b356a371902e7fc62450b38be816">zip_code_tree</a>, std::stack&lt; size_t &gt; chain_numbers=std::stack&lt; size_t &gt;(), bool right_to_left=true, size_t <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a6caa9a2974db62abf95a7dd802e9c294">distance_limit</a>=std::numeric_limits&lt; size_t &gt;::max())</td></tr>
<tr class="separator:a5f0c90085f4f13c3f4fa55b990c6a62c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a286ea3abdb56edac42658aebec39d14f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a286ea3abdb56edac42658aebec39d14f">distance_iterator</a> (const <a class="el" href="classvg_1_1ZipCodeTree_1_1seed__iterator.html">seed_iterator</a> &amp;from, size_t <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a6caa9a2974db62abf95a7dd802e9c294">distance_limit</a>=std::numeric_limits&lt; size_t &gt;::max())</td></tr>
<tr class="memdesc:a286ea3abdb56edac42658aebec39d14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a reverse iterator from the given seed iterator.  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a286ea3abdb56edac42658aebec39d14f">More...</a><br /></td></tr>
<tr class="separator:a286ea3abdb56edac42658aebec39d14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac048f1543033b8b1adc5c8e660100e47"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#ac048f1543033b8b1adc5c8e660100e47">distance_iterator</a> (const <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a> &amp;other)=default</td></tr>
<tr class="separator:ac048f1543033b8b1adc5c8e660100e47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03cc8cddc66d94ea1a82763f5c6551d7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a03cc8cddc66d94ea1a82763f5c6551d7">distance_iterator</a> (<a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:a03cc8cddc66d94ea1a82763f5c6551d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d3759baafbaae1df50bb9964ff7c8bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a8d3759baafbaae1df50bb9964ff7c8bb">operator=</a> (const <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a> &amp;other)=default</td></tr>
<tr class="separator:a8d3759baafbaae1df50bb9964ff7c8bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8959b0bd6f9cf2b08d621042d5cf9500"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a8959b0bd6f9cf2b08d621042d5cf9500">operator=</a> (<a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:a8959b0bd6f9cf2b08d621042d5cf9500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa50db4002ca8c0e3e5be9b9806592398"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#aa50db4002ca8c0e3e5be9b9806592398">operator++</a> ()</td></tr>
<tr class="memdesc:aa50db4002ca8c0e3e5be9b9806592398"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move in right_to_left direction until we hit another seed or the end.  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#aa50db4002ca8c0e3e5be9b9806592398">More...</a><br /></td></tr>
<tr class="separator:aa50db4002ca8c0e3e5be9b9806592398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f7484f1f42a6e3a7841223433f341ea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a8f7484f1f42a6e3a7841223433f341ea">move_index</a> ()</td></tr>
<tr class="separator:a8f7484f1f42a6e3a7841223433f341ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fa77d2c15695fb7af6014c57cd1a72d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a7fa77d2c15695fb7af6014c57cd1a72d">operator==</a> (const <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a> &amp;other) const</td></tr>
<tr class="separator:a7fa77d2c15695fb7af6014c57cd1a72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdb624f4fb08c3031300a1fa508de3a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a5fdb624f4fb08c3031300a1fa508de3a">operator!=</a> (const <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a> &amp;other) const</td></tr>
<tr class="memdesc:a5fdb624f4fb08c3031300a1fa508de3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compare for inequality.  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a5fdb624f4fb08c3031300a1fa508de3a">More...</a><br /></td></tr>
<tr class="separator:a5fdb624f4fb08c3031300a1fa508de3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a705a4a40214b5d1d5a5d14d82b00e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a21a705a4a40214b5d1d5a5d14d82b00e">done</a> () const</td></tr>
<tr class="memdesc:a21a705a4a40214b5d1d5a5d14d82b00e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the iteration done?  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a21a705a4a40214b5d1d5a5d14d82b00e">More...</a><br /></td></tr>
<tr class="separator:a21a705a4a40214b5d1d5a5d14d82b00e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e963bb92c2b06cef524332ddc309143"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ZipCodeTree_1_1seed__result__t.html">seed_result_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a4e963bb92c2b06cef524332ddc309143">operator*</a> () const</td></tr>
<tr class="separator:a4e963bb92c2b06cef524332ddc309143"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a1ce6afc697f038211434e2e532bd16e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a1ce6afc697f038211434e2e532bd16e2">use_saved_traversal</a> ()</td></tr>
<tr class="memdesc:a1ce6afc697f038211434e2e532bd16e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set current <a class="el" href="structvg_1_1ZipCodeTree_1_1distance__iterator_1_1iteration__position.html">iteration_position</a> to the top of pending_traversals.  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a1ce6afc697f038211434e2e532bd16e2">More...</a><br /></td></tr>
<tr class="separator:a1ce6afc697f038211434e2e532bd16e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ce051884c054587350530f4d7e92c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a13ce051884c054587350530f4d7e92c0">save_opposite_cyclic_snarl_exit</a> (size_t chain_num)</td></tr>
<tr class="separator:a13ce051884c054587350530f4d7e92c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad14fad5faab24a3b3c7b73dad1119990"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#ad14fad5faab24a3b3c7b73dad1119990">push</a> (size_t value)</td></tr>
<tr class="memdesc:ad14fad5faab24a3b3c7b73dad1119990"><td class="mdescLeft">&#160;</td><td class="mdescRight">Push a value to the stack.  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#ad14fad5faab24a3b3c7b73dad1119990">More...</a><br /></td></tr>
<tr class="separator:ad14fad5faab24a3b3c7b73dad1119990"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3323131fa5ff649d7eebf73e413b5efc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a3323131fa5ff649d7eebf73e413b5efc">pop</a> ()</td></tr>
<tr class="memdesc:a3323131fa5ff649d7eebf73e413b5efc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pop a value from the stack and return it.  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a3323131fa5ff649d7eebf73e413b5efc">More...</a><br /></td></tr>
<tr class="separator:a3323131fa5ff649d7eebf73e413b5efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af618e6cc265d8df8ef13b513d7ca0040"><td class="memItemLeft" align="right" valign="top">size_t &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#af618e6cc265d8df8ef13b513d7ca0040">top</a> ()</td></tr>
<tr class="memdesc:af618e6cc265d8df8ef13b513d7ca0040"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a mutable reference to the value on top of the stack.  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#af618e6cc265d8df8ef13b513d7ca0040">More...</a><br /></td></tr>
<tr class="separator:af618e6cc265d8df8ef13b513d7ca0040"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4c3d78d90cf08b364012088d1a6f1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#abf4c3d78d90cf08b364012088d1a6f1a">dup</a> ()</td></tr>
<tr class="memdesc:abf4c3d78d90cf08b364012088d1a6f1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Duplicate the top item on the stack.  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#abf4c3d78d90cf08b364012088d1a6f1a">More...</a><br /></td></tr>
<tr class="separator:abf4c3d78d90cf08b364012088d1a6f1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18babbfdd0e7bd5776ec2a2f9c837656"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a18babbfdd0e7bd5776ec2a2f9c837656">depth</a> () const</td></tr>
<tr class="memdesc:a18babbfdd0e7bd5776ec2a2f9c837656"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check stack depth.  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a18babbfdd0e7bd5776ec2a2f9c837656">More...</a><br /></td></tr>
<tr class="separator:a18babbfdd0e7bd5776ec2a2f9c837656"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1dd2606c3bc0421316309a0be46e4df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#ad1dd2606c3bc0421316309a0be46e4df">swap</a> ()</td></tr>
<tr class="memdesc:ad1dd2606c3bc0421316309a0be46e4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse the top two elements of the stack.  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#ad1dd2606c3bc0421316309a0be46e4df">More...</a><br /></td></tr>
<tr class="separator:ad1dd2606c3bc0421316309a0be46e4df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0edf066db25bf87cfc81f962d306089"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#ab0edf066db25bf87cfc81f962d306089">stack_snarl_distances</a> (size_t snarl_start_i, size_t chain_num, bool right_side)</td></tr>
<tr class="separator:ab0edf066db25bf87cfc81f962d306089"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1069c3b150d6da8c4fceb61be5be36e8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a1069c3b150d6da8c4fceb61be5be36e8">stack_matrix_value</a> (size_t matrix_start_i, bool has_main_diagonal, size_t row, size_t col)</td></tr>
<tr class="separator:a1069c3b150d6da8c4fceb61be5be36e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d6b489a138b0b01880bfdd67fbfc32"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#ab1d6b489a138b0b01880bfdd67fbfc32">get_matrix_value</a> (size_t matrix_start_i, bool has_main_diagonal, size_t row, size_t col)</td></tr>
<tr class="separator:ab1d6b489a138b0b01880bfdd67fbfc32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae267bbabfdc79c3b30271288eb0c2973"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#ae267bbabfdc79c3b30271288eb0c2973">get_cyclic_snarl_bound_distance</a> (size_t snarl_start_i, size_t row, bool to_end)</td></tr>
<tr class="separator:ae267bbabfdc79c3b30271288eb0c2973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941d5dbfa9f4bb38fc5defbe982f975e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a941d5dbfa9f4bb38fc5defbe982f975e">stack_below_top</a> (size_t value)</td></tr>
<tr class="separator:a941d5dbfa9f4bb38fc5defbe982f975e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa50d5429154274042e53a97dbc2ea4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a1aa50d5429154274042e53a97dbc2ea4">halt</a> ()</td></tr>
<tr class="separator:a1aa50d5429154274042e53a97dbc2ea4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a911fb6f0a523f3e50c561a1100d1f36d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a911fb6f0a523f3e50c561a1100d1f36d">unimplemented_error</a> ()</td></tr>
<tr class="memdesc:a911fb6f0a523f3e50c561a1100d1f36d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Throw a domain_error that the current state/symbol combo is unimplemented.  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a911fb6f0a523f3e50c561a1100d1f36d">More...</a><br /></td></tr>
<tr class="separator:a911fb6f0a523f3e50c561a1100d1f36d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0165add1598dd599904787ffb8c756cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ZipCodeTree_1_1tree__item__t.html">tree_item_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a0165add1598dd599904787ffb8c756cb">current_item</a> () const</td></tr>
<tr class="memdesc:a0165add1598dd599904787ffb8c756cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">What item does index point to?  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a0165add1598dd599904787ffb8c756cb">More...</a><br /></td></tr>
<tr class="separator:a0165add1598dd599904787ffb8c756cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef783e01306bbe84f48a4499b489107c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#aef783e01306bbe84f48a4499b489107c">entered_snarl</a> () const</td></tr>
<tr class="separator:aef783e01306bbe84f48a4499b489107c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a563b69a1651f0333d0e6da15f27eb0f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a563b69a1651f0333d0e6da15f27eb0f6">exited_snarl</a> () const</td></tr>
<tr class="separator:a563b69a1651f0333d0e6da15f27eb0f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab77d06ac447200cfcc068aca150046f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#ab77d06ac447200cfcc068aca150046f9">entered_chain</a> () const</td></tr>
<tr class="separator:ab77d06ac447200cfcc068aca150046f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1bada9cc419718878176d47ba526fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a9c1bada9cc419718878176d47ba526fd">exited_chain</a> () const</td></tr>
<tr class="separator:a9c1bada9cc419718878176d47ba526fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eafbf88dadbf51c6437fb0bd2f2eefa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a1eafbf88dadbf51c6437fb0bd2f2eefa">skip_chain</a> ()</td></tr>
<tr class="separator:a1eafbf88dadbf51c6437fb0bd2f2eefa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58bf1dae9a324b0eab52a27629f0412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#af58bf1dae9a324b0eab52a27629f0412">initialize_chain</a> ()</td></tr>
<tr class="separator:af58bf1dae9a324b0eab52a27629f0412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6906596d601eb920469da40f266ffcb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#aa6906596d601eb920469da40f266ffcb">initialize_snarl</a> (size_t chain_num)</td></tr>
<tr class="memdesc:aa6906596d601eb920469da40f266ffcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decide what to do right after entering a new snarl.  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#aa6906596d601eb920469da40f266ffcb">More...</a><br /></td></tr>
<tr class="separator:aa6906596d601eb920469da40f266ffcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdefc32348a3322b01ce14761f71289d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#afdefc32348a3322b01ce14761f71289d">continue_snarl</a> ()</td></tr>
<tr class="separator:afdefc32348a3322b01ce14761f71289d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6b67d98e174c7f6ef05a46d62bdb0f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a6d6b67d98e174c7f6ef05a46d62bdb0f">tick</a> ()</td></tr>
<tr class="separator:a6d6b67d98e174c7f6ef05a46d62bdb0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a43cfc2473be5f819cc2ecd413626267e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a43cfc2473be5f819cc2ecd413626267e">end_index</a></td></tr>
<tr class="memdesc:a43cfc2473be5f819cc2ecd413626267e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Where we have to stop.  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a43cfc2473be5f819cc2ecd413626267e">More...</a><br /></td></tr>
<tr class="separator:a43cfc2473be5f819cc2ecd413626267e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d07f882bb947bfcbec2d5844d0ac091"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a3d07f882bb947bfcbec2d5844d0ac091">original_index</a></td></tr>
<tr class="memdesc:a3d07f882bb947bfcbec2d5844d0ac091"><td class="mdescLeft">&#160;</td><td class="mdescRight">Where we started from.  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a3d07f882bb947bfcbec2d5844d0ac091">More...</a><br /></td></tr>
<tr class="separator:a3d07f882bb947bfcbec2d5844d0ac091"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6caa9a2974db62abf95a7dd802e9c294"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a6caa9a2974db62abf95a7dd802e9c294">distance_limit</a></td></tr>
<tr class="memdesc:a6caa9a2974db62abf95a7dd802e9c294"><td class="mdescLeft">&#160;</td><td class="mdescRight">Distance limit we will go up to.  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a6caa9a2974db62abf95a7dd802e9c294">More...</a><br /></td></tr>
<tr class="separator:a6caa9a2974db62abf95a7dd802e9c294"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a890122ec24db71b4df72a27c52d61b8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a890122ec24db71b4df72a27c52d61b8a">original_right_to_left</a></td></tr>
<tr class="memdesc:a890122ec24db71b4df72a27c52d61b8a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Original direction.  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a890122ec24db71b4df72a27c52d61b8a">More...</a><br /></td></tr>
<tr class="separator:a890122ec24db71b4df72a27c52d61b8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac158b356a371902e7fc62450b38be816"><td class="memItemLeft" align="right" valign="top">const vector&lt; <a class="el" href="structvg_1_1ZipCodeTree_1_1tree__item__t.html">tree_item_t</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#ac158b356a371902e7fc62450b38be816">zip_code_tree</a></td></tr>
<tr class="memdesc:ac158b356a371902e7fc62450b38be816"><td class="mdescLeft">&#160;</td><td class="mdescRight">References to the zip code tree to let us look up distance matrices.  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#ac158b356a371902e7fc62450b38be816">More...</a><br /></td></tr>
<tr class="separator:ac158b356a371902e7fc62450b38be816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b516e7ae6aeeaed3eb22a6b5f4f1863"><td class="memItemLeft" align="right" valign="top">std::unordered_map&lt; size_t, std::pair&lt; size_t, size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a3b516e7ae6aeeaed3eb22a6b5f4f1863">best_cyclic_snarl_exits</a></td></tr>
<tr class="separator:a3b516e7ae6aeeaed3eb22a6b5f4f1863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ae76976a9153a529a68e027eeee8c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ZipCodeTree_1_1distance__iterator_1_1iteration__position.html">iteration_position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a64ae76976a9153a529a68e027eeee8c0">pos</a></td></tr>
<tr class="memdesc:a64ae76976a9153a529a68e027eeee8c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The iterator's current position (state, direction, stack, etc.)  <a href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a64ae76976a9153a529a68e027eeee8c0">More...</a><br /></td></tr>
<tr class="separator:a64ae76976a9153a529a68e027eeee8c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fcb30414859be215c015b15b398ec8"><td class="memItemLeft" align="right" valign="top">std::stack&lt; <a class="el" href="structvg_1_1ZipCodeTree_1_1distance__iterator_1_1iteration__position.html">iteration_position</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#af3fcb30414859be215c015b15b398ec8">pending_traversals</a></td></tr>
<tr class="separator:af3fcb30414859be215c015b15b398ec8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Iterator that looks sideways in the tree from a seed, possibly up to a maximum base distance.</p>
<p>Iteration flow:</p>
<p>Original Python implementation: <a href="https://github.com/benedictpaten/long_read_giraffe_chainer_prototype/blob/b590c34055474b0c901a681a1aa99f1651abb6a4/zip_tree_iterator.py">https://github.com/benedictpaten/long_read_giraffe_chainer_prototype/blob/b590c34055474b0c901a681a1aa99f1651abb6a4/zip_tree_iterator.py</a>.</p>
<p>New cyclic snarl handling flowchart: <a href="https://docs.google.com/drawings/d/1diKMXCuMteR06fF64BhSttsD5RHh3eTnd8FtyYqs17Y/edit?usp=sharing">https://docs.google.com/drawings/d/1diKMXCuMteR06fF64BhSttsD5RHh3eTnd8FtyYqs17Y/edit?usp=sharing</a></p>
<p>In order to de-duplicate work, this iterator will not actually look at <em>everything</em> before it. If it knows that seeds from a given chain would have already output transitions to its own position, then it won't even look at anything in that chain. This occurs in cyclic snarls.</p>
<p>For example, since previous chains in a cyclic snarl will have already visited all other chains, later chains do not have to visit previous ones. Similarly, the traversal should never have to enter a cyclic snarl from the outside, since any possible transition crossing the snarl boundary will be found by traversals starting from seeds inside the snarl.</p>
<p>Since a seed in a cyclic snarl may exit in either direction, the iterator "saves" one point (the opposite of its current direction), remembering the stack state and index, to be restored later. Then, when the main iterator hits the end, it can restore the saved state and continue.</p>
<p>The iterator implements simple memorization of snarl exit distances. This is done for only cyclic snarls, as they are the only ones that literarlly turn one traversal into two via the exit-in-both-directions behavior. Each time the iterator calculates the running distance to exit a cyclic snarl, it will check if it has ever seen a better or equal distance, and if so will pretend that the distance is infinite/unreachable. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="aa62eb94739c4b9145d7d72c0818fdb9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa62eb94739c4b9145d7d72c0818fdb9b">&#9670;&nbsp;</a></span>State</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#aa62eb94739c4b9145d7d72c0818fdb9b">vg::ZipCodeTree::distance_iterator::State</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Type for the state of the I-can't-believe-it's-not-a-pushdown-automaton </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aa62eb94739c4b9145d7d72c0818fdb9babbcfa4a338d4b3f9dd2b254360e4c2f2"></a>S_START&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa62eb94739c4b9145d7d72c0818fdb9baadbd2e2b41af1343c217a8121d252c45"></a>S_SCAN_CHAIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa62eb94739c4b9145d7d72c0818fdb9ba8511e4711c1e15ee3afbc973020c5faf"></a>S_SCAN_DAG_SNARL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aa62eb94739c4b9145d7d72c0818fdb9ba8e59dd53e13591f259102bf4d286fbcc"></a>S_SCAN_CYCLIC_SNARL&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a5f0c90085f4f13c3f4fa55b990c6a62c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0c90085f4f13c3f4fa55b990c6a62c">&#9670;&nbsp;</a></span>distance_iterator() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::ZipCodeTree::distance_iterator::distance_iterator </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1ZipCodeTree_1_1tree__item__t.html">tree_item_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>zip_code_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::stack&lt; size_t &gt;&#160;</td>
          <td class="paramname"><em>chain_numbers</em> = <code>std::stack&lt;size_t&gt;()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>right_to_left</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance_limit</em> = <code>std::numeric_limits&lt;size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a reverse iterator starting from start_index, going in the given direction, and with an optional distance limit </p>

</div>
</div>
<a id="a286ea3abdb56edac42658aebec39d14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a286ea3abdb56edac42658aebec39d14f">&#9670;&nbsp;</a></span>distance_iterator() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::ZipCodeTree::distance_iterator::distance_iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1ZipCodeTree_1_1seed__iterator.html">seed_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance_limit</em> = <code>std::numeric_limits&lt;size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a reverse iterator from the given seed iterator. </p>

</div>
</div>
<a id="ac048f1543033b8b1adc5c8e660100e47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac048f1543033b8b1adc5c8e660100e47">&#9670;&nbsp;</a></span>distance_iterator() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::ZipCodeTree::distance_iterator::distance_iterator </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a03cc8cddc66d94ea1a82763f5c6551d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03cc8cddc66d94ea1a82763f5c6551d7">&#9670;&nbsp;</a></span>distance_iterator() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::ZipCodeTree::distance_iterator::distance_iterator </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afdefc32348a3322b01ce14761f71289d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdefc32348a3322b01ce14761f71289d">&#9670;&nbsp;</a></span>continue_snarl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeTree::distance_iterator::continue_snarl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decide what to do when re-entering a snarl, having already stacked up distances </p>

</div>
</div>
<a id="a0165add1598dd599904787ffb8c756cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0165add1598dd599904787ffb8c756cb">&#9670;&nbsp;</a></span>current_item()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ZipCodeTree_1_1tree__item__t.html">tree_item_t</a> vg::ZipCodeTree::distance_iterator::current_item </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What item does index point to? </p>

</div>
</div>
<a id="a18babbfdd0e7bd5776ec2a2f9c837656"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18babbfdd0e7bd5776ec2a2f9c837656">&#9670;&nbsp;</a></span>depth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::ZipCodeTree::distance_iterator::depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Check stack depth. </p>

</div>
</div>
<a id="a21a705a4a40214b5d1d5a5d14d82b00e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21a705a4a40214b5d1d5a5d14d82b00e">&#9670;&nbsp;</a></span>done()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCodeTree::distance_iterator::done </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the iteration done? </p>

</div>
</div>
<a id="abf4c3d78d90cf08b364012088d1a6f1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf4c3d78d90cf08b364012088d1a6f1a">&#9670;&nbsp;</a></span>dup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::ZipCodeTree::distance_iterator::dup </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Duplicate the top item on the stack. </p>

</div>
</div>
<a id="ab77d06ac447200cfcc068aca150046f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab77d06ac447200cfcc068aca150046f9">&#9670;&nbsp;</a></span>entered_chain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCodeTree::distance_iterator::entered_chain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aef783e01306bbe84f48a4499b489107c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef783e01306bbe84f48a4499b489107c">&#9670;&nbsp;</a></span>entered_snarl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCodeTree::distance_iterator::entered_snarl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the current symbol is an entrance/exit, based on the direction the iterator is going (right_to_left) </p>

</div>
</div>
<a id="a9c1bada9cc419718878176d47ba526fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c1bada9cc419718878176d47ba526fd">&#9670;&nbsp;</a></span>exited_chain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCodeTree::distance_iterator::exited_chain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a563b69a1651f0333d0e6da15f27eb0f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a563b69a1651f0333d0e6da15f27eb0f6">&#9670;&nbsp;</a></span>exited_snarl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCodeTree::distance_iterator::exited_snarl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae267bbabfdc79c3b30271288eb0c2973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae267bbabfdc79c3b30271288eb0c2973">&#9670;&nbsp;</a></span>get_cyclic_snarl_bound_distance()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCodeTree::distance_iterator::get_cyclic_snarl_bound_distance </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>snarl_start_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper which simplifies the call to <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a1069c3b150d6da8c4fceb61be5be36e8">stack_matrix_value()</a> Get a distance to the start or end of a CYCLIC snarl Also handles the memorization with best_cyclic_snarl_exits row is zero-indexed within the matrix </p>

</div>
</div>
<a id="ab1d6b489a138b0b01880bfdd67fbfc32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d6b489a138b0b01880bfdd67fbfc32">&#9670;&nbsp;</a></span>get_matrix_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCodeTree::distance_iterator::get_matrix_value </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>matrix_start_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_main_diagonal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper for <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#a1069c3b150d6da8c4fceb61be5be36e8">stack_matrix_value()</a> Get a value from a triangular distance matrix row and col are zero-indexed within the matrix </p>

</div>
</div>
<a id="a1aa50d5429154274042e53a97dbc2ea4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa50d5429154274042e53a97dbc2ea4">&#9670;&nbsp;</a></span>halt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::ZipCodeTree::distance_iterator::halt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stop parsing because nothing else can be below the distance limit. This moves the current index to end_index. </p>

</div>
</div>
<a id="af58bf1dae9a324b0eab52a27629f0412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58bf1dae9a324b0eab52a27629f0412">&#9670;&nbsp;</a></span>initialize_chain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeTree::distance_iterator::initialize_chain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Decide what to do right after entering a new chain. This chain's distance should be on top of the stack. </p>

</div>
</div>
<a id="aa6906596d601eb920469da40f266ffcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6906596d601eb920469da40f266ffcb">&#9670;&nbsp;</a></span>initialize_snarl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeTree::distance_iterator::initialize_snarl </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chain_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decide what to do right after entering a new snarl. </p>

</div>
</div>
<a id="a8f7484f1f42a6e3a7841223433f341ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f7484f1f42a6e3a7841223433f341ea">&#9670;&nbsp;</a></span>move_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeTree::distance_iterator::move_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move index in right_to_left direction If we hit the end and have pending traversals, use one </p>

</div>
</div>
<a id="a5fdb624f4fb08c3031300a1fa508de3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fdb624f4fb08c3031300a1fa508de3a">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCodeTree::distance_iterator::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compare for inequality. </p>

</div>
</div>
<a id="a4e963bb92c2b06cef524332ddc309143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e963bb92c2b06cef524332ddc309143">&#9670;&nbsp;</a></span>operator*()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::ZipCodeTree::distance_iterator::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the index and orientation of the seed we are currently at, and the distance to it. Automatically handles orientation depending on right_to_left </p>

</div>
</div>
<a id="aa50db4002ca8c0e3e5be9b9806592398"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa50db4002ca8c0e3e5be9b9806592398">&#9670;&nbsp;</a></span>operator++()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::ZipCodeTree::distance_iterator::operator++ </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Move in right_to_left direction until we hit another seed or the end. </p>

</div>
</div>
<a id="a8d3759baafbaae1df50bb9964ff7c8bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d3759baafbaae1df50bb9964ff7c8bb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a>&amp; vg::ZipCodeTree::distance_iterator::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8959b0bd6f9cf2b08d621042d5cf9500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8959b0bd6f9cf2b08d621042d5cf9500">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a>&amp; vg::ZipCodeTree::distance_iterator::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7fa77d2c15695fb7af6014c57cd1a72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fa77d2c15695fb7af6014c57cd1a72d">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCodeTree::distance_iterator::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compare for equality to see if we hit end This just trusts that the two iterators are for the same tree </p>

</div>
</div>
<a id="a3323131fa5ff649d7eebf73e413b5efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3323131fa5ff649d7eebf73e413b5efc">&#9670;&nbsp;</a></span>pop()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::ZipCodeTree::distance_iterator::pop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pop a value from the stack and return it. </p>

</div>
</div>
<a id="ad14fad5faab24a3b3c7b73dad1119990"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad14fad5faab24a3b3c7b73dad1119990">&#9670;&nbsp;</a></span>push()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::ZipCodeTree::distance_iterator::push </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Push a value to the stack. </p>

</div>
</div>
<a id="a13ce051884c054587350530f4d7e92c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ce051884c054587350530f4d7e92c0">&#9670;&nbsp;</a></span>save_opposite_cyclic_snarl_exit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeTree::distance_iterator::save_opposite_cyclic_snarl_exit </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chain_num</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save a traversal exiting a cyclic snarl in the opposite direction as the current one, e.g. using an edge C1_R -&gt; SNARL_START </p>

</div>
</div>
<a id="a1eafbf88dadbf51c6437fb0bd2f2eefa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eafbf88dadbf51c6437fb0bd2f2eefa">&#9670;&nbsp;</a></span>skip_chain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeTree::distance_iterator::skip_chain </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Skip the current chain, jumping to the matching end and then one past it to continue the snarl Bound pair index should be right below current distance </p>

</div>
</div>
<a id="a941d5dbfa9f4bb38fc5defbe982f975e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941d5dbfa9f4bb38fc5defbe982f975e">&#9670;&nbsp;</a></span>stack_below_top()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeTree::distance_iterator::stack_below_top </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper for <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#ab0edf066db25bf87cfc81f962d306089">stack_snarl_distances()</a> Stack a single value below the running distance </p>

</div>
</div>
<a id="a1069c3b150d6da8c4fceb61be5be36e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1069c3b150d6da8c4fceb61be5be36e8">&#9670;&nbsp;</a></span>stack_matrix_value()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeTree::distance_iterator::stack_matrix_value </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>matrix_start_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>has_main_diagonal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>col</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper for <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html#ab0edf066db25bf87cfc81f962d306089">stack_snarl_distances()</a> Stack a single value from a triangular distance matrix row and col are zero-indexed within the matrix </p>

</div>
</div>
<a id="ab0edf066db25bf87cfc81f962d306089"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0edf066db25bf87cfc81f962d306089">&#9670;&nbsp;</a></span>stack_snarl_distances()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeTree::distance_iterator::stack_snarl_distances </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>snarl_start_i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chain_num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>right_side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Push distances relevant to a given chain onto the stack chain_num is one-indexed, so the first chain is 1, and the last is N right_side indicates if distances exit from the right or left side </p>

</div>
</div>
<a id="ad1dd2606c3bc0421316309a0be46e4df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1dd2606c3bc0421316309a0be46e4df">&#9670;&nbsp;</a></span>swap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::ZipCodeTree::distance_iterator::swap </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse the top two elements of the stack. </p>

</div>
</div>
<a id="a6d6b67d98e174c7f6ef05a46d62bdb0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6b67d98e174c7f6ef05a46d62bdb0f">&#9670;&nbsp;</a></span>tick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::ZipCodeTree::distance_iterator::tick </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Tick the automaton, looking at the symbol at *it and updating the stack and state. Returns true to yield a value at the current symbol, or to halt, and false otherwise. </p>

</div>
</div>
<a id="af618e6cc265d8df8ef13b513d7ca0040"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af618e6cc265d8df8ef13b513d7ca0040">&#9670;&nbsp;</a></span>top()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::ZipCodeTree::distance_iterator::top </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a mutable reference to the value on top of the stack. </p>

</div>
</div>
<a id="a911fb6f0a523f3e50c561a1100d1f36d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a911fb6f0a523f3e50c561a1100d1f36d">&#9670;&nbsp;</a></span>unimplemented_error()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeTree::distance_iterator::unimplemented_error </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Throw a domain_error that the current state/symbol combo is unimplemented. </p>

</div>
</div>
<a id="a1ce6afc697f038211434e2e532bd16e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce6afc697f038211434e2e532bd16e2">&#9670;&nbsp;</a></span>use_saved_traversal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeTree::distance_iterator::use_saved_traversal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set current <a class="el" href="structvg_1_1ZipCodeTree_1_1distance__iterator_1_1iteration__position.html">iteration_position</a> to the top of pending_traversals. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a3b516e7ae6aeeaed3eb22a6b5f4f1863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b516e7ae6aeeaed3eb22a6b5f4f1863">&#9670;&nbsp;</a></span>best_cyclic_snarl_exits</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt;size_t, std::pair&lt;size_t, size_t&gt; &gt; vg::ZipCodeTree::distance_iterator::best_cyclic_snarl_exits</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Best distance for each snarl exit we've seen Stored as {snarl start index : (start dist, end dist)} </p>

</div>
</div>
<a id="a6caa9a2974db62abf95a7dd802e9c294"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6caa9a2974db62abf95a7dd802e9c294">&#9670;&nbsp;</a></span>distance_limit</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCodeTree::distance_iterator::distance_limit</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Distance limit we will go up to. </p>

</div>
</div>
<a id="a43cfc2473be5f819cc2ecd413626267e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43cfc2473be5f819cc2ecd413626267e">&#9670;&nbsp;</a></span>end_index</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCodeTree::distance_iterator::end_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Where we have to stop. </p>

</div>
</div>
<a id="a3d07f882bb947bfcbec2d5844d0ac091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d07f882bb947bfcbec2d5844d0ac091">&#9670;&nbsp;</a></span>original_index</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCodeTree::distance_iterator::original_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Where we started from. </p>

</div>
</div>
<a id="a890122ec24db71b4df72a27c52d61b8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a890122ec24db71b4df72a27c52d61b8a">&#9670;&nbsp;</a></span>original_right_to_left</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCodeTree::distance_iterator::original_right_to_left</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Original direction. </p>

</div>
</div>
<a id="af3fcb30414859be215c015b15b398ec8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fcb30414859be215c015b15b398ec8">&#9670;&nbsp;</a></span>pending_traversals</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::stack&lt;<a class="el" href="structvg_1_1ZipCodeTree_1_1distance__iterator_1_1iteration__position.html">iteration_position</a>&gt; vg::ZipCodeTree::distance_iterator::pending_traversals</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Starting positions of other traversals that we will do later When the current traversal can no longer go on, we pop one of these and set the current position to it </p>

</div>
</div>
<a id="a64ae76976a9153a529a68e027eeee8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ae76976a9153a529a68e027eeee8c0">&#9670;&nbsp;</a></span>pos</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ZipCodeTree_1_1distance__iterator_1_1iteration__position.html">iteration_position</a> vg::ZipCodeTree::distance_iterator::pos</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The iterator's current position (state, direction, stack, etc.) </p>

</div>
</div>
<a id="ac158b356a371902e7fc62450b38be816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac158b356a371902e7fc62450b38be816">&#9670;&nbsp;</a></span>zip_code_tree</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt;<a class="el" href="structvg_1_1ZipCodeTree_1_1tree__item__t.html">tree_item_t</a>&gt;* vg::ZipCodeTree::distance_iterator::zip_code_tree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>References to the zip code tree to let us look up distance matrices. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="zip__code__tree_8hpp.html">zip_code_tree.hpp</a></li>
<li>src/<a class="el" href="zip__code__tree_8cpp.html">zip_code_tree.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.1
</small></address>
</body>
</html>
