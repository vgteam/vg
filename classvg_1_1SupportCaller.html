<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::SupportCaller Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1SupportCaller.html">SupportCaller</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classvg_1_1SupportCaller-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::SupportCaller Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;support_caller.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::SupportCaller:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1SupportCaller.png" usemap="#vg::SupportCaller_map" alt=""/>
  <map id="vg::SupportCaller_map" name="vg::SupportCaller_map">
<area href="classvg_1_1Configurable.html" alt="vg::Configurable" shape="rect" coords="0,0,110,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller_1_1PrimaryPath.html">PrimaryPath</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ae794f8e0fba185201cc7ce6d41f2a09d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#ae794f8e0fba185201cc7ce6d41f2a09d">SupportCaller</a> ()=default</td></tr>
<tr class="separator:ae794f8e0fba185201cc7ce6d41f2a09d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17d18dd922c1cc6b0432fa64c20fc0c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a17d18dd922c1cc6b0432fa64c20fc0c5">call</a> (<a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;augmented, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;site_manager, string pileup_filename=&quot;&quot;)</td></tr>
<tr class="separator:a17d18dd922c1cc6b0432fa64c20fc0c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8584ce2b987941760a9f46bfd5e2f1fd"><td class="memItemLeft" align="right" valign="top">tuple&lt; vector&lt; <a class="el" href="structvg_1_1Support.html">Support</a> &gt;<br class="typebreak"/>
, vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a8584ce2b987941760a9f46bfd5e2f1fd">get_traversal_supports_and_sizes</a> (<a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;augmented, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;snarl_manager, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;site, const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;traversals, const vector&lt; const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> * &gt; &amp;minus_traversals={})</td></tr>
<tr class="separator:a8584ce2b987941760a9f46bfd5e2f1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b98d45a2f068ec980309b7a3e03b3e0"><td class="memItemLeft" align="right" valign="top">tuple&lt; <a class="el" href="structvg_1_1Support.html">Support</a>, <a class="el" href="structvg_1_1Support.html">Support</a>, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a3b98d45a2f068ec980309b7a3e03b3e0">get_traversal_support</a> (<a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;augmented, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;snarl_manager, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *site, const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;traversal, const vector&lt; const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> * &gt; &amp;already_used={}, const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> *ref_traversal=nullptr)</td></tr>
<tr class="separator:a3b98d45a2f068ec980309b7a3e03b3e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9617d7c962abebc73b02b624e39fa738"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Support.html">Support</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a9617d7c962abebc73b02b624e39fa738">get_inversion_supports</a> (<a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;augmented, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;snarl_manager, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;site, const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;traversals, const vector&lt; size_t &gt; &amp;traversal_sizes, int best_allele, int second_best_allele)</td></tr>
<tr class="separator:a9617d7c962abebc73b02b624e39fa738"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfd7e51e300c2fe08c5ae08043197786"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#abfd7e51e300c2fe08c5ae08043197786">find_best_traversals</a> (<a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;augmented, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;snarl_manager, <a class="el" href="classvg_1_1TraversalFinder.html">TraversalFinder</a> *finder, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;site, const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;baseline_support, size_t copy_budget, function&lt; void(const <a class="el" href="structvg_1_1Locus.html">Locus</a> &amp;, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *, const vcflib::Variant *)&gt; emit_locus)</td></tr>
<tr class="separator:abfd7e51e300c2fe08c5ae08043197786"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d2b7d632acf148d00dd28755657c000"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a7d2b7d632acf148d00dd28755657c000">recall_locus</a> (<a class="el" href="structvg_1_1Locus.html">Locus</a> &amp;locus, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;site, vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;traversals, vector&lt; vector&lt; int &gt;&gt; &amp;trav_alleles, vector&lt; vcflib::Variant * &gt; &amp;site_variants, function&lt; void(const <a class="el" href="structvg_1_1Locus.html">Locus</a> &amp;, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *, const vcflib::Variant *)&gt; emit_locus)</td></tr>
<tr class="separator:a7d2b7d632acf148d00dd28755657c000"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4abd0bfb4a2da2dff66e8046517d89c5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a4abd0bfb4a2da2dff66e8046517d89c5">emit_variant</a> (map&lt; string, string &gt; &amp;contig_names_by_path_name, vcflib::VariantCallFile &amp;vcf, <a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;augmented, <a class="el" href="structvg_1_1Support.html">Support</a> &amp;baseline_support, <a class="el" href="structvg_1_1Support.html">Support</a> &amp;global_baseline_support, const <a class="el" href="structvg_1_1Locus.html">Locus</a> &amp;locus, <a class="el" href="classvg_1_1SupportCaller_1_1PrimaryPath.html">PrimaryPath</a> &amp;primary_path, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *site)</td></tr>
<tr class="separator:a4abd0bfb4a2da2dff66e8046517d89c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3465ffd62bf11ebf1ebb23f88b696398"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a3465ffd62bf11ebf1ebb23f88b696398">emit_recall_variant</a> (map&lt; string, string &gt; &amp;contig_names_by_path_name, vcflib::VariantCallFile &amp;vcf, <a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;augmented, <a class="el" href="structvg_1_1Support.html">Support</a> &amp;baseline_support, <a class="el" href="structvg_1_1Support.html">Support</a> &amp;global_baseline_support, const <a class="el" href="structvg_1_1Locus.html">Locus</a> &amp;locus, <a class="el" href="classvg_1_1SupportCaller_1_1PrimaryPath.html">PrimaryPath</a> &amp;primary_path, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *site, const vcflib::Variant *recall_variant)</td></tr>
<tr class="separator:a3465ffd62bf11ebf1ebb23f88b696398"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a34e1af508b8d08eeaa4e5628e6bd11"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a7a34e1af508b8d08eeaa4e5628e6bd11">add_variant_info_and_emit</a> (vcflib::Variant &amp;variant, <a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;augmented, const <a class="el" href="structvg_1_1Locus.html">Locus</a> &amp;locus, const <a class="el" href="structvg_1_1Genotype.html">Genotype</a> &amp;genotype, int best_allele, int second_best_allele, const vector&lt; int &gt; &amp;used_alleles, <a class="el" href="structvg_1_1Support.html">Support</a> &amp;baseline_support, <a class="el" href="structvg_1_1Support.html">Support</a> &amp;global_baseline_support)</td></tr>
<tr class="separator:a7a34e1af508b8d08eeaa4e5628e6bd11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a122bc21c6e3795bf018cacf541ab6d6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a122bc21c6e3795bf018cacf541ab6d6e">is_reference</a> (const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;trav, <a class="el" href="structvg_1_1AugmentedGraph.html">AugmentedGraph</a> &amp;augmented)</td></tr>
<tr class="separator:a122bc21c6e3795bf018cacf541ab6d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6d58daaa5f0c090e934d0dbaaa14ce8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#aa6d58daaa5f0c090e934d0dbaaa14ce8">is_reference</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, <a class="el" href="structvg_1_1AugmentedGraph.html">AugmentedGraph</a> &amp;augmented)</td></tr>
<tr class="separator:aa6d58daaa5f0c090e934d0dbaaa14ce8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e0c3c04b02b50a8dd7aa2f17891ea05"><td class="memItemLeft" align="right" valign="top">map&lt; string, <a class="el" href="classvg_1_1SupportCaller_1_1PrimaryPath.html">PrimaryPath</a> &gt;<br class="typebreak"/>
::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a2e0c3c04b02b50a8dd7aa2f17891ea05">find_path</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;site)</td></tr>
<tr class="separator:a2e0c3c04b02b50a8dd7aa2f17891ea05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcc97bc5517cf93bc14083509746d3c7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#abcc97bc5517cf93bc14083509746d3c7">get_deletion_length</a> (const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;end1, const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;end2, <a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;augmented)</td></tr>
<tr class="separator:abcc97bc5517cf93bc14083509746d3c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1Configurable"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1Configurable')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1Configurable.html">vg::Configurable</a></td></tr>
<tr class="memitem:afa7bba48c6289ea9b9095acd79a5658e inherit pub_methods_classvg_1_1Configurable"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Configurable.html#afa7bba48c6289ea9b9095acd79a5658e">register_option</a> (<a class="el" href="classvg_1_1OptionInterface.html">OptionInterface</a> *option)</td></tr>
<tr class="separator:afa7bba48c6289ea9b9095acd79a5658e inherit pub_methods_classvg_1_1Configurable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553f14c4f4a19bb51d40ffb211945b3a inherit pub_methods_classvg_1_1Configurable"><td class="memItemLeft" align="right" valign="top">virtual vector&lt; <a class="el" href="classvg_1_1OptionInterface.html">OptionInterface</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Configurable.html#a553f14c4f4a19bb51d40ffb211945b3a">get_options</a> ()</td></tr>
<tr class="separator:a553f14c4f4a19bb51d40ffb211945b3a inherit pub_methods_classvg_1_1Configurable"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee830d6a5cdcf8e7a2896a443bcc80cc inherit pub_methods_classvg_1_1Configurable"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Configurable.html#aee830d6a5cdcf8e7a2896a443bcc80cc">get_name</a> ()</td></tr>
<tr class="separator:aee830d6a5cdcf8e7a2896a443bcc80cc inherit pub_methods_classvg_1_1Configurable"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa339586afbf179881045478d4b6f09db"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#aa339586afbf179881045478d4b6f09db">support_quality</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;support)</td></tr>
<tr class="separator:aa339586afbf179881045478d4b6f09db"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a8dab4df2537ef96e9803d630f5920aec"><td class="memItemLeft" align="right" valign="top">map&lt; string, <a class="el" href="classvg_1_1SupportCaller_1_1PrimaryPath.html">PrimaryPath</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a8dab4df2537ef96e9803d630f5920aec">primary_paths</a></td></tr>
<tr class="separator:a8dab4df2537ef96e9803d630f5920aec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8b8ec1ae50ef22ec1bb7f9307edcdd"><td class="memItemLeft" align="right" valign="top">function&lt; double(const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#abc8b8ec1ae50ef22ec1bb7f9307edcdd">support_val</a></td></tr>
<tr class="separator:abc8b8ec1ae50ef22ec1bb7f9307edcdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363b181f0b11a99ca083c84ad3e3e20f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a363b181f0b11a99ca083c84ad3e3e20f">convert_to_vcf</a></td></tr>
<tr class="memdesc:a363b181f0b11a99ca083c84ad3e3e20f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should we output in VCF (true) or Protobuf <a class="el" href="structvg_1_1Locus.html" title="Describes a genetic locus with multiple possible alleles, a genotype, and observational support...">Locus</a> (false) format?  <a href="#a363b181f0b11a99ca083c84ad3e3e20f">More...</a><br/></td></tr>
<tr class="separator:a363b181f0b11a99ca083c84ad3e3e20f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6584c21b8d57196db570a3642e23a27"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#ae6584c21b8d57196db570a3642e23a27">locus_buffer_size</a> = 1000</td></tr>
<tr class="memdesc:ae6584c21b8d57196db570a3642e23a27"><td class="mdescLeft">&#160;</td><td class="mdescRight">How big should our output buffer be?  <a href="#ae6584c21b8d57196db570a3642e23a27">More...</a><br/></td></tr>
<tr class="separator:ae6584c21b8d57196db570a3642e23a27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6600a3aeeb8f2bbf19f422d0eb8f841a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; vector&lt; string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a6600a3aeeb8f2bbf19f422d0eb8f841a">ref_path_names</a></td></tr>
<tr class="memdesc:a6600a3aeeb8f2bbf19f422d0eb8f841a"><td class="mdescLeft">&#160;</td><td class="mdescRight">What are the names of the reference paths, if any, in the graph?  <a href="#a6600a3aeeb8f2bbf19f422d0eb8f841a">More...</a><br/></td></tr>
<tr class="separator:a6600a3aeeb8f2bbf19f422d0eb8f841a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d89567cf42fb8cb646001046c55d0cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; vector&lt; string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a6d89567cf42fb8cb646001046c55d0cc">contig_name_overrides</a></td></tr>
<tr class="separator:a6d89567cf42fb8cb646001046c55d0cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c187e37f3ba63eeaba57b9b1bc2ae64"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a3c187e37f3ba63eeaba57b9b1bc2ae64">length_overrides</a></td></tr>
<tr class="separator:a3c187e37f3ba63eeaba57b9b1bc2ae64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e613538924447d54fbecbf8d14f501d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a4e613538924447d54fbecbf8d14f501d">sample_name</a></td></tr>
<tr class="memdesc:a4e613538924447d54fbecbf8d14f501d"><td class="mdescLeft">&#160;</td><td class="mdescRight">What name should we use for the sample in the VCF file?  <a href="#a4e613538924447d54fbecbf8d14f501d">More...</a><br/></td></tr>
<tr class="separator:a4e613538924447d54fbecbf8d14f501d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed18b083fd15705d07c6a5e35739937"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#afed18b083fd15705d07c6a5e35739937">variant_offset</a></td></tr>
<tr class="memdesc:afed18b083fd15705d07c6a5e35739937"><td class="mdescLeft">&#160;</td><td class="mdescRight">How far should we offset positions of variants?  <a href="#afed18b083fd15705d07c6a5e35739937">More...</a><br/></td></tr>
<tr class="separator:afed18b083fd15705d07c6a5e35739937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae1d059f7ca1760f2f2232bf10823df8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#aae1d059f7ca1760f2f2232bf10823df8">max_search_depth</a></td></tr>
<tr class="separator:aae1d059f7ca1760f2f2232bf10823df8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cea088e31aee9726bda4efd25fef82f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a4cea088e31aee9726bda4efd25fef82f">max_search_width</a></td></tr>
<tr class="separator:a4cea088e31aee9726bda4efd25fef82f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65abecae63da2cabc9a3bc4f7a710ded"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a65abecae63da2cabc9a3bc4f7a710ded">min_fraction_for_call</a></td></tr>
<tr class="separator:a65abecae63da2cabc9a3bc4f7a710ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e5b0b963ac2a2c00c36ab31a13765c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a94e5b0b963ac2a2c00c36ab31a13765c">max_het_bias</a></td></tr>
<tr class="separator:a94e5b0b963ac2a2c00c36ab31a13765c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a370d5fb988f39ab6a03efbf1bbed1d65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a370d5fb988f39ab6a03efbf1bbed1d65">max_ref_het_bias</a></td></tr>
<tr class="memdesc:a370d5fb988f39ab6a03efbf1bbed1d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like above, but applied to ref / alt ratio (instead of alt / ref)  <a href="#a370d5fb988f39ab6a03efbf1bbed1d65">More...</a><br/></td></tr>
<tr class="separator:a370d5fb988f39ab6a03efbf1bbed1d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af03841cbfb977456890928bbcd831362"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#af03841cbfb977456890928bbcd831362">max_indel_het_bias</a></td></tr>
<tr class="memdesc:af03841cbfb977456890928bbcd831362"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the max het bias, but applies to novel indels.  <a href="#af03841cbfb977456890928bbcd831362">More...</a><br/></td></tr>
<tr class="separator:af03841cbfb977456890928bbcd831362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5685ff84488c17db0bca88f8ce7d697"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#ac5685ff84488c17db0bca88f8ce7d697">max_indel_ma_bias</a></td></tr>
<tr class="memdesc:ac5685ff84488c17db0bca88f8ce7d697"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like the max het bias, but applies to multiallelic indels.  <a href="#ac5685ff84488c17db0bca88f8ce7d697">More...</a><br/></td></tr>
<tr class="separator:ac5685ff84488c17db0bca88f8ce7d697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8db9e682e135333e47b6ecb0b5374efb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a8db9e682e135333e47b6ecb0b5374efb">min_total_support_for_call</a></td></tr>
<tr class="separator:a8db9e682e135333e47b6ecb0b5374efb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da5805e7c262a8fe317ad9e0b49817a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a1da5805e7c262a8fe317ad9e0b49817a">ref_bin_size</a></td></tr>
<tr class="separator:a1da5805e7c262a8fe317ad9e0b49817a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72cd919ebff400d32250e4f0882929f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a72cd919ebff400d32250e4f0882929f4">expected_coverage</a></td></tr>
<tr class="separator:a72cd919ebff400d32250e4f0882929f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a032117d5fd316be83877834de8d25a99"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a032117d5fd316be83877834de8d25a99">use_average_support</a></td></tr>
<tr class="separator:a032117d5fd316be83877834de8d25a99"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3826a4f33deff50ad7d35c0b121e95c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#ad3826a4f33deff50ad7d35c0b121e95c">average_support_switch_threshold</a></td></tr>
<tr class="separator:ad3826a4f33deff50ad7d35c0b121e95c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4149e268405a8af09ee45decd51ec717"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a4149e268405a8af09ee45decd51ec717">max_bubble_paths</a> = 100</td></tr>
<tr class="separator:a4149e268405a8af09ee45decd51ec717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31afb796c7822133359248f2f53d2c4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a31afb796c7822133359248f2f53d2c4b">min_mad_for_filter</a></td></tr>
<tr class="separator:a31afb796c7822133359248f2f53d2c4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c9519695b82b720072a1125a638b30"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a89c9519695b82b720072a1125a638b30">max_dp_for_filter</a></td></tr>
<tr class="memdesc:a89c9519695b82b720072a1125a638b30"><td class="mdescLeft">&#160;</td><td class="mdescRight">what's the maximum total depth to give a PASS in the filter column  <a href="#a89c9519695b82b720072a1125a638b30">More...</a><br/></td></tr>
<tr class="separator:a89c9519695b82b720072a1125a638b30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4ac3dd541bcb9ab18eeb73ba93b4809"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#aa4ac3dd541bcb9ab18eeb73ba93b4809">max_dp_multiple_for_filter</a></td></tr>
<tr class="separator:aa4ac3dd541bcb9ab18eeb73ba93b4809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f075288ed00491db3479a2717a595d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a3f075288ed00491db3479a2717a595d8">max_local_dp_multiple_for_filter</a></td></tr>
<tr class="separator:a3f075288ed00491db3479a2717a595d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2588765531eceb32bfc8a487d6503d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#aca2588765531eceb32bfc8a487d6503d">min_ad_log_likelihood_for_filter</a></td></tr>
<tr class="memdesc:aca2588765531eceb32bfc8a487d6503d"><td class="mdescLeft">&#160;</td><td class="mdescRight">what's the min log likelihood for allele depth assignments to PASS?  <a href="#aca2588765531eceb32bfc8a487d6503d">More...</a><br/></td></tr>
<tr class="separator:aca2588765531eceb32bfc8a487d6503d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a216ee27f03698399b7ded8342d846ba1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a216ee27f03698399b7ded8342d846ba1">write_trivial_calls</a></td></tr>
<tr class="separator:a216ee27f03698399b7ded8342d846ba1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c63051b322bb03bb9de210c6b63ee7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a92c63051b322bb03bb9de210c6b63ee7">call_other_by_coverage</a></td></tr>
<tr class="separator:a92c63051b322bb03bb9de210c6b63ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a626d85743ce833b7745afe9c1ab66cb6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a626d85743ce833b7745afe9c1ab66cb6">use_support_count</a></td></tr>
<tr class="separator:a626d85743ce833b7745afe9c1ab66cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2310ebac3bb08de54267e7f7aa1b06d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a2310ebac3bb08de54267e7f7aa1b06d4">support_file_name</a></td></tr>
<tr class="memdesc:a2310ebac3bb08de54267e7f7aa1b06d4"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvg_1_1Path.html">Path</a> of supports file generated from the <a class="el" href="classvg_1_1PileupAugmenter.html">PileupAugmenter</a> (via vg augment)  <a href="#a2310ebac3bb08de54267e7f7aa1b06d4">More...</a><br/></td></tr>
<tr class="separator:a2310ebac3bb08de54267e7f7aa1b06d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3251426f491b2efad76f0db8f28512f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a3251426f491b2efad76f0db8f28512f4">leave_shared_ends</a></td></tr>
<tr class="separator:a3251426f491b2efad76f0db8f28512f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a643327cc6aa0bd911a56dd13bf298e54"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a643327cc6aa0bd911a56dd13bf298e54">max_inversion_size</a></td></tr>
<tr class="separator:a643327cc6aa0bd911a56dd13bf298e54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fde552e0e331791c139efb536de4128"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a8fde552e0e331791c139efb536de4128">recall_vcf_filename</a></td></tr>
<tr class="separator:a8fde552e0e331791c139efb536de4128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf461014ec4fe763c6f65dda3523d7bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#aaf461014ec4fe763c6f65dda3523d7bb">recall_ref_fasta_filename</a></td></tr>
<tr class="separator:aaf461014ec4fe763c6f65dda3523d7bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add419898b3f716efbe495ca75fa14fd4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#add419898b3f716efbe495ca75fa14fd4">recall_ins_fasta_filename</a></td></tr>
<tr class="separator:add419898b3f716efbe495ca75fa14fd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8568b0cb2e9d2a2b6926d189a7fcead9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a8568b0cb2e9d2a2b6926d189a7fcead9">pack_file_name</a></td></tr>
<tr class="memdesc:a8568b0cb2e9d2a2b6926d189a7fcead9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvg_1_1Path.html">Path</a> of pack file generated from vg pack.  <a href="#a8568b0cb2e9d2a2b6926d189a7fcead9">More...</a><br/></td></tr>
<tr class="separator:a8568b0cb2e9d2a2b6926d189a7fcead9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c006411b59c4b2b85c81ae593e018e4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Option.html">Option</a>&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a7c006411b59c4b2b85c81ae593e018e4">xg_file_name</a></td></tr>
<tr class="separator:a7c006411b59c4b2b85c81ae593e018e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74478df30c0c02519b875bef8b946d71"><td class="memItemLeft" align="right" valign="top">vcflib::VariantCallFile&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a74478df30c0c02519b875bef8b946d71">variant_file</a></td></tr>
<tr class="memdesc:a74478df30c0c02519b875bef8b946d71"><td class="mdescLeft">&#160;</td><td class="mdescRight">structures to hold the recall vcf and fastas  <a href="#a74478df30c0c02519b875bef8b946d71">More...</a><br/></td></tr>
<tr class="separator:a74478df30c0c02519b875bef8b946d71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c8a316d75b2e1db80894b6ce230fb8"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; FastaReference &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#ae0c8a316d75b2e1db80894b6ce230fb8">ref_fasta</a></td></tr>
<tr class="separator:ae0c8a316d75b2e1db80894b6ce230fb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1209f27455e07ab97aae155418e5e6"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; FastaReference &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#afc1209f27455e07ab97aae155418e5e6">ins_fasta</a></td></tr>
<tr class="separator:afc1209f27455e07ab97aae155418e5e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a999d3ecc21ca9cab7ac9b14159ae1c44"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a999d3ecc21ca9cab7ac9b14159ae1c44">min_alt_path_support</a> = 0.2</td></tr>
<tr class="memdesc:a999d3ecc21ca9cab7ac9b14159ae1c44"><td class="mdescLeft">&#160;</td><td class="mdescRight">minimum average base support on alt path for it to be considered  <a href="#a999d3ecc21ca9cab7ac9b14159ae1c44">More...</a><br/></td></tr>
<tr class="separator:a999d3ecc21ca9cab7ac9b14159ae1c44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16284074baabe10886ae5e33b2d0e165"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a16284074baabe10886ae5e33b2d0e165">verbose</a> = false</td></tr>
<tr class="memdesc:a16284074baabe10886ae5e33b2d0e165"><td class="mdescLeft">&#160;</td><td class="mdescRight">print warnings etc. to stderr  <a href="#a16284074baabe10886ae5e33b2d0e165">More...</a><br/></td></tr>
<tr class="separator:a16284074baabe10886ae5e33b2d0e165"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a915a93847b01934900fd4c6dcb61b333"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportCaller.html#a915a93847b01934900fd4c6dcb61b333">max_unsupported_edge_size</a> = 20</td></tr>
<tr class="separator:a915a93847b01934900fd4c6dcb61b333"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classvg_1_1SupportCaller.html">SupportCaller</a>: take an augmented graph from a Caller and produce actual calls in a VCF. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae794f8e0fba185201cc7ce6d41f2a09d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::SupportCaller::SupportCaller </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set up to call with default parameters. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7a34e1af508b8d08eeaa4e5628e6bd11"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SupportCaller::add_variant_info_and_emit </td>
          <td>(</td>
          <td class="paramtype">vcflib::Variant &amp;&#160;</td>
          <td class="paramname"><em>variant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>augmented</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Locus.html">Locus</a> &amp;&#160;</td>
          <td class="paramname"><em>locus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Genotype.html">Genotype</a> &amp;&#160;</td>
          <td class="paramname"><em>genotype</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>best_allele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>second_best_allele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>used_alleles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>baseline_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>global_baseline_support</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>add the info fields to a variant and actually emit it (used by both emit_variant and emit_recall_variant) </p>

</div>
</div>
<a class="anchor" id="a17d18dd922c1cc6b0432fa64c20fc0c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SupportCaller::call </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>augmented</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td>
          <td class="paramname"><em>site_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>pileup_filename</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce calls for the given annotated augmented graph. If a pileup_filename is provided, the pileup is loaded again and used to add comments describing variants </p>

</div>
</div>
<a class="anchor" id="a3465ffd62bf11ebf1ebb23f88b696398"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SupportCaller::emit_recall_variant </td>
          <td>(</td>
          <td class="paramtype">map&lt; string, string &gt; &amp;&#160;</td>
          <td class="paramname"><em>contig_names_by_path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcflib::VariantCallFile &amp;&#160;</td>
          <td class="paramname"><em>vcf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>augmented</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>baseline_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>global_baseline_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Locus.html">Locus</a> &amp;&#160;</td>
          <td class="paramname"><em>locus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SupportCaller_1_1PrimaryPath.html">PrimaryPath</a> &amp;&#160;</td>
          <td class="paramname"><em>primary_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>site</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vcflib::Variant *&#160;</td>
          <td class="paramname"><em>recall_variant</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like emit_variant, but use the given vcf variant as a template and just compute the genotype and info </p>

</div>
</div>
<a class="anchor" id="a4abd0bfb4a2da2dff66e8046517d89c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SupportCaller::emit_variant </td>
          <td>(</td>
          <td class="paramtype">map&lt; string, string &gt; &amp;&#160;</td>
          <td class="paramname"><em>contig_names_by_path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcflib::VariantCallFile &amp;&#160;</td>
          <td class="paramname"><em>vcf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>augmented</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>baseline_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>global_baseline_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Locus.html">Locus</a> &amp;&#160;</td>
          <td class="paramname"><em>locus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SupportCaller_1_1PrimaryPath.html">PrimaryPath</a> &amp;&#160;</td>
          <td class="paramname"><em>primary_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>site</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function emits the given variant on the given primary path, as VCF. It needs to take the site as an argument because it may be called for children of the site we're working on right now. </p>

</div>
</div>
<a class="anchor" id="abfd7e51e300c2fe08c5ae08043197786"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; vg::SupportCaller::find_best_traversals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>augmented</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1TraversalFinder.html">TraversalFinder</a> *&#160;</td>
          <td class="paramname"><em>finder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>site</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>baseline_support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>copy_budget</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(const <a class="el" href="structvg_1_1Locus.html">Locus</a> &amp;, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *, const vcflib::Variant *)&gt;&#160;</td>
          <td class="paramname"><em>emit_locus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For the given snarl, find the reference traversal, the best traversal, and the second-best traversal, recursively, if any exist. These traversals will be fully filled in with nodes.</p>
<p>Only snarls which are ultrabubbles can be called.</p>
<p>Expects the given baseline support for a diploid call.</p>
<p>Will not return more than 1 + copy_budget SnarlTraversals, and will return less if some copies are called as having the same traversal.</p>
<p>Does not deduplicate agains the ref traversal; it may be the same as the best or second-best.</p>
<p>Uses the given copy number allowance, and emits a <a class="el" href="structvg_1_1Locus.html" title="Describes a genetic locus with multiple possible alleles, a genotype, and observational support...">Locus</a> for this <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> and any child Snarls.</p>
<p>If no path through the <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes. ">Snarl</a> can be found, emits no <a class="el" href="structvg_1_1Locus.html" title="Describes a genetic locus with multiple possible alleles, a genotype, and observational support...">Locus</a> and returns no SnarlTraversals. </p>

</div>
</div>
<a class="anchor" id="a2e0c3c04b02b50a8dd7aa2f17891ea05"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, <a class="el" href="classvg_1_1SupportCaller_1_1PrimaryPath.html">SupportCaller::PrimaryPath</a> &gt;::iterator vg::SupportCaller::find_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>site</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the primary path, if any, that the given site is threaded onto.</p>
<p>TODO: can only work by brute-force search. </p>

</div>
</div>
<a class="anchor" id="abcc97bc5517cf93bc14083509746d3c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::SupportCaller::get_deletion_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>end1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>end2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>augmented</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the lenght of a deletion deletion edge along (the first found) primary path. If no path found or not a deletion edge, return 0. </p>

</div>
</div>
<a class="anchor" id="a9617d7c962abebc73b02b624e39fa738"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Support.html">Support</a> &gt; vg::SupportCaller::get_inversion_supports </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>augmented</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>site</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>traversals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>traversal_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>best_allele</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>second_best_allele</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the edge supports of an inversion. This is to be used for computing genotypes with average support, as the normal supports will almost always return 0/1 due to the nodes having the same support. If the alleles don't refer to a simple inversion, an empty vector is returned (and should be ignored) </p>

</div>
</div>
<a class="anchor" id="a3b98d45a2f068ec980309b7a3e03b3e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple&lt; <a class="el" href="structvg_1_1Support.html">Support</a>, <a class="el" href="structvg_1_1Support.html">Support</a>, size_t &gt; vg::SupportCaller::get_traversal_support </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>augmented</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>site</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>traversal</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>already_used</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> *&#160;</td>
          <td class="paramname"><em>ref_traversal</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the min support, total support, bp size (to divide total by for average support), optionally special-casing the material used by another traversal. Material used by another traversal only makes half its coverage available to this traversal. If ref_traversal specified (and not same as traversal), its contents will be forbidden from boosting the average support to avoid the actual variation from getting diluted by shared reference.</p>
<p>Get the min support, total support, bp size (to divide total by for average support), and fraction of unsupported edges for a traversal, optionally special-casing the material used by another traversal. Material used by another traversal only makes half its coverage available to this traversal. </p>

</div>
</div>
<a class="anchor" id="a8584ce2b987941760a9f46bfd5e2f1fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple&lt; vector&lt; <a class="el" href="structvg_1_1Support.html">Support</a> &gt;, vector&lt; size_t &gt; &gt; vg::SupportCaller::get_traversal_supports_and_sizes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>augmented</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>site</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>traversals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>minus_traversals</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the support and size for each traversal in a list. Discount support of minus_traversal if it's specified. Use average_support_switch_threshold and use_average_support to decide whether to return min or avg supports.</p>
<p>Get the support for each traversal in a list, using average_support_switch_threshold to decide if we use the minimum or average. Apply the min_supported_edges cutoff to set support to 0 if not enough edges were supported. </p>

</div>
</div>
<a class="anchor" id="a122bc21c6e3795bf018cacf541ab6d6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::SupportCaller::is_reference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>trav</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1AugmentedGraph.html">AugmentedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>augmented</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decide if the given <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> is included in the original base graph (true), or if it represents a novel variant (false).</p>
<p>Looks at the nodes in the traversal, and sees if their calls are CALL_REFERENCE or not.</p>
<p>Handles single-edge traversals. </p>

</div>
</div>
<a class="anchor" id="aa6d58daaa5f0c090e934d0dbaaa14ce8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::SupportCaller::is_reference </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1AugmentedGraph.html">AugmentedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>augmented</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decide if the given <a class="el" href="structvg_1_1Path.html">Path</a> is included in the original base graph (true) or if it represents a novel variant (false).</p>
<p>Looks at the nodes, and sees if their calls are CALL_REFERENCE or not.</p>
<p>The path can't be empty; it has to be anchored to something (probably the start and end of the snarl it came from). </p>

</div>
</div>
<a class="anchor" id="a7d2b7d632acf148d00dd28755657c000"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SupportCaller::recall_locus </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Locus.html">Locus</a> &amp;&#160;</td>
          <td class="paramname"><em>locus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>site</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>traversals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>trav_alleles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vcflib::Variant * &gt; &amp;&#160;</td>
          <td class="paramname"><em>site_variants</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(const <a class="el" href="structvg_1_1Locus.html">Locus</a> &amp;, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *, const vcflib::Variant *)&gt;&#160;</td>
          <td class="paramname"><em>emit_locus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Instead of just emitting the locus, use the site info from the VCF to output a locus for each variant in the VCF that touchces our site. </p>

</div>
</div>
<a class="anchor" id="aa339586afbf179881045478d4b6f09db"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static double vg::SupportCaller::support_quality </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>support</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="ad3826a4f33deff50ad7d35c0b121e95c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;size_t&gt; vg::SupportCaller::average_support_switch_threshold</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;use-avg-support-above&quot;</span>, <span class="stringliteral">&quot;uUaAtT&quot;</span>, 100,</div>
<div class="line">        <span class="stringliteral">&quot;use average instead of minimum support for sites this long or longer&quot;</span>}</div>
</div><!-- fragment --><p>Max traversal length threshold at which we switch from minimum support to average support (so we don't use average support on pairs of adjacent errors and miscall them, but we do use it on long runs of reference inside a deletion where the min support might not be representative. </p>

</div>
</div>
<a class="anchor" id="a92c63051b322bb03bb9de210c6b63ee7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;bool&gt; vg::SupportCaller::call_other_by_coverage</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;call-nodes-by-coverage&quot;</span>, <span class="stringliteral">&quot;cCoObB&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line">        <span class="stringliteral">&quot;make calls on nodes/edges outside snarls by coverage&quot;</span>}</div>
</div><!-- fragment --><p>Should we call on nodes/edges outside of snarls by coverage (true), or just assert that primary path things exist and off-path things don't (false)? </p>

</div>
</div>
<a class="anchor" id="a6d89567cf42fb8cb646001046c55d0cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;vector&lt;string&gt; &gt; vg::SupportCaller::contig_name_overrides</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;contig&quot;</span>, <span class="stringliteral">&quot;c&quot;</span>, {},</div>
<div class="line">        <span class="stringliteral">&quot;use the given name as the VCF name for the corresponding reference path (can repeat)&quot;</span>}</div>
</div><!-- fragment --><p>What name should we give each contig in the VCF file? Autodetected from path names if empty or too short. </p>

</div>
</div>
<a class="anchor" id="a363b181f0b11a99ca083c84ad3e3e20f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;bool&gt; vg::SupportCaller::convert_to_vcf</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;no-vcf&quot;</span>, <span class="stringliteral">&quot;V&quot;</span>, <span class="keyword">true</span>,</div>
<div class="line">        <span class="stringliteral">&quot;output variants in binary Loci format instead of text VCF format&quot;</span>}</div>
</div><!-- fragment -->
<p>Should we output in VCF (true) or Protobuf <a class="el" href="structvg_1_1Locus.html" title="Describes a genetic locus with multiple possible alleles, a genotype, and observational support...">Locus</a> (false) format? </p>

</div>
</div>
<a class="anchor" id="a72cd919ebff400d32250e4f0882929f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;double&gt; vg::SupportCaller::expected_coverage</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;avg-coverage&quot;</span>, <span class="stringliteral">&quot;C&quot;</span>, 0.0,</div>
<div class="line">        <span class="stringliteral">&quot;specify expected coverage (instead of computing on reference)&quot;</span>}</div>
</div><!-- fragment --><p>On some graphs, we can't get the coverage because it's split over parallel paths. Allow overriding here </p>

</div>
</div>
<a class="anchor" id="afc1209f27455e07ab97aae155418e5e6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;FastaReference&gt; vg::SupportCaller::ins_fasta</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a3251426f491b2efad76f0db8f28512f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;bool&gt; vg::SupportCaller::leave_shared_ends</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;leave-shared-ends&quot;</span>, <span class="stringliteral">&quot;X&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line">            <span class="stringliteral">&quot;don&#39;t collapse shared prefix and suffix of alleles in VCF output&quot;</span>}</div>
</div><!-- fragment --><p>Don't collapse the shared prefix and suffix of the different alleles in an output VCF line. This is mostly for debugging. </p>

</div>
</div>
<a class="anchor" id="a3c187e37f3ba63eeaba57b9b1bc2ae64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;vector&lt;size_t&gt; &gt; vg::SupportCaller::length_overrides</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;length&quot;</span>, <span class="stringliteral">&quot;l&quot;</span>, {},</div>
<div class="line">        <span class="stringliteral">&quot;override total sequence length in VCF for the corresponding reference path (can repeat)&quot;</span>}</div>
</div><!-- fragment --><p>What should the total sequence length reported in the VCF header be for each contig? Autodetected from path lengths if empty or too short. </p>

</div>
</div>
<a class="anchor" id="ae6584c21b8d57196db570a3642e23a27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::SupportCaller::locus_buffer_size = 1000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How big should our output buffer be? </p>

</div>
</div>
<a class="anchor" id="a4149e268405a8af09ee45decd51ec717"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::SupportCaller::max_bubble_paths = 100</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>What's the maximum number of bubble path combinations we can explore while finding one with maximum support? </p>

</div>
</div>
<a class="anchor" id="a89c9519695b82b720072a1125a638b30"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;size_t&gt; vg::SupportCaller::max_dp_for_filter</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;max-dp&quot;</span>, <span class="stringliteral">&quot;MmDdAaXxPp&quot;</span>, 0,</div>
<div class="line">        <span class="stringliteral">&quot;max depth to PASS filter (0 for unlimited)&quot;</span>}</div>
</div><!-- fragment -->
<p>what's the maximum total depth to give a PASS in the filter column </p>

</div>
</div>
<a class="anchor" id="aa4ac3dd541bcb9ab18eeb73ba93b4809"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;double&gt; vg::SupportCaller::max_dp_multiple_for_filter</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;max-dp-multiple&quot;</span>, <span class="stringliteral">&quot;MmDdAaXxPp&quot;</span>, 0,</div>
<div class="line">        <span class="stringliteral">&quot;max portion of global expected depth to PASS filter (0 for unlimited)&quot;</span>}</div>
</div><!-- fragment --><p>what's the maximum total depth to give a PASS in the filter column, as a multiple of the global baseline coverage? </p>

</div>
</div>
<a class="anchor" id="a94e5b0b963ac2a2c00c36ab31a13765c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;double&gt; vg::SupportCaller::max_het_bias</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;max-het-bias&quot;</span>, <span class="stringliteral">&quot;H&quot;</span>, 10,</div>
<div class="line">        <span class="stringliteral">&quot;max imbalance factor to call heterozygous, alt major on SNPs&quot;</span>}</div>
</div><!-- fragment --><p>What fraction of the reads supporting an alt are we willing to discount? At 2, if twice the reads support one allele as the other, we'll call homozygous instead of heterozygous. At infinity, every call will be heterozygous if even one read supports each allele. </p>

</div>
</div>
<a class="anchor" id="af03841cbfb977456890928bbcd831362"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;double&gt; vg::SupportCaller::max_indel_het_bias</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;max-indel-het-bias&quot;</span>, <span class="stringliteral">&quot;I&quot;</span>, 3,</div>
<div class="line">        <span class="stringliteral">&quot;max imbalance factor to call heterozygous, alt major on indels&quot;</span>}</div>
</div><!-- fragment -->
<p>Like the max het bias, but applies to novel indels. </p>

</div>
</div>
<a class="anchor" id="ac5685ff84488c17db0bca88f8ce7d697"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;double&gt; vg::SupportCaller::max_indel_ma_bias</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;max-indel-ma-bias&quot;</span>, <span class="stringliteral">&quot;G&quot;</span>, 6,</div>
<div class="line">        <span class="stringliteral">&quot;max imbalance factor between ref and alt2 to call 1/2 double alt on indels&quot;</span>}</div>
</div><!-- fragment -->
<p>Like the max het bias, but applies to multiallelic indels. </p>

</div>
</div>
<a class="anchor" id="a643327cc6aa0bd911a56dd13bf298e54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;int&gt; vg::SupportCaller::max_inversion_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;max-inv&quot;</span>, <span class="stringliteral">&quot;e&quot;</span>, 1000,</div>
<div class="line">            <span class="stringliteral">&quot;maximum detectable inversion size in number of nodes&quot;</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a3f075288ed00491db3479a2717a595d8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;double&gt; vg::SupportCaller::max_local_dp_multiple_for_filter</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;max-local-dp-multiple&quot;</span>, <span class="stringliteral">&quot;MmLlOoDdAaXxPp&quot;</span>, 0,</div>
<div class="line">        <span class="stringliteral">&quot;max portion of local expected depth to PASS filter (0 for unlimited)&quot;</span>}</div>
</div><!-- fragment --><p>what's the maximum total depth to give a PASS in the filter column, as a multiple of the local baseline coverage? </p>

</div>
</div>
<a class="anchor" id="a370d5fb988f39ab6a03efbf1bbed1d65"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;double&gt; vg::SupportCaller::max_ref_het_bias</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;max-ref-bias&quot;</span>, <span class="stringliteral">&quot;R&quot;</span>, 4.5,</div>
<div class="line">        <span class="stringliteral">&quot;max imbalance factor to call heterozygous, ref major&quot;</span>}</div>
</div><!-- fragment -->
<p>Like above, but applied to ref / alt ratio (instead of alt / ref) </p>

</div>
</div>
<a class="anchor" id="aae1d059f7ca1760f2f2232bf10823df8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;int64_t&gt; vg::SupportCaller::max_search_depth</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;max-search-depth&quot;</span>, <span class="stringliteral">&quot;D&quot;</span>, 1000,</div>
<div class="line">        <span class="stringliteral">&quot;maximum depth for path search&quot;</span>}</div>
</div><!-- fragment --><p>How many nodes should we be willing to look at on our path back to the primary path? Keep in mind we need to look at all valid paths (and all combinations thereof) until we find a valid pair. </p>

</div>
</div>
<a class="anchor" id="a4cea088e31aee9726bda4efd25fef82f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;int64_t&gt; vg::SupportCaller::max_search_width</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;max-search-width&quot;</span>, <span class="stringliteral">&quot;wWmMsS&quot;</span>, 1000,</div>
<div class="line">        <span class="stringliteral">&quot;maximum width for path search&quot;</span>}</div>
</div><!-- fragment --><p>How many search states should we allow on the DFS stack when searching for traversals? </p>

</div>
</div>
<a class="anchor" id="a915a93847b01934900fd4c6dcb61b333"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::SupportCaller::max_unsupported_edge_size = 20</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>inversion or deletion edges greater than this length with 0 support will clamp average support down to 0. this is primarily to prevent FP inversions when using average support </p>

</div>
</div>
<a class="anchor" id="aca2588765531eceb32bfc8a487d6503d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;double&gt; vg::SupportCaller::min_ad_log_likelihood_for_filter</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;min-ad-log-likelihood&quot;</span>, <span class="stringliteral">&quot;MmAaDdLliI&quot;</span>, -9.0,</div>
<div class="line">        <span class="stringliteral">&quot;min log likelihood for AD assignments to PASS filter (0 for unlimited)&quot;</span>}</div>
</div><!-- fragment -->
<p>what's the min log likelihood for allele depth assignments to PASS? </p>

</div>
</div>
<a class="anchor" id="a999d3ecc21ca9cab7ac9b14159ae1c44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::SupportCaller::min_alt_path_support = 0.2</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>minimum average base support on alt path for it to be considered </p>

</div>
</div>
<a class="anchor" id="a65abecae63da2cabc9a3bc4f7a710ded"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;double&gt; vg::SupportCaller::min_fraction_for_call</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;min-cov-frac&quot;</span>, <span class="stringliteral">&quot;F&quot;</span>, 0,</div>
<div class="line">        <span class="stringliteral">&quot;min fraction of average coverage at which to call&quot;</span>}</div>
</div><!-- fragment --><p>What fraction of average coverage should be the minimum to call a variant (or a single copy)? Default to 0 because vg call is still applying depth thresholding </p>

</div>
</div>
<a class="anchor" id="a31afb796c7822133359248f2f53d2c4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;size_t&gt; vg::SupportCaller::min_mad_for_filter</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;min-mad&quot;</span>, <span class="stringliteral">&quot;E&quot;</span>, 5,</div>
<div class="line">        <span class="stringliteral">&quot;min. ref/alt allele depth to PASS filter or be a second-best allele&quot;</span>}</div>
</div><!-- fragment --><p>what's the minimum ref or alt allele depth to give a PASS in the filter column? Also used as a min actual support for a second-best allele call </p>

</div>
</div>
<a class="anchor" id="a8db9e682e135333e47b6ecb0b5374efb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;size_t&gt; vg::SupportCaller::min_total_support_for_call</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;min-count&quot;</span>, <span class="stringliteral">&quot;n&quot;</span>, 1, </div>
<div class="line">        <span class="stringliteral">&quot;min total supporting read count to call a variant&quot;</span>}</div>
</div><!-- fragment --><p>What's the minimum integer number of reads that must support a call? We don't necessarily want to call a SNP as het because we have a single </p>

</div>
</div>
<a class="anchor" id="a8568b0cb2e9d2a2b6926d189a7fcead9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;string&gt; vg::SupportCaller::pack_file_name</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;pack-file&quot;</span>, <span class="stringliteral">&quot;P&quot;</span>, {}, </div>
<div class="line">            <span class="stringliteral">&quot;path of pack file from vg pack&quot;</span>}</div>
</div><!-- fragment -->
<p><a class="el" href="structvg_1_1Path.html">Path</a> of pack file generated from vg pack. </p>

</div>
</div>
<a class="anchor" id="a8dab4df2537ef96e9803d630f5920aec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;string, <a class="el" href="classvg_1_1SupportCaller_1_1PrimaryPath.html">PrimaryPath</a>&gt; vg::SupportCaller::primary_paths</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="add419898b3f716efbe495ca75fa14fd4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;string&gt; vg::SupportCaller::recall_ins_fasta_filename</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;insertion-fasta&quot;</span>, <span class="stringliteral">&quot;Z&quot;</span>, <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;Insertion FASTA required for --recall-vcf in the presence of symbolic insertions&quot;</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aaf461014ec4fe763c6f65dda3523d7bb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;string&gt; vg::SupportCaller::recall_ref_fasta_filename</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;recall-fasta&quot;</span>, <span class="stringliteral">&quot;a&quot;</span>, <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;Reference FASTA required for --recall-vcf in the presence of symbolic deletions or inversions&quot;</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a8fde552e0e331791c139efb536de4128"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;string&gt; vg::SupportCaller::recall_vcf_filename</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;recall-vcf&quot;</span>, <span class="stringliteral">&quot;f&quot;</span>, <span class="stringliteral">&quot;&quot;</span>,</div>
<div class="line">            <span class="stringliteral">&quot;VCF to genotype against.  Must have been used to create input graph with vg construct -a&quot;</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1da5805e7c262a8fe317ad9e0b49817a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;size_t&gt; vg::SupportCaller::ref_bin_size</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;bin-size&quot;</span>, <span class="stringliteral">&quot;B&quot;</span>, 250,</div>
<div class="line">        <span class="stringliteral">&quot;bin size used for counting coverage&quot;</span>}</div>
</div><!-- fragment --><p>Bin size used for counting coverage along the reference path. The bin coverage is used for computing the probability of an allele of a certain depth </p>

</div>
</div>
<a class="anchor" id="ae0c8a316d75b2e1db80894b6ce230fb8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;FastaReference&gt; vg::SupportCaller::ref_fasta</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6600a3aeeb8f2bbf19f422d0eb8f841a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;vector&lt;string&gt; &gt; vg::SupportCaller::ref_path_names</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;ref&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>, {},</div>
<div class="line">        <span class="stringliteral">&quot;use the path with the given name as a reference path (can repeat)&quot;</span>}</div>
</div><!-- fragment -->
<p>What are the names of the reference paths, if any, in the graph? </p>

</div>
</div>
<a class="anchor" id="a4e613538924447d54fbecbf8d14f501d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;string&gt; vg::SupportCaller::sample_name</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;sample&quot;</span>, <span class="stringliteral">&quot;S&quot;</span>, <span class="stringliteral">&quot;SAMPLE&quot;</span>,</div>
<div class="line">        <span class="stringliteral">&quot;name the sample in the VCF with the given name&quot;</span>}</div>
</div><!-- fragment -->
<p>What name should we use for the sample in the VCF file? </p>

</div>
</div>
<a class="anchor" id="a2310ebac3bb08de54267e7f7aa1b06d4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;string&gt; vg::SupportCaller::support_file_name</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;support-file&quot;</span>, <span class="stringliteral">&quot;s&quot;</span>, {},</div>
<div class="line">            <span class="stringliteral">&quot;path of file containing supports generated by vg augment -P -s&quot;</span>}</div>
</div><!-- fragment -->
<p><a class="el" href="structvg_1_1Path.html">Path</a> of supports file generated from the <a class="el" href="classvg_1_1PileupAugmenter.html">PileupAugmenter</a> (via vg augment) </p>

</div>
</div>
<a class="anchor" id="abc8b8ec1ae50ef22ec1bb7f9307edcdd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">function&lt;double(const <a class="el" href="structvg_1_1Support.html">Support</a>&amp;)&gt; vg::SupportCaller::support_val</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the amount of support. Can use this function to toggle between unweighted (total from genotypekit) and quality-weighted (support_quality below) in one place. </p>

</div>
</div>
<a class="anchor" id="a032117d5fd316be83877834de8d25a99"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;bool&gt; vg::SupportCaller::use_average_support</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;use-avg-support&quot;</span>, <span class="stringliteral">&quot;u&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line">        <span class="stringliteral">&quot;use average instead of minimum support&quot;</span>}</div>
</div><!-- fragment --><p>Should we use average support instead of minimum support for our calculations? </p>

</div>
</div>
<a class="anchor" id="a626d85743ce833b7745afe9c1ab66cb6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;bool&gt; vg::SupportCaller::use_support_count</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;use-support-count&quot;</span>, <span class="stringliteral">&quot;T&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line">        <span class="stringliteral">&quot;use total support count instead of total support quality for selecting top alleles&quot;</span>}</div>
</div><!-- fragment --><p>Use total support count (true) instead of total support quality (false) when choosing top alleles and deciding gentypes based on the biases. </p>

</div>
</div>
<a class="anchor" id="a74478df30c0c02519b875bef8b946d71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vcflib::VariantCallFile vg::SupportCaller::variant_file</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>structures to hold the recall vcf and fastas </p>

</div>
</div>
<a class="anchor" id="afed18b083fd15705d07c6a5e35739937"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;int64_t&gt; vg::SupportCaller::variant_offset</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;offset&quot;</span>, <span class="stringliteral">&quot;o&quot;</span>, 0,</div>
<div class="line">        <span class="stringliteral">&quot;offset variant positions by this amount in VCF&quot;</span>}</div>
</div><!-- fragment -->
<p>How far should we offset positions of variants? </p>

</div>
</div>
<a class="anchor" id="a16284074baabe10886ae5e33b2d0e165"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::SupportCaller::verbose = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print warnings etc. to stderr </p>

</div>
</div>
<a class="anchor" id="a216ee27f03698399b7ded8342d846ba1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;bool&gt; vg::SupportCaller::write_trivial_calls</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;trival&quot;</span>, <span class="stringliteral">&quot;ivtTIRV&quot;</span>, <span class="keyword">false</span>,</div>
<div class="line">        <span class="stringliteral">&quot;write trivial vcf calls (ex 0/0 genotypes)&quot;</span>}</div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7c006411b59c4b2b85c81ae593e018e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Option.html">Option</a>&lt;string&gt; vg::SupportCaller::xg_file_name</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">{<span class="keyword">this</span>, <span class="stringliteral">&quot;xg-file&quot;</span>, <span class="stringliteral">&quot;x&quot;</span>, {},</div>
<div class="line">            <span class="stringliteral">&quot;path of xg file (required to read pack file with -P)&quot;</span>}</div>
</div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="support__caller_8hpp.html">support_caller.hpp</a></li>
<li>src/<a class="el" href="support__caller_8cpp.html">support_caller.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
