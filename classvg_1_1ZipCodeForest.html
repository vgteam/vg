<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::ZipCodeForest Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1ZipCodeForest.html">ZipCodeForest</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="classvg_1_1ZipCodeForest-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::ZipCodeForest Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;zip_code_tree.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ZipCodeForest_1_1child__info__t.html">child_info_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This stores information about the state of the forest as we fill it in.  <a href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ZipCodeForest_1_1sort__value__t.html">sort_value_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab6f83d5af9f5ab490040e469f38b68df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#ab6f83d5af9f5ab490040e469f38b68df">ZipCodeForest</a> ()</td></tr>
<tr class="memdesc:ab6f83d5af9f5ab490040e469f38b68df"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvg_1_1Constructor.html">Constructor</a>.  <a href="classvg_1_1ZipCodeForest.html#ab6f83d5af9f5ab490040e469f38b68df">More...</a><br /></td></tr>
<tr class="separator:ab6f83d5af9f5ab490040e469f38b68df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeea5f048e6e7711971b764591ee63ec"><td class="memTemplParams" colspan="2">template&lt;typename Minimizer &gt; </td></tr>
<tr class="memitem:abeea5f048e6e7711971b764591ee63ec"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#abeea5f048e6e7711971b764591ee63ec">fill_in_forest</a> (const vector&lt; <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &gt; &amp;seeds, const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; Minimizer &gt; &amp;minimizers, const SnarlDistanceIndex &amp;distance_index, size_t gap_distance_limit, size_t distance_limit=std::numeric_limits&lt; size_t &gt;::max())</td></tr>
<tr class="separator:abeea5f048e6e7711971b764591ee63ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cabd6faae5283f02bfe5397a17908fa"><td class="memTemplParams" colspan="2">template&lt;typename Minimizer &gt; </td></tr>
<tr class="memitem:a4cabd6faae5283f02bfe5397a17908fa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a4cabd6faae5283f02bfe5397a17908fa">print_self</a> (const vector&lt; <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &gt; *seeds, const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; Minimizer &gt; *minimizers) const</td></tr>
<tr class="separator:a4cabd6faae5283f02bfe5397a17908fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e851b424a075f606092a97d0106845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a61e851b424a075f606092a97d0106845">validate_zip_forest</a> (const SnarlDistanceIndex &amp;distance_index, const vector&lt; <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &gt; *seeds, size_t distance_limit=std::numeric_limits&lt; size_t &gt;::max()) const</td></tr>
<tr class="separator:a61e851b424a075f606092a97d0106845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72304772e60e79909b71f8a51e65d6a5"><td class="memTemplParams" colspan="2">template&lt;typename Minimizer &gt; </td></tr>
<tr class="memitem:a72304772e60e79909b71f8a51e65d6a5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a72304772e60e79909b71f8a51e65d6a5">get_cyclic_snarl_intervals</a> (<a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; Minimizer &gt; &amp;minimizers, const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">ZipCodeForest::interval_state_t</a> &amp;snarl_interval, const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">ZipCodeForest::interval_state_t</a> &amp;parent_interval, const forward_list&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">ZipCodeForest::interval_state_t</a> &gt; &amp;child_intervals, forward_list&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">ZipCodeForest::interval_state_t</a> &gt; &amp;next_intervals) const</td></tr>
<tr class="separator:a72304772e60e79909b71f8a51e65d6a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af85d4ca7594aee84b37f7864e24e5ce6"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1ZipCodeTree.html">ZipCodeTree</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#af85d4ca7594aee84b37f7864e24e5ce6">trees</a></td></tr>
<tr class="memdesc:af85d4ca7594aee84b37f7864e24e5ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual data, a collection of ZipCodeTrees.  <a href="classvg_1_1ZipCodeForest.html#af85d4ca7594aee84b37f7864e24e5ce6">More...</a><br /></td></tr>
<tr class="separator:af85d4ca7594aee84b37f7864e24e5ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a93f9eaa38dd8024a73a2aeca456e5156"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html">SnarlDistanceIndexClusterer::Seed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a></td></tr>
<tr class="separator:a93f9eaa38dd8024a73a2aeca456e5156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bc3d5c8b89cd4260cdacbcd3e853df"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvg_1_1ZipCodeTree.html#ad2249d10c3c707b5433b916d388117ad">ZipCodeTree::tree_item_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a21bc3d5c8b89cd4260cdacbcd3e853df">tree_item_type_t</a></td></tr>
<tr class="separator:a21bc3d5c8b89cd4260cdacbcd3e853df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4d116fc7bbdf877de9a8968133f5d5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structvg_1_1ZipCodeTree_1_1tree__item__t.html">ZipCodeTree::tree_item_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a6f4d116fc7bbdf877de9a8968133f5d5">tree_item_t</a></td></tr>
<tr class="separator:a6f4d116fc7bbdf877de9a8968133f5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a499f52fbb75374e2dc06ce7998ad8fd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a499f52fbb75374e2dc06ce7998ad8fd6">sort_one_interval</a> (<a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;interval) const</td></tr>
<tr class="separator:a499f52fbb75374e2dc06ce7998ad8fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade4c028524fd9e0c4a6267335584171"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#aade4c028524fd9e0c4a6267335584171">radix_sort_zipcodes</a> (vector&lt; size_t &gt; &amp;zipcode_sort_order, const vector&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1sort__value__t.html">sort_value_t</a> &gt; &amp;sort_values_by_seed, const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;interval, bool reverse_order, size_t min_value, size_t max_value, bool sort_by_chain_component=false) const</td></tr>
<tr class="separator:aade4c028524fd9e0c4a6267335584171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eed49e06827ec7883f8abe8da3d548e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a5eed49e06827ec7883f8abe8da3d548e">default_sort_zipcodes</a> (vector&lt; size_t &gt; &amp;zipcode_sort_order, const vector&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1sort__value__t.html">sort_value_t</a> &gt; &amp;sort_values_by_seed, const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;interval, bool reverse_order) const</td></tr>
<tr class="separator:a5eed49e06827ec7883f8abe8da3d548e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9a60acfcb3f8521eeb7bbf5e36007b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a2c9a60acfcb3f8521eeb7bbf5e36007b">get_next_intervals</a> (<a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;interval, std::forward_list&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &gt; &amp;next_intervals) const</td></tr>
<tr class="separator:a2c9a60acfcb3f8521eeb7bbf5e36007b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad32664318549a51d8727204d665a2bc6"><td class="memTemplParams" colspan="2">template&lt;typename Minimizer &gt; </td></tr>
<tr class="memitem:ad32664318549a51d8727204d665a2bc6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#ad32664318549a51d8727204d665a2bc6">get_cyclic_snarl_intervals</a> (<a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; Minimizer &gt; &amp;minimizers, const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;snarl_interval, const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;parent_interval, const forward_list&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &gt; &amp;child_intervals, forward_list&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &gt; &amp;next_intervals) const</td></tr>
<tr class="separator:ad32664318549a51d8727204d665a2bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56fb93ecb975f5f6c12deeef5b1f9b20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a56fb93ecb975f5f6c12deeef5b1f9b20">open_chain</a> (<a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const size_t &amp;depth, size_t seed_index, bool chain_is_reversed)</td></tr>
<tr class="separator:a56fb93ecb975f5f6c12deeef5b1f9b20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2307457a70762459688446395338b3f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a2307457a70762459688446395338b3f8">close_chain</a> (<a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const size_t &amp;depth, const <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &amp;last_seed, bool chain_is_reversed)</td></tr>
<tr class="separator:a2307457a70762459688446395338b3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70358ab79a7212af23bc6ebffcb43fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#ac70358ab79a7212af23bc6ebffcb43fd">add_child_to_chain</a> (<a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const size_t &amp;depth, const size_t &amp;seed_index, bool child_is_reversed, bool chain_is_reversed)</td></tr>
<tr class="separator:ac70358ab79a7212af23bc6ebffcb43fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab219e010a4e80804f7c5f6ada581f18d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#ab219e010a4e80804f7c5f6ada581f18d">open_snarl</a> (<a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const size_t &amp;depth)</td></tr>
<tr class="separator:ab219e010a4e80804f7c5f6ada581f18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5579f467bd35b2e13a753af31baf5bf6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a5579f467bd35b2e13a753af31baf5bf6">close_snarl</a> (<a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const size_t &amp;depth, const <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &amp;last_seed, bool last_is_reversed, bool is_cyclic_snarl)</td></tr>
<tr class="separator:a5579f467bd35b2e13a753af31baf5bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9a5fa1b979958b9785310fddab5f01e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#aa9a5fa1b979958b9785310fddab5f01e">add_snarl_distances</a> (<a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const size_t &amp;depth, const <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &amp;seed, bool child_is_reversed, bool snarl_is_reversed, bool to_snarl_end, bool is_cyclic_snarl)</td></tr>
<tr class="separator:aa9a5fa1b979958b9785310fddab5f01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:ab939e5ee856a9ac2531d0d8ac14e7cbe"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#ab939e5ee856a9ac2531d0d8ac14e7cbe">get_correlation</a> (const vector&lt; std::pair&lt; size_t, size_t &gt;&gt; &amp;values)</td></tr>
<tr class="separator:ab939e5ee856a9ac2531d0d8ac14e7cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A collection of ZipCodeTrees The <a class="el" href="classvg_1_1ZipCodeForest.html">ZipCodeForest</a> takes a set of seeds and makes ZipCodeTrees There will be a separate tree for each connected component or slice of a chain that is too far from anything else on both sides, using the given distance limit </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a93f9eaa38dd8024a73a2aeca456e5156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f9eaa38dd8024a73a2aeca456e5156">&#9670;&nbsp;</a></span>Seed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html">SnarlDistanceIndexClusterer::Seed</a> <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">vg::ZipCodeForest::Seed</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f4d116fc7bbdf877de9a8968133f5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f4d116fc7bbdf877de9a8968133f5d5">&#9670;&nbsp;</a></span>tree_item_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structvg_1_1ZipCodeTree_1_1tree__item__t.html">ZipCodeTree::tree_item_t</a> <a class="el" href="classvg_1_1ZipCodeForest.html#a6f4d116fc7bbdf877de9a8968133f5d5">vg::ZipCodeForest::tree_item_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21bc3d5c8b89cd4260cdacbcd3e853df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bc3d5c8b89cd4260cdacbcd3e853df">&#9670;&nbsp;</a></span>tree_item_type_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classvg_1_1ZipCodeTree.html#ad2249d10c3c707b5433b916d388117ad">ZipCodeTree::tree_item_type_t</a> <a class="el" href="classvg_1_1ZipCodeTree.html#ad2249d10c3c707b5433b916d388117ad">vg::ZipCodeForest::tree_item_type_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab6f83d5af9f5ab490040e469f38b68df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f83d5af9f5ab490040e469f38b68df">&#9670;&nbsp;</a></span>ZipCodeForest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::ZipCodeForest::ZipCodeForest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classvg_1_1Constructor.html">Constructor</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac70358ab79a7212af23bc6ebffcb43fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70358ab79a7212af23bc6ebffcb43fd">&#9670;&nbsp;</a></span>add_child_to_chain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::add_child_to_chain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>seed_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>child_is_reversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain_is_reversed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9a5fa1b979958b9785310fddab5f01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9a5fa1b979958b9785310fddab5f01e">&#9670;&nbsp;</a></span>add_snarl_distances()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::add_snarl_distances </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>child_is_reversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>snarl_is_reversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_snarl_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_cyclic_snarl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2307457a70762459688446395338b3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2307457a70762459688446395338b3f8">&#9670;&nbsp;</a></span>close_chain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::close_chain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &amp;&#160;</td>
          <td class="paramname"><em>last_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain_is_reversed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5579f467bd35b2e13a753af31baf5bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5579f467bd35b2e13a753af31baf5bf6">&#9670;&nbsp;</a></span>close_snarl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::close_snarl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &amp;&#160;</td>
          <td class="paramname"><em>last_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>last_is_reversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_cyclic_snarl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5eed49e06827ec7883f8abe8da3d548e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eed49e06827ec7883f8abe8da3d548e">&#9670;&nbsp;</a></span>default_sort_zipcodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::default_sort_zipcodes </td>
          <td>(</td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>zipcode_sort_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1sort__value__t.html">sort_value_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sort_values_by_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function to sort the seeds using std::sort Sorts the slice of seeds in the given interval of zipcode_sort_order, which is a vector of indices into seeds </p>

</div>
</div>
<a id="abeea5f048e6e7711971b764591ee63ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeea5f048e6e7711971b764591ee63ec">&#9670;&nbsp;</a></span>fill_in_forest()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Minimizer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::fill_in_forest </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; Minimizer &gt; &amp;&#160;</td>
          <td class="paramname"><em>minimizers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>gap_distance_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance_limit</em> = <code>std::numeric_limits&lt;size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate the zip forest If a distance limit is given, then also partition the tree into subtrees that are farther than the distance_limit from each other Otherwise, the forest will just be connected components The gap_distance_limit is the limit for making runs of seeds in a cyclic snarl- it should be roughly the distance that the dynamic programming is willing to jump to connect two consecutive minimizers TODO: I think the distance_limit should just be the same as the gap_distance_limit If a distance_limit is given, then distances larger than the distance limit are not guaranteed to be accurate, but will be greater than the distance_limit </p>

</div>
</div>
<a id="ab939e5ee856a9ac2531d0d8ac14e7cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab939e5ee856a9ac2531d0d8ac14e7cbe">&#9670;&nbsp;</a></span>get_correlation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::ZipCodeForest::get_correlation </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; std::pair&lt; size_t, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given a vector of value pairs, and a bool indicating if the pair is used for the correlation, return the correlation. This is the spearman correlation for now </p>

</div>
</div>
<a id="ad32664318549a51d8727204d665a2bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad32664318549a51d8727204d665a2bc6">&#9670;&nbsp;</a></span>get_cyclic_snarl_intervals() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Minimizer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::get_cyclic_snarl_intervals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; Minimizer &gt; &amp;&#160;</td>
          <td class="paramname"><em>minimizers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>parent_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const forward_list&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child_intervals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">forward_list&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>next_intervals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given intervals representing child chains on a cyclic snarl, re-partition them and get new intervals representing runs of seeds that are "close" in each chain. Like in get_next_intervals, new intervals are added to next_intervals in their sort order. Two seeds are close to each other if: (1) the distance between them on the read is &lt;= t, where t is a given distance limit, (2) the minimum distance between them on the chain is &lt;= t, and (3) they are on the same strand in the read. Runs are sorted by their latest position in the read, and oriented according to the orientation of the read through the snarl. The orientation of the read in the snarl's parent chain and in the snarl children are estimated by finding the spearman correlation of the seeds. If the orientation of a run is unclear, then it is duplicated to be oriented in each direction <br  />
 </p>

</div>
</div>
<a id="a72304772e60e79909b71f8a51e65d6a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72304772e60e79909b71f8a51e65d6a5">&#9670;&nbsp;</a></span>get_cyclic_snarl_intervals() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Minimizer &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::get_cyclic_snarl_intervals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; Minimizer &gt; &amp;&#160;</td>
          <td class="paramname"><em>minimizers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">ZipCodeForest::interval_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">ZipCodeForest::interval_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>parent_interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const forward_list&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">ZipCodeForest::interval_state_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>child_intervals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">forward_list&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">ZipCodeForest::interval_state_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>next_intervals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c9a60acfcb3f8521eeb7bbf5e36007b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9a60acfcb3f8521eeb7bbf5e36007b">&#9670;&nbsp;</a></span>get_next_intervals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::get_next_intervals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_list&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>next_intervals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assuming that the range of seeds in sort_values_by_seeds given by the interval is sorted, add the intervals of the children of the interval to the front of next_intervals. The new intervals get added in their sort order, so the start of a chain will be at the start of the list, to be popped first. For children of chains, seeds that are on the chain itself and not nested will be put on the same interval if there are no seeds in snarls between them, even if they are not on the same node </p>

</div>
</div>
<a id="a56fb93ecb975f5f6c12deeef5b1f9b20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56fb93ecb975f5f6c12deeef5b1f9b20">&#9670;&nbsp;</a></span>open_chain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::open_chain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>seed_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain_is_reversed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab219e010a4e80804f7c5f6ada581f18d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab219e010a4e80804f7c5f6ada581f18d">&#9670;&nbsp;</a></span>open_snarl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::open_snarl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4cabd6faae5283f02bfe5397a17908fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cabd6faae5283f02bfe5397a17908fa">&#9670;&nbsp;</a></span>print_self()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Minimizer &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::print_self </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &gt; *&#160;</td>
          <td class="paramname"><em>seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; Minimizer &gt; *&#160;</td>
          <td class="paramname"><em>minimizers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aade4c028524fd9e0c4a6267335584171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade4c028524fd9e0c4a6267335584171">&#9670;&nbsp;</a></span>radix_sort_zipcodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::radix_sort_zipcodes </td>
          <td>(</td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>zipcode_sort_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1sort__value__t.html">sort_value_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sort_values_by_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_by_chain_component</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function to sort the seeds using radix sort Sorts the slice of seeds in the given interval of zipcode_sort_order, which is a vector of indices into seeds reverse_order is true if the order should be reversed. The interval also has an is_reversed field, which refers to the orientation in the snarl tree This should run in linear time, but it is dependent on the values being sorted on to have a small range min_ and max_value are the minimum and maximum value being sorted on If sort_by_chain_component is true, then sort on the chain component in sort_values </p>

</div>
</div>
<a id="a499f52fbb75374e2dc06ce7998ad8fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499f52fbb75374e2dc06ce7998ad8fd6">&#9670;&nbsp;</a></span>sort_one_interval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::sort_one_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts the given interval (which must contain seeds on the same snarl/chain/node at the given depth) Sorting is roughly linear along the top-level chains, in a topological-ish order in snarls. Uses radix_sort_zipcodes and default_sort_zipcodes For chains, everything is sorted with the prefix sum value of the chain itself from the distance index, not the order in the chain in the zip code tree. Everything will be sorted in the order of the zip code tree, but the values will be set from the distance index. This means that later, the values may be out of order or may need to be subtracted from the length of the chain to get the distances to the ends of the chain </p>

</div>
</div>
<a id="a61e851b424a075f606092a97d0106845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e851b424a075f606092a97d0106845">&#9670;&nbsp;</a></span>validate_zip_forest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::validate_zip_forest </td>
          <td>(</td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &gt; *&#160;</td>
          <td class="paramname"><em>seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance_limit</em> = <code>std::numeric_limits&lt;size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af85d4ca7594aee84b37f7864e24e5ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85d4ca7594aee84b37f7864e24e5ce6">&#9670;&nbsp;</a></span>trees</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="classvg_1_1ZipCodeTree.html">ZipCodeTree</a>&gt; vg::ZipCodeForest::trees</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The actual data, a collection of ZipCodeTrees. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="zip__code__tree_8hpp.html">zip_code_tree.hpp</a></li>
<li>src/<a class="el" href="zip__code__tree_8cpp.html">zip_code_tree.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
