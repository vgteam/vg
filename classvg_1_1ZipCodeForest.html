<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::ZipCodeForest Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1ZipCodeForest.html">ZipCodeForest</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classvg_1_1ZipCodeForest-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::ZipCodeForest Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;zip_code_tree.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ZipCodeForest_1_1child__info__t.html">child_info_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This stores information about the state of the forest as we fill it in.  <a href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ZipCodeForest_1_1seed__info__t.html">seed_info_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ZipCodeForest_1_1sort__value__t.html">sort_value_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab6f83d5af9f5ab490040e469f38b68df"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#ab6f83d5af9f5ab490040e469f38b68df">ZipCodeForest</a> ()</td></tr>
<tr class="memdesc:ab6f83d5af9f5ab490040e469f38b68df"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvg_1_1Constructor.html">Constructor</a>.  <a href="classvg_1_1ZipCodeForest.html#ab6f83d5af9f5ab490040e469f38b68df">More...</a><br /></td></tr>
<tr class="separator:ab6f83d5af9f5ab490040e469f38b68df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e85202bb164a9c152fb8f6f43c050a2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a8e85202bb164a9c152fb8f6f43c050a2">fill_in_forest</a> (const vector&lt; <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &gt; &amp;seeds, const SnarlDistanceIndex &amp;distance_index, size_t distance_limit=std::numeric_limits&lt; size_t &gt;::max())</td></tr>
<tr class="separator:a8e85202bb164a9c152fb8f6f43c050a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab609e62b11436a2c69e0bf36797fefb1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#ab609e62b11436a2c69e0bf36797fefb1">print_self</a> (const vector&lt; <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &gt; *seeds) const</td></tr>
<tr class="separator:ab609e62b11436a2c69e0bf36797fefb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61e851b424a075f606092a97d0106845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a61e851b424a075f606092a97d0106845">validate_zip_forest</a> (const SnarlDistanceIndex &amp;distance_index, const vector&lt; <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &gt; *seeds, size_t distance_limit=std::numeric_limits&lt; size_t &gt;::max()) const</td></tr>
<tr class="separator:a61e851b424a075f606092a97d0106845"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:af85d4ca7594aee84b37f7864e24e5ce6"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1ZipCodeTree.html">ZipCodeTree</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#af85d4ca7594aee84b37f7864e24e5ce6">trees</a></td></tr>
<tr class="memdesc:af85d4ca7594aee84b37f7864e24e5ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual data, a collection of ZipCodeTrees.  <a href="classvg_1_1ZipCodeForest.html#af85d4ca7594aee84b37f7864e24e5ce6">More...</a><br /></td></tr>
<tr class="separator:af85d4ca7594aee84b37f7864e24e5ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a93f9eaa38dd8024a73a2aeca456e5156"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html">SnarlDistanceIndexClusterer::Seed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a></td></tr>
<tr class="separator:a93f9eaa38dd8024a73a2aeca456e5156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21bc3d5c8b89cd4260cdacbcd3e853df"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="classvg_1_1ZipCodeTree.html#ad2249d10c3c707b5433b916d388117ad">ZipCodeTree::tree_item_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a21bc3d5c8b89cd4260cdacbcd3e853df">tree_item_type_t</a></td></tr>
<tr class="separator:a21bc3d5c8b89cd4260cdacbcd3e853df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4d116fc7bbdf877de9a8968133f5d5"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structvg_1_1ZipCodeTree_1_1tree__item__t.html">ZipCodeTree::tree_item_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a6f4d116fc7bbdf877de9a8968133f5d5">tree_item_t</a></td></tr>
<tr class="separator:a6f4d116fc7bbdf877de9a8968133f5d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a499f52fbb75374e2dc06ce7998ad8fd6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a499f52fbb75374e2dc06ce7998ad8fd6">sort_one_interval</a> (<a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;interval) const</td></tr>
<tr class="separator:a499f52fbb75374e2dc06ce7998ad8fd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aade4c028524fd9e0c4a6267335584171"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#aade4c028524fd9e0c4a6267335584171">radix_sort_zipcodes</a> (vector&lt; size_t &gt; &amp;zipcode_sort_order, const vector&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1sort__value__t.html">sort_value_t</a> &gt; &amp;sort_values_by_seed, const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;interval, bool reverse_order, size_t min_value, size_t max_value, bool sort_by_chain_component=false) const</td></tr>
<tr class="separator:aade4c028524fd9e0c4a6267335584171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eed49e06827ec7883f8abe8da3d548e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a5eed49e06827ec7883f8abe8da3d548e">default_sort_zipcodes</a> (vector&lt; size_t &gt; &amp;zipcode_sort_order, const vector&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1sort__value__t.html">sort_value_t</a> &gt; &amp;sort_values_by_seed, const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;interval, bool reverse_order) const</td></tr>
<tr class="separator:a5eed49e06827ec7883f8abe8da3d548e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9a60acfcb3f8521eeb7bbf5e36007b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a2c9a60acfcb3f8521eeb7bbf5e36007b">get_next_intervals</a> (<a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;interval, std::forward_list&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &gt; &amp;next_intervals) const</td></tr>
<tr class="separator:a2c9a60acfcb3f8521eeb7bbf5e36007b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39be64ea490a29bb4c59eb503a08ce5c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a39be64ea490a29bb4c59eb503a08ce5c">move_slice</a> (<a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const size_t &amp;depth)</td></tr>
<tr class="separator:a39be64ea490a29bb4c59eb503a08ce5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedf4d4e0d4837917b3244a77f3f8aa2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#aedf4d4e0d4837917b3244a77f3f8aa2d">open_chain</a> (<a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;interval)</td></tr>
<tr class="separator:aedf4d4e0d4837917b3244a77f3f8aa2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2307457a70762459688446395338b3f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a2307457a70762459688446395338b3f8">close_chain</a> (<a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const size_t &amp;depth, const <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &amp;last_seed, bool chain_is_reversed)</td></tr>
<tr class="separator:a2307457a70762459688446395338b3f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac70358ab79a7212af23bc6ebffcb43fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#ac70358ab79a7212af23bc6ebffcb43fd">add_child_to_chain</a> (<a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const size_t &amp;depth, const size_t &amp;seed_index, bool child_is_reversed, bool chain_is_reversed)</td></tr>
<tr class="separator:ac70358ab79a7212af23bc6ebffcb43fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f247c1e2fe2d7cf7cf43ba72ee06097"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a4f247c1e2fe2d7cf7cf43ba72ee06097">open_snarl</a> (<a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const size_t &amp;depth, bool is_cyclic_snarl)</td></tr>
<tr class="memdesc:a4f247c1e2fe2d7cf7cf43ba72ee06097"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start a new snarl of the given type at the given depth.  <a href="classvg_1_1ZipCodeForest.html#a4f247c1e2fe2d7cf7cf43ba72ee06097">More...</a><br /></td></tr>
<tr class="separator:a4f247c1e2fe2d7cf7cf43ba72ee06097"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72ed3945435b9383523db554b1068605"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a72ed3945435b9383523db554b1068605">close_snarl</a> (<a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const size_t &amp;depth, const <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &amp;last_seed, bool last_is_reversed)</td></tr>
<tr class="separator:a72ed3945435b9383523db554b1068605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0b8337aa133b4f4cf51a65be37e126e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#af0b8337aa133b4f4cf51a65be37e126e">add_distance_matrix</a> (<a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const size_t &amp;depth, bool snarl_is_reversed)</td></tr>
<tr class="separator:af0b8337aa133b4f4cf51a65be37e126e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a938f2d3c36ab09c5c7a80f33b9ac365c"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1seed__info__t.html">seed_info_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a938f2d3c36ab09c5c7a80f33b9ac365c">get_edge_seeds</a> (const <a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const size_t &amp;depth) const</td></tr>
<tr class="separator:a938f2d3c36ab09c5c7a80f33b9ac365c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a152f1bf73ad3f6569b7cfc7b6d64a07e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#a152f1bf73ad3f6569b7cfc7b6d64a07e">add_edges_to_end</a> (vector&lt; <a class="el" href="classvg_1_1ZipCodeForest.html#a6f4d116fc7bbdf877de9a8968133f5d5">tree_item_t</a> &gt; &amp;dist_matrix, <a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const size_t &amp;depth, const vector&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1seed__info__t.html">seed_info_t</a> &gt; &amp;edge_seeds, bool snarl_is_reversed, bool is_cyclic_snarl) const</td></tr>
<tr class="separator:a152f1bf73ad3f6569b7cfc7b6d64a07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa495701a9416c85c785fc0e3e9d58e1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeForest.html#aa495701a9416c85c785fc0e3e9d58e1b">add_edges_for_chains</a> (vector&lt; <a class="el" href="classvg_1_1ZipCodeForest.html#a6f4d116fc7bbdf877de9a8968133f5d5">tree_item_t</a> &gt; &amp;dist_matrix, <a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;forest_state, const size_t &amp;depth, const vector&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1seed__info__t.html">seed_info_t</a> &gt; &amp;edge_seeds, bool snarl_is_reversed, bool is_cyclic_snarl) const</td></tr>
<tr class="separator:aa495701a9416c85c785fc0e3e9d58e1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a93f9eaa38dd8024a73a2aeca456e5156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93f9eaa38dd8024a73a2aeca456e5156">&#9670;&nbsp;</a></span>Seed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html">SnarlDistanceIndexClusterer::Seed</a> <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">vg::ZipCodeForest::Seed</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a6f4d116fc7bbdf877de9a8968133f5d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f4d116fc7bbdf877de9a8968133f5d5">&#9670;&nbsp;</a></span>tree_item_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structvg_1_1ZipCodeTree_1_1tree__item__t.html">ZipCodeTree::tree_item_t</a> <a class="el" href="classvg_1_1ZipCodeForest.html#a6f4d116fc7bbdf877de9a8968133f5d5">vg::ZipCodeForest::tree_item_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21bc3d5c8b89cd4260cdacbcd3e853df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21bc3d5c8b89cd4260cdacbcd3e853df">&#9670;&nbsp;</a></span>tree_item_type_t</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classvg_1_1ZipCodeTree.html#ad2249d10c3c707b5433b916d388117ad">ZipCodeTree::tree_item_type_t</a> <a class="el" href="classvg_1_1ZipCodeTree.html#ad2249d10c3c707b5433b916d388117ad">vg::ZipCodeForest::tree_item_type_t</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab6f83d5af9f5ab490040e469f38b68df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6f83d5af9f5ab490040e469f38b68df">&#9670;&nbsp;</a></span>ZipCodeForest()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::ZipCodeForest::ZipCodeForest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="classvg_1_1Constructor.html">Constructor</a>. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ac70358ab79a7212af23bc6ebffcb43fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac70358ab79a7212af23bc6ebffcb43fd">&#9670;&nbsp;</a></span>add_child_to_chain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::add_child_to_chain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>seed_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>child_is_reversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain_is_reversed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a seed (or snarl starting at a seed) and the preceeding chain edge If the seed is far enough from the previous thing in the chain and it can be a new slice, split off a subtree depth is chain child's depth (may also be chain depth if trivial) seed_index is the index of the current seed in the list of seeds </p>

</div>
</div>
<a id="af0b8337aa133b4f4cf51a65be37e126e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0b8337aa133b4f4cf51a65be37e126e">&#9670;&nbsp;</a></span>add_distance_matrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCodeForest::add_distance_matrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>snarl_is_reversed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a triangular distance matrix for a snarl to its front The matrix starts with a CHAIN_COUNT with the number of child chains, and then is a list of EDGEs; for each item in order, all distances to it from all previous items, possibly including self-loops Returns the size of the distance matrix added (plus the CHAIN_COUNT) </p>

</div>
</div>
<a id="aa495701a9416c85c785fc0e3e9d58e1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa495701a9416c85c785fc0e3e9d58e1b">&#9670;&nbsp;</a></span>add_edges_for_chains()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::add_edges_for_chains </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1ZipCodeForest.html#a6f4d116fc7bbdf877de9a8968133f5d5">tree_item_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dist_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1seed__info__t.html">seed_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>snarl_is_reversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_cyclic_snarl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper for <a class="el" href="classvg_1_1ZipCodeForest.html#af0b8337aa133b4f4cf51a65be37e126e">add_distance_matrix()</a> to add the chains' rows These are edges from everything prior to the given chain end bound </p>

</div>
</div>
<a id="a152f1bf73ad3f6569b7cfc7b6d64a07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a152f1bf73ad3f6569b7cfc7b6d64a07e">&#9670;&nbsp;</a></span>add_edges_to_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::add_edges_to_end </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1ZipCodeForest.html#a6f4d116fc7bbdf877de9a8968133f5d5">tree_item_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dist_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1seed__info__t.html">seed_info_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>snarl_is_reversed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_cyclic_snarl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper for <a class="el" href="classvg_1_1ZipCodeForest.html#af0b8337aa133b4f4cf51a65be37e126e">add_distance_matrix()</a> to add the last row These are edges from everything prior to the snarl end bound </p>

</div>
</div>
<a id="a2307457a70762459688446395338b3f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2307457a70762459688446395338b3f8">&#9670;&nbsp;</a></span>close_chain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::close_chain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &amp;&#160;</td>
          <td class="paramname"><em>last_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>chain_is_reversed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Close a chain that ends at last_seed If the chain was empty, remove it and anything relating to it If must be spliced out, take out a subtree Otherwise, add the end of the chain and, if the chain was in a snarl, remember the distance to the end of the chain </p>

</div>
</div>
<a id="a72ed3945435b9383523db554b1068605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72ed3945435b9383523db554b1068605">&#9670;&nbsp;</a></span>close_snarl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::close_snarl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &amp;&#160;</td>
          <td class="paramname"><em>last_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>last_is_reversed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Close a snarl at the given depth with the given last_seed If the snarl has no children, then delete the whole thing Otherwise, add all necessary distances and close it </p>

</div>
</div>
<a id="a5eed49e06827ec7883f8abe8da3d548e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5eed49e06827ec7883f8abe8da3d548e">&#9670;&nbsp;</a></span>default_sort_zipcodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::default_sort_zipcodes </td>
          <td>(</td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>zipcode_sort_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1sort__value__t.html">sort_value_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sort_values_by_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function for <a class="el" href="classvg_1_1ZipCodeForest.html#a499f52fbb75374e2dc06ce7998ad8fd6">sort_one_interval()</a> to sort seeds using std::sort Sorts the slice of seeds in the given interval of zipcode_sort_order, a vector of indices into seeds </p>

</div>
</div>
<a id="a8e85202bb164a9c152fb8f6f43c050a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e85202bb164a9c152fb8f6f43c050a2">&#9670;&nbsp;</a></span>fill_in_forest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::fill_in_forest </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance_limit</em> = <code>std::numeric_limits&lt;size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate the zip forest If a distance limit is given, then partition into subtrees that are farther than distance_limit from each other Otherwise, the forest will just be connected components </p>

</div>
</div>
<a id="a938f2d3c36ab09c5c7a80f33b9ac365c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938f2d3c36ab09c5c7a80f33b9ac365c">&#9670;&nbsp;</a></span>get_edge_seeds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1seed__info__t.html">ZipCodeForest::seed_info_t</a> &gt; vg::ZipCodeForest::get_edge_seeds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper for <a class="el" href="classvg_1_1ZipCodeForest.html#af0b8337aa133b4f4cf51a65be37e126e">add_distance_matrix()</a> Look up seeds for chain edges and remember <a class="el" href="structvg_1_1ZipCodeForest_1_1seed__info__t.html">seed_info_t</a> for each Returns [c1_L, c1_R, c2_L, c2_R, ...] for each chain side in the snarl </p>

</div>
</div>
<a id="a2c9a60acfcb3f8521eeb7bbf5e36007b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9a60acfcb3f8521eeb7bbf5e36007b">&#9670;&nbsp;</a></span>get_next_intervals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::get_next_intervals </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::forward_list&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>next_intervals</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Assuming that the range of seeds in forest_state.sort_values_by_seed given by interval is sorted, prepend child intervals to next_intervals. The new intervals get added in their sort order, so the start of a chain will be at the start of the list, to be popped first.</p>
<p>For children of chains, seeds on the chain itself and not nested will be on the same interval if there are no seeds in snarls between them, even if they are not on the same node </p>

</div>
</div>
<a id="a39be64ea490a29bb4c59eb503a08ce5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39be64ea490a29bb4c59eb503a08ce5c">&#9670;&nbsp;</a></span>move_slice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCodeForest::move_slice </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Move a slice of a chain into a new tree Chain copied from forest_state.open_chains.back().first to end This is used when a part is too far from the rest to be in the same tree Returns whether a whole chain was moved (true) or just a slice (false) </p>

</div>
</div>
<a id="aedf4d4e0d4837917b3244a77f3f8aa2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedf4d4e0d4837917b3244a77f3f8aa2d">&#9670;&nbsp;</a></span>open_chain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::open_chain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Open a chain that starts at the current_seed Also record its presence and distance-to-start in the parent snarl Assumes that the chain <em>has</em> a parent snarl, i.e. isn't top-level </p>

</div>
</div>
<a id="a4f247c1e2fe2d7cf7cf43ba72ee06097"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f247c1e2fe2d7cf7cf43ba72ee06097">&#9670;&nbsp;</a></span>open_snarl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::open_snarl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_cyclic_snarl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Start a new snarl of the given type at the given depth. </p>

</div>
</div>
<a id="ab609e62b11436a2c69e0bf36797fefb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab609e62b11436a2c69e0bf36797fefb1">&#9670;&nbsp;</a></span>print_self()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::print_self </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &gt; *&#160;</td>
          <td class="paramname"><em>seeds</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Print each zip code tree in the forest to stderr Ziptrees are prefaced by their index, e.g. "0: &lt;tree.print_self()&gt;" </p>

</div>
</div>
<a id="aade4c028524fd9e0c4a6267335584171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aade4c028524fd9e0c4a6267335584171">&#9670;&nbsp;</a></span>radix_sort_zipcodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::radix_sort_zipcodes </td>
          <td>(</td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>zipcode_sort_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1ZipCodeForest_1_1sort__value__t.html">sort_value_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sort_values_by_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sort_by_chain_component</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function for <a class="el" href="classvg_1_1ZipCodeForest.html#a499f52fbb75374e2dc06ce7998ad8fd6">sort_one_interval()</a> to sort seeds using radix sort Sorts the slice of seeds in the given interval of zipcode_sort_order, a vector of indices into seeds. Reverse order if reverse_order. The interval also has an is_reversed field, which refers to the orientation in the snarl tree. min_ and max_value are the minimum and maximum value being sorted on. If sort_by_chain_component is true, then sort on the chain component in sort_values</p>
<p>This should run in linear time, but is dependent on the values being sorted on to have a small range </p>

</div>
</div>
<a id="a499f52fbb75374e2dc06ce7998ad8fd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a499f52fbb75374e2dc06ce7998ad8fd6">&#9670;&nbsp;</a></span>sort_one_interval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::sort_one_interval </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1ZipCodeForest_1_1forest__growing__state__t.html">forest_growing_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>forest_state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1ZipCodeForest_1_1interval__state__t.html">interval_state_t</a> &amp;&#160;</td>
          <td class="paramname"><em>interval</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sorts an interval, which must contain seeds on the same snarl/chain/node Sorting is linear-ish along top-level chains, topological-ish in snarls. Uses <a class="el" href="classvg_1_1ZipCodeForest.html#aade4c028524fd9e0c4a6267335584171">radix_sort_zipcodes()</a> and <a class="el" href="classvg_1_1ZipCodeForest.html#a5eed49e06827ec7883f8abe8da3d548e">default_sort_zipcodes()</a></p>
<p>For chains, everything is sorted with the prefix sum value of the chain itself from the distance index, not the order in the zip code tree. Everything will be sorted in the order of the zip code tree, but the values will be set from the distance index. Later, the values may be out of order or may need to be subtracted from the length of the chain to get the distance to the ends of the chain </p>

</div>
</div>
<a id="a61e851b424a075f606092a97d0106845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61e851b424a075f606092a97d0106845">&#9670;&nbsp;</a></span>validate_zip_forest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeForest::validate_zip_forest </td>
          <td>(</td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1ZipCodeForest.html#a93f9eaa38dd8024a73a2aeca456e5156">Seed</a> &gt; *&#160;</td>
          <td class="paramname"><em>seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance_limit</em> = <code>std::numeric_limits&lt;size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check that the forest is correct:</p><ol type="1">
<li>Each tree is valid in itself</li>
<li>All seed positions (i.e. ignoring duplicates) appear at least once </li>
</ol>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="af85d4ca7594aee84b37f7864e24e5ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85d4ca7594aee84b37f7864e24e5ce6">&#9670;&nbsp;</a></span>trees</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="classvg_1_1ZipCodeTree.html">ZipCodeTree</a>&gt; vg::ZipCodeForest::trees</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The actual data, a collection of ZipCodeTrees. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="zip__code__tree_8hpp.html">zip_code_tree.hpp</a></li>
<li>src/<a class="el" href="zip__code__tree_8cpp.html">zip_code_tree.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
