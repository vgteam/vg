syntax = "proto3";

package vg;

// *Graphs* are collections of nodes and edges
// They can represent subgraphs of larger graphs
// or be wholly-self-sufficient.
// Protobuf memory limits of 67108864 bytes mean we typically keep the size
// of them small generating graphs as collections of smaller subgraphs.
//
message Graph {
    repeated Node node = 1;
    repeated Edge edge = 2;
    repeated Path path = 3;
    map<string, Info> info = 4;
}

// *Nodes* store sequence data and also links to other nodes.
// The graph is doubly-linked via IDs in prev/next fields in the Node objects.
//
message Node {
    string sequence = 1;   // sequence
    string name = 2;  // a name provides an identifier
    int64 id = 3;     // ids are critical, and unique within a graph
    bytes data = 4;   // arbitrary data
    map<string, Info> info = 5;
}

// *Edges* describe linkages between nodes. They are directed: from=prev, to=next.
//
message Edge {
    int64 from = 1; // ID of upstream node
    int64 to = 2;   // ID of downstream node
    bool from_start = 3; // if the edge leaves from the 5' (start) of a node
    bool to_end = 4; // if the edge goes to the 3' (end) of a node
    bytes data = 5; // arbitrary data
    map<string, Info> info = 6;
}

// info fields can be used to annotate objects in the graph
message Info {
    string id = 1;
    string str = 2;
    int64 int = 3;
    bytes data = 4;
    map<string, Info> info = 5;
}

// *Edits* describe how to generate a new string from elements
// in the graph. To determine the new string, just walk the series of edits,
// stepping from_length distance in the basis node, and to_length in the
// novel element, replacing from_length in the basis node with the sequence.
//
// *matches* from_length == to_length
// *snps* from_length == to_length; sequence = alt
// *deletions* from_length > to_length; sequence may be unset or empty
// *insertions* from_length < to_length; sequence contains relative insertion
// *skip* from_length == 0, to_length > 0; implies "soft clip" or sequence skip
//
message Edit {
    int32 from_length = 1; // length in target/ref
    int32 to_length = 2; // length in read/alt
    string sequence = 3;
    map<string, Info> info = 4;
}

// A Mapping defines the relationship between a node in system and another entity.
// An empty edit list implies complete match.
//
message Mapping {
    Position position = 1;
    repeated Edit edit = 2; // series of edit to transform to region in read/alt
    bool is_reverse = 3; // does the mapping go from the end of the node to the start
    map<string, Info> info = 4;
}

// A position in the graph is a pair of node and offset
//
message Position {
    int64 node_id = 1;
    int64 offset = 2;
    map<string, Info> info = 3;
}

// Paths are walks through nodes defined by a series of edits.
// They can be used to represent:
//    - haplotypes
//    - mappings of reads, or alignments, by including edits
//    - relationships between nodes
//    - annotations from other data sources, such as:
//          genes, exons, motifs, transcripts, peaks
//
message Path {
    string name = 1;
    repeated Mapping mapping = 2;
    map<string, Info> info = 3;
}

// Alignments link query strings, such as other genomes or reads, to paths.
//
message Alignment {
    string sequence = 1;
    Path path = 2;
    string name = 3;
    bytes quality = 4;
    int32 mapping_quality = 5;
    int32 score = 6;
    int32 query_position = 7;
    bool is_reverse = 8; // true if original sequence lies in the 3'->5' orientation
    string sample_name = 9;
    string read_group = 10;
    Alignment fragment_prev = 11; // e.g. contains an alignment with only a name, or only a graph mapping position
    Alignment fragment_next = 12; // same thing for next in fragment
    bytes data = 13;
    map<string, Info> info = 14;
}

// Fragments represent the library fragments that yield pairs of alignments
// or possibly a series of small alignments generated by a strobed read
message Fragment {
    repeated Alignment alignment = 1;
}

// used to serialize kmer matches
message KmerMatch {
    string sequence = 1;
    int64 node_id = 2;
    sint32 position = 3;
    
    // If true, this kmer is backwards relative to its node, and position counts from the end of the node.
    bool backward = 4; 
}
