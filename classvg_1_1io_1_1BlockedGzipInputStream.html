<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::io::BlockedGzipInputStream Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="namespacevg_1_1io.html">io</a></li><li class="navelem"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classvg_1_1io_1_1BlockedGzipInputStream-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::io::BlockedGzipInputStream Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;blocked_gzip_input_stream.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::io::BlockedGzipInputStream:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1io_1_1BlockedGzipInputStream.png" alt=""/>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a68ce515c9bee3c71da952dfe5db7ecac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#a68ce515c9bee3c71da952dfe5db7ecac">BlockedGzipInputStream</a> (std::istream &amp;stream, size_t thread_count=0)</td></tr>
<tr class="separator:a68ce515c9bee3c71da952dfe5db7ecac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56990712e743be20a39e760309a8934c"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#a56990712e743be20a39e760309a8934c">~BlockedGzipInputStream</a> ()</td></tr>
<tr class="memdesc:a56990712e743be20a39e760309a8934c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the stream.  <a href="classvg_1_1io_1_1BlockedGzipInputStream.html#a56990712e743be20a39e760309a8934c">More...</a><br /></td></tr>
<tr class="separator:a56990712e743be20a39e760309a8934c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a986e73fd3903582d1ab4110b73345d75"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#a986e73fd3903582d1ab4110b73345d75">BlockedGzipInputStream</a> (const <a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a> &amp;other)=delete</td></tr>
<tr class="separator:a986e73fd3903582d1ab4110b73345d75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaae753008929cd78c3ece15f1e73826d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#aaae753008929cd78c3ece15f1e73826d">operator=</a> (const <a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a> &amp;other)=delete</td></tr>
<tr class="separator:aaae753008929cd78c3ece15f1e73826d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2bcf77f6592aa95ac9ee599d9816e84"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#ae2bcf77f6592aa95ac9ee599d9816e84">BlockedGzipInputStream</a> (<a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:ae2bcf77f6592aa95ac9ee599d9816e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab978351afc9df57f66dfcbaf11932c17"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#ab978351afc9df57f66dfcbaf11932c17">operator=</a> (<a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a> &amp;&amp;other)=delete</td></tr>
<tr class="separator:ab978351afc9df57f66dfcbaf11932c17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91e4dc4f48957737a80e99a8ad32ba53"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#a91e4dc4f48957737a80e99a8ad32ba53">Next</a> (const void **data, int *size)</td></tr>
<tr class="separator:a91e4dc4f48957737a80e99a8ad32ba53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afae170aec0e88c42956c48fdce82d068"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#afae170aec0e88c42956c48fdce82d068">BackUp</a> (int count)</td></tr>
<tr class="separator:afae170aec0e88c42956c48fdce82d068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3849b5292df406dec93738920615987"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#af3849b5292df406dec93738920615987">Skip</a> (int count)</td></tr>
<tr class="separator:af3849b5292df406dec93738920615987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa90daab17c2449563e96bbca827c8ccf"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#aa90daab17c2449563e96bbca827c8ccf">ByteCount</a> () const</td></tr>
<tr class="memdesc:aa90daab17c2449563e96bbca827c8ccf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of bytes read since the stream was constructed.  <a href="classvg_1_1io_1_1BlockedGzipInputStream.html#aa90daab17c2449563e96bbca827c8ccf">More...</a><br /></td></tr>
<tr class="separator:aa90daab17c2449563e96bbca827c8ccf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b34e76da81d5a09d5ab2634a864d401"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#a4b34e76da81d5a09d5ab2634a864d401">Tell</a> () const</td></tr>
<tr class="separator:a4b34e76da81d5a09d5ab2634a864d401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa221be19182d88b7caa36ead3e63c829"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#aa221be19182d88b7caa36ead3e63c829">Seek</a> (int64_t virtual_offset)</td></tr>
<tr class="separator:aa221be19182d88b7caa36ead3e63c829"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb2633e42ca1b50ab167497e581e6bd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#a1eb2633e42ca1b50ab167497e581e6bd">IsBGZF</a> () const</td></tr>
<tr class="separator:a1eb2633e42ca1b50ab167497e581e6bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa45ae9d5a0c1689efa567d573ad5747c"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#aa45ae9d5a0c1689efa567d573ad5747c">SmellsLikeGzip</a> (std::istream &amp;in)</td></tr>
<tr class="separator:aa45ae9d5a0c1689efa567d573ad5747c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a2d575dc899c6ef50c6ffe7c374573fb9"><td class="memItemLeft" align="right" valign="top">BGZF *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#a2d575dc899c6ef50c6ffe7c374573fb9">handle</a></td></tr>
<tr class="separator:a2d575dc899c6ef50c6ffe7c374573fb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca10a84d86b0e9db6ef5727f9e454add"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#aca10a84d86b0e9db6ef5727f9e454add">byte_count</a></td></tr>
<tr class="memdesc:aca10a84d86b0e9db6ef5727f9e454add"><td class="mdescLeft">&#160;</td><td class="mdescRight">The counter to back ByteCount.  <a href="classvg_1_1io_1_1BlockedGzipInputStream.html#aca10a84d86b0e9db6ef5727f9e454add">More...</a><br /></td></tr>
<tr class="separator:aca10a84d86b0e9db6ef5727f9e454add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62a78fd952dc7239a74fd042eae0e562"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#a62a78fd952dc7239a74fd042eae0e562">know_offset</a></td></tr>
<tr class="memdesc:a62a78fd952dc7239a74fd042eae0e562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flag for whether our backing stream is tellable.  <a href="classvg_1_1io_1_1BlockedGzipInputStream.html#a62a78fd952dc7239a74fd042eae0e562">More...</a><br /></td></tr>
<tr class="separator:a62a78fd952dc7239a74fd042eae0e562"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Protobuf-style ZeroCopyInputStream that reads data from blocked gzip format, and allows interacting with virtual offsets. Cannot be moved or copied, because the base class can't be moved or copied. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a68ce515c9bee3c71da952dfe5db7ecac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68ce515c9bee3c71da952dfe5db7ecac">&#9670;&nbsp;</a></span>BlockedGzipInputStream() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::io::BlockedGzipInputStream::BlockedGzipInputStream </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>thread_count</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a new stream reading from the given C++ std::istream, wrapping it in a BGZF. The stream must be at a BGZF block header, since the header info is peeked.</p>
<p>If thread_count is more than 1, enables multi-threaded BGZF decoding. This needs to be part of the comstructor to ensure that it happens before any data is read through the decoder. </p>

</div>
</div>
<a id="a56990712e743be20a39e760309a8934c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56990712e743be20a39e760309a8934c">&#9670;&nbsp;</a></span>~BlockedGzipInputStream()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::io::BlockedGzipInputStream::~BlockedGzipInputStream </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the stream. </p>

</div>
</div>
<a id="a986e73fd3903582d1ab4110b73345d75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a986e73fd3903582d1ab4110b73345d75">&#9670;&nbsp;</a></span>BlockedGzipInputStream() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::io::BlockedGzipInputStream::BlockedGzipInputStream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2bcf77f6592aa95ac9ee599d9816e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2bcf77f6592aa95ac9ee599d9816e84">&#9670;&nbsp;</a></span>BlockedGzipInputStream() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::io::BlockedGzipInputStream::BlockedGzipInputStream </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="afae170aec0e88c42956c48fdce82d068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afae170aec0e88c42956c48fdce82d068">&#9670;&nbsp;</a></span>BackUp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::BlockedGzipInputStream::BackUp </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>When called after <a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#a91e4dc4f48957737a80e99a8ad32ba53">Next()</a>, mark the last count bytes of the buffer that <a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#a91e4dc4f48957737a80e99a8ad32ba53">Next()</a> produced as not having been read. </p>

</div>
</div>
<a id="aa90daab17c2449563e96bbca827c8ccf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa90daab17c2449563e96bbca827c8ccf">&#9670;&nbsp;</a></span>ByteCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::io::BlockedGzipInputStream::ByteCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of bytes read since the stream was constructed. </p>

</div>
</div>
<a id="a1eb2633e42ca1b50ab167497e581e6bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb2633e42ca1b50ab167497e581e6bd">&#9670;&nbsp;</a></span>IsBGZF()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::BlockedGzipInputStream::IsBGZF </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the stream being read really is BGZF, and false if we are operating on a non-blocked GZIP or uncompressed file. </p>

</div>
</div>
<a id="a91e4dc4f48957737a80e99a8ad32ba53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91e4dc4f48957737a80e99a8ad32ba53">&#9670;&nbsp;</a></span>Next()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::BlockedGzipInputStream::Next </td>
          <td>(</td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a buffer to read from. Saves the address of the buffer where data points, and the size of the buffer where size points. Returns false on an unrecoverable error or EOF, and true if a buffer was gotten. The data pointer must be valid until the next read call or until the stream is destroyed. </p>

</div>
</div>
<a id="ab978351afc9df57f66dfcbaf11932c17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab978351afc9df57f66dfcbaf11932c17">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a>&amp; vg::io::BlockedGzipInputStream::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaae753008929cd78c3ece15f1e73826d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaae753008929cd78c3ece15f1e73826d">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a>&amp; vg::io::BlockedGzipInputStream::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa221be19182d88b7caa36ead3e63c829"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa221be19182d88b7caa36ead3e63c829">&#9670;&nbsp;</a></span>Seek()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::BlockedGzipInputStream::Seek </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>virtual_offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Seek to the given virtual offset. Return true if successful, or false if the backing stream is unseekable, or not blocked. Note that this will cause problems if something reading from this stream is still operating on outstanding buffers; Any CodedInputStreams reading from this stream <em>must</em> be destroyed before this function is called. </p>

</div>
</div>
<a id="af3849b5292df406dec93738920615987"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3849b5292df406dec93738920615987">&#9670;&nbsp;</a></span>Skip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::BlockedGzipInputStream::Skip </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>count</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Skip ahead the given number of bytes. Return false if the end of the stream is reached, or an error occurs. If the end of the stream is hit, advances to the end of the stream. </p>

</div>
</div>
<a id="aa45ae9d5a0c1689efa567d573ad5747c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45ae9d5a0c1689efa567d573ad5747c">&#9670;&nbsp;</a></span>SmellsLikeGzip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::BlockedGzipInputStream::SmellsLikeGzip </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the given istream looks like GZIP-compressed data (i.e. has the GZIP magic number as its first two bytes). Replicates some of the sniffing logic that htslib does, but puts back the sniffed characters so the stream can be read fine either way after sniffing. </p>

</div>
</div>
<a id="a4b34e76da81d5a09d5ab2634a864d401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b34e76da81d5a09d5ab2634a864d401">&#9670;&nbsp;</a></span>Tell()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::io::BlockedGzipInputStream::Tell </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the blocked gzip virtual offset at which the next fresh buffer returned by <a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html#a91e4dc4f48957737a80e99a8ad32ba53">Next()</a> will start, or -1 if operating on an untellable stream like standard input or on a non-blocked file. Note that this will only get you the position of the next read if anything you are reading through is fully backed up to the next actually-unread byte. See Protobuf's CodedInputStream::Trim(). </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aca10a84d86b0e9db6ef5727f9e454add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca10a84d86b0e9db6ef5727f9e454add">&#9670;&nbsp;</a></span>byte_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::BlockedGzipInputStream::byte_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The counter to back ByteCount. </p>

</div>
</div>
<a id="a2d575dc899c6ef50c6ffe7c374573fb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d575dc899c6ef50c6ffe7c374573fb9">&#9670;&nbsp;</a></span>handle</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">BGZF* vg::io::BlockedGzipInputStream::handle</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>The open BGZF handle being read from. We use the BGZF's buffer as our buffer, and its block_offset for our seeks and back-ups. </p>

</div>
</div>
<a id="a62a78fd952dc7239a74fd042eae0e562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62a78fd952dc7239a74fd042eae0e562">&#9670;&nbsp;</a></span>know_offset</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::BlockedGzipInputStream::know_offset</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Flag for whether our backing stream is tellable. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deps/libvgio/include/vg/io/<a class="el" href="blocked__gzip__input__stream_8hpp.html">blocked_gzip_input_stream.hpp</a></li>
<li>deps/libvgio/src/<a class="el" href="blocked__gzip__input__stream_8cpp.html">blocked_gzip_input_stream.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
