<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::VG Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1VG.html">VG</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1VG-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::VG Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;vg.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::VG:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1VG.png" usemap="#vg::VG_map" alt=""/>
  <map id="vg::VG_map" name="vg::VG_map">
<area href="classvg_1_1Progressive.html" alt="vg::Progressive" shape="rect" coords="0,168,230,192"/>
<area href="classvg_1_1MutablePathDeletableHandleGraph.html" alt="vg::MutablePathDeletableHandleGraph" shape="rect" coords="240,168,470,192"/>
<area href="classvg_1_1MutablePathHandleGraph.html" alt="vg::MutablePathHandleGraph" shape="rect" coords="120,112,350,136"/>
<area href="classvg_1_1DeletableHandleGraph.html" alt="vg::DeletableHandleGraph" shape="rect" coords="360,112,590,136"/>
<area href="classvg_1_1PathHandleGraph.html" alt="vg::PathHandleGraph" shape="rect" coords="120,56,350,80"/>
<area href="classvg_1_1MutableHandleGraph.html" alt="vg::MutableHandleGraph" shape="rect" coords="360,56,590,80"/>
<area href="classvg_1_1HandleGraph.html" alt="vg::HandleGraph" shape="rect" coords="120,0,350,24"/>
<area href="classvg_1_1HandleGraph.html" alt="vg::HandleGraph" shape="rect" coords="360,0,590,24"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1VG_1_1Plan.html">Plan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for managing parallel construction of a graph.  <a href="structvg_1_1VG_1_1Plan.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a26a218b188035e086a5625170cfcf23c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a26a218b188035e086a5625170cfcf23c">get_handle</a> (const <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &amp;node_id, bool is_reverse=false) const </td></tr>
<tr class="memdesc:a26a218b188035e086a5625170cfcf23c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the handle for the node with the given ID in the given orientation.  <a href="#a26a218b188035e086a5625170cfcf23c">More...</a><br/></td></tr>
<tr class="separator:a26a218b188035e086a5625170cfcf23c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a275f9a67d357980049ff3a6cb475a0a6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a275f9a67d357980049ff3a6cb475a0a6">get_id</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a275f9a67d357980049ff3a6cb475a0a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID from a handle.  <a href="#a275f9a67d357980049ff3a6cb475a0a6">More...</a><br/></td></tr>
<tr class="separator:a275f9a67d357980049ff3a6cb475a0a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a101b575652f006b09c33ba271806e721"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a101b575652f006b09c33ba271806e721">get_is_reverse</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a101b575652f006b09c33ba271806e721"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the orientation of a handle.  <a href="#a101b575652f006b09c33ba271806e721">More...</a><br/></td></tr>
<tr class="separator:a101b575652f006b09c33ba271806e721"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47afbf1369e36d541a0ebddfc707d934"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a47afbf1369e36d541a0ebddfc707d934">flip</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a47afbf1369e36d541a0ebddfc707d934"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the orientation of a handle (potentially without getting its ID)  <a href="#a47afbf1369e36d541a0ebddfc707d934">More...</a><br/></td></tr>
<tr class="separator:a47afbf1369e36d541a0ebddfc707d934"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8816a7244ebad64663a1af13f5244c"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7f8816a7244ebad64663a1af13f5244c">get_length</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a7f8816a7244ebad64663a1af13f5244c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a node.  <a href="#a7f8816a7244ebad64663a1af13f5244c">More...</a><br/></td></tr>
<tr class="separator:a7f8816a7244ebad64663a1af13f5244c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7382f9cc8ef44b358495d021a0a0f80b"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7382f9cc8ef44b358495d021a0a0f80b">get_sequence</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="separator:a7382f9cc8ef44b358495d021a0a0f80b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fcb850d9dca13ccecb1cc63445e0c9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a49fcb850d9dca13ccecb1cc63445e0c9">follow_edges</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const function&lt; bool(const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee) const </td></tr>
<tr class="separator:a49fcb850d9dca13ccecb1cc63445e0c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af065aeb66bd1995f1edbcd3dccaf1fa7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af065aeb66bd1995f1edbcd3dccaf1fa7">for_each_handle</a> (const function&lt; bool(const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee, bool parallel=false) const </td></tr>
<tr class="separator:af065aeb66bd1995f1edbcd3dccaf1fa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f84f601f2ef13c0d9df3741ccdc192"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a85f84f601f2ef13c0d9df3741ccdc192">node_size</a> () const </td></tr>
<tr class="memdesc:a85f84f601f2ef13c0d9df3741ccdc192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of nodes in the graph.  <a href="#a85f84f601f2ef13c0d9df3741ccdc192">More...</a><br/></td></tr>
<tr class="separator:a85f84f601f2ef13c0d9df3741ccdc192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f9c36b6c3f7cbe933f705e9e9ba782"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a78f9c36b6c3f7cbe933f705e9e9ba782">min_node_id</a> () const </td></tr>
<tr class="memdesc:a78f9c36b6c3f7cbe933f705e9e9ba782"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum node ID used in the graph, if any are used.  <a href="#a78f9c36b6c3f7cbe933f705e9e9ba782">More...</a><br/></td></tr>
<tr class="separator:a78f9c36b6c3f7cbe933f705e9e9ba782"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3751016fff6e1e38d154515a13949e74"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3751016fff6e1e38d154515a13949e74">max_node_id</a> () const </td></tr>
<tr class="memdesc:a3751016fff6e1e38d154515a13949e74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum node ID used in the graph, if any are used.  <a href="#a3751016fff6e1e38d154515a13949e74">More...</a><br/></td></tr>
<tr class="separator:a3751016fff6e1e38d154515a13949e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1a8a09a49ea348f3714377b893319f6"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac1a8a09a49ea348f3714377b893319f6">get_degree</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left) const </td></tr>
<tr class="separator:ac1a8a09a49ea348f3714377b893319f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86daea8c9c2ff784598512fff740bd2c"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a86daea8c9c2ff784598512fff740bd2c">has_path</a> (const string &amp;path_name) const </td></tr>
<tr class="memdesc:a86daea8c9c2ff784598512fff740bd2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a path name exists and is legal to get a path handle for.  <a href="#a86daea8c9c2ff784598512fff740bd2c">More...</a><br/></td></tr>
<tr class="separator:a86daea8c9c2ff784598512fff740bd2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0789f1df0078dff5849a97f60ca4d51e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0789f1df0078dff5849a97f60ca4d51e">get_path_handle</a> (const string &amp;path_name) const </td></tr>
<tr class="memdesc:a0789f1df0078dff5849a97f60ca4d51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the path handle for the given path name.  <a href="#a0789f1df0078dff5849a97f60ca4d51e">More...</a><br/></td></tr>
<tr class="separator:a0789f1df0078dff5849a97f60ca4d51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71b9547040f0d8ae430d564aa897d97"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac71b9547040f0d8ae430d564aa897d97">get_path_name</a> (const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="memdesc:ac71b9547040f0d8ae430d564aa897d97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the name of a path from a handle to it.  <a href="#ac71b9547040f0d8ae430d564aa897d97">More...</a><br/></td></tr>
<tr class="separator:ac71b9547040f0d8ae430d564aa897d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a800d31a2623c04eaf0073554e7ca31c5"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a800d31a2623c04eaf0073554e7ca31c5">get_occurrence_count</a> (const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="memdesc:a800d31a2623c04eaf0073554e7ca31c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of node occurrences in the path.  <a href="#a800d31a2623c04eaf0073554e7ca31c5">More...</a><br/></td></tr>
<tr class="separator:a800d31a2623c04eaf0073554e7ca31c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20417af67e14d7800b20df8b0ac763f9"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a20417af67e14d7800b20df8b0ac763f9">get_path_count</a> () const </td></tr>
<tr class="memdesc:a20417af67e14d7800b20df8b0ac763f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of paths stored in the graph.  <a href="#a20417af67e14d7800b20df8b0ac763f9">More...</a><br/></td></tr>
<tr class="separator:a20417af67e14d7800b20df8b0ac763f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9c52c2e527b16a61c32e759b4a0b3c3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad9c52c2e527b16a61c32e759b4a0b3c3">for_each_path_handle</a> (const function&lt; void(const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; &amp;iteratee) const </td></tr>
<tr class="memdesc:ad9c52c2e527b16a61c32e759b4a0b3c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function on each path in the graph.  <a href="#ad9c52c2e527b16a61c32e759b4a0b3c3">More...</a><br/></td></tr>
<tr class="separator:ad9c52c2e527b16a61c32e759b4a0b3c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbef12f2d3db8d702f1fdf2aea40351d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#abbef12f2d3db8d702f1fdf2aea40351d">get_occurrence</a> (const <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;occurrence_handle) const </td></tr>
<tr class="memdesc:abbef12f2d3db8d702f1fdf2aea40351d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a node handle (node ID and orientation) from a handle to an occurrence on a path.  <a href="#abbef12f2d3db8d702f1fdf2aea40351d">More...</a><br/></td></tr>
<tr class="separator:abbef12f2d3db8d702f1fdf2aea40351d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff0e1716e97115deacaf3115786db5b"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#adff0e1716e97115deacaf3115786db5b">get_first_occurrence</a> (const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="memdesc:adff0e1716e97115deacaf3115786db5b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to the first occurrence in a path.  <a href="#adff0e1716e97115deacaf3115786db5b">More...</a><br/></td></tr>
<tr class="separator:adff0e1716e97115deacaf3115786db5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82696917d41113970d95e84cb2ed9f88"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a82696917d41113970d95e84cb2ed9f88">get_last_occurrence</a> (const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="memdesc:a82696917d41113970d95e84cb2ed9f88"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a handle to the last occurrence in a path.  <a href="#a82696917d41113970d95e84cb2ed9f88">More...</a><br/></td></tr>
<tr class="separator:a82696917d41113970d95e84cb2ed9f88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add251f0d262b6af53b11b244c17b39ec"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#add251f0d262b6af53b11b244c17b39ec">has_next_occurrence</a> (const <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;occurrence_handle) const </td></tr>
<tr class="memdesc:add251f0d262b6af53b11b244c17b39ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the occurrence is not the last occurence on the path, else false.  <a href="#add251f0d262b6af53b11b244c17b39ec">More...</a><br/></td></tr>
<tr class="separator:add251f0d262b6af53b11b244c17b39ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fdaf206869cf4a3d7fe09858fa757c8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a4fdaf206869cf4a3d7fe09858fa757c8">has_previous_occurrence</a> (const <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;occurrence_handle) const </td></tr>
<tr class="memdesc:a4fdaf206869cf4a3d7fe09858fa757c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the occurrence is not the first occurence on the path, else false.  <a href="#a4fdaf206869cf4a3d7fe09858fa757c8">More...</a><br/></td></tr>
<tr class="separator:a4fdaf206869cf4a3d7fe09858fa757c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8de058cf4945d57d348d148945281b00"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8de058cf4945d57d348d148945281b00">get_next_occurrence</a> (const <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;occurrence_handle) const </td></tr>
<tr class="memdesc:a8de058cf4945d57d348d148945281b00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the next occurrence on the path.  <a href="#a8de058cf4945d57d348d148945281b00">More...</a><br/></td></tr>
<tr class="separator:a8de058cf4945d57d348d148945281b00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb4c806b52f820abecb2ef14b39f9fac"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aeb4c806b52f820abecb2ef14b39f9fac">get_previous_occurrence</a> (const <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;occurrence_handle) const </td></tr>
<tr class="memdesc:aeb4c806b52f820abecb2ef14b39f9fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the previous occurrence on the path.  <a href="#aeb4c806b52f820abecb2ef14b39f9fac">More...</a><br/></td></tr>
<tr class="separator:aeb4c806b52f820abecb2ef14b39f9fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99957343fa6c48216d95787c1ddbd680"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a99957343fa6c48216d95787c1ddbd680">get_path_handle_of_occurrence</a> (const <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;occurrence_handle) const </td></tr>
<tr class="memdesc:a99957343fa6c48216d95787c1ddbd680"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the path that an occurrence is on.  <a href="#a99957343fa6c48216d95787c1ddbd680">More...</a><br/></td></tr>
<tr class="separator:a99957343fa6c48216d95787c1ddbd680"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a838967605238fb226a5a5a7836229c96"><td class="memItemLeft" align="right" valign="top">virtual vector<br class="typebreak"/>
&lt; <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a838967605238fb226a5a5a7836229c96">occurrences_of_handle</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;handle, bool match_orientation=false) const </td></tr>
<tr class="separator:a838967605238fb226a5a5a7836229c96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ad97e46dc1297b1a65a32697e2d37e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a54ad97e46dc1297b1a65a32697e2d37e">create_handle</a> (const string &amp;sequence)</td></tr>
<tr class="memdesc:a54ad97e46dc1297b1a65a32697e2d37e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node with the given sequence and return the handle.  <a href="#a54ad97e46dc1297b1a65a32697e2d37e">More...</a><br/></td></tr>
<tr class="separator:a54ad97e46dc1297b1a65a32697e2d37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae968a71f586b6cc3876f2e9452f4c576"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae968a71f586b6cc3876f2e9452f4c576">create_handle</a> (const string &amp;sequence, const <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &amp;<a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:ae968a71f586b6cc3876f2e9452f4c576"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a new node with the given id and sequence, then return the handle.  <a href="#ae968a71f586b6cc3876f2e9452f4c576">More...</a><br/></td></tr>
<tr class="separator:ae968a71f586b6cc3876f2e9452f4c576"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e52875d37f046daeaf9e7b301ad59ff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3e52875d37f046daeaf9e7b301ad59ff">destroy_handle</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="memdesc:a3e52875d37f046daeaf9e7b301ad59ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the node belonging to the given handle and all of its edges.  <a href="#a3e52875d37f046daeaf9e7b301ad59ff">More...</a><br/></td></tr>
<tr class="separator:a3e52875d37f046daeaf9e7b301ad59ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8922810d5228ab5c4619eb2ddc16e78b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8922810d5228ab5c4619eb2ddc16e78b">create_edge</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;right)</td></tr>
<tr class="memdesc:a8922810d5228ab5c4619eb2ddc16e78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an edge connecting the given handles in the given order and orientations.  <a href="#a8922810d5228ab5c4619eb2ddc16e78b">More...</a><br/></td></tr>
<tr class="separator:a8922810d5228ab5c4619eb2ddc16e78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4264e39e3826ded714992361ab879e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a9d4264e39e3826ded714992361ab879e">destroy_edge</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;right)</td></tr>
<tr class="memdesc:a9d4264e39e3826ded714992361ab879e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the edge connecting the given handles in the given order and orientations.  <a href="#a9d4264e39e3826ded714992361ab879e">More...</a><br/></td></tr>
<tr class="separator:a9d4264e39e3826ded714992361ab879e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1eb3332c0a99a25c75681da485297e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa1eb3332c0a99a25c75681da485297e5">clear</a> ()</td></tr>
<tr class="memdesc:aa1eb3332c0a99a25c75681da485297e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all nodes and edges. Does not update any stored paths.  <a href="#aa1eb3332c0a99a25c75681da485297e5">More...</a><br/></td></tr>
<tr class="separator:aa1eb3332c0a99a25c75681da485297e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4db6ea2a99bda9a48411491aa6ed4e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3d4db6ea2a99bda9a48411491aa6ed4e">swap_handles</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;a, const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;b)</td></tr>
<tr class="separator:a3d4db6ea2a99bda9a48411491aa6ed4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ee06ac168f037f2cff3b332079b49c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab5ee06ac168f037f2cff3b332079b49c">apply_orientation</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="separator:ab5ee06ac168f037f2cff3b332079b49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5dbc95fa80e7fe3dc04d62ac6d7b3c"><td class="memItemLeft" align="right" valign="top">virtual vector&lt; <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7a5dbc95fa80e7fe3dc04d62ac6d7b3c">divide_handle</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;handle, const vector&lt; size_t &gt; &amp;offsets)</td></tr>
<tr class="separator:a7a5dbc95fa80e7fe3dc04d62ac6d7b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb25bd1fdb9e36c55157c5be864ca403"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#adb25bd1fdb9e36c55157c5be864ca403">destroy_path</a> (const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;path)</td></tr>
<tr class="memdesc:adb25bd1fdb9e36c55157c5be864ca403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the given path. Invalidates handles to the path and its node occurrences.  <a href="#adb25bd1fdb9e36c55157c5be864ca403">More...</a><br/></td></tr>
<tr class="separator:adb25bd1fdb9e36c55157c5be864ca403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bcd5d003953bbec11cd6162e53bb974"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a4bcd5d003953bbec11cd6162e53bb974">create_path_handle</a> (const string &amp;<a class="el" href="classvg_1_1VG.html#a1f6fcd5a907e9bee524cf37a62ad5be2">name</a>)</td></tr>
<tr class="memdesc:a4bcd5d003953bbec11cd6162e53bb974"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a path with the given name.  <a href="#a4bcd5d003953bbec11cd6162e53bb974">More...</a><br/></td></tr>
<tr class="separator:a4bcd5d003953bbec11cd6162e53bb974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27ce8091357377810e01f45bc783e49"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa27ce8091357377810e01f45bc783e49">append_occurrence</a> (const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;path, const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;to_append)</td></tr>
<tr class="memdesc:aa27ce8091357377810e01f45bc783e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a visit to a node to the given path.  <a href="#aa27ce8091357377810e01f45bc783e49">More...</a><br/></td></tr>
<tr class="separator:aa27ce8091357377810e01f45bc783e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1131c1ff0a94ed2ec9ef35cb678801b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae1131c1ff0a94ed2ec9ef35cb678801b">set_edge</a> (<a class="el" href="structvg_1_1Edge.html">Edge</a> *)</td></tr>
<tr class="separator:ae1131c1ff0a94ed2ec9ef35cb678801b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b659686076f3d6b7b63ec9678d76a93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2b659686076f3d6b7b63ec9678d76a93">print_edges</a> (void)</td></tr>
<tr class="separator:a2b659686076f3d6b7b63ec9678d76a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eaedf10280d72862aa6f0b65a3d383e"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5eaedf10280d72862aa6f0b65a3d383e">edges_start</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a5eaedf10280d72862aa6f0b65a3d383e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get nodes and backward flags following edges that attach to this node's start.  <a href="#a5eaedf10280d72862aa6f0b65a3d383e">More...</a><br/></td></tr>
<tr class="separator:a5eaedf10280d72862aa6f0b65a3d383e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a9f315e43b96496fb5674df52623f7"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad9a9f315e43b96496fb5674df52623f7">edges_start</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:ad9a9f315e43b96496fb5674df52623f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get nodes and backward flags following edges that attach to this node's start.  <a href="#ad9a9f315e43b96496fb5674df52623f7">More...</a><br/></td></tr>
<tr class="separator:ad9a9f315e43b96496fb5674df52623f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdabb41079406d955795f2cfb72b496d"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#acdabb41079406d955795f2cfb72b496d">edges_end</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:acdabb41079406d955795f2cfb72b496d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get nodes and backward flags following edges that attach to this node's end.  <a href="#acdabb41079406d955795f2cfb72b496d">More...</a><br/></td></tr>
<tr class="separator:acdabb41079406d955795f2cfb72b496d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec901943e03aeae91638bce6952efc14"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aec901943e03aeae91638bce6952efc14">edges_end</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:aec901943e03aeae91638bce6952efc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get nodes and backward flags following edges that attach to this node's end.  <a href="#aec901943e03aeae91638bce6952efc14">More...</a><br/></td></tr>
<tr class="separator:aec901943e03aeae91638bce6952efc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3720ce267c8167ce679a015063dab6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a9e3720ce267c8167ce679a015063dab6">size</a> (void)</td></tr>
<tr class="memdesc:a9e3720ce267c8167ce679a015063dab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes.  <a href="#a9e3720ce267c8167ce679a015063dab6">More...</a><br/></td></tr>
<tr class="separator:a9e3720ce267c8167ce679a015063dab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23641dedefa2b6d573939515fcf5974c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a23641dedefa2b6d573939515fcf5974c">length</a> (void)</td></tr>
<tr class="memdesc:a23641dedefa2b6d573939515fcf5974c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total sequence length.  <a href="#a23641dedefa2b6d573939515fcf5974c">More...</a><br/></td></tr>
<tr class="separator:a23641dedefa2b6d573939515fcf5974c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2399de59931e282fb1f4d3da9a8dcb1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac2399de59931e282fb1f4d3da9a8dcb1">VG</a> (void)</td></tr>
<tr class="memdesc:ac2399de59931e282fb1f4d3da9a8dcb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="#ac2399de59931e282fb1f4d3da9a8dcb1">More...</a><br/></td></tr>
<tr class="separator:ac2399de59931e282fb1f4d3da9a8dcb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc9648985454d3aedd9a477ff0c52b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2dc9648985454d3aedd9a477ff0c52b2">VG</a> (istream &amp;in, bool showp=false, bool warn_on_duplicates=true)</td></tr>
<tr class="memdesc:a2dc9648985454d3aedd9a477ff0c52b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from protobufs.  <a href="#a2dc9648985454d3aedd9a477ff0c52b2">More...</a><br/></td></tr>
<tr class="separator:a2dc9648985454d3aedd9a477ff0c52b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c22829197fc65ced4dd2e0f53cb20ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3c22829197fc65ced4dd2e0f53cb20ff">from_istream</a> (istream &amp;in, bool showp=false, bool warn_on_duplicates=true)</td></tr>
<tr class="separator:a3c22829197fc65ced4dd2e0f53cb20ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6479a304ef4b265a6339f9549e9ac0c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a6479a304ef4b265a6339f9549e9ac0c3">VG</a> (function&lt; bool(<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;)&gt; &amp;get_next_graph, bool showp=false, bool warn_on_duplicates=true)</td></tr>
<tr class="separator:a6479a304ef4b265a6339f9549e9ac0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d321b31b873153431c261090d052af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af4d321b31b873153431c261090d052af">VG</a> (const <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;from, bool showp=false, bool warn_on_duplicates=true)</td></tr>
<tr class="memdesc:af4d321b31b873153431c261090d052af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a single Protobuf graph. The same as making an empty <a class="el" href="classvg_1_1VG.html">VG</a> and using <a class="el" href="classvg_1_1VG.html#a2519c3b939f48bca226e6fdea4c91f9d">extend()</a>.  <a href="#af4d321b31b873153431c261090d052af">More...</a><br/></td></tr>
<tr class="separator:af4d321b31b873153431c261090d052af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeafee2d3bc6e0039e99fccdea10f4f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#abeafee2d3bc6e0039e99fccdea10f4f9">VG</a> (set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes, set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;edges)</td></tr>
<tr class="separator:abeafee2d3bc6e0039e99fccdea10f4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12f5208ae9a2f22a31658dfaad28229b"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, vcflib::Variant &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a12f5208ae9a2f22a31658dfaad28229b">get_node_id_to_variant</a> (vcflib::VariantCallFile vfile)</td></tr>
<tr class="separator:a12f5208ae9a2f22a31658dfaad28229b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c8fe573ad9ea52634a7e7421c143de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a40c8fe573ad9ea52634a7e7421c143de">dice_nodes</a> (int max_node_size)</td></tr>
<tr class="memdesc:a40c8fe573ad9ea52634a7e7421c143de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Chop up the nodes.  <a href="#a40c8fe573ad9ea52634a7e7421c143de">More...</a><br/></td></tr>
<tr class="separator:a40c8fe573ad9ea52634a7e7421c143de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a998cfb17a4433f05a1579f0d704208a6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a998cfb17a4433f05a1579f0d704208a6">unchop</a> (void)</td></tr>
<tr class="memdesc:a998cfb17a4433f05a1579f0d704208a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the reverse &mdash; combines nodes by removing edges where doing so has no effect on the graph labels.  <a href="#a998cfb17a4433f05a1579f0d704208a6">More...</a><br/></td></tr>
<tr class="separator:a998cfb17a4433f05a1579f0d704208a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0dcdbceae7ad22b60e4966e9644b612"><td class="memItemLeft" align="right" valign="top">set&lt; list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad0dcdbceae7ad22b60e4966e9644b612">simple_components</a> (int min_size=1)</td></tr>
<tr class="separator:ad0dcdbceae7ad22b60e4966e9644b612"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adff96e1df8d63362f110efa996d817e1"><td class="memItemLeft" align="right" valign="top">set&lt; list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#adff96e1df8d63362f110efa996d817e1">simple_multinode_components</a> (void)</td></tr>
<tr class="memdesc:adff96e1df8d63362f110efa996d817e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the simple components of multiple nodes.  <a href="#adff96e1df8d63362f110efa996d817e1">More...</a><br/></td></tr>
<tr class="separator:adff96e1df8d63362f110efa996d817e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab447b1c70f7c4dc6576bfabc1990c337"><td class="memItemLeft" align="right" valign="top">set&lt; set&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab447b1c70f7c4dc6576bfabc1990c337">strongly_connected_components</a> (void)</td></tr>
<tr class="memdesc:ab447b1c70f7c4dc6576bfabc1990c337"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the strongly connected components of the graph.  <a href="#ab447b1c70f7c4dc6576bfabc1990c337">More...</a><br/></td></tr>
<tr class="separator:ab447b1c70f7c4dc6576bfabc1990c337"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21c034f10ebf2555f8a69564368be8f7"><td class="memItemLeft" align="right" valign="top">set&lt; set&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a21c034f10ebf2555f8a69564368be8f7">multinode_strongly_connected_components</a> (void)</td></tr>
<tr class="memdesc:a21c034f10ebf2555f8a69564368be8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get only multi-node strongly connected components.  <a href="#a21c034f10ebf2555f8a69564368be8f7">More...</a><br/></td></tr>
<tr class="separator:a21c034f10ebf2555f8a69564368be8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71388f637b255bf16a940e735a12aacd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a71388f637b255bf16a940e735a12aacd">is_acyclic</a> (void)</td></tr>
<tr class="memdesc:a71388f637b255bf16a940e735a12aacd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the graph does not contain cycles.  <a href="#a71388f637b255bf16a940e735a12aacd">More...</a><br/></td></tr>
<tr class="separator:a71388f637b255bf16a940e735a12aacd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049393f32addf4071a14de2e874e94ac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a049393f32addf4071a14de2e874e94ac">keep_multinode_strongly_connected_components</a> (void)</td></tr>
<tr class="memdesc:a049393f32addf4071a14de2e874e94ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all elements which are not in a strongly connected component.  <a href="#a049393f32addf4071a14de2e874e94ac">More...</a><br/></td></tr>
<tr class="separator:a049393f32addf4071a14de2e874e94ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad09549b6cfab8e1097dd207e01e57812"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad09549b6cfab8e1097dd207e01e57812">is_self_looping</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:ad09549b6cfab8e1097dd207e01e57812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the specified node have any self-loops?  <a href="#ad09549b6cfab8e1097dd207e01e57812">More...</a><br/></td></tr>
<tr class="separator:ad09549b6cfab8e1097dd207e01e57812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a310f10ff59e15468e8350844465f15e7"><td class="memItemLeft" align="right" valign="top">set&lt; list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a310f10ff59e15468e8350844465f15e7">elementary_cycles</a> (void)</td></tr>
<tr class="memdesc:a310f10ff59e15468e8350844465f15e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get simple cycles following Johnson's elementary cycles algorithm.  <a href="#a310f10ff59e15468e8350844465f15e7">More...</a><br/></td></tr>
<tr class="separator:a310f10ff59e15468e8350844465f15e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d37ff935d8881dcf03010187e1ceb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a64d37ff935d8881dcf03010187e1ceb3">concat_nodes</a> (const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="separator:a64d37ff935d8881dcf03010187e1ceb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f9aa921b25ba77f37366768b4b090ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1f9aa921b25ba77f37366768b4b090ec">merge_nodes</a> (const list&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes)</td></tr>
<tr class="separator:a1f9aa921b25ba77f37366768b4b090ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a217f8b5abd62bcdb256cf15926c9fe5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a217f8b5abd62bcdb256cf15926c9fe5c">normalize</a> (int max_iter=1, bool debug=false)</td></tr>
<tr class="memdesc:a217f8b5abd62bcdb256cf15926c9fe5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use unchop and sibling merging to simplify the graph into a normalized form.  <a href="#a217f8b5abd62bcdb256cf15926c9fe5c">More...</a><br/></td></tr>
<tr class="separator:a217f8b5abd62bcdb256cf15926c9fe5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7604b2833cf3e0855c5c29619f4a270"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad7604b2833cf3e0855c5c29619f4a270">bluntify</a> (void)</td></tr>
<tr class="memdesc:ad7604b2833cf3e0855c5c29619f4a270"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove redundant overlaps.  <a href="#ad7604b2833cf3e0855c5c29619f4a270">More...</a><br/></td></tr>
<tr class="separator:ad7604b2833cf3e0855c5c29619f4a270"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7958e987d875acb903acabf9903a8a88"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7958e987d875acb903acabf9903a8a88">dagify</a> (uint32_t expand_scc_steps, unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;node_translation, size_t target_min_walk_length=0, size_t component_length_max=0)</td></tr>
<tr class="separator:a7958e987d875acb903acabf9903a8a88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f838bd143f7909838bf2139b15576ac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a6f838bd143f7909838bf2139b15576ac">backtracking_unroll</a> (uint32_t max_length, uint32_t max_depth, unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;node_translation)</td></tr>
<tr class="memdesc:a6f838bd143f7909838bf2139b15576ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a new graph that unrolls the current one using backtracking. Caution: exponential in branching.  <a href="#a6f838bd143f7909838bf2139b15576ac">More...</a><br/></td></tr>
<tr class="separator:a6f838bd143f7909838bf2139b15576ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc568712b6d4aa3b6dc965f37cc769a7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#afc568712b6d4aa3b6dc965f37cc769a7">unfold</a> (uint32_t max_length, unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;node_translation)</td></tr>
<tr class="separator:afc568712b6d4aa3b6dc965f37cc769a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00287a092635fc711de1f0a82f66ae77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a00287a092635fc711de1f0a82f66ae77">reverse_complement_graph</a> (unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;node_translation)</td></tr>
<tr class="memdesc:a00287a092635fc711de1f0a82f66ae77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the reverse complemented graph with topology preserved. Record translation in provided map.  <a href="#a00287a092635fc711de1f0a82f66ae77">More...</a><br/></td></tr>
<tr class="separator:a00287a092635fc711de1f0a82f66ae77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbd7b9f01799a351e0e5ba420fa06679"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#abbd7b9f01799a351e0e5ba420fa06679">identity_translation</a> (unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;node_translation)</td></tr>
<tr class="memdesc:abbd7b9f01799a351e0e5ba420fa06679"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record the translation of this graph into itself in the provided map.  <a href="#abbd7b9f01799a351e0e5ba420fa06679">More...</a><br/></td></tr>
<tr class="separator:abbd7b9f01799a351e0e5ba420fa06679"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc72119c835adc52a935efca0bdda0b"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair<br class="typebreak"/>
&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7fc72119c835adc52a935efca0bdda0b">overlay_node_translations</a> (const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;over, const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;under)</td></tr>
<tr class="memdesc:a7fc72119c835adc52a935efca0bdda0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume two node translations, the over is based on the under; merge them.  <a href="#a7fc72119c835adc52a935efca0bdda0b">More...</a><br/></td></tr>
<tr class="separator:a7fc72119c835adc52a935efca0bdda0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cb2d6686e0bb92d7f0b632fc813702"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a93cb2d6686e0bb92d7f0b632fc813702">break_cycles</a> (void)</td></tr>
<tr class="separator:a93cb2d6686e0bb92d7f0b632fc813702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad517da731d2bf9c81cc28e0a1367af33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad517da731d2bf9c81cc28e0a1367af33">remove_non_path</a> (void)</td></tr>
<tr class="memdesc:ad517da731d2bf9c81cc28e0a1367af33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove pieces of the graph which are not part of any path.  <a href="#ad517da731d2bf9c81cc28e0a1367af33">More...</a><br/></td></tr>
<tr class="separator:ad517da731d2bf9c81cc28e0a1367af33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c369b4c1b0dfa4e9fbc0d3bce82648"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a30c369b4c1b0dfa4e9fbc0d3bce82648">remove_path</a> (void)</td></tr>
<tr class="memdesc:a30c369b4c1b0dfa4e9fbc0d3bce82648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove pieces of the graph which are part of some path.  <a href="#a30c369b4c1b0dfa4e9fbc0d3bce82648">More...</a><br/></td></tr>
<tr class="separator:a30c369b4c1b0dfa4e9fbc0d3bce82648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f160750dfed33c16a257bd5cbecddf"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a26f160750dfed33c16a257bd5cbecddf">get_path_edges</a> (void)</td></tr>
<tr class="memdesc:a26f160750dfed33c16a257bd5cbecddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all of the edges that are on any path.  <a href="#a26f160750dfed33c16a257bd5cbecddf">More...</a><br/></td></tr>
<tr class="separator:a26f160750dfed33c16a257bd5cbecddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5079416ab826cbc8a5eea3869eb892"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8e5079416ab826cbc8a5eea3869eb892">flip_doubly_reversed_edges</a> (void)</td></tr>
<tr class="memdesc:a8e5079416ab826cbc8a5eea3869eb892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert edges that are both from_start and to_end to "regular" ones from end to start.  <a href="#a8e5079416ab826cbc8a5eea3869eb892">More...</a><br/></td></tr>
<tr class="separator:a8e5079416ab826cbc8a5eea3869eb892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aef48163c0dd4267d24b629de8a04c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8aef48163c0dd4267d24b629de8a04c8">from_turtle</a> (string filename, string baseuri, bool showp=false)</td></tr>
<tr class="memdesc:a8aef48163c0dd4267d24b629de8a04c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a graph from a Turtle stream.  <a href="#a8aef48163c0dd4267d24b629de8a04c8">More...</a><br/></td></tr>
<tr class="separator:a8aef48163c0dd4267d24b629de8a04c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7513ddb88aeb58bd85a810c2a2ccdf67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7513ddb88aeb58bd85a810c2a2ccdf67">~VG</a> (void)</td></tr>
<tr class="memdesc:a7513ddb88aeb58bd85a810c2a2ccdf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="#a7513ddb88aeb58bd85a810c2a2ccdf67">More...</a><br/></td></tr>
<tr class="separator:a7513ddb88aeb58bd85a810c2a2ccdf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3148455330df9ac055c6bd1eb7da3167"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3148455330df9ac055c6bd1eb7da3167">VG</a> (const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;other)</td></tr>
<tr class="memdesc:a3148455330df9ac055c6bd1eb7da3167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="#a3148455330df9ac055c6bd1eb7da3167">More...</a><br/></td></tr>
<tr class="separator:a3148455330df9ac055c6bd1eb7da3167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8365ccd6a093ec50f7d54b1c7a7c672"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab8365ccd6a093ec50f7d54b1c7a7c672">VG</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ab8365ccd6a093ec50f7d54b1c7a7c672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="#ab8365ccd6a093ec50f7d54b1c7a7c672">More...</a><br/></td></tr>
<tr class="separator:ab8365ccd6a093ec50f7d54b1c7a7c672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af307e84054373091afc6760a418087ed"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af307e84054373091afc6760a418087ed">operator=</a> (const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;other)</td></tr>
<tr class="memdesc:af307e84054373091afc6760a418087ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#af307e84054373091afc6760a418087ed">More...</a><br/></td></tr>
<tr class="separator:af307e84054373091afc6760a418087ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870b32af2443419ae7013b192d0caad6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a870b32af2443419ae7013b192d0caad6">operator=</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a870b32af2443419ae7013b192d0caad6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#a870b32af2443419ae7013b192d0caad6">More...</a><br/></td></tr>
<tr class="separator:a870b32af2443419ae7013b192d0caad6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f71911fe2c652dc11aec0a0d705b1e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7f71911fe2c652dc11aec0a0d705b1e4">build_indexes</a> (void)</td></tr>
<tr class="separator:a7f71911fe2c652dc11aec0a0d705b1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5156da43d4175597d7a8b1d88b5179af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5156da43d4175597d7a8b1d88b5179af">build_node_indexes</a> (void)</td></tr>
<tr class="separator:a5156da43d4175597d7a8b1d88b5179af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb2cb59474393ac822847033f185d17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3fb2cb59474393ac822847033f185d17">build_edge_indexes</a> (void)</td></tr>
<tr class="separator:a3fb2cb59474393ac822847033f185d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78095fb5d27e182c5cc4d5c10d3da39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa78095fb5d27e182c5cc4d5c10d3da39">build_indexes_no_init_size</a> (void)</td></tr>
<tr class="separator:aa78095fb5d27e182c5cc4d5c10d3da39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca442744267b08609887cd842ca543d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0ca442744267b08609887cd842ca543d">build_node_indexes_no_init_size</a> (void)</td></tr>
<tr class="separator:a0ca442744267b08609887cd842ca543d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63d4a22a3baa5b21623128b81a14872"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af63d4a22a3baa5b21623128b81a14872">build_edge_indexes_no_init_size</a> (void)</td></tr>
<tr class="separator:af63d4a22a3baa5b21623128b81a14872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70998a8e262e0afa074a2a287807705f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a70998a8e262e0afa074a2a287807705f">index_paths</a> (void)</td></tr>
<tr class="separator:a70998a8e262e0afa074a2a287807705f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212a2d1028f28046088a86e128b40559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a212a2d1028f28046088a86e128b40559">clear_node_indexes</a> (void)</td></tr>
<tr class="separator:a212a2d1028f28046088a86e128b40559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51220e88887adf92d7cff25dad5cd91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af51220e88887adf92d7cff25dad5cd91">clear_node_indexes_no_resize</a> (void)</td></tr>
<tr class="separator:af51220e88887adf92d7cff25dad5cd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d4b49633db2aef463e0070e0af64a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a10d4b49633db2aef463e0070e0af64a0">clear_edge_indexes</a> (void)</td></tr>
<tr class="separator:a10d4b49633db2aef463e0070e0af64a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5195712f8aa650417d93324ff1c89ecf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5195712f8aa650417d93324ff1c89ecf">clear_edge_indexes_no_resize</a> (void)</td></tr>
<tr class="separator:a5195712f8aa650417d93324ff1c89ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae960ce1d640fadc4772795f6d0ff5b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aae960ce1d640fadc4772795f6d0ff5b5">clear_indexes</a> (void)</td></tr>
<tr class="separator:aae960ce1d640fadc4772795f6d0ff5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103c69bad02121590779530338861374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a103c69bad02121590779530338861374">clear_indexes_no_resize</a> (void)</td></tr>
<tr class="separator:a103c69bad02121590779530338861374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8879b1e6aab38b9a246deba0f05ccfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af8879b1e6aab38b9a246deba0f05ccfe">resize_indexes</a> (void)</td></tr>
<tr class="separator:af8879b1e6aab38b9a246deba0f05ccfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d4e45a9a410c451b1cad44ef7068ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a63d4e45a9a410c451b1cad44ef7068ad">rebuild_indexes</a> (void)</td></tr>
<tr class="separator:a63d4e45a9a410c451b1cad44ef7068ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6541146b6410cec4be3e2a7379ea3bcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a6541146b6410cec4be3e2a7379ea3bcf">rebuild_edge_indexes</a> (void)</td></tr>
<tr class="separator:a6541146b6410cec4be3e2a7379ea3bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abc84684faea29b49032ec254d5e13b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0abc84684faea29b49032ec254d5e13b">merge</a> (<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a0abc84684faea29b49032ec254d5e13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Literally merge protobufs.  <a href="#a0abc84684faea29b49032ec254d5e13b">More...</a><br/></td></tr>
<tr class="separator:a0abc84684faea29b49032ec254d5e13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f22f6bb4a3e7a2aea7b3887237faec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a40f22f6bb4a3e7a2aea7b3887237faec">merge</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g)</td></tr>
<tr class="memdesc:a40f22f6bb4a3e7a2aea7b3887237faec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Literally merge protobufs.  <a href="#a40f22f6bb4a3e7a2aea7b3887237faec">More...</a><br/></td></tr>
<tr class="separator:a40f22f6bb4a3e7a2aea7b3887237faec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e534461834b2937b7f0b0c2420b899"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa4e534461834b2937b7f0b0c2420b899">clear_paths</a> (void)</td></tr>
<tr class="memdesc:aa4e534461834b2937b7f0b0c2420b899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the paths object (which indexes the graph.paths) and the graph paths themselves.  <a href="#aa4e534461834b2937b7f0b0c2420b899">More...</a><br/></td></tr>
<tr class="separator:aa4e534461834b2937b7f0b0c2420b899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124188a9e0cd68c87c2bc009ea7bd799"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a124188a9e0cd68c87c2bc009ea7bd799">sync_paths</a> (void)</td></tr>
<tr class="memdesc:a124188a9e0cd68c87c2bc009ea7bd799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize in-memory indexes and protobuf graph.  <a href="#a124188a9e0cd68c87c2bc009ea7bd799">More...</a><br/></td></tr>
<tr class="separator:a124188a9e0cd68c87c2bc009ea7bd799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aff716eee0bf720b3836caa761d48be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5aff716eee0bf720b3836caa761d48be">merge_union</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g)</td></tr>
<tr class="separator:a5aff716eee0bf720b3836caa761d48be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33424c3be8c3e088631dfb37c48773d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a33424c3be8c3e088631dfb37c48773d3">remove_duplicated_in</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g)</td></tr>
<tr class="memdesc:a33424c3be8c3e088631dfb37c48773d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to merge_union.  <a href="#a33424c3be8c3e088631dfb37c48773d3">More...</a><br/></td></tr>
<tr class="separator:a33424c3be8c3e088631dfb37c48773d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9fb73c326ecfab70e35e44dff6a937"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aba9fb73c326ecfab70e35e44dff6a937">remove_duplicates</a> (void)</td></tr>
<tr class="memdesc:aba9fb73c326ecfab70e35e44dff6a937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicated nodes and edges.  <a href="#aba9fb73c326ecfab70e35e44dff6a937">More...</a><br/></td></tr>
<tr class="separator:aba9fb73c326ecfab70e35e44dff6a937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ea2fe244a857ff24d0176449bedd4ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a4ea2fe244a857ff24d0176449bedd4ad">prune_complex_paths</a> (int <a class="el" href="classvg_1_1VG.html#a23641dedefa2b6d573939515fcf5974c">length</a>, int edge_max, <a class="el" href="structvg_1_1Node.html">Node</a> *head_node, <a class="el" href="structvg_1_1Node.html">Node</a> *tail_node)</td></tr>
<tr class="separator:a4ea2fe244a857ff24d0176449bedd4ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a590703c2954a2a15d735995c2007a879"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a590703c2954a2a15d735995c2007a879">prune_short_subgraphs</a> (size_t min_size)</td></tr>
<tr class="separator:a590703c2954a2a15d735995c2007a879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722dcb12f09e01f43d3257bda35201b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a722dcb12f09e01f43d3257bda35201b1">serialize_to_emitter</a> (<a class="el" href="classvg_1_1stream_1_1ProtobufEmitter.html">stream::ProtobufEmitter</a>&lt; <a class="el" href="structvg_1_1Graph.html">Graph</a> &gt; &amp;emitter, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> chunk_size=1000)</td></tr>
<tr class="separator:a722dcb12f09e01f43d3257bda35201b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab217740a8290f9706c260172f19ef221"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab217740a8290f9706c260172f19ef221">serialize_to_ostream</a> (ostream &amp;out, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> chunk_size=1000)</td></tr>
<tr class="separator:ab217740a8290f9706c260172f19ef221"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8841bfa5a6c888820e6a29c8010e72fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8841bfa5a6c888820e6a29c8010e72fc">serialize_to_file</a> (const string &amp;file_name, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> chunk_size=1000)</td></tr>
<tr class="separator:a8841bfa5a6c888820e6a29c8010e72fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161ef56bd0eeee937602f60b8617f24d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a161ef56bd0eeee937602f60b8617f24d">compact_ids</a> (void)</td></tr>
<tr class="memdesc:a161ef56bd0eeee937602f60b8617f24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squish the node IDs down into as small a space as possible. Fixes up paths itself.  <a href="#a161ef56bd0eeee937602f60b8617f24d">More...</a><br/></td></tr>
<tr class="separator:a161ef56bd0eeee937602f60b8617f24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a522cc6a9721f305ab01ce823d843662d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a522cc6a9721f305ab01ce823d843662d">increment_node_ids</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> increment)</td></tr>
<tr class="memdesc:a522cc6a9721f305ab01ce823d843662d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given value to all node IDs. Preserves the paths.  <a href="#a522cc6a9721f305ab01ce823d843662d">More...</a><br/></td></tr>
<tr class="separator:a522cc6a9721f305ab01ce823d843662d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356612f42ba60fe5895f3abe7501173a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a356612f42ba60fe5895f3abe7501173a">decrement_node_ids</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> decrement)</td></tr>
<tr class="memdesc:a356612f42ba60fe5895f3abe7501173a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract the given value from all the node IDs. Must not create a node with 0 or negative IDs. Invalidates the paths.  <a href="#a356612f42ba60fe5895f3abe7501173a">More...</a><br/></td></tr>
<tr class="separator:a356612f42ba60fe5895f3abe7501173a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8c9051591df60d405a8dc1006aa6d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0f8c9051591df60d405a8dc1006aa6d5">swap_node_id</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> node_id, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> new_id)</td></tr>
<tr class="separator:a0f8c9051591df60d405a8dc1006aa6d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa906c5779ea372eb4dd0d9b8cc224be3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa906c5779ea372eb4dd0d9b8cc224be3">swap_node_id</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> new_id)</td></tr>
<tr class="separator:aa906c5779ea372eb4dd0d9b8cc224be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2519c3b939f48bca226e6fdea4c91f9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2519c3b939f48bca226e6fdea4c91f9d">extend</a> (const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;g, bool warn_on_duplicates=false)</td></tr>
<tr class="separator:a2519c3b939f48bca226e6fdea4c91f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e517214b33812b16f195a1f87841c0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5e517214b33812b16f195a1f87841c0d">extend</a> (const <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;<a class="el" href="classvg_1_1VG.html#a4772c77ed932bfed4d21e247918381a4">graph</a>, bool warn_on_duplicates=false)</td></tr>
<tr class="separator:a5e517214b33812b16f195a1f87841c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5272032c1e57d839176fc8e39bd87e18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5272032c1e57d839176fc8e39bd87e18">append</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g)</td></tr>
<tr class="separator:a5272032c1e57d839176fc8e39bd87e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d06218f137184c366de80df755ae001"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7d06218f137184c366de80df755ae001">combine</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g)</td></tr>
<tr class="separator:a7d06218f137184c366de80df755ae001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e4dac76edcf0218f9749352c19acae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a66e4dac76edcf0218f9749352c19acae">include</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="memdesc:a66e4dac76edcf0218f9749352c19acae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit the graph to include the path.  <a href="#a66e4dac76edcf0218f9749352c19acae">More...</a><br/></td></tr>
<tr class="separator:a66e4dac76edcf0218f9749352c19acae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4355473c385843b7652d49601dd630d2"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a4355473c385843b7652d49601dd630d2">edit</a> (vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;paths_to_add, bool save_paths=false, bool update_paths=false, bool break_at_ends=false)</td></tr>
<tr class="separator:a4355473c385843b7652d49601dd630d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f70eb7eddb0245be7cdfc048616638"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a78f70eb7eddb0245be7cdfc048616638">edit_fast</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;dangling, size_t max_node_size=1024)</td></tr>
<tr class="separator:a78f70eb7eddb0245be7cdfc048616638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e451c4a4a95e15244acc4972296124"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a67e451c4a4a95e15244acc4972296124">find_breakpoints</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&gt; &amp;breakpoints, bool break_ends=true)</td></tr>
<tr class="separator:a67e451c4a4a95e15244acc4972296124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd6b4acbb2607a2decc9aa0f8891057"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5cd6b4acbb2607a2decc9aa0f8891057">ensure_breakpoints</a> (const map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&gt; &amp;breakpoints)</td></tr>
<tr class="separator:a5cd6b4acbb2607a2decc9aa0f8891057"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9912608c8779ce01c6c6e06f86588311"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a9912608c8779ce01c6c6e06f86588311">forwardize_breakpoints</a> (const map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&gt; &amp;breakpoints)</td></tr>
<tr class="memdesc:a9912608c8779ce01c6c6e06f86588311"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the breakpoints onto the forward strand.  <a href="#a9912608c8779ce01c6c6e06f86588311">More...</a><br/></td></tr>
<tr class="separator:a9912608c8779ce01c6c6e06f86588311"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a841b4f3a9dc5641c7646e2b6ab03aaac"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a841b4f3a9dc5641c7646e2b6ab03aaac">add_nodes_and_edges</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, const map&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;node_translation, map&lt; pair&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, string &gt;, vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt;&gt; &amp;added_seqs, map&lt; <a class="el" href="structvg_1_1Node.html">Node</a> *, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;added_nodes, const map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, size_t &gt; &amp;orig_node_sizes, set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;dangling, size_t max_node_size=1024)</td></tr>
<tr class="separator:a841b4f3a9dc5641c7646e2b6ab03aaac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bb4c469f870e8181ac72550a1e1a82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a05bb4c469f870e8181ac72550a1e1a82">add_nodes_and_edges</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, const map&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;node_translation, map&lt; pair&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, string &gt;, vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt;&gt; &amp;added_seqs, map&lt; <a class="el" href="structvg_1_1Node.html">Node</a> *, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;added_nodes, const map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, size_t &gt; &amp;orig_node_sizes, size_t max_node_size=1024)</td></tr>
<tr class="memdesc:a05bb4c469f870e8181ac72550a1e1a82"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version doesn't require a set of dangling sides to populate.  <a href="#a05bb4c469f870e8181ac72550a1e1a82">More...</a><br/></td></tr>
<tr class="separator:a05bb4c469f870e8181ac72550a1e1a82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12bbb607ad1e55d73f61bbe002ee2511"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a12bbb607ad1e55d73f61bbe002ee2511">make_translation</a> (const map&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;node_translation, const map&lt; <a class="el" href="structvg_1_1Node.html">Node</a> *, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;added_nodes, const map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, size_t &gt; &amp;orig_node_sizes)</td></tr>
<tr class="memdesc:a12bbb607ad1e55d73f61bbe002ee2511"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a graph <a class="el" href="structvg_1_1Translation.html">Translation</a> object from information about the editing process.  <a href="#a12bbb607ad1e55d73f61bbe002ee2511">More...</a><br/></td></tr>
<tr class="separator:a12bbb607ad1e55d73f61bbe002ee2511"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e265ee441758d81fdb7c038e2fa8cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad3e265ee441758d81fdb7c038e2fa8cc">add_node</a> (const <a class="el" href="structvg_1_1Node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:ad3e265ee441758d81fdb7c038e2fa8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given node, by value.  <a href="#ad3e265ee441758d81fdb7c038e2fa8cc">More...</a><br/></td></tr>
<tr class="separator:ad3e265ee441758d81fdb7c038e2fa8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71d30b767f067a874c933f13f6c34e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae71d30b767f067a874c933f13f6c34e5">add_nodes</a> (const vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:ae71d30b767f067a874c933f13f6c34e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given nodes, by value.  <a href="#ae71d30b767f067a874c933f13f6c34e5">More...</a><br/></td></tr>
<tr class="separator:ae71d30b767f067a874c933f13f6c34e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613c931c81518212917053d07e9bf8a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a613c931c81518212917053d07e9bf8a8">add_edge</a> (const <a class="el" href="structvg_1_1Edge.html">Edge</a> &amp;edge)</td></tr>
<tr class="memdesc:a613c931c81518212917053d07e9bf8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given edge, by value.  <a href="#a613c931c81518212917053d07e9bf8a8">More...</a><br/></td></tr>
<tr class="separator:a613c931c81518212917053d07e9bf8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f23cdd532ca7b8d3c0bb9cceff3d378"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7f23cdd532ca7b8d3c0bb9cceff3d378">add_edges</a> (const vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; &amp;edges)</td></tr>
<tr class="memdesc:a7f23cdd532ca7b8d3c0bb9cceff3d378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given edges, by value.  <a href="#a7f23cdd532ca7b8d3c0bb9cceff3d378">More...</a><br/></td></tr>
<tr class="separator:a7f23cdd532ca7b8d3c0bb9cceff3d378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679e39a7c1771c3ecc7204bd3b999583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a679e39a7c1771c3ecc7204bd3b999583">add_edges</a> (const vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;edges)</td></tr>
<tr class="memdesc:a679e39a7c1771c3ecc7204bd3b999583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given edges, by value.  <a href="#a679e39a7c1771c3ecc7204bd3b999583">More...</a><br/></td></tr>
<tr class="separator:a679e39a7c1771c3ecc7204bd3b999583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab796330d50fdff47f5c080e251efea68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab796330d50fdff47f5c080e251efea68">add_nodes</a> (const set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes)</td></tr>
<tr class="memdesc:ab796330d50fdff47f5c080e251efea68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given nodes, by value.  <a href="#ab796330d50fdff47f5c080e251efea68">More...</a><br/></td></tr>
<tr class="separator:ab796330d50fdff47f5c080e251efea68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8712eefbfd373c45f54d6bac8188c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#acb8712eefbfd373c45f54d6bac8188c6">add_edges</a> (const set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;edges)</td></tr>
<tr class="memdesc:acb8712eefbfd373c45f54d6bac8188c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given edges, by value.  <a href="#acb8712eefbfd373c45f54d6bac8188c6">More...</a><br/></td></tr>
<tr class="separator:acb8712eefbfd373c45f54d6bac8188c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a94aeff38cf579243532fde605260a2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8a94aeff38cf579243532fde605260a2">node_count</a> (void) const </td></tr>
<tr class="memdesc:a8a94aeff38cf579243532fde605260a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of nodes in the graph.  <a href="#a8a94aeff38cf579243532fde605260a2">More...</a><br/></td></tr>
<tr class="separator:a8a94aeff38cf579243532fde605260a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe56e78d2178e689e623a35fcbdff2f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7fe56e78d2178e689e623a35fcbdff2f">edge_count</a> (void) const </td></tr>
<tr class="memdesc:a7fe56e78d2178e689e623a35fcbdff2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of edges in the graph.  <a href="#a7fe56e78d2178e689e623a35fcbdff2f">More...</a><br/></td></tr>
<tr class="separator:a7fe56e78d2178e689e623a35fcbdff2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab928179a1a4c5a535aefab8cda99c591"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab928179a1a4c5a535aefab8cda99c591">total_length_of_nodes</a> (void)</td></tr>
<tr class="separator:ab928179a1a4c5a535aefab8cda99c591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0202180fa7153f464c3b1d3ff70dc9cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0202180fa7153f464c3b1d3ff70dc9cb">node_rank</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a0202180fa7153f464c3b1d3ff70dc9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rank of the node in the protobuf array that backs the graph.  <a href="#a0202180fa7153f464c3b1d3ff70dc9cb">More...</a><br/></td></tr>
<tr class="separator:a0202180fa7153f464c3b1d3ff70dc9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa564542c73b2b800a4fa42e591c1879f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa564542c73b2b800a4fa42e591c1879f">node_rank</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:aa564542c73b2b800a4fa42e591c1879f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rank of the node in the protobuf array that backs the graph.  <a href="#aa564542c73b2b800a4fa42e591c1879f">More...</a><br/></td></tr>
<tr class="separator:aa564542c73b2b800a4fa42e591c1879f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff00edd627e3445eee7f43927bb1518"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1ff00edd627e3445eee7f43927bb1518">start_degree</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a1ff00edd627e3445eee7f43927bb1518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges attached to the start of a node.  <a href="#a1ff00edd627e3445eee7f43927bb1518">More...</a><br/></td></tr>
<tr class="separator:a1ff00edd627e3445eee7f43927bb1518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cf82dca43799a03d93b199133f1d4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af3cf82dca43799a03d93b199133f1d4b">end_degree</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:af3cf82dca43799a03d93b199133f1d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges attached to the end of a node.  <a href="#af3cf82dca43799a03d93b199133f1d4b">More...</a><br/></td></tr>
<tr class="separator:af3cf82dca43799a03d93b199133f1d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ac6e61dfa9350459dbb9586088c4a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af9ac6e61dfa9350459dbb9586088c4a5">left_degree</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node)</td></tr>
<tr class="memdesc:af9ac6e61dfa9350459dbb9586088c4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges attached to the left side of a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>.  <a href="#af9ac6e61dfa9350459dbb9586088c4a5">More...</a><br/></td></tr>
<tr class="separator:af9ac6e61dfa9350459dbb9586088c4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23622195177dff4c7c8416edffb7fc93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a23622195177dff4c7c8416edffb7fc93">right_degree</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node)</td></tr>
<tr class="memdesc:a23622195177dff4c7c8416edffb7fc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges attached to the right side of a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>.  <a href="#a23622195177dff4c7c8416edffb7fc93">More...</a><br/></td></tr>
<tr class="separator:a23622195177dff4c7c8416edffb7fc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6a5e92afb1a70d9c63a1848a01f241"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5b6a5e92afb1a70d9c63a1848a01f241">edges_of_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;edges)</td></tr>
<tr class="separator:a5b6a5e92afb1a70d9c63a1848a01f241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bf5492e5c6d586cd266d2a48f792df"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa1bf5492e5c6d586cd266d2a48f792df">edges_of</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:aa1bf5492e5c6d586cd266d2a48f792df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edges of the specified node.  <a href="#aa1bf5492e5c6d586cd266d2a48f792df">More...</a><br/></td></tr>
<tr class="separator:aa1bf5492e5c6d586cd266d2a48f792df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a7e0aa663eadc0ebdaaf13b667323e"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae1a7e0aa663eadc0ebdaaf13b667323e">edges_from</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:ae1a7e0aa663eadc0ebdaaf13b667323e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edges from the specified node.  <a href="#ae1a7e0aa663eadc0ebdaaf13b667323e">More...</a><br/></td></tr>
<tr class="separator:ae1a7e0aa663eadc0ebdaaf13b667323e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3789cf6561f2d3da5ef85f23b5c6454f"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3789cf6561f2d3da5ef85f23b5c6454f">edges_to</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a3789cf6561f2d3da5ef85f23b5c6454f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edges to the specified node.  <a href="#a3789cf6561f2d3da5ef85f23b5c6454f">More...</a><br/></td></tr>
<tr class="separator:a3789cf6561f2d3da5ef85f23b5c6454f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2d900fc42cffe079c3ba3897717eae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3b2d900fc42cffe079c3ba3897717eae">edges_of_nodes</a> (set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes, set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;edges)</td></tr>
<tr class="memdesc:a3b2d900fc42cffe079c3ba3897717eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edges of the specified set of nodes, and add them to the given set of edge pointers.  <a href="#a3b2d900fc42cffe079c3ba3897717eae">More...</a><br/></td></tr>
<tr class="separator:a3b2d900fc42cffe079c3ba3897717eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a156ac1e1fde520bae82850105c6c66"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1a156ac1e1fde520bae82850105c6c66">sides_to</a> (<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> side)</td></tr>
<tr class="memdesc:a1a156ac1e1fde520bae82850105c6c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sides on the other side of edges to this side of the node.  <a href="#a1a156ac1e1fde520bae82850105c6c66">More...</a><br/></td></tr>
<tr class="separator:a1a156ac1e1fde520bae82850105c6c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac670f3c729f93ebaa7c8bd5063225597"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac670f3c729f93ebaa7c8bd5063225597">sides_from</a> (<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> side)</td></tr>
<tr class="memdesc:ac670f3c729f93ebaa7c8bd5063225597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sides on the other side of edges from this side of the node.  <a href="#ac670f3c729f93ebaa7c8bd5063225597">More...</a><br/></td></tr>
<tr class="separator:ac670f3c729f93ebaa7c8bd5063225597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63aa329381f85cffbb793d19a8b17b52"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a63aa329381f85cffbb793d19a8b17b52">sides_from</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a63aa329381f85cffbb793d19a8b17b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sides from both sides of the node.  <a href="#a63aa329381f85cffbb793d19a8b17b52">More...</a><br/></td></tr>
<tr class="separator:a63aa329381f85cffbb793d19a8b17b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2b9b646282c9a466a531916213e867"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aee2b9b646282c9a466a531916213e867">sides_to</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:aee2b9b646282c9a466a531916213e867"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sides to both sides of the node.  <a href="#aee2b9b646282c9a466a531916213e867">More...</a><br/></td></tr>
<tr class="separator:aee2b9b646282c9a466a531916213e867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030b75d2ad50905cc01fe4b7223cbb83"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a030b75d2ad50905cc01fe4b7223cbb83">sides_of</a> (<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> side)</td></tr>
<tr class="memdesc:a030b75d2ad50905cc01fe4b7223cbb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of sides_to and sides_from.  <a href="#a030b75d2ad50905cc01fe4b7223cbb83">More...</a><br/></td></tr>
<tr class="separator:a030b75d2ad50905cc01fe4b7223cbb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21a20098d0a29a1f3f0e9f932fcce462"><td class="memItemLeft" align="right" valign="top">set&lt; pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a21a20098d0a29a1f3f0e9f932fcce462">sides_context</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> node_id)</td></tr>
<tr class="memdesc:a21a20098d0a29a1f3f0e9f932fcce462"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all sides connecting to this node.  <a href="#a21a20098d0a29a1f3f0e9f932fcce462">More...</a><br/></td></tr>
<tr class="separator:a21a20098d0a29a1f3f0e9f932fcce462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38b7b580164861c1ced0b660bd4fa4c4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a38b7b580164861c1ced0b660bd4fa4c4">same_context</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> id1, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> id2)</td></tr>
<tr class="memdesc:a38b7b580164861c1ced0b660bd4fa4c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use sides_from an sides_to to determine if both nodes have the same context.  <a href="#a38b7b580164861c1ced0b660bd4fa4c4">More...</a><br/></td></tr>
<tr class="separator:a38b7b580164861c1ced0b660bd4fa4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7237af28b6fd3159ce048ec66679935c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7237af28b6fd3159ce048ec66679935c">is_ancestor_prev</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> node_id, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> candidate_id)</td></tr>
<tr class="memdesc:a7237af28b6fd3159ce048ec66679935c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the node is a prev ancestor of this one.  <a href="#a7237af28b6fd3159ce048ec66679935c">More...</a><br/></td></tr>
<tr class="separator:a7237af28b6fd3159ce048ec66679935c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9353f02748091b04439a26fda57f9b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aec9353f02748091b04439a26fda57f9b">is_ancestor_prev</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> node_id, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> candidate_id, set&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;seen, size_t steps=64)</td></tr>
<tr class="memdesc:aec9353f02748091b04439a26fda57f9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the node is a prev ancestor of this one by trying to find it in a given number of steps.  <a href="#aec9353f02748091b04439a26fda57f9b">More...</a><br/></td></tr>
<tr class="separator:aec9353f02748091b04439a26fda57f9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e98e20589f3f63de75f4dc63526562"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a65e98e20589f3f63de75f4dc63526562">is_ancestor_next</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> node_id, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> candidate_id)</td></tr>
<tr class="memdesc:a65e98e20589f3f63de75f4dc63526562"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the node is a next ancestor of this one.  <a href="#a65e98e20589f3f63de75f4dc63526562">More...</a><br/></td></tr>
<tr class="separator:a65e98e20589f3f63de75f4dc63526562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a837620e82b388581d91300a53c099574"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a837620e82b388581d91300a53c099574">is_ancestor_next</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> node_id, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> candidate_id, set&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;seen, size_t steps=64)</td></tr>
<tr class="memdesc:a837620e82b388581d91300a53c099574"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the node is a next ancestor of this one by trying to find it in a given number of steps.  <a href="#a837620e82b388581d91300a53c099574">More...</a><br/></td></tr>
<tr class="separator:a837620e82b388581d91300a53c099574"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a156ee8c5d3650f08ab4d806980d6926a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a156ee8c5d3650f08ab4d806980d6926a">common_ancestor_prev</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> id1, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> id2, size_t steps=64)</td></tr>
<tr class="memdesc:a156ee8c5d3650f08ab4d806980d6926a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a common ancestor by walking back up to steps from the first node.  <a href="#a156ee8c5d3650f08ab4d806980d6926a">More...</a><br/></td></tr>
<tr class="separator:a156ee8c5d3650f08ab4d806980d6926a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d087adcf01ebfa68541bc6f487278e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a95d087adcf01ebfa68541bc6f487278e">common_ancestor_next</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> id1, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> id2, size_t steps=64)</td></tr>
<tr class="memdesc:a95d087adcf01ebfa68541bc6f487278e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a common ancestor by walking forward up to steps from the first node.  <a href="#a95d087adcf01ebfa68541bc6f487278e">More...</a><br/></td></tr>
<tr class="separator:a95d087adcf01ebfa68541bc6f487278e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abac7d4642b9bcc25bc5299af18f523bc"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#abac7d4642b9bcc25bc5299af18f523bc">siblings_to</a> (const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;traversal)</td></tr>
<tr class="memdesc:abac7d4642b9bcc25bc5299af18f523bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">To-siblings are nodes which also have edges to them from the same nodes as this one.  <a href="#abac7d4642b9bcc25bc5299af18f523bc">More...</a><br/></td></tr>
<tr class="separator:abac7d4642b9bcc25bc5299af18f523bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac684d17ffe4c85ce74a4677fdfaf7672"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac684d17ffe4c85ce74a4677fdfaf7672">siblings_from</a> (const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;traversal)</td></tr>
<tr class="memdesc:ac684d17ffe4c85ce74a4677fdfaf7672"><td class="mdescLeft">&#160;</td><td class="mdescRight">From-siblings are nodes which also have edges to them from the same nodes as this one.  <a href="#ac684d17ffe4c85ce74a4677fdfaf7672">More...</a><br/></td></tr>
<tr class="separator:ac684d17ffe4c85ce74a4677fdfaf7672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a79ae3ab132b28cf72b6c18644fcf2f"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0a79ae3ab132b28cf72b6c18644fcf2f">full_siblings_to</a> (const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;trav)</td></tr>
<tr class="memdesc:a0a79ae3ab132b28cf72b6c18644fcf2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full to-siblings are nodes traversals which share exactly the same upstream <code><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a></code>s.  <a href="#a0a79ae3ab132b28cf72b6c18644fcf2f">More...</a><br/></td></tr>
<tr class="separator:a0a79ae3ab132b28cf72b6c18644fcf2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2eb11662200dc88ef8397a1b2232056"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae2eb11662200dc88ef8397a1b2232056">full_siblings_from</a> (const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;trav)</td></tr>
<tr class="memdesc:ae2eb11662200dc88ef8397a1b2232056"><td class="mdescLeft">&#160;</td><td class="mdescRight">Full from-siblings are nodes traversals which share exactly the same downstream <code><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a></code>s.  <a href="#ae2eb11662200dc88ef8397a1b2232056">More...</a><br/></td></tr>
<tr class="separator:ae2eb11662200dc88ef8397a1b2232056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f202743732e5335bb1b15413914eaa6"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5f202743732e5335bb1b15413914eaa6">siblings_of</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a5f202743732e5335bb1b15413914eaa6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get general siblings of a node.  <a href="#a5f202743732e5335bb1b15413914eaa6">More...</a><br/></td></tr>
<tr class="separator:a5f202743732e5335bb1b15413914eaa6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e90bd47ffc24a55b1588be8f5328717"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3e90bd47ffc24a55b1588be8f5328717">simplify_siblings</a> (void)</td></tr>
<tr class="separator:a3e90bd47ffc24a55b1588be8f5328717"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c037db7f5ec45293ac6650d46040237"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5c037db7f5ec45293ac6650d46040237">simplify_to_siblings</a> (const set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&gt; &amp;to_sibs)</td></tr>
<tr class="memdesc:a5c037db7f5ec45293ac6650d46040237"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove easily-resolvable redundancy in the graph for all provided to-sibling sets.  <a href="#a5c037db7f5ec45293ac6650d46040237">More...</a><br/></td></tr>
<tr class="separator:a5c037db7f5ec45293ac6650d46040237"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a171c17f06d7bb0645776f466fe3d3a1d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a171c17f06d7bb0645776f466fe3d3a1d">simplify_from_siblings</a> (const set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&gt; &amp;from_sibs)</td></tr>
<tr class="memdesc:a171c17f06d7bb0645776f466fe3d3a1d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove easily-resolvable redundancy in the graph for all provided from-sibling sets.  <a href="#a171c17f06d7bb0645776f466fe3d3a1d">More...</a><br/></td></tr>
<tr class="separator:a171c17f06d7bb0645776f466fe3d3a1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afce50214291804f0d9bdf9bcd39125a4"><td class="memItemLeft" align="right" valign="top">set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#afce50214291804f0d9bdf9bcd39125a4">transitive_sibling_sets</a> (const set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&gt; &amp;sibs)</td></tr>
<tr class="memdesc:afce50214291804f0d9bdf9bcd39125a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove intransitive sibling sets, such as where (A, B, C) = S1 but C  S2.  <a href="#afce50214291804f0d9bdf9bcd39125a4">More...</a><br/></td></tr>
<tr class="separator:afce50214291804f0d9bdf9bcd39125a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb33bdc43954b8acd955bb4425a48df1"><td class="memItemLeft" align="right" valign="top">set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#acb33bdc43954b8acd955bb4425a48df1">identically_oriented_sibling_sets</a> (const set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&gt; &amp;sibs)</td></tr>
<tr class="memdesc:acb33bdc43954b8acd955bb4425a48df1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove sibling sets which don't have identical orientation.  <a href="#acb33bdc43954b8acd955bb4425a48df1">More...</a><br/></td></tr>
<tr class="separator:acb33bdc43954b8acd955bb4425a48df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab213a64c6240d08603530982c0b75047"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab213a64c6240d08603530982c0b75047">adjacent</a> (const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos1, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos2)</td></tr>
<tr class="memdesc:ab213a64c6240d08603530982c0b75047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if pos1 occurs directly before pos2.  <a href="#ab213a64c6240d08603530982c0b75047">More...</a><br/></td></tr>
<tr class="separator:ab213a64c6240d08603530982c0b75047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb95ac1c24c5263a962c13f3d6bc0c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8cb95ac1c24c5263a962c13f3d6bc0c3">create_node</a> (const string &amp;seq)</td></tr>
<tr class="memdesc:a8cb95ac1c24c5263a962c13f3d6bc0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a node. Use the <a class="el" href="classvg_1_1VG.html">VG</a> class to generate ids.  <a href="#a8cb95ac1c24c5263a962c13f3d6bc0c3">More...</a><br/></td></tr>
<tr class="separator:a8cb95ac1c24c5263a962c13f3d6bc0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5736bb79bf9bcb96ea21c6945c61dcfb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5736bb79bf9bcb96ea21c6945c61dcfb">create_node</a> (const string &amp;seq, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a5736bb79bf9bcb96ea21c6945c61dcfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a node. Use a specified, nonzero node ID.  <a href="#a5736bb79bf9bcb96ea21c6945c61dcfb">More...</a><br/></td></tr>
<tr class="separator:a5736bb79bf9bcb96ea21c6945c61dcfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49c1cef3ec020f0f494dbb0fd24deb7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a49c1cef3ec020f0f494dbb0fd24deb7c">get_node</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a49c1cef3ec020f0f494dbb0fd24deb7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a particular node.  <a href="#a49c1cef3ec020f0f494dbb0fd24deb7c">More...</a><br/></td></tr>
<tr class="separator:a49c1cef3ec020f0f494dbb0fd24deb7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceed581863f873d9b18e9a158e85e1f9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aceed581863f873d9b18e9a158e85e1f9">get_node</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>) const </td></tr>
<tr class="separator:aceed581863f873d9b18e9a158e85e1f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44edad9ba2a6df332234b43715dd71db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a44edad9ba2a6df332234b43715dd71db">nonoverlapping_node_context_without_paths</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;g)</td></tr>
<tr class="separator:a44edad9ba2a6df332234b43715dd71db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a525e3290d6968c79314c2500f13cc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a6a525e3290d6968c79314c2500f13cc3">expand_context</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g, size_t distance, bool add_paths=true, bool use_steps=true)</td></tr>
<tr class="separator:a6a525e3290d6968c79314c2500f13cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4ead561b46cd1cde77ada1f611befa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aca4ead561b46cd1cde77ada1f611befa">expand_context_by_steps</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g, size_t steps, bool add_paths=true)</td></tr>
<tr class="memdesc:aca4ead561b46cd1cde77ada1f611befa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the context of the given graph by the given number of steps.  <a href="#aca4ead561b46cd1cde77ada1f611befa">More...</a><br/></td></tr>
<tr class="separator:aca4ead561b46cd1cde77ada1f611befa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba5a5416ee9eaf67c7ae5607fc7ae1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5ba5a5416ee9eaf67c7ae5607fc7ae1f">expand_context_by_length</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g, size_t <a class="el" href="classvg_1_1VG.html#a23641dedefa2b6d573939515fcf5974c">length</a>, bool add_paths=true, bool reflect=false, const set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;barriers=set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;())</td></tr>
<tr class="separator:a5ba5a5416ee9eaf67c7ae5607fc7ae1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cd34f3c968f90370c42e8692222619"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab9cd34f3c968f90370c42e8692222619">destroy_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:ab9cd34f3c968f90370c42e8692222619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the node at the given pointer. This pointer must point to a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> owned by the graph.  <a href="#ab9cd34f3c968f90370c42e8692222619">More...</a><br/></td></tr>
<tr class="separator:ab9cd34f3c968f90370c42e8692222619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb9f662f9241f12249331c878ade136e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#acb9f662f9241f12249331c878ade136e">destroy_node</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:acb9f662f9241f12249331c878ade136e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the node with the given ID.  <a href="#acb9f662f9241f12249331c878ade136e">More...</a><br/></td></tr>
<tr class="separator:acb9f662f9241f12249331c878ade136e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c72c4989c1bebcec7e98115041b501"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a37c72c4989c1bebcec7e98115041b501">has_node</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>) const </td></tr>
<tr class="memdesc:a37c72c4989c1bebcec7e98115041b501"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has a node with the given ID.  <a href="#a37c72c4989c1bebcec7e98115041b501">More...</a><br/></td></tr>
<tr class="separator:a37c72c4989c1bebcec7e98115041b501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec9fb90202c77a6d104c634e2d2a3e62"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aec9fb90202c77a6d104c634e2d2a3e62">has_node</a> (const <a class="el" href="structvg_1_1Node.html">Node</a> *node) const </td></tr>
<tr class="memdesc:aec9fb90202c77a6d104c634e2d2a3e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph contains the given node.  <a href="#aec9fb90202c77a6d104c634e2d2a3e62">More...</a><br/></td></tr>
<tr class="separator:aec9fb90202c77a6d104c634e2d2a3e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907734904cd304ecee0b432ed598d106"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a907734904cd304ecee0b432ed598d106">has_node</a> (const <a class="el" href="structvg_1_1Node.html">Node</a> &amp;node) const </td></tr>
<tr class="memdesc:a907734904cd304ecee0b432ed598d106"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph contains the given node.  <a href="#a907734904cd304ecee0b432ed598d106">More...</a><br/></td></tr>
<tr class="separator:a907734904cd304ecee0b432ed598d106"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04774a86b07508e9e5955abfba2171ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a04774a86b07508e9e5955abfba2171ff">find_node_by_name_or_add_new</a> (string <a class="el" href="classvg_1_1VG.html#a1f6fcd5a907e9bee524cf37a62ad5be2">name</a>)</td></tr>
<tr class="memdesc:a04774a86b07508e9e5955abfba2171ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node with the given name, or create a new one if none is found.  <a href="#a04774a86b07508e9e5955abfba2171ff">More...</a><br/></td></tr>
<tr class="separator:a04774a86b07508e9e5955abfba2171ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af585f2161de09403d197e05fbcfb9a07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af585f2161de09403d197e05fbcfb9a07">for_each_node</a> (function&lt; void(<a class="el" href="structvg_1_1Node.html">Node</a> *)&gt; lambda)</td></tr>
<tr class="memdesc:af585f2161de09403d197e05fbcfb9a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the given function on every node.  <a href="#af585f2161de09403d197e05fbcfb9a07">More...</a><br/></td></tr>
<tr class="separator:af585f2161de09403d197e05fbcfb9a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8815f6165628d04e4dade8987aeeb22a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8815f6165628d04e4dade8987aeeb22a">for_each_node</a> (function&lt; void(const <a class="el" href="structvg_1_1Node.html">Node</a> *)&gt; lambda) const </td></tr>
<tr class="separator:a8815f6165628d04e4dade8987aeeb22a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39790d52fe4c09804086d58164258fcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a39790d52fe4c09804086d58164258fcf">for_each_node_parallel</a> (function&lt; void(<a class="el" href="structvg_1_1Node.html">Node</a> *)&gt; lambda)</td></tr>
<tr class="memdesc:a39790d52fe4c09804086d58164258fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the given function on every node in parallel.  <a href="#a39790d52fe4c09804086d58164258fcf">More...</a><br/></td></tr>
<tr class="separator:a39790d52fe4c09804086d58164258fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892abc4056e30044ae9ce0db9e4871f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a892abc4056e30044ae9ce0db9e4871f0">for_each_connected_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, function&lt; void(<a class="el" href="structvg_1_1Node.html">Node</a> *)&gt; lambda)</td></tr>
<tr class="memdesc:a892abc4056e30044ae9ce0db9e4871f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Go through all the nodes in the same connected component as the given node. Ignores relative orientation.  <a href="#a892abc4056e30044ae9ce0db9e4871f0">More...</a><br/></td></tr>
<tr class="separator:a892abc4056e30044ae9ce0db9e4871f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0db609d022b3c3183403600970238f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aec0db609d022b3c3183403600970238f">dfs</a> (const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;node_begin_fn, const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;node_end_fn, const function&lt; bool(void)&gt; &amp;break_fn, const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;edge_fn, const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;tree_fn, const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;edge_curr_fn, const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;edge_cross_fn, const vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *sources, const unordered_set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *sinks)</td></tr>
<tr class="separator:aec0db609d022b3c3183403600970238f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287e5d12ba0bc0823d1b6e0fa56af3d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a287e5d12ba0bc0823d1b6e0fa56af3d6">dfs</a> (const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;node_begin_fn, const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;node_end_fn, const vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *sources=NULL, const unordered_set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *sinks=NULL)</td></tr>
<tr class="memdesc:a287e5d12ba0bc0823d1b6e0fa56af3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of dfs for only handling nodes.  <a href="#a287e5d12ba0bc0823d1b6e0fa56af3d6">More...</a><br/></td></tr>
<tr class="separator:a287e5d12ba0bc0823d1b6e0fa56af3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee80f3ce939643d59157e1a1d707068"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8ee80f3ce939643d59157e1a1d707068">dfs</a> (const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;node_begin_fn, const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;node_end_fn, const function&lt; bool(void)&gt; &amp;break_fn)</td></tr>
<tr class="memdesc:a8ee80f3ce939643d59157e1a1d707068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of dfs for only handling nodes + break function.  <a href="#a8ee80f3ce939643d59157e1a1d707068">More...</a><br/></td></tr>
<tr class="separator:a8ee80f3ce939643d59157e1a1d707068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa778c3d1697c79aa924c5e4d1179a646"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa778c3d1697c79aa924c5e4d1179a646">empty</a> (void) const </td></tr>
<tr class="memdesc:aa778c3d1697c79aa924c5e4d1179a646"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the graph empty?  <a href="#aa778c3d1697c79aa924c5e4d1179a646">More...</a><br/></td></tr>
<tr class="separator:aa778c3d1697c79aa924c5e4d1179a646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b75ca400f858be77b0716ab7c68dfcb"><td class="memItemLeft" align="right" valign="top">const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2b75ca400f858be77b0716ab7c68dfcb">hash</a> (void)</td></tr>
<tr class="memdesc:a2b75ca400f858be77b0716ab7c68dfcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a digest of the serialized graph.  <a href="#a2b75ca400f858be77b0716ab7c68dfcb">More...</a><br/></td></tr>
<tr class="separator:a2b75ca400f858be77b0716ab7c68dfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b107027697644d771eb529037201f71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a9b107027697644d771eb529037201f71">remove_null_nodes</a> (void)</td></tr>
<tr class="separator:a9b107027697644d771eb529037201f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92694e7fd89275603c967739e60e0d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab92694e7fd89275603c967739e60e0d2">remove_node_forwarding_edges</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:ab92694e7fd89275603c967739e60e0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node but connect all of its predecessor and successor nodes with new edges.  <a href="#ab92694e7fd89275603c967739e60e0d2">More...</a><br/></td></tr>
<tr class="separator:ab92694e7fd89275603c967739e60e0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e887a7b2cfc666f2210889a2dec791b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0e887a7b2cfc666f2210889a2dec791b">remove_null_nodes_forwarding_edges</a> (void)</td></tr>
<tr class="memdesc:a0e887a7b2cfc666f2210889a2dec791b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove null nodes but connect predecessors and successors, preserving structure.  <a href="#a0e887a7b2cfc666f2210889a2dec791b">More...</a><br/></td></tr>
<tr class="separator:a0e887a7b2cfc666f2210889a2dec791b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40dd9bc0458a4948afd676374ae8d1f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a40dd9bc0458a4948afd676374ae8d1f0">remove_orphan_edges</a> (void)</td></tr>
<tr class="memdesc:a40dd9bc0458a4948afd676374ae8d1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove edges for which one of the nodes is not present.  <a href="#a40dd9bc0458a4948afd676374ae8d1f0">More...</a><br/></td></tr>
<tr class="separator:a40dd9bc0458a4948afd676374ae8d1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76005ed499eea217c9f778028751137c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a76005ed499eea217c9f778028751137c">remove_inverting_edges</a> (void)</td></tr>
<tr class="memdesc:a76005ed499eea217c9f778028751137c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove edges representing an inversion and edges on the reverse complement.  <a href="#a76005ed499eea217c9f778028751137c">More...</a><br/></td></tr>
<tr class="separator:a76005ed499eea217c9f778028751137c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1dbb49df52e016746829776ca0f952"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8d1dbb49df52e016746829776ca0f952">has_inverting_edges</a> (void)</td></tr>
<tr class="memdesc:a8d1dbb49df52e016746829776ca0f952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has inversions.  <a href="#a8d1dbb49df52e016746829776ca0f952">More...</a><br/></td></tr>
<tr class="separator:a8d1dbb49df52e016746829776ca0f952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2aa9d438bcec4d7facbfcc44abea8fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac2aa9d438bcec4d7facbfcc44abea8fd">keep_paths</a> (const set&lt; string &gt; &amp;path_names, set&lt; string &gt; &amp;kept_names)</td></tr>
<tr class="separator:ac2aa9d438bcec4d7facbfcc44abea8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cc16f52f478a25e84c6f1fc2805915"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a65cc16f52f478a25e84c6f1fc2805915">keep_path</a> (const string &amp;path_name)</td></tr>
<tr class="separator:a65cc16f52f478a25e84c6f1fc2805915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1df72d85d8a72524b76abca972f33d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5f1df72d85d8a72524b76abca972f33d">path_edge_count</a> (list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;path, int32_t <a class="el" href="namespacevg.html#a416939020600ce2996331c350f1fe68c">offset</a>, int path_length)</td></tr>
<tr class="separator:a5f1df72d85d8a72524b76abca972f33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f45b42614f4ac36c8060634ec0d9805"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8f45b42614f4ac36c8060634ec0d9805">path_end_node_offset</a> (list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;path, int32_t <a class="el" href="namespacevg.html#a416939020600ce2996331c350f1fe68c">offset</a>, int path_length)</td></tr>
<tr class="separator:a8f45b42614f4ac36c8060634ec0d9805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871d05e0a2d0b76092e20fe86bd12e2b"><td class="memItemLeft" align="right" valign="top">const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a871d05e0a2d0b76092e20fe86bd12e2b">paths_as_alignments</a> (void)</td></tr>
<tr class="memdesc:a871d05e0a2d0b76092e20fe86bd12e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the stored paths in this graph to alignments.  <a href="#a871d05e0a2d0b76092e20fe86bd12e2b">More...</a><br/></td></tr>
<tr class="separator:a871d05e0a2d0b76092e20fe86bd12e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce6fe02b243b4f0f82bbf801fd507fa"><td class="memItemLeft" align="right" valign="top">const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a4ce6fe02b243b4f0f82bbf801fd507fa">path_sequence</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="memdesc:a4ce6fe02b243b4f0f82bbf801fd507fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sequence string of path.  <a href="#a4ce6fe02b243b4f0f82bbf801fd507fa">More...</a><br/></td></tr>
<tr class="separator:a4ce6fe02b243b4f0f82bbf801fd507fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bd4133841d1d781fb0df4171773139"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad9bd4133841d1d781fb0df4171773139">path_identity</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path1, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path2)</td></tr>
<tr class="separator:ad9bd4133841d1d781fb0df4171773139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57296ecbcfce10f95b86233e10c35d7d"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a57296ecbcfce10f95b86233e10c35d7d">trav_sequence</a> (const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;trav)</td></tr>
<tr class="memdesc:a57296ecbcfce10f95b86233e10c35d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sequence of a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>.  <a href="#a57296ecbcfce10f95b86233e10c35d7d">More...</a><br/></td></tr>
<tr class="separator:a57296ecbcfce10f95b86233e10c35d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8d1d0b977473d9c5b1b0ffa304a338"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1f8d1d0b977473d9c5b1b0ffa304a338">get_node_at_nucleotide</a> (string pathname, int nuc)</td></tr>
<tr class="separator:a1f8d1d0b977473d9c5b1b0ffa304a338"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecb9833a1b3e7d5ca41fcaa96000976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8ecb9833a1b3e7d5ca41fcaa96000976">create_edge</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *from, <a class="el" href="structvg_1_1Node.html">Node</a> *to, bool from_start=false, bool to_end=false)</td></tr>
<tr class="separator:a8ecb9833a1b3e7d5ca41fcaa96000976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaea0ac806a69899322f10155d5def595"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aaea0ac806a69899322f10155d5def595">create_edge</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> from, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> to, bool from_start=false, bool to_end=false)</td></tr>
<tr class="separator:aaea0ac806a69899322f10155d5def595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd0565d5133a239856444049783edcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8fd0565d5133a239856444049783edcd">create_edge</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> left, <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> right)</td></tr>
<tr class="separator:a8fd0565d5133a239856444049783edcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cd4705aa5b919f349d02089c97cbc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac2cd4705aa5b919f349d02089c97cbc2">create_edge</a> (<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> side1, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> side2)</td></tr>
<tr class="separator:ac2cd4705aa5b919f349d02089c97cbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8668ddc84b9abe4fe9cb5acb3efd877b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8668ddc84b9abe4fe9cb5acb3efd877b">get_edge</a> (const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side1, const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side2)</td></tr>
<tr class="separator:a8668ddc84b9abe4fe9cb5acb3efd877b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227023072262f46f7c423d30cf8bc443"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a227023072262f46f7c423d30cf8bc443">get_edge</a> (const pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;sides)</td></tr>
<tr class="separator:a227023072262f46f7c423d30cf8bc443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63d7ba7b69594ee99f3ad99dd394171"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af63d7ba7b69594ee99f3ad99dd394171">get_edge</a> (const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;left, const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;right)</td></tr>
<tr class="memdesc:af63d7ba7b69594ee99f3ad99dd394171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edge connecting the given oriented nodes in the given order.  <a href="#af63d7ba7b69594ee99f3ad99dd394171">More...</a><br/></td></tr>
<tr class="separator:af63d7ba7b69594ee99f3ad99dd394171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284327157f9d4b82224fc856179a668d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a284327157f9d4b82224fc856179a668d">destroy_edge</a> (<a class="el" href="structvg_1_1Edge.html">Edge</a> *edge)</td></tr>
<tr class="memdesc:a284327157f9d4b82224fc856179a668d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the edge at the given pointer. This pointer must point to an edge owned by the graph.  <a href="#a284327157f9d4b82224fc856179a668d">More...</a><br/></td></tr>
<tr class="separator:a284327157f9d4b82224fc856179a668d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6b91020abf39815d28995eceac4e2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#abe6b91020abf39815d28995eceac4e2d">destroy_edge</a> (const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side1, const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side2)</td></tr>
<tr class="memdesc:abe6b91020abf39815d28995eceac4e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the edge between the given sides of nodes. These can be in either order.  <a href="#abe6b91020abf39815d28995eceac4e2d">More...</a><br/></td></tr>
<tr class="separator:abe6b91020abf39815d28995eceac4e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd2744b37b62862df68e82cbe7b6b59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7fd2744b37b62862df68e82cbe7b6b59">destroy_edge</a> (const pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;sides)</td></tr>
<tr class="memdesc:a7fd2744b37b62862df68e82cbe7b6b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the edge between the given sides of nodes. This can take sides in any order.  <a href="#a7fd2744b37b62862df68e82cbe7b6b59">More...</a><br/></td></tr>
<tr class="separator:a7fd2744b37b62862df68e82cbe7b6b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0b7db8d3043747e8b9a44cba4eaac9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1c0b7db8d3043747e8b9a44cba4eaac9">unindex_edge_by_node_sides</a> (const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side1, const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side2)</td></tr>
<tr class="separator:a1c0b7db8d3043747e8b9a44cba4eaac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5677da9ff22052f6c6a85bfe66e1256d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5677da9ff22052f6c6a85bfe66e1256d">unindex_edge_by_node_sides</a> (<a class="el" href="structvg_1_1Edge.html">Edge</a> *edge)</td></tr>
<tr class="separator:a5677da9ff22052f6c6a85bfe66e1256d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ff7033966852f5fb3852716cab21a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a53ff7033966852f5fb3852716cab21a9">index_edge_by_node_sides</a> (<a class="el" href="structvg_1_1Edge.html">Edge</a> *edge)</td></tr>
<tr class="separator:a53ff7033966852f5fb3852716cab21a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eecbad7b22574c0617ad9a3d0808a6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5eecbad7b22574c0617ad9a3d0808a6e">has_edge</a> (const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side1, const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side2)</td></tr>
<tr class="memdesc:a5eecbad7b22574c0617ad9a3d0808a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edge between the given node sides, which can be in either order.  <a href="#a5eecbad7b22574c0617ad9a3d0808a6e">More...</a><br/></td></tr>
<tr class="separator:a5eecbad7b22574c0617ad9a3d0808a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d10f80caa0eea2f594c4a0d6ba8c6b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a64d10f80caa0eea2f594c4a0d6ba8c6b">has_edge</a> (const pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;sides)</td></tr>
<tr class="memdesc:a64d10f80caa0eea2f594c4a0d6ba8c6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an edge. This can take sides in any order.  <a href="#a64d10f80caa0eea2f594c4a0d6ba8c6b">More...</a><br/></td></tr>
<tr class="separator:a64d10f80caa0eea2f594c4a0d6ba8c6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c01851e7e97fda9828383c6de4a765"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa6c01851e7e97fda9828383c6de4a765">has_edge</a> (<a class="el" href="structvg_1_1Edge.html">Edge</a> *edge)</td></tr>
<tr class="memdesc:aa6c01851e7e97fda9828383c6de4a765"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an edge. This can take sides in any order.  <a href="#aa6c01851e7e97fda9828383c6de4a765">More...</a><br/></td></tr>
<tr class="separator:aa6c01851e7e97fda9828383c6de4a765"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab50d35554acf27ab2883b160866c5161"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab50d35554acf27ab2883b160866c5161">has_edge</a> (const <a class="el" href="structvg_1_1Edge.html">Edge</a> &amp;edge)</td></tr>
<tr class="memdesc:ab50d35554acf27ab2883b160866c5161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an edge. This can take sides in any order.  <a href="#ab50d35554acf27ab2883b160866c5161">More...</a><br/></td></tr>
<tr class="separator:ab50d35554acf27ab2883b160866c5161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fb4de3494407b800c3efda254851cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a49fb4de3494407b800c3efda254851cf">has_inverting_edge</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *n)</td></tr>
<tr class="memdesc:a49fb4de3494407b800c3efda254851cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an inverting edge on the given node.  <a href="#a49fb4de3494407b800c3efda254851cf">More...</a><br/></td></tr>
<tr class="separator:a49fb4de3494407b800c3efda254851cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7bbf066c6608211e7527ba50b23e48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7b7bbf066c6608211e7527ba50b23e48">has_inverting_edge_from</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *n)</td></tr>
<tr class="memdesc:a7b7bbf066c6608211e7527ba50b23e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an inverting edge from the given node.  <a href="#a7b7bbf066c6608211e7527ba50b23e48">More...</a><br/></td></tr>
<tr class="separator:a7b7bbf066c6608211e7527ba50b23e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63088ee0039a8e1f5cf6b5a3b23f745a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a63088ee0039a8e1f5cf6b5a3b23f745a">has_inverting_edge_to</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *n)</td></tr>
<tr class="memdesc:a63088ee0039a8e1f5cf6b5a3b23f745a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an inverting edge to the given node.  <a href="#a63088ee0039a8e1f5cf6b5a3b23f745a">More...</a><br/></td></tr>
<tr class="separator:a63088ee0039a8e1f5cf6b5a3b23f745a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7fdd8c951cbf8b25e116435b5e1e0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3d7fdd8c951cbf8b25e116435b5e1e0e">for_each_edge</a> (function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; lambda)</td></tr>
<tr class="memdesc:a3d7fdd8c951cbf8b25e116435b5e1e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the given function for each edge.  <a href="#a3d7fdd8c951cbf8b25e116435b5e1e0e">More...</a><br/></td></tr>
<tr class="separator:a3d7fdd8c951cbf8b25e116435b5e1e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bd448b5f9115c64efdd6514cbf05ae0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0bd448b5f9115c64efdd6514cbf05ae0">for_each_edge</a> (function&lt; void(const <a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; lambda) const </td></tr>
<tr class="separator:a0bd448b5f9115c64efdd6514cbf05ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a20aa427767a27fd15d181ccca8c42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a46a20aa427767a27fd15d181ccca8c42">for_each_edge_parallel</a> (function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; lambda)</td></tr>
<tr class="memdesc:a46a20aa427767a27fd15d181ccca8c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the given function for each edge, in parallel.  <a href="#a46a20aa427767a27fd15d181ccca8c42">More...</a><br/></td></tr>
<tr class="separator:a46a20aa427767a27fd15d181ccca8c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeabcaa5e19486dbab418184a312d9777"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aeabcaa5e19486dbab418184a312d9777">circularize</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> head, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> tail)</td></tr>
<tr class="memdesc:aeabcaa5e19486dbab418184a312d9777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Circularize a subgraph / path using the head / tail nodes.  <a href="#aeabcaa5e19486dbab418184a312d9777">More...</a><br/></td></tr>
<tr class="separator:aeabcaa5e19486dbab418184a312d9777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96ff883534a13b28b18cd84dd094e72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad96ff883534a13b28b18cd84dd094e72">circularize</a> (vector&lt; string &gt; pathnames)</td></tr>
<tr class="separator:ad96ff883534a13b28b18cd84dd094e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68d2bfaa6627686967add4ca7fb5f4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad68d2bfaa6627686967add4ca7fb5f4c">connect_node_to_nodes</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node, vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="separator:ad68d2bfaa6627686967add4ca7fb5f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8189716ecbb9eeeefec8be64e34a9e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab8189716ecbb9eeeefec8be64e34a9e3">connect_node_to_nodes</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes, bool from_start=false)</td></tr>
<tr class="separator:ab8189716ecbb9eeeefec8be64e34a9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee6066424793dfcda9097419f03b568"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7ee6066424793dfcda9097419f03b568">connect_nodes_to_node</a> (vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes, <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node)</td></tr>
<tr class="separator:a7ee6066424793dfcda9097419f03b568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4db5878a40e8dc7d2d2b25ff62ff1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#acc4db5878a40e8dc7d2d2b25ff62ff1e">connect_nodes_to_node</a> (vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes, <a class="el" href="structvg_1_1Node.html">Node</a> *node, bool to_end=false)</td></tr>
<tr class="memdesc:acc4db5878a40e8dc7d2d2b25ff62ff1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">connect nodes -&gt; node.  <a href="#acc4db5878a40e8dc7d2d2b25ff62ff1e">More...</a><br/></td></tr>
<tr class="separator:acc4db5878a40e8dc7d2d2b25ff62ff1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06f0fcad4bf5b1c29cf937a870a58b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad06f0fcad4bf5b1c29cf937a870a58b4">divide_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, int pos, <a class="el" href="structvg_1_1Node.html">Node</a> *&amp;left, <a class="el" href="structvg_1_1Node.html">Node</a> *&amp;right)</td></tr>
<tr class="separator:ad06f0fcad4bf5b1c29cf937a870a58b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bee7317e4f7e42d85d8e7ef8d07273a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7bee7317e4f7e42d85d8e7ef8d07273a">divide_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, vector&lt; int &gt; &amp;positions, vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;parts)</td></tr>
<tr class="memdesc:a7bee7317e4f7e42d85d8e7ef8d07273a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a node at a given internal position. This version works on a collection of internal positions, in linear time.  <a href="#a7bee7317e4f7e42d85d8e7ef8d07273a">More...</a><br/></td></tr>
<tr class="separator:a7bee7317e4f7e42d85d8e7ef8d07273a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce3b7afc274a50cd7b1296e64ca2f01"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1ce3b7afc274a50cd7b1296e64ca2f01">divide_path</a> (map&lt; long, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;path, long pos, <a class="el" href="structvg_1_1Node.html">Node</a> *&amp;left, <a class="el" href="structvg_1_1Node.html">Node</a> *&amp;right)</td></tr>
<tr class="memdesc:a1ce3b7afc274a50cd7b1296e64ca2f01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a path at a position. Also invalidates stored rank information.  <a href="#a1ce3b7afc274a50cd7b1296e64ca2f01">More...</a><br/></td></tr>
<tr class="separator:a1ce3b7afc274a50cd7b1296e64ca2f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a4e14a60334c2ba3ce3bed0e3fd0b91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5a4e14a60334c2ba3ce3bed0e3fd0b91">to_dot</a> (ostream &amp;out, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; alignments={}, vector&lt; <a class="el" href="structvg_1_1Locus.html">Locus</a> &gt; loci={}, bool show_paths=false, bool walk_paths=false, bool annotate_paths=false, bool show_mappings=false, bool simple_mode=false, bool invert_edge_ports=false, bool color_variants=false, bool ultrabubble_labeling=false, bool skip_missing_nodes=false, bool ascii_labels=false, int random_seed=0)</td></tr>
<tr class="memdesc:a5a4e14a60334c2ba3ce3bed0e3fd0b91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the graph to Dot format.  <a href="#a5a4e14a60334c2ba3ce3bed0e3fd0b91">More...</a><br/></td></tr>
<tr class="separator:a5a4e14a60334c2ba3ce3bed0e3fd0b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfa66da1d94de2ebc0620be45c3393f8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#adfa66da1d94de2ebc0620be45c3393f8">to_dot</a> (ostream &amp;out, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; alignments={}, bool show_paths=false, bool walk_paths=false, bool annotate_paths=false, bool show_mappings=false, bool invert_edge_ports=false, int random_seed=0, bool color_variants=false)</td></tr>
<tr class="memdesc:adfa66da1d94de2ebc0620be45c3393f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the graph to Dot format.  <a href="#adfa66da1d94de2ebc0620be45c3393f8">More...</a><br/></td></tr>
<tr class="separator:adfa66da1d94de2ebc0620be45c3393f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582500a3d49fe231faa49a5c2e467cc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a582500a3d49fe231faa49a5c2e467cc8">to_turtle</a> (ostream &amp;out, const string &amp;rdf_base_uri, bool precompress)</td></tr>
<tr class="memdesc:a582500a3d49fe231faa49a5c2e467cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the graph to Turtle format.  <a href="#a582500a3d49fe231faa49a5c2e467cc8">More...</a><br/></td></tr>
<tr class="separator:a582500a3d49fe231faa49a5c2e467cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77d93fdf76698460ce509ea5dcde954"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa77d93fdf76698460ce509ea5dcde954">is_valid</a> (bool check_nodes=true, bool check_edges=true, bool check_paths=true, bool check_orphans=true)</td></tr>
<tr class="memdesc:aa77d93fdf76698460ce509ea5dcde954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph is valid or not, according to the specified criteria.  <a href="#aa77d93fdf76698460ce509ea5dcde954">More...</a><br/></td></tr>
<tr class="separator:aa77d93fdf76698460ce509ea5dcde954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa402d1cf817f83ca44f72f6112b6a2e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa402d1cf817f83ca44f72f6112b6a2e3">swap_nodes</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *a, <a class="el" href="structvg_1_1Node.html">Node</a> *b)</td></tr>
<tr class="memdesc:aa402d1cf817f83ca44f72f6112b6a2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the given nodes. TODO: what does that mean?  <a href="#aa402d1cf817f83ca44f72f6112b6a2e3">More...</a><br/></td></tr>
<tr class="separator:aa402d1cf817f83ca44f72f6112b6a2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6a43b2e456d0e9e17f3e7f8d3b4478"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1b6a43b2e456d0e9e17f3e7f8d3b4478">align</a> (const string &amp;sequence, <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *aligner, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0, bool multithreaded_xdrop=false, bool print_score_matrices=false)</td></tr>
<tr class="separator:a1b6a43b2e456d0e9e17f3e7f8d3b4478"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bad7dd2c8179b37694e80e2e191d515"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a4bad7dd2c8179b37694e80e2e191d515">align</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *aligner, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0, bool multithreaded_xdrop=false, bool print_score_matrices=false)</td></tr>
<tr class="separator:a4bad7dd2c8179b37694e80e2e191d515"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a077755b905705f812643d91af60bbc2c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a077755b905705f812643d91af60bbc2c">align</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *aligner, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0, bool multithreaded_xdrop=false, bool print_score_matrices=false)</td></tr>
<tr class="separator:a077755b905705f812643d91af60bbc2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66f810b0e599dc056a7de5f69fe41c8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a66f810b0e599dc056a7de5f69fe41c8b">align</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0, bool multithreaded_xdrop=false, bool print_score_matrices=false)</td></tr>
<tr class="separator:a66f810b0e599dc056a7de5f69fe41c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44e5c2abb453e19753210bca93555408"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a44e5c2abb453e19753210bca93555408">align</a> (const string &amp;sequence, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0, bool multithreaded_xdrop=false, bool print_score_matrices=false)</td></tr>
<tr class="separator:a44e5c2abb453e19753210bca93555408"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e6e37a281459834547a74974393fbe7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a4e6e37a281459834547a74974393fbe7">align_qual_adjusted</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *qual_adj_aligner, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0, bool multithreaded_xdrop=false, bool print_score_matrices=false)</td></tr>
<tr class="separator:a4e6e37a281459834547a74974393fbe7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c4e8a8a3c83b48cd7a213420f2c3f5a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5c4e8a8a3c83b48cd7a213420f2c3f5a">align_qual_adjusted</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *qual_adj_aligner, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0, bool multithreaded_xdrop=false, bool print_score_matrices=false)</td></tr>
<tr class="separator:a5c4e8a8a3c83b48cd7a213420f2c3f5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1c02fc3a1a438240d42fcc5b5081b7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0f1c02fc3a1a438240d42fcc5b5081b7">align_qual_adjusted</a> (const string &amp;sequence, <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *qual_adj_aligner, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0, bool multithreaded_xdrop=false, bool print_score_matrices=false)</td></tr>
<tr class="separator:a0f1c02fc3a1a438240d42fcc5b5081b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc8d762d07088089247b632c835a19d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8dc8d762d07088089247b632c835a19d">paths_between</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *from, <a class="el" href="structvg_1_1Node.html">Node</a> *to, vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;<a class="el" href="classvg_1_1VG.html#a7c5150aba84e7ed2bde7986462a79989">paths</a>)</td></tr>
<tr class="separator:a8dc8d762d07088089247b632c835a19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af39a51572be3a442165d50e555e325ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af39a51572be3a442165d50e555e325ce">paths_between</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> from, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> to, vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;<a class="el" href="classvg_1_1VG.html#a7c5150aba84e7ed2bde7986462a79989">paths</a>)</td></tr>
<tr class="separator:af39a51572be3a442165d50e555e325ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5821862279a350885f5368a54a5cba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ada5821862279a350885f5368a54a5cba">likelihoods</a> (vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alignments, vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;<a class="el" href="classvg_1_1VG.html#a7c5150aba84e7ed2bde7986462a79989">paths</a>, vector&lt; long double &gt; &amp;likelihoods)</td></tr>
<tr class="separator:ada5821862279a350885f5368a54a5cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08e778396904ad3b3f20f605f54628d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac08e778396904ad3b3f20f605f54628d">nodes_prev</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> n, vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:ac08e778396904ad3b3f20f605f54628d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nodes attached to the left side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations.  <a href="#ac08e778396904ad3b3f20f605f54628d">More...</a><br/></td></tr>
<tr class="separator:ac08e778396904ad3b3f20f605f54628d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3e69ced0c3135f3f363c14bf752aad"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0f3e69ced0c3135f3f363c14bf752aad">nodes_prev</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> n)</td></tr>
<tr class="memdesc:a0f3e69ced0c3135f3f363c14bf752aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nodes attached to the left side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations.  <a href="#a0f3e69ced0c3135f3f363c14bf752aad">More...</a><br/></td></tr>
<tr class="separator:a0f3e69ced0c3135f3f363c14bf752aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a962957210c079fa242b383d5c65de3"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0a962957210c079fa242b383d5c65de3">travs_to</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node)</td></tr>
<tr class="memdesc:a0a962957210c079fa242b383d5c65de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get traversals before this node on the same strand. Same as nodes_prev but using set.  <a href="#a0a962957210c079fa242b383d5c65de3">More...</a><br/></td></tr>
<tr class="separator:a0a962957210c079fa242b383d5c65de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b084d958fd8069839884dc3a01ed745"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0b084d958fd8069839884dc3a01ed745">nodes_next</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> n, vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:a0b084d958fd8069839884dc3a01ed745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nodes attached to the right side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations.  <a href="#a0b084d958fd8069839884dc3a01ed745">More...</a><br/></td></tr>
<tr class="separator:a0b084d958fd8069839884dc3a01ed745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f1bb7fa27d4d4312017b113aab099a"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a62f1bb7fa27d4d4312017b113aab099a">nodes_next</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> n)</td></tr>
<tr class="memdesc:a62f1bb7fa27d4d4312017b113aab099a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nodes attached to the right side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations.  <a href="#a62f1bb7fa27d4d4312017b113aab099a">More...</a><br/></td></tr>
<tr class="separator:a62f1bb7fa27d4d4312017b113aab099a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a493a0628857a3bfae181295ba541d"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a34a493a0628857a3bfae181295ba541d">travs_from</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node)</td></tr>
<tr class="memdesc:a34a493a0628857a3bfae181295ba541d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get traversals after this node on the same strand. Same as nodes_next but using set.  <a href="#a34a493a0628857a3bfae181295ba541d">More...</a><br/></td></tr>
<tr class="separator:a34a493a0628857a3bfae181295ba541d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae065082f817e9bc0e278cf71f31af1e2"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae065082f817e9bc0e278cf71f31af1e2">travs_of</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node)</td></tr>
<tr class="memdesc:ae065082f817e9bc0e278cf71f31af1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get traversals either before or after this node on the same strand.  <a href="#ae065082f817e9bc0e278cf71f31af1e2">More...</a><br/></td></tr>
<tr class="separator:ae065082f817e9bc0e278cf71f31af1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1091113608fae5b9cbafc87cf4cf82a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1091113608fae5b9cbafc87cf4cf82a2">node_count_prev</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> n)</td></tr>
<tr class="memdesc:a1091113608fae5b9cbafc87cf4cf82a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the nodes attached to the left side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>.  <a href="#a1091113608fae5b9cbafc87cf4cf82a2">More...</a><br/></td></tr>
<tr class="separator:a1091113608fae5b9cbafc87cf4cf82a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c614759c77b4b0a95b25360c2fa1fa0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a4c614759c77b4b0a95b25360c2fa1fa0">node_count_next</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> n)</td></tr>
<tr class="memdesc:a4c614759c77b4b0a95b25360c2fa1fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the nodes attached to the right side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>.  <a href="#a4c614759c77b4b0a95b25360c2fa1fa0">More...</a><br/></td></tr>
<tr class="separator:a4c614759c77b4b0a95b25360c2fa1fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3195bfadb7e65e4952c4b98d51e862f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3195bfadb7e65e4952c4b98d51e862f1">create_path</a> (const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:a3195bfadb7e65e4952c4b98d51e862f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a path.  <a href="#a3195bfadb7e65e4952c4b98d51e862f1">More...</a><br/></td></tr>
<tr class="separator:a3195bfadb7e65e4952c4b98d51e862f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc07ec73a57485a700e621517c962b8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#adc07ec73a57485a700e621517c962b8b">create_path</a> (const vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:adc07ec73a57485a700e621517c962b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a path.  <a href="#adc07ec73a57485a700e621517c962b8b">More...</a><br/></td></tr>
<tr class="separator:adc07ec73a57485a700e621517c962b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f4e2ab506f4ef673836b5901bb3809"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af8f4e2ab506f4ef673836b5901bb3809">path_string</a> (const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:af8f4e2ab506f4ef673836b5901bb3809"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string sequence for all the NodeTraversals on the given path.  <a href="#af8f4e2ab506f4ef673836b5901bb3809">More...</a><br/></td></tr>
<tr class="separator:af8f4e2ab506f4ef673836b5901bb3809"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a927b79f3f4c9582b0f8e988bb4ef1aa1"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a927b79f3f4c9582b0f8e988bb4ef1aa1">path_string</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:a927b79f3f4c9582b0f8e988bb4ef1aa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9273361525befc57536dc96a762c29d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa9273361525befc57536dc96a762c29d">expand_path</a> (const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;path, vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;expanded)</td></tr>
<tr class="memdesc:aa9273361525befc57536dc96a762c29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a path. TODO: what does that mean?  <a href="#aa9273361525befc57536dc96a762c29d">More...</a><br/></td></tr>
<tr class="separator:aa9273361525befc57536dc96a762c29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093f4e4dffe0d03806df32edc33cdb9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a093f4e4dffe0d03806df32edc33cdb9a">node_starts_in_path</a> (const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;path, map&lt; <a class="el" href="structvg_1_1Node.html">Node</a> *, int &gt; &amp;<a class="el" href="namespacevg.html#a30f5b0dc3732e48a6d9b8d1c895cd8d1">node_start</a>)</td></tr>
<tr class="separator:a093f4e4dffe0d03806df32edc33cdb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf8c0e391c1a6c027ed26b991d8cad0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a9bf8c0e391c1a6c027ed26b991d8cad0">nodes_are_perfect_path_neighbors</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> left, <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> right)</td></tr>
<tr class="separator:a9bf8c0e391c1a6c027ed26b991d8cad0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd555e66c8fa99984c8cb24aef0ab6f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#acd555e66c8fa99984c8cb24aef0ab6f9">mapping_is_total_match</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="memdesc:acd555e66c8fa99984c8cb24aef0ab6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the mapping completely covers the node it maps to and is a perfect match.  <a href="#acd555e66c8fa99984c8cb24aef0ab6f9">More...</a><br/></td></tr>
<tr class="separator:acd555e66c8fa99984c8cb24aef0ab6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a153260c1839238abff26b2e989d8799d"><td class="memItemLeft" align="right" valign="top">map&lt; string, vector&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a153260c1839238abff26b2e989d8799d">concat_mappings_for_node_pair</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> id1, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> id2)</td></tr>
<tr class="memdesc:a153260c1839238abff26b2e989d8799d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate the mappings for a pair of nodes; handles multiple mappings per path.  <a href="#a153260c1839238abff26b2e989d8799d">More...</a><br/></td></tr>
<tr class="separator:a153260c1839238abff26b2e989d8799d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2367b4d49cca4c57a2529d92512cba59"><td class="memItemLeft" align="right" valign="top">map&lt; string, vector&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2367b4d49cca4c57a2529d92512cba59">concat_mappings_for_nodes</a> (const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="separator:a2367b4d49cca4c57a2529d92512cba59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae151983cac753c02ce3852274798f8d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae151983cac753c02ce3852274798f8d5">expand_path</a> (list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;path, vector&lt; list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;::iterator &gt; &amp;expanded)</td></tr>
<tr class="separator:ae151983cac753c02ce3852274798f8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27c591957478a17605c2453749f7d20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac27c591957478a17605c2453749f7d20">node_starts_in_path</a> (list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;path, map&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> *, int &gt; &amp;<a class="el" href="namespacevg.html#a30f5b0dc3732e48a6d9b8d1c895cd8d1">node_start</a>)</td></tr>
<tr class="separator:ac27c591957478a17605c2453749f7d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4878ca3ebc2c14d008e57c7ae8d5845"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad4878ca3ebc2c14d008e57c7ae8d5845">prune_complex</a> (int path_length, int edge_max, <a class="el" href="structvg_1_1Node.html">Node</a> *head_node, <a class="el" href="structvg_1_1Node.html">Node</a> *tail_node)</td></tr>
<tr class="separator:ad4878ca3ebc2c14d008e57c7ae8d5845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0765f466db760a9a450f4d4115a59bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae0765f466db760a9a450f4d4115a59bd">prune_complex_with_head_tail</a> (int path_length, int edge_max)</td></tr>
<tr class="separator:ae0765f466db760a9a450f4d4115a59bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec84f7813f59a16b2d0c1bd72904ae5b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aec84f7813f59a16b2d0c1bd72904ae5b">random_read</a> (size_t read_len, mt19937 &amp;rng, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> min_id, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> max_id, bool either_strand)</td></tr>
<tr class="separator:aec84f7813f59a16b2d0c1bd72904ae5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af31e90fe77a1d30244011dd8dbbf5f25"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af31e90fe77a1d30244011dd8dbbf5f25">disjoint_subgraphs</a> (list&lt; <a class="el" href="classvg_1_1VG.html">VG</a> &gt; &amp;subgraphs)</td></tr>
<tr class="memdesc:af31e90fe77a1d30244011dd8dbbf5f25"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find subgraphs.  <a href="#af31e90fe77a1d30244011dd8dbbf5f25">More...</a><br/></td></tr>
<tr class="separator:af31e90fe77a1d30244011dd8dbbf5f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eecc0bd555c31d1c541c3ce44b421c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7eecc0bd555c31d1c541c3ce44b421c3">head_nodes</a> (vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes)</td></tr>
<tr class="memdesc:a7eecc0bd555c31d1c541c3ce44b421c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the head nodes (nodes with edges only to their right sides). These are required to be oriented forward.  <a href="#a7eecc0bd555c31d1c541c3ce44b421c3">More...</a><br/></td></tr>
<tr class="separator:a7eecc0bd555c31d1c541c3ce44b421c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a44c415fb5882c184e2f35bb3999700"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3a44c415fb5882c184e2f35bb3999700">head_nodes</a> (void)</td></tr>
<tr class="memdesc:a3a44c415fb5882c184e2f35bb3999700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the head nodes (nodes with edges only to their right sides). These are required to be oriented forward.  <a href="#a3a44c415fb5882c184e2f35bb3999700">More...</a><br/></td></tr>
<tr class="separator:a3a44c415fb5882c184e2f35bb3999700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5cdd8d94bcfce1302ba9e2cbfb5e412"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae5cdd8d94bcfce1302ba9e2cbfb5e412">is_head_node</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:ae5cdd8d94bcfce1302ba9e2cbfb5e412"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a node is a head node.  <a href="#ae5cdd8d94bcfce1302ba9e2cbfb5e412">More...</a><br/></td></tr>
<tr class="separator:ae5cdd8d94bcfce1302ba9e2cbfb5e412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc3866468d5eb941fa6ba010ccce2ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1bc3866468d5eb941fa6ba010ccce2ec">is_head_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a1bc3866468d5eb941fa6ba010ccce2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a node is a head node.  <a href="#a1bc3866468d5eb941fa6ba010ccce2ec">More...</a><br/></td></tr>
<tr class="separator:a1bc3866468d5eb941fa6ba010ccce2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bd74b77e139691555c8d48ecf67d9f"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a25bd74b77e139691555c8d48ecf67d9f">tail_nodes</a> (void)</td></tr>
<tr class="memdesc:a25bd74b77e139691555c8d48ecf67d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tail nodes (nodes with edges only to their left sides). These are required to be oriented forward.  <a href="#a25bd74b77e139691555c8d48ecf67d9f">More...</a><br/></td></tr>
<tr class="separator:a25bd74b77e139691555c8d48ecf67d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fbc525ed5e9f2a7b00c333f03fe6c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a47fbc525ed5e9f2a7b00c333f03fe6c8">tail_nodes</a> (vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes)</td></tr>
<tr class="memdesc:a47fbc525ed5e9f2a7b00c333f03fe6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tail nodes (nodes with edges only to their left sides). These are required to be oriented forward.  <a href="#a47fbc525ed5e9f2a7b00c333f03fe6c8">More...</a><br/></td></tr>
<tr class="separator:a47fbc525ed5e9f2a7b00c333f03fe6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b412ca09b09b3c0e07bcd5bd9ee03b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a40b412ca09b09b3c0e07bcd5bd9ee03b">is_tail_node</a> (<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a40b412ca09b09b3c0e07bcd5bd9ee03b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a node is a tail node.  <a href="#a40b412ca09b09b3c0e07bcd5bd9ee03b">More...</a><br/></td></tr>
<tr class="separator:a40b412ca09b09b3c0e07bcd5bd9ee03b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58b227f21324d30be531088ed49b0f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af58b227f21324d30be531088ed49b0f1">is_tail_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:af58b227f21324d30be531088ed49b0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a node is a tail node.  <a href="#af58b227f21324d30be531088ed49b0f1">More...</a><br/></td></tr>
<tr class="separator:af58b227f21324d30be531088ed49b0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688cbe42750d98695114ad4ad640c1d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a688cbe42750d98695114ad4ad640c1d3">collect_subgraph</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;subgraph)</td></tr>
<tr class="memdesc:a688cbe42750d98695114ad4ad640c1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the subgraph of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a>. TODO: what does that mean?  <a href="#a688cbe42750d98695114ad4ad640c1d3">More...</a><br/></td></tr>
<tr class="separator:a688cbe42750d98695114ad4ad640c1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817384b8d147371448ad60e1db097b52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a817384b8d147371448ad60e1db097b52">join_heads</a> (void)</td></tr>
<tr class="memdesc:a817384b8d147371448ad60e1db097b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join head nodes of graph to common null node, creating a new single head.  <a href="#a817384b8d147371448ad60e1db097b52">More...</a><br/></td></tr>
<tr class="separator:a817384b8d147371448ad60e1db097b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc40377520118436b729cd68be16d0ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#adc40377520118436b729cd68be16d0ba">join_heads</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, bool from_start=false)</td></tr>
<tr class="memdesc:adc40377520118436b729cd68be16d0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join head nodes of graph to specified node. Optionally from the start/to the end of the new node.  <a href="#adc40377520118436b729cd68be16d0ba">More...</a><br/></td></tr>
<tr class="separator:adc40377520118436b729cd68be16d0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e3f7942afd3ca82bfb78083c245146"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a33e3f7942afd3ca82bfb78083c245146">join_tails</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, bool to_end=false)</td></tr>
<tr class="memdesc:a33e3f7942afd3ca82bfb78083c245146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join tail nodes of graph to specified node. Optionally from the start/to the end of the new node.  <a href="#a33e3f7942afd3ca82bfb78083c245146">More...</a><br/></td></tr>
<tr class="separator:a33e3f7942afd3ca82bfb78083c245146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2239c89d6ac7e9dec0d76325c2a68f97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2239c89d6ac7e9dec0d76325c2a68f97">wrap_with_null_nodes</a> (void)</td></tr>
<tr class="memdesc:a2239c89d6ac7e9dec0d76325c2a68f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add singular head and tail null nodes to graph.  <a href="#a2239c89d6ac7e9dec0d76325c2a68f97">More...</a><br/></td></tr>
<tr class="separator:a2239c89d6ac7e9dec0d76325c2a68f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27730f354959a95c892c5ea5787fb687"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a27730f354959a95c892c5ea5787fb687">add_start_end_markers</a> (int <a class="el" href="classvg_1_1VG.html#a23641dedefa2b6d573939515fcf5974c">length</a>, char start_char, char end_char, <a class="el" href="structvg_1_1Node.html">Node</a> *&amp;start_node, <a class="el" href="structvg_1_1Node.html">Node</a> *&amp;end_node, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &amp;start_id, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &amp;end_id)</td></tr>
<tr class="separator:a27730f354959a95c892c5ea5787fb687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1Progressive"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1Progressive')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1Progressive.html">vg::Progressive</a></td></tr>
<tr class="memitem:a4eb5050eb36ed519cbfa398748ef183b inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a4eb5050eb36ed519cbfa398748ef183b">preload_progress</a> (const string &amp;message)</td></tr>
<tr class="separator:a4eb5050eb36ed519cbfa398748ef183b inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cce3f715516ed2bbb4ce3a312b01e02 inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a1cce3f715516ed2bbb4ce3a312b01e02">create_progress</a> (const string &amp;message, long count)</td></tr>
<tr class="separator:a1cce3f715516ed2bbb4ce3a312b01e02 inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d4e92a36a277be5bc0cee5d01f5ca1 inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a75d4e92a36a277be5bc0cee5d01f5ca1">create_progress</a> (long count)</td></tr>
<tr class="separator:a75d4e92a36a277be5bc0cee5d01f5ca1 inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d64e6aa69bc094c163f4827602a302c inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a0d64e6aa69bc094c163f4827602a302c">update_progress</a> (long i)</td></tr>
<tr class="separator:a0d64e6aa69bc094c163f4827602a302c inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1de11917caf25974a02e2f5c3946280 inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#ab1de11917caf25974a02e2f5c3946280">increment_progress</a> ()</td></tr>
<tr class="separator:ab1de11917caf25974a02e2f5c3946280 inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab8c6ae92870077bb59f86a15c8d18f inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#aaab8c6ae92870077bb59f86a15c8d18f">destroy_progress</a> (void)</td></tr>
<tr class="separator:aaab8c6ae92870077bb59f86a15c8d18f inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1PathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1PathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1PathHandleGraph.html">vg::PathHandleGraph</a></td></tr>
<tr class="memitem:a373e2c9973e81d20269cf2ad9dde985d inherit pub_methods_classvg_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PathHandleGraph.html#a373e2c9973e81d20269cf2ad9dde985d">is_empty</a> (const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const </td></tr>
<tr class="memdesc:a373e2c9973e81d20269cf2ad9dde985d inherit pub_methods_classvg_1_1PathHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given path is empty, and false otherwise.  <a href="#a373e2c9973e81d20269cf2ad9dde985d">More...</a><br/></td></tr>
<tr class="separator:a373e2c9973e81d20269cf2ad9dde985d inherit pub_methods_classvg_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51a6d2b2904c2a6214dcdcb4fec9a8a2 inherit pub_methods_classvg_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PathHandleGraph.html#a51a6d2b2904c2a6214dcdcb4fec9a8a2">for_each_occurrence_in_path</a> (const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;path, const function&lt; void(const <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;)&gt; &amp;iteratee) const </td></tr>
<tr class="memdesc:a51a6d2b2904c2a6214dcdcb4fec9a8a2 inherit pub_methods_classvg_1_1PathHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over all the occurrences along a path, from first through last.  <a href="#a51a6d2b2904c2a6214dcdcb4fec9a8a2">More...</a><br/></td></tr>
<tr class="separator:a51a6d2b2904c2a6214dcdcb4fec9a8a2 inherit pub_methods_classvg_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1HandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1HandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1HandleGraph.html">vg::HandleGraph</a></td></tr>
<tr class="memitem:a8f125524a5f48b6649afcf7f9d148853 inherit pub_methods_classvg_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a8f125524a5f48b6649afcf7f9d148853 inherit pub_methods_classvg_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1HandleGraph.html#a8f125524a5f48b6649afcf7f9d148853">follow_edges</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, T &amp;&amp;iteratee) const -&gt; typename std::enable_if&lt; std::is_void&lt; decltype(iteratee(<a class="el" href="classvg_1_1HandleGraph.html#a4494fdac542d1003881c5c4d0af653f5">get_handle</a>(0, false)))&gt;::value &gt;::type</td></tr>
<tr class="separator:a8f125524a5f48b6649afcf7f9d148853 inherit pub_methods_classvg_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d0856da0aa5c07e104ad067294c7214 inherit pub_methods_classvg_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2d0856da0aa5c07e104ad067294c7214 inherit pub_methods_classvg_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1HandleGraph.html#a2d0856da0aa5c07e104ad067294c7214">for_each_handle</a> (T &amp;&amp;iteratee, bool parallel=false) const -&gt; typename std::enable_if&lt; std::is_void&lt; decltype(iteratee(<a class="el" href="classvg_1_1HandleGraph.html#a4494fdac542d1003881c5c4d0af653f5">get_handle</a>(0, false)))&gt;::value &gt;::type</td></tr>
<tr class="separator:a2d0856da0aa5c07e104ad067294c7214 inherit pub_methods_classvg_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93a545944215ba9654d3be7f716cad4 inherit pub_methods_classvg_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HandleGraph.html#aa93a545944215ba9654d3be7f716cad4">get_handle</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit) const </td></tr>
<tr class="separator:aa93a545944215ba9654d3be7f716cad4 inherit pub_methods_classvg_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89eb63ad01cbb2e816a808d617b4536c inherit pub_methods_classvg_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HandleGraph.html#a89eb63ad01cbb2e816a808d617b4536c">to_visit</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a89eb63ad01cbb2e816a808d617b4536c inherit pub_methods_classvg_1_1HandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a Protobuf <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl. ">Visit</a> from a handle.  <a href="#a89eb63ad01cbb2e816a808d617b4536c">More...</a><br/></td></tr>
<tr class="separator:a89eb63ad01cbb2e816a808d617b4536c inherit pub_methods_classvg_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fa7d284e5a5277a61dc021a92ca98b2 inherit pub_methods_classvg_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HandleGraph.html#a0fa7d284e5a5277a61dc021a92ca98b2">forward</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;handle) const </td></tr>
<tr class="memdesc:a0fa7d284e5a5277a61dc021a92ca98b2 inherit pub_methods_classvg_1_1HandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the locally forward version of a handle.  <a href="#a0fa7d284e5a5277a61dc021a92ca98b2">More...</a><br/></td></tr>
<tr class="separator:a0fa7d284e5a5277a61dc021a92ca98b2 inherit pub_methods_classvg_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1745a25509fdc440bbd4aa5438419464 inherit pub_methods_classvg_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a6225846768d2b6dbbbefab9e240a9e02">edge_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HandleGraph.html#a1745a25509fdc440bbd4aa5438419464">edge_handle</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;right) const </td></tr>
<tr class="separator:a1745a25509fdc440bbd4aa5438419464 inherit pub_methods_classvg_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa615a87264a5dca19767805ed39758d inherit pub_methods_classvg_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HandleGraph.html#afa615a87264a5dca19767805ed39758d">traverse_edge_handle</a> (const <a class="el" href="namespacevg.html#a6225846768d2b6dbbbefab9e240a9e02">edge_t</a> &amp;edge, const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;left) const </td></tr>
<tr class="separator:afa615a87264a5dca19767805ed39758d inherit pub_methods_classvg_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65b8e2e73873e73dd0448949dd09f795 inherit pub_methods_classvg_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HandleGraph.html#a65b8e2e73873e73dd0448949dd09f795">for_each_edge</a> (const function&lt; bool(const <a class="el" href="namespacevg.html#a6225846768d2b6dbbbefab9e240a9e02">edge_t</a> &amp;)&gt; &amp;iteratee, bool parallel=false) const </td></tr>
<tr class="separator:a65b8e2e73873e73dd0448949dd09f795 inherit pub_methods_classvg_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1DeletableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1DeletableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1DeletableHandleGraph.html">vg::DeletableHandleGraph</a></td></tr>
<tr class="memitem:a44599a2826bbce64bdfdc9a852da0e15 inherit pub_methods_classvg_1_1DeletableHandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DeletableHandleGraph.html#a44599a2826bbce64bdfdc9a852da0e15">destroy_edge</a> (const <a class="el" href="namespacevg.html#a6225846768d2b6dbbbefab9e240a9e02">edge_t</a> &amp;edge)</td></tr>
<tr class="memdesc:a44599a2826bbce64bdfdc9a852da0e15 inherit pub_methods_classvg_1_1DeletableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper for destroy_edge.  <a href="#a44599a2826bbce64bdfdc9a852da0e15">More...</a><br/></td></tr>
<tr class="separator:a44599a2826bbce64bdfdc9a852da0e15 inherit pub_methods_classvg_1_1DeletableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1MutableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1MutableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1MutableHandleGraph.html">vg::MutableHandleGraph</a></td></tr>
<tr class="memitem:a6a43778a31cb0169c956eafa6d658a1c inherit pub_methods_classvg_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MutableHandleGraph.html#a6a43778a31cb0169c956eafa6d658a1c">create_edge</a> (const <a class="el" href="namespacevg.html#a6225846768d2b6dbbbefab9e240a9e02">edge_t</a> &amp;edge)</td></tr>
<tr class="memdesc:a6a43778a31cb0169c956eafa6d658a1c inherit pub_methods_classvg_1_1MutableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper for create_edge.  <a href="#a6a43778a31cb0169c956eafa6d658a1c">More...</a><br/></td></tr>
<tr class="separator:a6a43778a31cb0169c956eafa6d658a1c inherit pub_methods_classvg_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa16d4d335419ea2a7377187eb2520011 inherit pub_methods_classvg_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structvg_1_1handle__t.html">handle_t</a>, <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MutableHandleGraph.html#aa16d4d335419ea2a7377187eb2520011">divide_handle</a> (const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;handle, size_t <a class="el" href="namespacevg.html#a416939020600ce2996331c350f1fe68c">offset</a>)</td></tr>
<tr class="memdesc:aa16d4d335419ea2a7377187eb2520011 inherit pub_methods_classvg_1_1MutableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of divide_handle for a single division point.  <a href="#aa16d4d335419ea2a7377187eb2520011">More...</a><br/></td></tr>
<tr class="separator:aa16d4d335419ea2a7377187eb2520011 inherit pub_methods_classvg_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4772c77ed932bfed4d21e247918381a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a4772c77ed932bfed4d21e247918381a4">graph</a></td></tr>
<tr class="memdesc:a4772c77ed932bfed4d21e247918381a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protobuf-based representation.  <a href="#a4772c77ed932bfed4d21e247918381a4">More...</a><br/></td></tr>
<tr class="separator:a4772c77ed932bfed4d21e247918381a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5150aba84e7ed2bde7986462a79989"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Paths.html">Paths</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7c5150aba84e7ed2bde7986462a79989">paths</a></td></tr>
<tr class="separator:a7c5150aba84e7ed2bde7986462a79989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6fcd5a907e9bee524cf37a62ad5be2"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1f6fcd5a907e9bee524cf37a62ad5be2">name</a></td></tr>
<tr class="memdesc:a1f6fcd5a907e9bee524cf37a62ad5be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the graph.  <a href="#a1f6fcd5a907e9bee524cf37a62ad5be2">More...</a><br/></td></tr>
<tr class="separator:a1f6fcd5a907e9bee524cf37a62ad5be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93f069b1a683a86ff2981a7f340ac009"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a93f069b1a683a86ff2981a7f340ac009">current_id</a></td></tr>
<tr class="memdesc:a93f069b1a683a86ff2981a7f340ac009"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current id for <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> to be added next.  <a href="#a93f069b1a683a86ff2981a7f340ac009">More...</a><br/></td></tr>
<tr class="separator:a93f069b1a683a86ff2981a7f340ac009"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf9360fb7acb595296f55cb445f87543"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aaf9360fb7acb595296f55cb445f87543">node_by_id</a></td></tr>
<tr class="memdesc:aaf9360fb7acb595296f55cb445f87543"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a></code>s by id.  <a href="#aaf9360fb7acb595296f55cb445f87543">More...</a><br/></td></tr>
<tr class="separator:aaf9360fb7acb595296f55cb445f87543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab754d45647580a21216bd010b72c6815"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1pair__hash__map.html">pair_hash_map</a>&lt; pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <br class="typebreak"/>
<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;, <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab754d45647580a21216bd010b72c6815">edge_by_sides</a></td></tr>
<tr class="separator:ab754d45647580a21216bd010b72c6815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce9aecf57e0684821ee277d983eb248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="structvg_1_1Node.html">Node</a> *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2ce9aecf57e0684821ee277d983eb248">node_index</a></td></tr>
<tr class="separator:a2ce9aecf57e0684821ee277d983eb248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2c02a8216f0bb9b3a78e985845ea1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2e2c02a8216f0bb9b3a78e985845ea1b">edge_index</a></td></tr>
<tr class="separator:a2e2c02a8216f0bb9b3a78e985845ea1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5eda797a26ee9d8c217527d77554e2ab"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, vector&lt; pair<br class="typebreak"/>
&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5eda797a26ee9d8c217527d77554e2ab">edges_on_start</a></td></tr>
<tr class="memdesc:a5eda797a26ee9d8c217527d77554e2ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the destinations and backward flags for edges attached to the starts of nodes (whether that node is "from" or "to").  <a href="#a5eda797a26ee9d8c217527d77554e2ab">More...</a><br/></td></tr>
<tr class="separator:a5eda797a26ee9d8c217527d77554e2ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947ad1a02ca5be020879d56976a00e2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, vector&lt; pair<br class="typebreak"/>
&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a947ad1a02ca5be020879d56976a00e2a">edges_on_end</a></td></tr>
<tr class="memdesc:a947ad1a02ca5be020879d56976a00e2a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the destinations and backward flags for edges attached to the ends of nodes (whether that node is "from" or "to").  <a href="#a947ad1a02ca5be020879d56976a00e2a">More...</a><br/></td></tr>
<tr class="separator:a947ad1a02ca5be020879d56976a00e2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac697184acf2edadca58ddc776f9f4e7e"><td class="memItemLeft" align="right" valign="top">map&lt; string, <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac697184acf2edadca58ddc776f9f4e7e">variant_to_traversal</a></td></tr>
<tr class="separator:ac697184acf2edadca58ddc776f9f4e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classvg_1_1Progressive"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classvg_1_1Progressive')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classvg_1_1Progressive.html">vg::Progressive</a></td></tr>
<tr class="memitem:a6653625f496832c4cb8711185d5e04cb inherit pub_attribs_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a6653625f496832c4cb8711185d5e04cb">show_progress</a> = false</td></tr>
<tr class="separator:a6653625f496832c4cb8711185d5e04cb inherit pub_attribs_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aaf5016c5e5d28db6db32aa7626440238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aaf5016c5e5d28db6db32aa7626440238">_for_each_kmer</a> (int kmer_size, bool path_only, int edge_max, function&lt; void(string &amp;, list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;::iterator, int, list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;)&gt; lambda, bool parallel, int stride, bool allow_dups, bool allow_negatives, <a class="el" href="structvg_1_1Node.html">Node</a> *node=nullptr)</td></tr>
<tr class="separator:aaf5016c5e5d28db6db32aa7626440238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6179a1c150509895e543c07e785a7fd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a6179a1c150509895e543c07e785a7fd5">align</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *aligner, <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *qual_adj_aligner, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0, bool multithreaded_xdrop=false, bool print_score_matrices=false)</td></tr>
<tr class="separator:a6179a1c150509895e543c07e785a7fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd0f191fe33bd4590f15f309d0fd89c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aafd0f191fe33bd4590f15f309d0fd89c">init</a> (void)</td></tr>
<tr class="separator:aafd0f191fe33bd4590f15f309d0fd89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a5c70121b4a8463c118b9c90c7090b28f"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5c70121b4a8463c118b9c90c7090b28f">empty_ids</a></td></tr>
<tr class="memdesc:a5c70121b4a8463c118b9c90c7090b28f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for functions that sometimes need to be passed an empty vector.  <a href="#a5c70121b4a8463c118b9c90c7090b28f">More...</a><br/></td></tr>
<tr class="separator:a5c70121b4a8463c118b9c90c7090b28f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f32ef3d653601d2fcac5c1b31de0abb"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a9f32ef3d653601d2fcac5c1b31de0abb">empty_edge_ends</a></td></tr>
<tr class="memdesc:a9f32ef3d653601d2fcac5c1b31de0abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for functions that sometimes need to be passed an empty vector.  <a href="#a9f32ef3d653601d2fcac5c1b31de0abb">More...</a><br/></td></tr>
<tr class="separator:a9f32ef3d653601d2fcac5c1b31de0abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a variation graph. Graphs consist of nodes, connected by edges. Graphs are bidirected and may be cyclic. Nodes carry forward-oriented sequences. Edges are directed, with a "from" and to" node, and are generally
used to connect the end of the "from" node to the start of the "to" node. However, edges can connect to either the start or end of either node. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ac2399de59931e282fb1f4d3da9a8dcb1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a class="anchor" id="a2dc9648985454d3aedd9a477ff0c52b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showp</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn_on_duplicates</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from protobufs. </p>

</div>
</div>
<a class="anchor" id="a6479a304ef4b265a6339f9549e9ac0c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype">function&lt; bool(<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>get_next_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showp</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn_on_duplicates</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from an arbitrary source of <a class="el" href="structvg_1_1Graph.html">Graph</a> protobuf messages (which populates the given <a class="el" href="structvg_1_1Graph.html">Graph</a> and returns a flag for whether it's valid). </p>

</div>
</div>
<a class="anchor" id="af4d321b31b873153431c261090d052af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showp</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn_on_duplicates</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from a single Protobuf graph. The same as making an empty <a class="el" href="classvg_1_1VG.html">VG</a> and using <a class="el" href="classvg_1_1VG.html#a2519c3b939f48bca226e6fdea4c91f9d">extend()</a>. </p>

</div>
</div>
<a class="anchor" id="abeafee2d3bc6e0039e99fccdea10f4f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype">set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from sets of nodes and edges. For example, from a subgraph of another graph. </p>

</div>
</div>
<a class="anchor" id="a7513ddb88aeb58bd85a810c2a2ccdf67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::~VG </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a class="anchor" id="a3148455330df9ac055c6bd1eb7da3167"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a class="anchor" id="ab8365ccd6a093ec50f7d54b1c7a7c672"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aaf5016c5e5d28db6db32aa7626440238"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::_for_each_kmer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kmer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>path_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(string &amp;, list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;::iterator, int, list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_dups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call the given function on each kmer. If parallel is specified, goes through nodes one per thread. If node is not null, looks only at kmers of that specific node. </p>

</div>
</div>
<a class="anchor" id="a613c931c81518212917053d07e9bf8a8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given edge, by value. </p>

</div>
</div>
<a class="anchor" id="a7f23cdd532ca7b8d3c0bb9cceff3d378"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_edges </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given edges, by value. </p>

</div>
</div>
<a class="anchor" id="a679e39a7c1771c3ecc7204bd3b999583"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_edges </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given edges, by value. </p>

</div>
</div>
<a class="anchor" id="acb8712eefbfd373c45f54d6bac8188c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_edges </td>
          <td>(</td>
          <td class="paramtype">const set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given edges, by value. </p>

</div>
</div>
<a class="anchor" id="ad3e265ee441758d81fdb7c038e2fa8cc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given node, by value. </p>

</div>
</div>
<a class="anchor" id="ae71d30b767f067a874c933f13f6c34e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_nodes </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given nodes, by value. </p>

</div>
</div>
<a class="anchor" id="ab796330d50fdff47f5c080e251efea68"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_nodes </td>
          <td>(</td>
          <td class="paramtype">const set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given nodes, by value. </p>

</div>
</div>
<a class="anchor" id="a841b4f3a9dc5641c7646e2b6ab03aaac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::VG::add_nodes_and_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; pair&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, string &gt;, vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>added_seqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; <a class="el" href="structvg_1_1Node.html">Node</a> *, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>added_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig_node_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dangling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_node_size</em> = <code>1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a path on nodes that may or may not exist, and a map from start position in the old graph to a node in the current graph, add all the new sequence and edges required by the path. The given path must not contain adjacent perfect match edits in the same mapping, or any deletions on the start or end of mappings (the removal of which can be accomplished with the <a class="el" href="namespacevg.html#a486054f13a4dc43e37c0f0131f6a51ad">Path::simplify()</a> function).</p>
<p>Outputs (and caches for subsequent calls) novel node runs in added_seqs, and <a class="el" href="classvg_1_1Paths.html">Paths</a> describing where novel nodes translate back to in the original graph in added_nodes. Also needs a map of the original sizes of nodes deleted from the original graph, for reverse complementing. If dangling is nonempty, left edges of nodes created for initial inserts will connect to the specified sides. At the end, dangling is populated with the side corresponding to the last edit in the path.</p>
<p>Returns a fully embedded version of the path, after all node insertions, divisions, and translations. </p>

</div>
</div>
<a class="anchor" id="a05bb4c469f870e8181ac72550a1e1a82"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::VG::add_nodes_and_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; pair&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, string &gt;, vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>added_seqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; <a class="el" href="structvg_1_1Node.html">Node</a> *, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>added_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig_node_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_node_size</em> = <code>1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version doesn't require a set of dangling sides to populate. </p>

</div>
</div>
<a class="anchor" id="a27730f354959a95c892c5ea5787fb687"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_start_end_markers </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>start_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>end_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>end_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>start_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>end_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a start node and an end node, where all existing heads in the graph are connected to the start node, and all existing tails in the graph are connected to the end node. Any connected components in the graph which do not have either are connected to the start at an arbitrary point, and the end node from nodes going to that arbitrary point. If start_node or end_node is null, a new node will be created. Otherwise, the passed node will be used. Note that this visits every node, to make sure it is attached to all connected components. Note that if a graph has, say, heads but no tails, the start node will be attached buut the end node will be free-floating. </p>

</div>
</div>
<a class="anchor" id="ab213a64c6240d08603530982c0b75047"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::adjacent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if pos1 occurs directly before pos2. </p>

</div>
</div>
<a class="anchor" id="a1b6a43b2e456d0e9e17f3e7f8d3b4478"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multithreaded_xdrop</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align without base quality adjusted scores. Align to the graph. May modify the graph by re-ordering the nodes. May add nodes to the graph, but cleans them up afterward. </p>

</div>
</div>
<a class="anchor" id="a4bad7dd2c8179b37694e80e2e191d515"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multithreaded_xdrop</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align without base quality adjusted scores. Align to the graph. May modify the graph by re-ordering the nodes. May add nodes to the graph, but cleans them up afterward. </p>

</div>
</div>
<a class="anchor" id="a077755b905705f812643d91af60bbc2c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multithreaded_xdrop</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a66f810b0e599dc056a7de5f69fe41c8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multithreaded_xdrop</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align with default <a class="el" href="classvg_1_1Aligner.html">Aligner</a>. Align to the graph. May modify the graph by re-ordering the nodes. May add nodes to the graph, but cleans them up afterward. </p>

</div>
</div>
<a class="anchor" id="a44e5c2abb453e19753210bca93555408"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multithreaded_xdrop</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align with default <a class="el" href="classvg_1_1Aligner.html">Aligner</a>. Align to the graph. May modify the graph by re-ordering the nodes. May add nodes to the graph, but cleans them up afterward. </p>

</div>
</div>
<a class="anchor" id="a6179a1c150509895e543c07e785a7fd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td>
          <td class="paramname"><em>qual_adj_aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multithreaded_xdrop</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Private method to funnel other align functions into. max_span specifies the min distance to unfold the graph to, and is meant to be the longest path that the specified sequence could cover, accounting for deletions. If it's less than the sequence's length, the sequence's length is used. band_padding_override gives the band padding to use for banded global alignment. In banded global mode, if the band padding override is nonzero, permissive banding is not used, and instead the given band padding is provided. If the band padding override is not provided, the max span is used as the band padding and permissive banding is enabled. </p>

</div>
</div>
<a class="anchor" id="a4e6e37a281459834547a74974393fbe7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align_qual_adjusted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td>
          <td class="paramname"><em>qual_adj_aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multithreaded_xdrop</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align with base quality adjusted scores. Align to the graph. May modify the graph by re-ordering the nodes. May add nodes to the graph, but cleans them up afterward. </p>

</div>
</div>
<a class="anchor" id="a5c4e8a8a3c83b48cd7a213420f2c3f5a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align_qual_adjusted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td>
          <td class="paramname"><em>qual_adj_aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multithreaded_xdrop</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0f1c02fc3a1a438240d42fcc5b5081b7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align_qual_adjusted </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td>
          <td class="paramname"><em>qual_adj_aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>multithreaded_xdrop</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_score_matrices</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align with base quality adjusted scores. Align to the graph. May modify the graph by re-ordering the nodes. May add nodes to the graph, but cleans them up afterward. </p>

</div>
</div>
<a class="anchor" id="a5272032c1e57d839176fc8e39bd87e18"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add another graph into this graph, attaching tails to heads. Modify ids of the second graph to ensure we don't have conflicts. Then attach tails of this graph to the heads of the other, and extend(g). </p>

</div>
</div>
<a class="anchor" id="aa27ce8091357377810e01f45bc783e49"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> vg::VG::append_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to_append</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a visit to a node to the given path. </p>

<p>Implements <a class="el" href="classvg_1_1MutablePathHandleGraph.html#af876e799ddde6285646957452753f7ed">vg::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ab5ee06ac168f037f2cff3b332079b49c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1handle__t.html">handle_t</a> vg::VG::apply_orientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alter the node that the given handle corresponds to so the orientation indicated by the handle becomes the node's local forward orientation. Rewrites all edges pointing to the node and the node's sequence to reflect this. Invalidates all handles to the node (including the one passed). Returns a new, valid handle to the node in its new forward orientation. Note that it is possible for the node's ID to change. </p>

<p>Implements <a class="el" href="classvg_1_1MutableHandleGraph.html#ae11f07b5471c7ad209d8fadecb59a936">vg::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a6f838bd143f7909838bf2139b15576ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> vg::VG::backtracking_unroll </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a new graph that unrolls the current one using backtracking. Caution: exponential in branching. </p>

</div>
</div>
<a class="anchor" id="ad7604b2833cf3e0855c5c29619f4a270"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::bluntify </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove redundant overlaps. </p>

</div>
</div>
<a class="anchor" id="a93cb2d6686e0bb92d7f0b632fc813702"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; vg::VG::break_cycles </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use our topological sort to quickly break cycles in the graph, return the edges which are removed. Very non-optimal, but fast. </p>

</div>
</div>
<a class="anchor" id="a3fb2cb59474393ac822847033f185d17"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::build_edge_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af63d4a22a3baa5b21623128b81a14872"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::build_edge_indexes_no_init_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7f71911fe2c652dc11aec0a0d705b1e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::build_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa78095fb5d27e182c5cc4d5c10d3da39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::build_indexes_no_init_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5156da43d4175597d7a8b1d88b5179af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::build_node_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0ca442744267b08609887cd842ca543d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::build_node_indexes_no_init_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aeabcaa5e19486dbab418184a312d9777"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::circularize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Circularize a subgraph / path using the head / tail nodes. </p>

</div>
</div>
<a class="anchor" id="ad96ff883534a13b28b18cd84dd094e72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::circularize </td>
          <td>(</td>
          <td class="paramtype">vector&lt; string &gt;&#160;</td>
          <td class="paramname"><em>pathnames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa1eb3332c0a99a25c75681da485297e5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all nodes and edges. Does not update any stored paths. </p>

<p>Implements <a class="el" href="classvg_1_1DeletableHandleGraph.html#aca6a64c9e7f41c4077febbb8c231b58d">vg::DeletableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a10d4b49633db2aef463e0070e0af64a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_edge_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5195712f8aa650417d93324ff1c89ecf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_edge_indexes_no_resize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aae960ce1d640fadc4772795f6d0ff5b5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a103c69bad02121590779530338861374"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_indexes_no_resize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a212a2d1028f28046088a86e128b40559"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_node_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af51220e88887adf92d7cff25dad5cd91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_node_indexes_no_resize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa4e534461834b2937b7f0b0c2420b899"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_paths </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the paths object (which indexes the graph.paths) and the graph paths themselves. </p>

</div>
</div>
<a class="anchor" id="a688cbe42750d98695114ad4ad640c1d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::collect_subgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the subgraph of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a>. TODO: what does that mean? </p>

</div>
</div>
<a class="anchor" id="a7d06218f137184c366de80df755ae001"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add another graph into this graph. Don't append or join the nodes in the graphs; just ensure that ids are unique, then apply extend. </p>

</div>
</div>
<a class="anchor" id="a95d087adcf01ebfa68541bc6f487278e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> vg::VG::common_ancestor_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>steps</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find a common ancestor by walking forward up to steps from the first node. </p>

</div>
</div>
<a class="anchor" id="a156ee8c5d3650f08ab4d806980d6926a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> vg::VG::common_ancestor_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>steps</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find a common ancestor by walking back up to steps from the first node. </p>

</div>
</div>
<a class="anchor" id="a161ef56bd0eeee937602f60b8617f24d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::compact_ids </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Squish the node IDs down into as small a space as possible. Fixes up paths itself. </p>

</div>
</div>
<a class="anchor" id="a153260c1839238abff26b2e989d8799d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;string, vector&lt;<a class="el" href="classvg_1_1mapping__t.html">mapping_t</a>&gt; &gt; vg::VG::concat_mappings_for_node_pair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate the mappings for a pair of nodes; handles multiple mappings per path. </p>

</div>
</div>
<a class="anchor" id="a2367b4d49cca4c57a2529d92512cba59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, vector&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt; &gt; vg::VG::concat_mappings_for_nodes </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenate mappings for a list of nodes that we want to concatenate. Returns, for each path name, a vector of merged mappings, once per path traversal of the run of nodes. Those merged mappings are in the orientation of the merged node (so mappings to nodes that are traversed in reverse will have their flags toggled). We assume that all mappings on the given nodes are full-length perfect matches, and that all the nodes are perfect path neighbors. </p>

</div>
</div>
<a class="anchor" id="a64d37ff935d8881dcf03010187e1ceb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::concat_nodes </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Concatenates the nodes into a new node with the same external linkage as the provided component. After calling this, paths will be invalid until <a class="el" href="classvg_1_1Paths.html#aaf065b12a8a942c96f6d88a2c6db7c8e">Paths::compact_ranks()</a> is called. </p>

</div>
</div>
<a class="anchor" id="ad68d2bfaa6627686967add4ca7fb5f4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::connect_node_to_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect node -&gt; nodes. Connects from the right side of the first to the left side of the second. </p>

</div>
</div>
<a class="anchor" id="ab8189716ecbb9eeeefec8be64e34a9e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::connect_node_to_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_start</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect node -&gt; nodes. You can optionally use the start of the first node instead of the end. </p>

</div>
</div>
<a class="anchor" id="a7ee6066424793dfcda9097419f03b568"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::connect_nodes_to_node </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>connect nodes -&gt; node. Connects from the right side of the first to the left side of the second. </p>

</div>
</div>
<a class="anchor" id="acc4db5878a40e8dc7d2d2b25ff62ff1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::connect_nodes_to_node </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_end</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>connect nodes -&gt; node. </p>

</div>
</div>
<a class="anchor" id="a8922810d5228ab5c4619eb2ddc16e78b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::create_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an edge connecting the given handles in the given order and orientations. </p>

<p>Implements <a class="el" href="classvg_1_1MutableHandleGraph.html#a0d9cb79c32996386b0cb3f4582772a36">vg::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a8ecb9833a1b3e7d5ca41fcaa96000976"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::create_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_start</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_end</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an edge. If the given edge cannot be created, returns null. If the given edge already exists, returns the existing edge. </p>

</div>
</div>
<a class="anchor" id="aaea0ac806a69899322f10155d5def595"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::create_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_start</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_end</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an edge. If the given edge cannot be created, returns null. If the given edge already exists, returns the existing edge. </p>

</div>
</div>
<a class="anchor" id="a8fd0565d5133a239856444049783edcd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::create_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a left-to-right edge from the left <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> to the right one, respecting orientations. If the given edge cannot be created, returns null. If the given edge already exists, returns the existing edge. </p>

</div>
</div>
<a class="anchor" id="ac2cd4705aa5b919f349d02089c97cbc2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::create_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td>
          <td class="paramname"><em>side1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td>
          <td class="paramname"><em>side2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make an edge connecting the given sides of nodes. If the given edge cannot be created, returns null. If the given edge already exists, returns the existing edge. </p>

</div>
</div>
<a class="anchor" id="a54ad97e46dc1297b1a65a32697e2d37e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1handle__t.html">handle_t</a> vg::VG::create_handle </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new node with the given sequence and return the handle. </p>

<p>Implements <a class="el" href="classvg_1_1MutableHandleGraph.html#a51c65a199b04930371968bfd71179f21">vg::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ae968a71f586b6cc3876f2e9452f4c576"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1handle__t.html">handle_t</a> vg::VG::create_handle </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a new node with the given id and sequence, then return the handle. </p>

<p>Implements <a class="el" href="classvg_1_1MutableHandleGraph.html#a777dd0a8b47a17885d507d4dde61fb26">vg::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a8cb95ac1c24c5263a962c13f3d6bc0c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::create_node </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a node. Use the <a class="el" href="classvg_1_1VG.html">VG</a> class to generate ids. </p>

</div>
</div>
<a class="anchor" id="a5736bb79bf9bcb96ea21c6945c61dcfb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::create_node </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a node. Use a specified, nonzero node ID. </p>

</div>
</div>
<a class="anchor" id="a3195bfadb7e65e4952c4b98d51e862f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::VG::create_path </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a path. </p>

</div>
</div>
<a class="anchor" id="adc07ec73a57485a700e621517c962b8b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::VG::create_path </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a path. </p>

</div>
</div>
<a class="anchor" id="a4bcd5d003953bbec11cd6162e53bb974"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> vg::VG::create_path_handle </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a path with the given name. </p>

<p>Implements <a class="el" href="classvg_1_1MutablePathHandleGraph.html#a27bae43aecdfdda8e5cd7eacbfee3c95">vg::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a7958e987d875acb903acabf9903a8a88"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> vg::VG::dagify </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>expand_scc_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>target_min_walk_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>component_length_max</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turn the graph into a dag by copying strongly connected components expand_scc_steps times and translating the edges in the component to flow through the copies in one direction. Assumes that all nodes in the graph are articulated on one consistent strand. Tolerates doubly-reversing edges in the input graph. </p>

</div>
</div>
<a class="anchor" id="a356612f42ba60fe5895f3abe7501173a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::decrement_node_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>decrement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract the given value from all the node IDs. Must not create a node with 0 or negative IDs. Invalidates the paths. </p>

</div>
</div>
<a class="anchor" id="a9d4264e39e3826ded714992361ab879e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the edge connecting the given handles in the given order and orientations. </p>

<p>Implements <a class="el" href="classvg_1_1DeletableHandleGraph.html#a293bbe88a0aa08a2b5f289ad88b5f05a">vg::DeletableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a284327157f9d4b82224fc856179a668d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the edge at the given pointer. This pointer must point to an edge owned by the graph. </p>

</div>
</div>
<a class="anchor" id="abe6b91020abf39815d28995eceac4e2d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the edge between the given sides of nodes. These can be in either order. </p>

</div>
</div>
<a class="anchor" id="a7fd2744b37b62862df68e82cbe7b6b59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_edge </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sides</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the edge between the given sides of nodes. This can take sides in any order. </p>

</div>
</div>
<a class="anchor" id="a3e52875d37f046daeaf9e7b301ad59ff"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the node belonging to the given handle and all of its edges. </p>

<p>Implements <a class="el" href="classvg_1_1DeletableHandleGraph.html#ad4c283d30c7454456b808fa8e1e18c04">vg::DeletableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ab9cd34f3c968f90370c42e8692222619"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the node at the given pointer. This pointer must point to a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> owned by the graph. </p>

</div>
</div>
<a class="anchor" id="acb9f662f9241f12249331c878ade136e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the node with the given ID. </p>

</div>
</div>
<a class="anchor" id="adb25bd1fdb9e36c55157c5be864ca403"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the given path. Invalidates handles to the path and its node occurrences. </p>

<p>Implements <a class="el" href="classvg_1_1MutablePathHandleGraph.html#adce32a8a89b8bb17c53685eadb0f6514">vg::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aec0db609d022b3c3183403600970238f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::dfs </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_begin_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_end_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>break_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>tree_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_curr_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_cross_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *&#160;</td>
          <td class="paramname"><em>sinks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do a DFS search of the bidirected graph. A bidirected DFS starts at some root node, and traverses first all the nodes found reading out the right of that node in their appropriate relative orientations (including the root), and then all the nodes found reading left out of that node in their appropriate orientations (including the root). If any unvisited nodes are left in other connected components, the process will repeat from one such node, until all nodes have been visited in each orientation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_begin_fn</td><td>Called when node orientattion is first encountered. </td></tr>
    <tr><td class="paramname">node_end_fn</td><td>Called when node orientation goes out of scope. </td></tr>
    <tr><td class="paramname">break_fn</td><td>Called to check if we should stop the DFS. </td></tr>
    <tr><td class="paramname">edge_fn</td><td>Called when an edge is encountered. </td></tr>
    <tr><td class="paramname">tree_fn</td><td>Called when an edge forms part of the DFS spanning tree. </td></tr>
    <tr><td class="paramname">edge_curr_fn</td><td>Called when we meet an edge in the current tree component. </td></tr>
    <tr><td class="paramname">edge_cross_fn</td><td>Called when we meet an edge in an already-traversed tree component. </td></tr>
    <tr><td class="paramname">sources</td><td>Start only at these node traversals. </td></tr>
    <tr><td class="paramname">sinks</td><td>When hitting a sink, don't keep walking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a287e5d12ba0bc0823d1b6e0fa56af3d6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::dfs </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_begin_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_end_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *&#160;</td>
          <td class="paramname"><em>sources</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *&#160;</td>
          <td class="paramname"><em>sinks</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialization of dfs for only handling nodes. </p>

</div>
</div>
<a class="anchor" id="a8ee80f3ce939643d59157e1a1d707068"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::dfs </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_begin_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_end_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>break_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialization of dfs for only handling nodes + break function. </p>

</div>
</div>
<a class="anchor" id="a40c8fe573ad9ea52634a7e7421c143de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::dice_nodes </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_node_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Chop up the nodes. </p>

</div>
</div>
<a class="anchor" id="af31e90fe77a1d30244011dd8dbbf5f25"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::disjoint_subgraphs </td>
          <td>(</td>
          <td class="paramtype">list&lt; <a class="el" href="classvg_1_1VG.html">VG</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraphs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find subgraphs. </p>

</div>
</div>
<a class="anchor" id="a7a5dbc95fa80e7fe3dc04d62ac6d7b3c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &gt; vg::VG::divide_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a handle's underlying node at the given offsets in the handle's orientation. Returns all of the handles to the parts. Other handles to the node being split may be invalidated. The split pieces stay in the same local forward orientation as the original node, but the returned handles come in the order and orientation appropriate for the handle passed in. </p>

<p>Implements <a class="el" href="classvg_1_1MutableHandleGraph.html#ad8213ef82343d5103f2d2fa663218d1b">vg::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ad06f0fcad4bf5b1c29cf937a870a58b4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::divide_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide a node at a given internal position. Inserts the new nodes in the correct paths, but can't update the ranks, so they need to be cleared and re-calculated by the caller. </p>

</div>
</div>
<a class="anchor" id="a7bee7317e4f7e42d85d8e7ef8d07273a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::divide_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide a node at a given internal position. This version works on a collection of internal positions, in linear time. </p>

</div>
</div>
<a class="anchor" id="a1ce3b7afc274a50cd7b1296e64ca2f01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::divide_path </td>
          <td>(</td>
          <td class="paramtype">map&lt; long, <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide a path at a position. Also invalidates stored rank information. </p>

</div>
</div>
<a class="anchor" id="a7fe56e78d2178e689e623a35fcbdff2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::edge_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of edges in the graph. </p>

</div>
</div>
<a class="anchor" id="acdabb41079406d955795f2cfb72b496d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp; vg::VG::edges_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get nodes and backward flags following edges that attach to this node's end. </p>

</div>
</div>
<a class="anchor" id="aec901943e03aeae91638bce6952efc14"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp; vg::VG::edges_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get nodes and backward flags following edges that attach to this node's end. </p>

</div>
</div>
<a class="anchor" id="ae1a7e0aa663eadc0ebdaaf13b667323e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; vg::VG::edges_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edges from the specified node. </p>

</div>
</div>
<a class="anchor" id="aa1bf5492e5c6d586cd266d2a48f792df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; vg::VG::edges_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edges of the specified node. </p>

</div>
</div>
<a class="anchor" id="a5b6a5e92afb1a70d9c63a1848a01f241"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::edges_of_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the edges of the specified node, and add them to the given vector. Guaranteed to add each edge only once per call. </p>

</div>
</div>
<a class="anchor" id="a3b2d900fc42cffe079c3ba3897717eae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::edges_of_nodes </td>
          <td>(</td>
          <td class="paramtype">set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edges of the specified set of nodes, and add them to the given set of edge pointers. </p>

</div>
</div>
<a class="anchor" id="a5eaedf10280d72862aa6f0b65a3d383e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp; vg::VG::edges_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get nodes and backward flags following edges that attach to this node's start. </p>

</div>
</div>
<a class="anchor" id="ad9a9f315e43b96496fb5674df52623f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp; vg::VG::edges_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get nodes and backward flags following edges that attach to this node's start. </p>

</div>
</div>
<a class="anchor" id="a3789cf6561f2d3da5ef85f23b5c6454f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; vg::VG::edges_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edges to the specified node. </p>

</div>
</div>
<a class="anchor" id="a4355473c385843b7652d49601dd630d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; vg::VG::edit </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths_to_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>save_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>break_at_ends</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Edit the graph to include all the sequence and edges added by the given paths. Can handle paths that visit nodes in any orientation. Returns a vector of Translations, one per node existing after the edit, describing how each new or conserved node is embedded in the old graph. Note that this method sorts the graph and rebuilds the path index, so it should not be called in a loop.</p>
<p>If update_paths is true, the paths will be modified to reflect their embedding in the modified graph. If save_paths is true, the paths as embedded in the graph will be added to the graph's set of paths. If break_at_ends is true (or save_paths is true), nodes will be broken at the ends of paths that start/end woth perfect matches, so the paths can be added to the vg graph's paths object. </p>

</div>
</div>
<a class="anchor" id="a78f70eb7eddb0245be7cdfc048616638"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; vg::VG::edit_fast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dangling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_node_size</em> = <code>1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Edit the graph to include all the sequences and edges added by the given path. Returns a vector of Translations, one per original-node fragment. Completely novel nodes are not mentioned, and nodes with no Translations are assumed to be carried through unchanged. Invalidates the rank-based <a class="el" href="classvg_1_1Paths.html">Paths</a> index. Does not sort the graph. Suitable for calling in a loop.</p>
<p>Can attach newly created nodes on the left of the path to the given set of dangling NodeSides, and populates the set at the end with the <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> corresponding to the end of the path. This mechanism allows edits that hit the end of a node to be attached to what comes before/after the node by the caller, as this function doesn't handle that. </p>

</div>
</div>
<a class="anchor" id="a310f10ff59e15468e8350844465f15e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt;list&lt;<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&gt; &gt; vg::VG::elementary_cycles </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get simple cycles following Johnson's elementary cycles algorithm. </p>

</div>
</div>
<a class="anchor" id="aa778c3d1697c79aa924c5e4d1179a646"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the graph empty? </p>

</div>
</div>
<a class="anchor" id="af3cf82dca43799a03d93b199133f1d4b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::end_degree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of edges attached to the end of a node. </p>

</div>
</div>
<a class="anchor" id="a5cd6b4acbb2607a2decc9aa0f8891057"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; vg::VG::ensure_breakpoints </td>
          <td>(</td>
          <td class="paramtype">const map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breakpoints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a map from node ID to a set of offsets at which new nodes should start (which may include 0 and 1-past-the-end, which should be ignored), break the specified nodes at those positions. Returns a map from old node start position to new node pointer in the graph. Note that the caller will have to crear and rebuild path rank data.</p>
<p>Returns a map from old node start position to new node. This map contains some entries pointing to null, for positions past the ends of original nodes. It also maps from positions on either strand of the old node to the same new node pointer; the new node's forward strand is always the same as the old node's forward strand. </p>

</div>
</div>
<a class="anchor" id="a6a525e3290d6968c79314c2500f13cc3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::expand_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_paths</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_steps</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expand the context of what's already in the given graph by the given distance, either in nodes or in bases. Pulls material from this graph. </p>

</div>
</div>
<a class="anchor" id="a5ba5a5416ee9eaf67c7ae5607fc7ae1f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::expand_context_by_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_paths</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reflect</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>barriers</em> = <code>set&lt;<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expand the context of the given graph by the given number of bases. If reflect is true, bounce off the ends of nodes to get siblings of nodes you came from. Can take a set of NodeSides not to look out from, that act as barriers to context expansion. These barriers will have no edges attached to them in the final graph. </p>

</div>
</div>
<a class="anchor" id="aca4ead561b46cd1cde77ada1f611befa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::expand_context_by_steps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_paths</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand the context of the given graph by the given number of steps. </p>

</div>
</div>
<a class="anchor" id="aa9273361525befc57536dc96a762c29d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::expand_path </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expanded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand a path. TODO: what does that mean? </p>

</div>
</div>
<a class="anchor" id="ae151983cac753c02ce3852274798f8d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::expand_path </td>
          <td>(</td>
          <td class="paramtype">list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;::iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>expanded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expand a path. TODO: what does that mean? These versions handle paths in which nodes can be traversed multiple times. Unfortunately since we're throwing non-const iterators around, we can't take the input path as const. </p>

</div>
</div>
<a class="anchor" id="a2519c3b939f48bca226e6fdea4c91f9d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::extend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn_on_duplicates</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iteratively add when nodes and edges are novel. Good when there are very many overlaps. TODO: If you are using this with warn on duplicates on, and you know there shouldn't be any duplicates, maybe you should use merge instead. This version sorts paths on rank after adding in the path mappings from the other graph. </p>

</div>
</div>
<a class="anchor" id="a5e517214b33812b16f195a1f87841c0d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::extend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn_on_duplicates</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This version does not sort path mappings by rank. In order to preserve paths, call <a class="el" href="classvg_1_1Paths.html#a2970302cae3a54ef7f4296dbf49266fd">Paths::sort_by_mapping_rank()</a> and <a class="el" href="classvg_1_1Paths.html#a5f80df5846bdac0b502a70af97dc65de" title="Reassign ranks and rebuild indexes, treating the mapping lists in _paths as the truth. ">Paths::rebuild_mapping_aux()</a> after you are done adding in graphs to this graph. </p>

</div>
</div>
<a class="anchor" id="a67e451c4a4a95e15244acc4972296124"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::find_breakpoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breakpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>break_ends</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find all the points at which a <a class="el" href="structvg_1_1Path.html">Path</a> enters or leaves nodes in the graph. Adds them to the given map by node ID of sets of bases in the node that will need to become the starts of new nodes.</p>
<p>If break_ends is true, emits breakpoints at the ends of the path, even if it starts/ends with perfect matches. </p>

</div>
</div>
<a class="anchor" id="a04774a86b07508e9e5955abfba2171ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::find_node_by_name_or_add_new </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a node with the given name, or create a new one if none is found. </p>

</div>
</div>
<a class="anchor" id="a47afbf1369e36d541a0ebddfc707d934"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1handle__t.html">handle_t</a> vg::VG::flip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert the orientation of a handle (potentially without getting its ID) </p>

<p>Implements <a class="el" href="classvg_1_1HandleGraph.html#aea3f6ed1dafd6228babe0cd037ed7e99">vg::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a8e5079416ab826cbc8a5eea3869eb892"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::flip_doubly_reversed_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert edges that are both from_start and to_end to "regular" ones from end to start. </p>

</div>
</div>
<a class="anchor" id="a49fcb850d9dca13ccecb1cc63445e0c9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::follow_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the handles to next/previous (right/left) nodes. Passes them to a callback which returns false to stop iterating and true to continue. Returns true if we finished and false if we stopped early. </p>

<p>Implements <a class="el" href="classvg_1_1HandleGraph.html#a2cacd515737fabf640cfcb8ac7cc8ce7">vg::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a892abc4056e30044ae9ce0db9e4871f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_connected_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Node.html">Node</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Go through all the nodes in the same connected component as the given node. Ignores relative orientation. </p>

</div>
</div>
<a class="anchor" id="a3d7fdd8c951cbf8b25e116435b5e1e0e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_edge </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the given function for each edge. </p>

</div>
</div>
<a class="anchor" id="a0bd448b5f9115c64efdd6514cbf05ae0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_edge </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(const <a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a46a20aa427767a27fd15d181ccca8c42"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_edge_parallel </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the given function for each edge, in parallel. </p>

</div>
</div>
<a class="anchor" id="af065aeb66bd1995f1edbcd3dccaf1fa7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_handle </td>
          <td>(</td>
          <td class="paramtype">const function&lt; bool(const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the nodes in the graph in their local forward orientations, in their internal stored order. Stop if the iteratee returns false. </p>

<p>Implements <a class="el" href="classvg_1_1HandleGraph.html#ada522d0f2c88b6d71a533565a71cd404">vg::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="af585f2161de09403d197e05fbcfb9a07"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_node </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Node.html">Node</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the given function on every node. </p>

</div>
</div>
<a class="anchor" id="a8815f6165628d04e4dade8987aeeb22a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_node </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(const <a class="el" href="structvg_1_1Node.html">Node</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a39790d52fe4c09804086d58164258fcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_node_parallel </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Node.html">Node</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the given function on every node in parallel. </p>

</div>
</div>
<a class="anchor" id="ad9c52c2e527b16a61c32e759b4a0b3c3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_path_handle </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a function on each path in the graph. </p>

<p>Implements <a class="el" href="classvg_1_1PathHandleGraph.html#a8720072e51e7ffd82b8acbddcdd83dca">vg::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a9912608c8779ce01c6c6e06f86588311"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt; &gt; vg::VG::forwardize_breakpoints </td>
          <td>(</td>
          <td class="paramtype">const map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breakpoints</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flips the breakpoints onto the forward strand. </p>

</div>
</div>
<a class="anchor" id="a3c22829197fc65ced4dd2e0f53cb20ff"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::from_istream </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showp</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn_on_duplicates</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8aef48163c0dd4267d24b629de8a04c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::from_turtle </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>baseuri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a graph from a Turtle stream. </p>
<p>Add the paths that we parsed into the vg object </p>

</div>
</div>
<a class="anchor" id="ae2eb11662200dc88ef8397a1b2232056"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::full_siblings_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>trav</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full from-siblings are nodes traversals which share exactly the same downstream <code><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a></code>s. </p>

</div>
</div>
<a class="anchor" id="a0a79ae3ab132b28cf72b6c18644fcf2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::full_siblings_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>trav</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Full to-siblings are nodes traversals which share exactly the same upstream <code><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a></code>s. </p>

</div>
</div>
<a class="anchor" id="ac1a8a09a49ea348f3714377b893319f6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::get_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Efficiently get the number of edges attached to one side of a handle. Uses the <a class="el" href="classvg_1_1VG.html">VG</a> graph's internal degree index. </p>

<p>Reimplemented from <a class="el" href="classvg_1_1HandleGraph.html#a7b3e0ec1c0ec12024897e8d04727e178">vg::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a8668ddc84b9abe4fe9cb5acb3efd877b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::get_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the specified edge. This can take sides in any order. </p>

</div>
</div>
<a class="anchor" id="a227023072262f46f7c423d30cf8bc443"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::get_edge </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sides</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the specified edge. This can take sides in any order. </p>

</div>
</div>
<a class="anchor" id="af63d7ba7b69594ee99f3ad99dd394171"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::get_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edge connecting the given oriented nodes in the given order. </p>

</div>
</div>
<a class="anchor" id="adff0e1716e97115deacaf3115786db5b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> vg::VG::get_first_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a handle to the first occurrence in a path. </p>

<p>Implements <a class="el" href="classvg_1_1PathHandleGraph.html#a09350720bbcfe65db7d11363dfc92473">vg::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a26a218b188035e086a5625170cfcf23c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1handle__t.html">handle_t</a> vg::VG::get_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &amp;&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the handle for the node with the given ID in the given orientation. </p>

<p>Implements <a class="el" href="classvg_1_1HandleGraph.html#a4494fdac542d1003881c5c4d0af653f5">vg::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a275f9a67d357980049ff3a6cb475a0a6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> vg::VG::get_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID from a handle. </p>

<p>Implements <a class="el" href="classvg_1_1HandleGraph.html#a29ed7838d188b60e1d9fdf33e5b9506c">vg::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a101b575652f006b09c33ba271806e721"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::get_is_reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the orientation of a handle. </p>

<p>Implements <a class="el" href="classvg_1_1HandleGraph.html#ae87f996d21dfaaef5bd8f3e205d6100d">vg::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a82696917d41113970d95e84cb2ed9f88"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> vg::VG::get_last_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a handle to the last occurrence in a path. </p>

<p>Implements <a class="el" href="classvg_1_1PathHandleGraph.html#ad1ffc982e8ae2c27ceee2e48e5cb7d80">vg::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a7f8816a7244ebad64663a1af13f5244c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::get_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of a node. </p>

<p>Implements <a class="el" href="classvg_1_1HandleGraph.html#a7a1678a95aab507073c6b1b75b874c54">vg::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a8de058cf4945d57d348d148945281b00"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> vg::VG::get_next_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the next occurrence on the path. </p>

<p>Implements <a class="el" href="classvg_1_1PathHandleGraph.html#a4c4f09c7d8566eaf25950131ef3ff941">vg::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a49c1cef3ec020f0f494dbb0fd24deb7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::get_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a particular node. </p>

</div>
</div>
<a class="anchor" id="aceed581863f873d9b18e9a158e85e1f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::get_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1f8d1d0b977473d9c5b1b0ffa304a338"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> vg::VG::get_node_at_nucleotide </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>pathname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nuc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes in a pathname and the nucleotide position (like from a vcf) and returns the node id which contains that position. </p>

</div>
</div>
<a class="anchor" id="a12f5208ae9a2f22a31658dfaad28229b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, vcflib::Variant &gt; vg::VG::get_node_id_to_variant </td>
          <td>(</td>
          <td class="paramtype">vcflib::VariantCallFile&#160;</td>
          <td class="paramname"><em>vfile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes in a VCF file and returns a map [node] = vcflib::variant. Unfortunately this is specific to a given graph and VCF.</p>
<p>It will need to throw warnings if the node or variant is not in the graph.</p>
<p>This is useful for VCF masking: </p>
<pre class="fragment">if map.find(node) then mask variant
</pre><p>It's also useful for calling known variants </p>
<pre class="fragment">for m in alignment.mappings:
   node = m.Pos.nodeID
   if node in node_to_vcf:
       return (alignment supports variant)
</pre><p>It would be nice if this also supported edges (e.g. for inversions/transversions/breakpoints?). </p>

</div>
</div>
<a class="anchor" id="abbef12f2d3db8d702f1fdf2aea40351d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1handle__t.html">handle_t</a> vg::VG::get_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a node handle (node ID and orientation) from a handle to an occurrence on a path. </p>

<p>Implements <a class="el" href="classvg_1_1PathHandleGraph.html#a110e302128e7fb0241f9e4e010303638">vg::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a800d31a2623c04eaf0073554e7ca31c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::get_occurrence_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of node occurrences in the path. </p>

<p>Implements <a class="el" href="classvg_1_1PathHandleGraph.html#a3aa87c089b4cb99f12f5dde8a36082c6">vg::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a20417af67e14d7800b20df8b0ac763f9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::get_path_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of paths stored in the graph. </p>

<p>Implements <a class="el" href="classvg_1_1PathHandleGraph.html#aa5af121027ad72f846305e151c8891f4">vg::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a26f160750dfed33c16a257bd5cbecddf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; vg::VG::get_path_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all of the edges that are on any path. </p>

</div>
</div>
<a class="anchor" id="a0789f1df0078dff5849a97f60ca4d51e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> vg::VG::get_path_handle </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the path handle for the given path name. </p>

<p>Implements <a class="el" href="classvg_1_1PathHandleGraph.html#a0ea388d1dfc18d1f8ec0e85b7a4c7233">vg::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a99957343fa6c48216d95787c1ddbd680"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> vg::VG::get_path_handle_of_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the path that an occurrence is on. </p>

<p>Implements <a class="el" href="classvg_1_1PathHandleGraph.html#a444b400530c76ba44f87d1837be3cf08">vg::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="ac71b9547040f0d8ae430d564aa897d97"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::VG::get_path_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the name of a path from a handle to it. </p>

<p>Implements <a class="el" href="classvg_1_1PathHandleGraph.html#abb52bb91be5f02e52c00b468dc05785d">vg::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aeb4c806b52f820abecb2ef14b39f9fac"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> vg::VG::get_previous_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the previous occurrence on the path. </p>

<p>Implements <a class="el" href="classvg_1_1PathHandleGraph.html#ae4da8b13b51abaec2d548d1e9f8da27d">vg::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a7382f9cc8ef44b358495d021a0a0f80b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::VG::get_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the sequence of a node, presented in the handle's local forward orientation. </p>

<p>Implements <a class="el" href="classvg_1_1HandleGraph.html#a6c06aec43a2afddb4e47ebbec6533e81">vg::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a5eecbad7b22574c0617ad9a3d0808a6e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edge between the given node sides, which can be in either order. </p>

</div>
</div>
<a class="anchor" id="a64d10f80caa0eea2f594c4a0d6ba8c6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_edge </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sides</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an edge. This can take sides in any order. </p>

</div>
</div>
<a class="anchor" id="aa6c01851e7e97fda9828383c6de4a765"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an edge. This can take sides in any order. </p>

</div>
</div>
<a class="anchor" id="ab50d35554acf27ab2883b160866c5161"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an edge. This can take sides in any order. </p>

</div>
</div>
<a class="anchor" id="a49fb4de3494407b800c3efda254851cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_inverting_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an inverting edge on the given node. </p>

</div>
</div>
<a class="anchor" id="a7b7bbf066c6608211e7527ba50b23e48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_inverting_edge_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an inverting edge from the given node. </p>

</div>
</div>
<a class="anchor" id="a63088ee0039a8e1f5cf6b5a3b23f745a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_inverting_edge_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an inverting edge to the given node. </p>

</div>
</div>
<a class="anchor" id="a8d1dbb49df52e016746829776ca0f952"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_inverting_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has inversions. </p>

</div>
</div>
<a class="anchor" id="add251f0d262b6af53b11b244c17b39ec"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_next_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the occurrence is not the last occurence on the path, else false. </p>

<p>Implements <a class="el" href="classvg_1_1PathHandleGraph.html#af8bd6f6b137b1643d71e9c3aaaa8ae51">vg::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a37c72c4989c1bebcec7e98115041b501"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the graph has a node with the given ID. </p>

<p>Implements <a class="el" href="classvg_1_1HandleGraph.html#a96e9f5f3bcb9c68e0a2fa5981c1892b4">vg::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="aec9fb90202c77a6d104c634e2d2a3e62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph contains the given node. </p>

</div>
</div>
<a class="anchor" id="a907734904cd304ecee0b432ed598d106"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph contains the given node. </p>

</div>
</div>
<a class="anchor" id="a86daea8c9c2ff784598512fff740bd2c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_path </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a path name exists and is legal to get a path handle for. </p>

<p>Implements <a class="el" href="classvg_1_1PathHandleGraph.html#a75a8f83e85941ec1bd020b17f72c2099">vg::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a4fdaf206869cf4a3d7fe09858fa757c8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_previous_occurrence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>occurrence_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the occurrence is not the first occurence on the path, else false. </p>

<p>Implements <a class="el" href="classvg_1_1PathHandleGraph.html#a2fd30d7cd633add657d3ba5a45463b1e">vg::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a2b75ca400f858be77b0716ab7c68dfcb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string vg::VG::hash </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a digest of the serialized graph. </p>

</div>
</div>
<a class="anchor" id="a7eecc0bd555c31d1c541c3ce44b421c3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::head_nodes </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the head nodes (nodes with edges only to their right sides). These are required to be oriented forward. </p>

</div>
</div>
<a class="anchor" id="a3a44c415fb5882c184e2f35bb3999700"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; vg::VG::head_nodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the head nodes (nodes with edges only to their right sides). These are required to be oriented forward. </p>

</div>
</div>
<a class="anchor" id="acb33bdc43954b8acd955bb4425a48df1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &gt; vg::VG::identically_oriented_sibling_sets </td>
          <td>(</td>
          <td class="paramtype">const set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sibs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove sibling sets which don't have identical orientation. </p>

</div>
</div>
<a class="anchor" id="abbd7b9f01799a351e0e5ba420fa06679"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::identity_translation </td>
          <td>(</td>
          <td class="paramtype">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record the translation of this graph into itself in the provided map. </p>

</div>
</div>
<a class="anchor" id="a66e4dac76edcf0218f9749352c19acae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::include </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit the graph to include the path. </p>

</div>
</div>
<a class="anchor" id="a522cc6a9721f305ab01ce823d843662d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::increment_node_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>increment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the given value to all node IDs. Preserves the paths. </p>

</div>
</div>
<a class="anchor" id="a53ff7033966852f5fb3852716cab21a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::index_edge_by_node_sides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an edge to the node side indexes. Doesn't touch the index of edges by node pairs or the graph; those must be updated seperately. </p>

</div>
</div>
<a class="anchor" id="a70998a8e262e0afa074a2a287807705f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::index_paths </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aafd0f191fe33bd4590f15f309d0fd89c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>setup, ensures that gssw == NULL on startup </p>

</div>
</div>
<a class="anchor" id="a71388f637b255bf16a940e735a12aacd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_acyclic </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if the graph does not contain cycles. </p>

</div>
</div>
<a class="anchor" id="a65e98e20589f3f63de75f4dc63526562"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_ancestor_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>candidate_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the node is a next ancestor of this one. </p>

</div>
</div>
<a class="anchor" id="a837620e82b388581d91300a53c099574"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_ancestor_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>candidate_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>steps</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the node is a next ancestor of this one by trying to find it in a given number of steps. </p>

</div>
</div>
<a class="anchor" id="a7237af28b6fd3159ce048ec66679935c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_ancestor_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>candidate_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the node is a prev ancestor of this one. </p>

</div>
</div>
<a class="anchor" id="aec9353f02748091b04439a26fda57f9b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_ancestor_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>candidate_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>steps</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the node is a prev ancestor of this one by trying to find it in a given number of steps. </p>

</div>
</div>
<a class="anchor" id="ae5cdd8d94bcfce1302ba9e2cbfb5e412"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_head_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a node is a head node. </p>

</div>
</div>
<a class="anchor" id="a1bc3866468d5eb941fa6ba010ccce2ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_head_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a node is a head node. </p>

</div>
</div>
<a class="anchor" id="ad09549b6cfab8e1097dd207e01e57812"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_self_looping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the specified node have any self-loops? </p>

</div>
</div>
<a class="anchor" id="a40b412ca09b09b3c0e07bcd5bd9ee03b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_tail_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a node is a tail node. </p>

</div>
</div>
<a class="anchor" id="af58b227f21324d30be531088ed49b0f1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_tail_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a node is a tail node. </p>

</div>
</div>
<a class="anchor" id="aa77d93fdf76698460ce509ea5dcde954"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_valid </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_nodes</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_edges</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_paths</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_orphans</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph is valid or not, according to the specified criteria. </p>

</div>
</div>
<a class="anchor" id="a817384b8d147371448ad60e1db097b52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::join_heads </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join head nodes of graph to common null node, creating a new single head. </p>

</div>
</div>
<a class="anchor" id="adc40377520118436b729cd68be16d0ba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::join_heads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_start</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join head nodes of graph to specified node. Optionally from the start/to the end of the new node. </p>

</div>
</div>
<a class="anchor" id="a33e3f7942afd3ca82bfb78083c245146"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::join_tails </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_end</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join tail nodes of graph to specified node. Optionally from the start/to the end of the new node. </p>

</div>
</div>
<a class="anchor" id="a049393f32addf4071a14de2e874e94ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::keep_multinode_strongly_connected_components </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all elements which are not in a strongly connected component. </p>

</div>
</div>
<a class="anchor" id="a65cc16f52f478a25e84c6f1fc2805915"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::keep_path </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac2aa9d438bcec4d7facbfcc44abea8fd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::keep_paths </td>
          <td>(</td>
          <td class="paramtype">const set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>kept_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Keep paths in the given set of path names. Populates kept_names with the names of the paths it actually found to keep. The paths specified may not overlap. Removes all nodes and edges not used by one of the specified paths. </p>

</div>
</div>
<a class="anchor" id="af9ac6e61dfa9350459dbb9586088c4a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::left_degree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of edges attached to the left side of a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>. </p>

</div>
</div>
<a class="anchor" id="a23641dedefa2b6d573939515fcf5974c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::length </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total sequence length. </p>

</div>
</div>
<a class="anchor" id="ada5821862279a350885f5368a54a5cba"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::likelihoods </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; long double &gt; &amp;&#160;</td>
          <td class="paramname"><em>likelihoods</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a12bbb607ad1e55d73f61bbe002ee2511"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; vg::VG::make_translation </td>
          <td>(</td>
          <td class="paramtype">const map&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; <a class="el" href="structvg_1_1Node.html">Node</a> *, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>added_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig_node_sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce a graph <a class="el" href="structvg_1_1Translation.html">Translation</a> object from information about the editing process. </p>

</div>
</div>
<a class="anchor" id="acd555e66c8fa99984c8cb24aef0ab6f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::mapping_is_total_match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the mapping completely covers the node it maps to and is a perfect match. </p>

</div>
</div>
<a class="anchor" id="a3751016fff6e1e38d154515a13949e74"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> vg::VG::max_node_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum node ID used in the graph, if any are used. </p>

<p>Implements <a class="el" href="classvg_1_1HandleGraph.html#ab1aec5f66a976e05bed4a1c1b5d07fc8">vg::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a0abc84684faea29b49032ec254d5e13b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Literally merge protobufs. </p>

</div>
</div>
<a class="anchor" id="a40f22f6bb4a3e7a2aea7b3887237faec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Literally merge protobufs. </p>

</div>
</div>
<a class="anchor" id="a1f9aa921b25ba77f37366768b4b090ec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::merge_nodes </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge the nodes into a single node, preserving external linkages. Use the orientation of the first node as the basis. </p>

</div>
</div>
<a class="anchor" id="a5aff716eee0bf720b3836caa761d48be"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::merge_union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge protobufs after removing overlaps. Good when there aren't many overlaps. </p>

</div>
</div>
<a class="anchor" id="a78f9c36b6c3f7cbe933f705e9e9ba782"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> vg::VG::min_node_id </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the minimum node ID used in the graph, if any are used. </p>

<p>Implements <a class="el" href="classvg_1_1HandleGraph.html#aa1e1111d95d1a51bbec312f372e09593">vg::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a21c034f10ebf2555f8a69564368be8f7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; set&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &gt; vg::VG::multinode_strongly_connected_components </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get only multi-node strongly connected components. </p>

</div>
</div>
<a class="anchor" id="a8a94aeff38cf579243532fde605260a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::node_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of nodes in the graph. </p>

</div>
</div>
<a class="anchor" id="a4c614759c77b4b0a95b25360c2fa1fa0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::node_count_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the nodes attached to the right side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>. </p>

</div>
</div>
<a class="anchor" id="a1091113608fae5b9cbafc87cf4cf82a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::node_count_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the nodes attached to the left side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>. </p>

</div>
</div>
<a class="anchor" id="a0202180fa7153f464c3b1d3ff70dc9cb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::node_rank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the rank of the node in the protobuf array that backs the graph. </p>

</div>
</div>
<a class="anchor" id="aa564542c73b2b800a4fa42e591c1879f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::node_rank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the rank of the node in the protobuf array that backs the graph. </p>

</div>
</div>
<a class="anchor" id="a85f84f601f2ef13c0d9df3741ccdc192"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::node_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of nodes in the graph. </p>

<p>Implements <a class="el" href="classvg_1_1HandleGraph.html#aab62413592de127f6e7ed629256bd963">vg::HandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a093f4e4dffe0d03806df32edc33cdb9a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::node_starts_in_path </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; <a class="el" href="structvg_1_1Node.html">Node</a> *, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill in the node_start map with the first index along the path at which each node appears. Caller is responsible for dealing with orientations. </p>

</div>
</div>
<a class="anchor" id="ac27c591957478a17605c2453749f7d20"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::node_starts_in_path </td>
          <td>(</td>
          <td class="paramtype">list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> *, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find node starts in a path. TODO: what does that mean? To get the starts out of the map this produces, you need to dereference the iterator and then get the address of the <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> (stored in the list) that you are talking about. </p>

</div>
</div>
<a class="anchor" id="a9bf8c0e391c1a6c027ed26b991d8cad0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::nodes_are_perfect_path_neighbors </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if nodes share all paths and the mappings they share in these paths are adjacent, in the specified relative order and orientation. </p>

</div>
</div>
<a class="anchor" id="a0b084d958fd8069839884dc3a01ed745"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::nodes_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nodes attached to the right side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations. </p>

</div>
</div>
<a class="anchor" id="a62f1bb7fa27d4d4312017b113aab099a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::nodes_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nodes attached to the right side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations. </p>

</div>
</div>
<a class="anchor" id="ac08e778396904ad3b3f20f605f54628d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::nodes_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nodes attached to the left side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations. </p>

</div>
</div>
<a class="anchor" id="a0f3e69ced0c3135f3f363c14bf752aad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::nodes_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nodes attached to the left side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations. </p>

</div>
</div>
<a class="anchor" id="a44edad9ba2a6df332234b43715dd71db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::nonoverlapping_node_context_without_paths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the subgraph of a node and all the edges it is responsible for (where it has the minimal ID) and add it into the given <a class="el" href="classvg_1_1VG.html">VG</a>. </p>

</div>
</div>
<a class="anchor" id="a217f8b5abd62bcdb256cf15926c9fe5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::normalize </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use unchop and sibling merging to simplify the graph into a normalized form. </p>

</div>
</div>
<a class="anchor" id="a838967605238fb226a5a5a7836229c96"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1occurrence__handle__t.html">occurrence_handle_t</a> &gt; vg::VG::occurrences_of_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>match_orientation</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a vector of all occurrences of a node on paths. Optionally restricts to occurrences that match the handle in orientation. </p>

<p>Implements <a class="el" href="classvg_1_1PathHandleGraph.html#aaf7a2a2def7cdb9f8f1ddc7d8835fe7c">vg::PathHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="af307e84054373091afc6760a418087ed"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a>&amp; vg::VG::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>

</div>
</div>
<a class="anchor" id="a870b32af2443419ae7013b192d0caad6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a>&amp; vg::VG::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

</div>
</div>
<a class="anchor" id="a7fc72119c835adc52a935efca0bdda0b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; vg::VG::overlay_node_translations </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>over</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>under</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assume two node translations, the over is based on the under; merge them. </p>

</div>
</div>
<a class="anchor" id="a5f1df72d85d8a72524b76abca972f33d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::path_edge_count </td>
          <td>(</td>
          <td class="paramtype">list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>path_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structvg_1_1Path.html">Path</a> stats. Starting from offset in the first node, how many edges do we cross? path must be nonempty and longer than the given length. offset is interpreted as relative to the first node in its on-path orientation, and is inclusive. </p>

</div>
</div>
<a class="anchor" id="a8f45b42614f4ac36c8060634ec0d9805"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::path_end_node_offset </td>
          <td>(</td>
          <td class="paramtype">list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>path_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine the offset in its last node at which the path starting at this offset in its first node ends. path must be nonempty and longer than the given length. offset is interpreted as relative to the first node in its on-path orientation, and is inclusive. Returned offset is remaining unused length in the last node touched. </p>

</div>
</div>
<a class="anchor" id="ad9bd4133841d1d781fb0df4171773139"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::VG::path_identity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return percent identity between two paths (# matches / (#matches + #mismatches)). Note: uses ssw aligner, so will only work on small paths. </p>

</div>
</div>
<a class="anchor" id="a4ce6fe02b243b4f0f82bbf801fd507fa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string vg::VG::path_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return sequence string of path. </p>

</div>
</div>
<a class="anchor" id="af8f4e2ab506f4ef673836b5901bb3809"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::VG::path_string </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the string sequence for all the NodeTraversals on the given path. </p>

</div>
</div>
<a class="anchor" id="a927b79f3f4c9582b0f8e988bb4ef1aa1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::VG::path_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the string sequence for traversing the given path. Assumes the path covers the entirety of any nodes visited. Handles backward nodes. </p>

</div>
</div>
<a class="anchor" id="a871d05e0a2d0b76092e20fe86bd12e2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::VG::paths_as_alignments </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the stored paths in this graph to alignments. </p>

</div>
</div>
<a class="anchor" id="a8dc8d762d07088089247b632c835a19d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::paths_between </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af39a51572be3a442165d50e555e325ce"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::paths_between </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2b659686076f3d6b7b63ec9678d76a93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::print_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad4878ca3ebc2c14d008e57c7ae8d5845"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::prune_complex </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>path_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>head_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>tail_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take all nodes that would introduce paths of &gt; edge_max edge crossings, remove them, and link their neighbors to head_node or tail_node depending on which direction the path extension was stopped. Optionally preserve edges on the embedded paths. For pruning graph prior to indexing with gcsa2. </p>

</div>
</div>
<a class="anchor" id="a4ea2fe244a857ff24d0176449bedd4ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::prune_complex_paths </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>head_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>tail_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Limit the local complexity of the graph, connecting pruned components to a head and tail node depending on the direction which we come into the node when the edge_max is passed. </p>

</div>
</div>
<a class="anchor" id="ae0765f466db760a9a450f4d4115a59bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::prune_complex_with_head_tail </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>path_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrap the graph with heads and tails before doing the prune. Utility function for preparing for indexing. </p>

</div>
</div>
<a class="anchor" id="a590703c2954a2a15d735995c2007a879"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::prune_short_subgraphs </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aec84f7813f59a16b2d0c1bd72904ae5b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::random_read </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>read_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mt19937 &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>min_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>max_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>either_strand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate random reads. Note that even if either_strand is false, having backward nodes in the graph will result in some reads from the global reverse strand. </p>

</div>
</div>
<a class="anchor" id="a6541146b6410cec4be3e2a7379ea3bcf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::rebuild_edge_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a63d4e45a9a410c451b1cad44ef7068ad"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::rebuild_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a33424c3be8c3e088631dfb37c48773d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_duplicated_in </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to merge_union. </p>

</div>
</div>
<a class="anchor" id="aba9fb73c326ecfab70e35e44dff6a937"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_duplicates </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove duplicated nodes and edges. </p>

</div>
</div>
<a class="anchor" id="a76005ed499eea217c9f778028751137c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_inverting_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove edges representing an inversion and edges on the reverse complement. </p>

</div>
</div>
<a class="anchor" id="ab92694e7fd89275603c967739e60e0d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_node_forwarding_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a node but connect all of its predecessor and successor nodes with new edges. </p>

</div>
</div>
<a class="anchor" id="ad517da731d2bf9c81cc28e0a1367af33"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_non_path </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove pieces of the graph which are not part of any path. </p>

</div>
</div>
<a class="anchor" id="a9b107027697644d771eb529037201f71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_null_nodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove nodes with no sequence. These are created in some cases during the process of graph construction. </p>

</div>
</div>
<a class="anchor" id="a0e887a7b2cfc666f2210889a2dec791b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_null_nodes_forwarding_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove null nodes but connect predecessors and successors, preserving structure. </p>

</div>
</div>
<a class="anchor" id="a40dd9bc0458a4948afd676374ae8d1f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_orphan_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove edges for which one of the nodes is not present. </p>

</div>
</div>
<a class="anchor" id="a30c369b4c1b0dfa4e9fbc0d3bce82648"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_path </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove pieces of the graph which are part of some path. </p>

</div>
</div>
<a class="anchor" id="af8879b1e6aab38b9a246deba0f05ccfe"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::resize_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a00287a092635fc711de1f0a82f66ae77"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> vg::VG::reverse_complement_graph </td>
          <td>(</td>
          <td class="paramtype">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the reverse complemented graph with topology preserved. Record translation in provided map. </p>

</div>
</div>
<a class="anchor" id="a23622195177dff4c7c8416edffb7fc93"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::right_degree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of edges attached to the right side of a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>. </p>

</div>
</div>
<a class="anchor" id="a38b7b580164861c1ced0b660bd4fa4c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::same_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use sides_from an sides_to to determine if both nodes have the same context. </p>

</div>
</div>
<a class="anchor" id="a722dcb12f09e01f43d3257bda35201b1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::serialize_to_emitter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1stream_1_1ProtobufEmitter.html">stream::ProtobufEmitter</a>&lt; <a class="el" href="structvg_1_1Graph.html">Graph</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>emitter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write chunked graphs to a ProtobufEmitter that will write them to a stream. Use when combining multiple <a class="el" href="classvg_1_1VG.html">VG</a> objects in a stream. <a class="el" href="structvg_1_1Graph.html">Graph</a> will be serialized in internal storage order. </p>

</div>
</div>
<a class="anchor" id="a8841bfa5a6c888820e6a29c8010e72fc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::serialize_to_file </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the graph to a file, with an EOF marker. <a class="el" href="structvg_1_1Graph.html">Graph</a> will be serialized in internal storage order. </p>

</div>
</div>
<a class="anchor" id="ab217740a8290f9706c260172f19ef221"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::serialize_to_ostream </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write to a stream in chunked graphs. Adds an EOF marker. Use when this <a class="el" href="classvg_1_1VG.html">VG</a> will be the only thing in the stream. <a class="el" href="structvg_1_1Graph.html">Graph</a> will be serialized in internal storage order. </p>

</div>
</div>
<a class="anchor" id="ae1131c1ff0a94ed2ec9ef35cb678801b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::set_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the edge indexes through this function. Picks up the sides being connected by the edge automatically, and silently drops the edge if they are already connected. </p>

</div>
</div>
<a class="anchor" id="ac684d17ffe4c85ce74a4677fdfaf7672"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::siblings_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>traversal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>From-siblings are nodes which also have edges to them from the same nodes as this one. </p>

</div>
</div>
<a class="anchor" id="a5f202743732e5335bb1b15413914eaa6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; vg::VG::siblings_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get general siblings of a node. </p>

</div>
</div>
<a class="anchor" id="abac7d4642b9bcc25bc5299af18f523bc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::siblings_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>traversal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>To-siblings are nodes which also have edges to them from the same nodes as this one. </p>

</div>
</div>
<a class="anchor" id="a21a20098d0a29a1f3f0e9f932fcce462"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, bool &gt; &gt; vg::VG::sides_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all sides connecting to this node. </p>

</div>
</div>
<a class="anchor" id="ac670f3c729f93ebaa7c8bd5063225597"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; vg::VG::sides_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td>
          <td class="paramname"><em>side</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sides on the other side of edges from this side of the node. </p>

</div>
</div>
<a class="anchor" id="a63aa329381f85cffbb793d19a8b17b52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; vg::VG::sides_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sides from both sides of the node. </p>

</div>
</div>
<a class="anchor" id="a030b75d2ad50905cc01fe4b7223cbb83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; vg::VG::sides_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td>
          <td class="paramname"><em>side</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Union of sides_to and sides_from. </p>

</div>
</div>
<a class="anchor" id="a1a156ac1e1fde520bae82850105c6c66"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; vg::VG::sides_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td>
          <td class="paramname"><em>side</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sides on the other side of edges to this side of the node. </p>

</div>
</div>
<a class="anchor" id="aee2b9b646282c9a466a531916213e867"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; vg::VG::sides_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sides to both sides of the node. </p>

</div>
</div>
<a class="anchor" id="ad0dcdbceae7ad22b60e4966e9644b612"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &gt; vg::VG::simple_components </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_size</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the set of components that could be merged into single nodes without changing the path space of the graph. Emits oriented traversals of nodes, in the order and orientation in which they are to be merged. </p>

</div>
</div>
<a class="anchor" id="adff96e1df8d63362f110efa996d817e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &gt; vg::VG::simple_multinode_components </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the simple components of multiple nodes. </p>

</div>
</div>
<a class="anchor" id="a171c17f06d7bb0645776f466fe3d3a1d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::simplify_from_siblings </td>
          <td>(</td>
          <td class="paramtype">const set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>from_sibs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove easily-resolvable redundancy in the graph for all provided from-sibling sets. </p>

</div>
</div>
<a class="anchor" id="a3e90bd47ffc24a55b1588be8f5328717"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::simplify_siblings </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove easily-resolvable redundancy in the graph. TODO: Cannot yet handle reversing edges! They will prevent the identification of siblings. </p>

</div>
</div>
<a class="anchor" id="a5c037db7f5ec45293ac6650d46040237"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::simplify_to_siblings </td>
          <td>(</td>
          <td class="paramtype">const set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>to_sibs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove easily-resolvable redundancy in the graph for all provided to-sibling sets. </p>

</div>
</div>
<a class="anchor" id="a9e3720ce267c8167ce679a015063dab6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of nodes. </p>

</div>
</div>
<a class="anchor" id="a1ff00edd627e3445eee7f43927bb1518"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::start_degree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of edges attached to the start of a node. </p>

</div>
</div>
<a class="anchor" id="ab447b1c70f7c4dc6576bfabc1990c337"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; set&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> &gt; &gt; vg::VG::strongly_connected_components </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the strongly connected components of the graph. </p>

</div>
</div>
<a class="anchor" id="a3d4db6ea2a99bda9a48411491aa6ed4e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::swap_handles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the nodes corresponding to the given handles, in the ordering used by for_each_handle when looping over the graph. Other handles to the nodes being swapped must not be invalidated. </p>

<p>Implements <a class="el" href="classvg_1_1MutableHandleGraph.html#a92fb5ae7e5f1cd198d42d152f8d87500">vg::MutableHandleGraph</a>.</p>

</div>
</div>
<a class="anchor" id="a0f8c9051591df60d405a8dc1006aa6d5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::swap_node_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>new_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the ID of the node with the first id to the second, new ID not used by any node. Invalidates any paths containing the node, since they are not updated. </p>

</div>
</div>
<a class="anchor" id="aa906c5779ea372eb4dd0d9b8cc224be3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::swap_node_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&#160;</td>
          <td class="paramname"><em>new_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the ID of the given node to the second, new ID not used by any node. Invalidates the paths. Invalidates any paths containing the node, since they are not updated. </p>

</div>
</div>
<a class="anchor" id="aa402d1cf817f83ca44f72f6112b6a2e3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::swap_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the given nodes. TODO: what does that mean? </p>

</div>
</div>
<a class="anchor" id="a124188a9e0cd68c87c2bc009ea7bd799"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::sync_paths </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize in-memory indexes and protobuf graph. </p>

</div>
</div>
<a class="anchor" id="a25bd74b77e139691555c8d48ecf67d9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; vg::VG::tail_nodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the tail nodes (nodes with edges only to their left sides). These are required to be oriented forward. </p>

</div>
</div>
<a class="anchor" id="a47fbc525ed5e9f2a7b00c333f03fe6c8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::tail_nodes </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the tail nodes (nodes with edges only to their left sides). These are required to be oriented forward. </p>

</div>
</div>
<a class="anchor" id="a5a4e14a60334c2ba3ce3bed0e3fd0b91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::to_dot </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td>
          <td class="paramname"><em>alignments</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Locus.html">Locus</a> &gt;&#160;</td>
          <td class="paramname"><em>loci</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>walk_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>annotate_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_mappings</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>simple_mode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert_edge_ports</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>color_variants</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ultrabubble_labeling</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_missing_nodes</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ascii_labels</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>random_seed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the graph to Dot format. </p>

</div>
</div>
<a class="anchor" id="adfa66da1d94de2ebc0620be45c3393f8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::to_dot </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td>
          <td class="paramname"><em>alignments</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>walk_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>annotate_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_mappings</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert_edge_ports</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>random_seed</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>color_variants</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the graph to Dot format. </p>

</div>
</div>
<a class="anchor" id="a582500a3d49fe231faa49a5c2e467cc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::to_turtle </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>rdf_base_uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>precompress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the graph to Turtle format. </p>

</div>
</div>
<a class="anchor" id="ab928179a1a4c5a535aefab8cda99c591"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> vg::VG::total_length_of_nodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total sequence length of nodes in the graph. TODO: redundant with <a class="el" href="classvg_1_1VG.html#a23641dedefa2b6d573939515fcf5974c" title="Total sequence length. ">length()</a>. </p>

</div>
</div>
<a class="anchor" id="afce50214291804f0d9bdf9bcd39125a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &gt; vg::VG::transitive_sibling_sets </td>
          <td>(</td>
          <td class="paramtype">const set&lt; set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sibs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove intransitive sibling sets, such as where (A, B, C) = S1 but C  S2. </p>

</div>
</div>
<a class="anchor" id="a57296ecbcfce10f95b86233e10c35d7d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::VG::trav_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>trav</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sequence of a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>. </p>

</div>
</div>
<a class="anchor" id="a34a493a0628857a3bfae181295ba541d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::travs_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get traversals after this node on the same strand. Same as nodes_next but using set. </p>

</div>
</div>
<a class="anchor" id="ae065082f817e9bc0e278cf71f31af1e2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::travs_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get traversals either before or after this node on the same strand. </p>

</div>
</div>
<a class="anchor" id="a0a962957210c079fa242b383d5c65de3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::travs_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get traversals before this node on the same strand. Same as nodes_prev but using set. </p>

</div>
</div>
<a class="anchor" id="a998cfb17a4433f05a1579f0d704208a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::unchop </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the reverse &mdash; combines nodes by removing edges where doing so has no effect on the graph labels. </p>

</div>
</div>
<a class="anchor" id="afc568712b6d4aa3b6dc965f37cc769a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> vg::VG::unfold </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ensure that all traversals up to max_length are represented as a path on one strand or the other without taking an inverting edge. All inverting edges are converted to non-inverting edges to reverse complement nodes. If no inverting edges are present, the strandedness of all nodes is the same as the input graph. If inverting edges are present, node strandedness is arbitrary. </p>

</div>
</div>
<a class="anchor" id="a1c0b7db8d3043747e8b9a44cba4eaac9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::unindex_edge_by_node_sides </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an edge from the node side indexes, so it doesn't show up when you ask for the edges connected to the side of a node. Makes the edge untraversable until the indexes are rebuilt. </p>

</div>
</div>
<a class="anchor" id="a5677da9ff22052f6c6a85bfe66e1256d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::unindex_edge_by_node_sides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an edge from the node side indexes, so it doesn't show up when you ask for the edges connected to the side of a node. Makes the edge untraversable until the indexes are rebuilt. </p>

</div>
</div>
<a class="anchor" id="a2239c89d6ac7e9dec0d76325c2a68f97"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::wrap_with_null_nodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add singular head and tail null nodes to graph. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a93f069b1a683a86ff2981a7f340ac009"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a> vg::VG::current_id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current id for <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a> to be added next. </p>

</div>
</div>
<a class="anchor" id="ab754d45647580a21216bd010b72c6815"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1pair__hash__map.html">pair_hash_map</a>&lt;pair&lt;<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&gt;, <a class="el" href="structvg_1_1Edge.html">Edge</a>*&gt; vg::VG::edge_by_sides</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code><a class="el" href="structvg_1_1Edge.html">Edge</a></code>s by sides of <code><a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a></code>s they connect. Since duplicate edges are not permitted, two edges cannot connect the same pair of node sides. Each edge is indexed here with the smaller <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> first. The actual node order is recorded in the <a class="el" href="structvg_1_1Edge.html">Edge</a> object. </p>

</div>
</div>
<a class="anchor" id="a2e2c02a8216f0bb9b3a78e985845ea1b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="structvg_1_1Edge.html">Edge</a>*, int&gt; vg::VG::edge_index</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a947ad1a02ca5be020879d56976a00e2a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, vector&lt;pair&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool&gt; &gt; &gt; vg::VG::edges_on_end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the destinations and backward flags for edges attached to the ends of nodes (whether that node is "from" or "to"). </p>

</div>
</div>
<a class="anchor" id="a5eda797a26ee9d8c217527d77554e2ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, vector&lt;pair&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool&gt; &gt; &gt; vg::VG::edges_on_start</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the destinations and backward flags for edges attached to the starts of nodes (whether that node is "from" or "to"). </p>

</div>
</div>
<a class="anchor" id="a9f32ef3d653601d2fcac5c1b31de0abb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;pair&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, bool&gt; &gt; vg::VG::empty_edge_ends</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Placeholder for functions that sometimes need to be passed an empty vector. </p>

</div>
</div>
<a class="anchor" id="a5c70121b4a8463c118b9c90c7090b28f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>&gt; vg::VG::empty_ids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Placeholder for functions that sometimes need to be passed an empty vector. </p>

</div>
</div>
<a class="anchor" id="a4772c77ed932bfed4d21e247918381a4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Graph.html">Graph</a> vg::VG::graph</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Protobuf-based representation. </p>

</div>
</div>
<a class="anchor" id="a1f6fcd5a907e9bee524cf37a62ad5be2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::VG::name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the graph. </p>

</div>
</div>
<a class="anchor" id="aaf9360fb7acb595296f55cb445f87543"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="namespacevg.html#a4bc2511884a0496ff2193e1a1151350a">id_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a>*&gt; vg::VG::node_by_id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code><a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data. ">Node</a></code>s by id. </p>

</div>
</div>
<a class="anchor" id="a2ce9aecf57e0684821ee277d983eb248"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="structvg_1_1Node.html">Node</a>*, int&gt; vg::VG::node_index</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nodes by position in nodes repeated field. this is critical to allow fast deletion of nodes </p>

</div>
</div>
<a class="anchor" id="a7c5150aba84e7ed2bde7986462a79989"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Paths.html">Paths</a> vg::VG::paths</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Manages paths of the graph. Initialized by setting paths._paths = graph.paths. </p>

</div>
</div>
<a class="anchor" id="ac697184acf2edadca58ddc776f9f4e7e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;string, <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a>&gt; vg::VG::variant_to_traversal</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="vg_8hpp.html">vg.hpp</a></li>
<li>src/<a class="el" href="vg_8cpp.html">vg.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
