<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::VG Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1VG.html">VG</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1VG-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::VG Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;vg.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::VG:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1VG.png" usemap="#vg::VG_map" alt=""/>
  <map id="vg::VG_map" name="vg::VG_map">
<area href="classvg_1_1Progressive.html" alt="vg::Progressive" shape="rect" coords="0,224,287,248"/>
<area href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html" alt="handlegraph::MutablePathDeletableHandleGraph" shape="rect" coords="908,224,1195,248"/>
<area href="classhandlegraph_1_1MutablePathMutableHandleGraph.html" alt="handlegraph::MutablePathMutableHandleGraph" shape="rect" coords="629,168,916,192"/>
<area href="classhandlegraph_1_1DeletableHandleGraph.html" alt="handlegraph::DeletableHandleGraph" shape="rect" coords="1188,168,1475,192"/>
<area href="classhandlegraph_1_1MutablePathHandleGraph.html" alt="handlegraph::MutablePathHandleGraph" shape="rect" coords="371,112,658,136"/>
<area href="classhandlegraph_1_1MutableHandleGraph.html" alt="handlegraph::MutableHandleGraph" shape="rect" coords="891,112,1178,136"/>
<area href="classhandlegraph_1_1MutableHandleGraph.html" alt="handlegraph::MutableHandleGraph" shape="rect" coords="1188,112,1475,136"/>
<area href="classhandlegraph_1_1PathHandleGraph.html" alt="handlegraph::PathHandleGraph" shape="rect" coords="148,56,435,80"/>
<area href="classhandlegraph_1_1MutablePathMetadata.html" alt="handlegraph::MutablePathMetadata" shape="rect" coords="594,56,881,80"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="891,56,1178,80"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="1188,56,1475,80"/>
<area href="classhandlegraph_1_1HandleGraph.html" alt="handlegraph::HandleGraph" shape="rect" coords="0,0,287,24"/>
<area href="classhandlegraph_1_1PathMetadata.html" alt="handlegraph::PathMetadata" shape="rect" coords="297,0,584,24"/>
<area href="classhandlegraph_1_1PathMetadata.html" alt="handlegraph::PathMetadata" shape="rect" coords="594,0,881,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1VG_1_1Plan.html">Plan</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Structure for managing parallel construction of a graph.  <a href="structvg_1_1VG_1_1Plan.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0ee4603518e9cd5915a65e65c2d763b2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0ee4603518e9cd5915a65e65c2d763b2">serialize</a> (ostream &amp;out) const</td></tr>
<tr class="memdesc:a0ee4603518e9cd5915a65e65c2d763b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the contents of this graph to an ostream.  <a href="classvg_1_1VG.html#a0ee4603518e9cd5915a65e65c2d763b2">More...</a><br /></td></tr>
<tr class="separator:a0ee4603518e9cd5915a65e65c2d763b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24359ba8e4ecbbd692bba5a517456659"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a24359ba8e4ecbbd692bba5a517456659">deserialize</a> (istream &amp;in)</td></tr>
<tr class="separator:a24359ba8e4ecbbd692bba5a517456659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70f50e6766af9262c732de26243658f5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a70f50e6766af9262c732de26243658f5">get_handle</a> (const <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &amp;node_id, bool is_reverse=false) const</td></tr>
<tr class="memdesc:a70f50e6766af9262c732de26243658f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the handle for the node with the given ID in the given orientation.  <a href="classvg_1_1VG.html#a70f50e6766af9262c732de26243658f5">More...</a><br /></td></tr>
<tr class="separator:a70f50e6766af9262c732de26243658f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f4b9ac16f23eb0420544ce8357736a3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a6f4b9ac16f23eb0420544ce8357736a3">get_id</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a6f4b9ac16f23eb0420544ce8357736a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID from a handle.  <a href="classvg_1_1VG.html#a6f4b9ac16f23eb0420544ce8357736a3">More...</a><br /></td></tr>
<tr class="separator:a6f4b9ac16f23eb0420544ce8357736a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e796617804bffe0203e422f2a23148"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a53e796617804bffe0203e422f2a23148">get_is_reverse</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a53e796617804bffe0203e422f2a23148"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the orientation of a handle.  <a href="classvg_1_1VG.html#a53e796617804bffe0203e422f2a23148">More...</a><br /></td></tr>
<tr class="separator:a53e796617804bffe0203e422f2a23148"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48a5e160f098327f149b7a8a7a5b3558"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a48a5e160f098327f149b7a8a7a5b3558">flip</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a48a5e160f098327f149b7a8a7a5b3558"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the orientation of a handle (potentially without getting its ID)  <a href="classvg_1_1VG.html#a48a5e160f098327f149b7a8a7a5b3558">More...</a><br /></td></tr>
<tr class="separator:a48a5e160f098327f149b7a8a7a5b3558"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff75e522e40559f5a5257a5cef776cdc"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aff75e522e40559f5a5257a5cef776cdc">get_length</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:aff75e522e40559f5a5257a5cef776cdc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a node.  <a href="classvg_1_1VG.html#aff75e522e40559f5a5257a5cef776cdc">More...</a><br /></td></tr>
<tr class="separator:aff75e522e40559f5a5257a5cef776cdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a353df9b2449ac859804359632283078b"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a353df9b2449ac859804359632283078b">get_sequence</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="separator:a353df9b2449ac859804359632283078b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c1118bd664e83254db09ba3e8a3ec3f"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a4c1118bd664e83254db09ba3e8a3ec3f">follow_edges_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="separator:a4c1118bd664e83254db09ba3e8a3ec3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7a11323fdb8a632f4dc5e405e74848"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#afa7a11323fdb8a632f4dc5e405e74848">for_each_handle_impl</a> (const function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee, bool parallel=false) const</td></tr>
<tr class="separator:afa7a11323fdb8a632f4dc5e405e74848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a495649c1646b865d6c88b8dc126589b0"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a495649c1646b865d6c88b8dc126589b0">get_node_count</a> () const</td></tr>
<tr class="memdesc:a495649c1646b865d6c88b8dc126589b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of nodes in the graph.  <a href="classvg_1_1VG.html#a495649c1646b865d6c88b8dc126589b0">More...</a><br /></td></tr>
<tr class="separator:a495649c1646b865d6c88b8dc126589b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4577be9213932c313efd3d016b88a31"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad4577be9213932c313efd3d016b88a31">get_edge_count</a> () const</td></tr>
<tr class="memdesc:ad4577be9213932c313efd3d016b88a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the total number of edges in the graph.  <a href="classvg_1_1VG.html#ad4577be9213932c313efd3d016b88a31">More...</a><br /></td></tr>
<tr class="separator:ad4577be9213932c313efd3d016b88a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27674d67445ddc135c3c8ab4d3d5231"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac27674d67445ddc135c3c8ab4d3d5231">min_node_id</a> () const</td></tr>
<tr class="memdesc:ac27674d67445ddc135c3c8ab4d3d5231"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the minimum node ID used in the graph, if any are used.  <a href="classvg_1_1VG.html#ac27674d67445ddc135c3c8ab4d3d5231">More...</a><br /></td></tr>
<tr class="separator:ac27674d67445ddc135c3c8ab4d3d5231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a03ad90e03794944c5e0d4d61780652"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5a03ad90e03794944c5e0d4d61780652">max_node_id</a> () const</td></tr>
<tr class="memdesc:a5a03ad90e03794944c5e0d4d61780652"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the maximum node ID used in the graph, if any are used.  <a href="classvg_1_1VG.html#a5a03ad90e03794944c5e0d4d61780652">More...</a><br /></td></tr>
<tr class="separator:a5a03ad90e03794944c5e0d4d61780652"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc0ac00267e00156e04c849a10b1cb74"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#afc0ac00267e00156e04c849a10b1cb74">get_degree</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left) const</td></tr>
<tr class="separator:afc0ac00267e00156e04c849a10b1cb74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a501886a0c593ac3231cfcc6989911ced"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a501886a0c593ac3231cfcc6989911ced">has_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const</td></tr>
<tr class="separator:a501886a0c593ac3231cfcc6989911ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cb582e352f75cc9d66e6eff0f4ba659"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7cb582e352f75cc9d66e6eff0f4ba659">get_base</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t index) const</td></tr>
<tr class="separator:a7cb582e352f75cc9d66e6eff0f4ba659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45075c22efc7cfb1ed06a8996fec119c"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a45075c22efc7cfb1ed06a8996fec119c">get_subsequence</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t index, size_t <a class="el" href="classvg_1_1VG.html#a9e3720ce267c8167ce679a015063dab6">size</a>) const</td></tr>
<tr class="separator:a45075c22efc7cfb1ed06a8996fec119c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b20ecaa6a8a3155b5abb90a3139f6de"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7b20ecaa6a8a3155b5abb90a3139f6de">get_path_count</a> () const</td></tr>
<tr class="memdesc:a7b20ecaa6a8a3155b5abb90a3139f6de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of paths stored in the graph.  <a href="classvg_1_1VG.html#a7b20ecaa6a8a3155b5abb90a3139f6de">More...</a><br /></td></tr>
<tr class="separator:a7b20ecaa6a8a3155b5abb90a3139f6de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0328316df2438f0006349c71206810e6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0328316df2438f0006349c71206810e6">has_path</a> (const string &amp;path_name) const</td></tr>
<tr class="memdesc:a0328316df2438f0006349c71206810e6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a path name exists and is legal to get a path handle for.  <a href="classvg_1_1VG.html#a0328316df2438f0006349c71206810e6">More...</a><br /></td></tr>
<tr class="separator:a0328316df2438f0006349c71206810e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6261550a7c6bbe7eb6ee0976639bc1d7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a6261550a7c6bbe7eb6ee0976639bc1d7">get_path_handle</a> (const string &amp;path_name) const</td></tr>
<tr class="memdesc:a6261550a7c6bbe7eb6ee0976639bc1d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the path handle for the given path name.  <a href="classvg_1_1VG.html#a6261550a7c6bbe7eb6ee0976639bc1d7">More...</a><br /></td></tr>
<tr class="separator:a6261550a7c6bbe7eb6ee0976639bc1d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ad62c3977b6f38f0b570ea78251dc6d"><td class="memItemLeft" align="right" valign="top">virtual string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8ad62c3977b6f38f0b570ea78251dc6d">get_path_name</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:a8ad62c3977b6f38f0b570ea78251dc6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the name of a path from a handle to it.  <a href="classvg_1_1VG.html#a8ad62c3977b6f38f0b570ea78251dc6d">More...</a><br /></td></tr>
<tr class="separator:a8ad62c3977b6f38f0b570ea78251dc6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1463f13c63b965a3663932e6fa87537e"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1463f13c63b965a3663932e6fa87537e">get_is_circular</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:a1463f13c63b965a3663932e6fa87537e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up whether a path is circular.  <a href="classvg_1_1VG.html#a1463f13c63b965a3663932e6fa87537e">More...</a><br /></td></tr>
<tr class="separator:a1463f13c63b965a3663932e6fa87537e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3efe30807d096a6175373bc3f4863dd7"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3efe30807d096a6175373bc3f4863dd7">get_step_count</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:a3efe30807d096a6175373bc3f4863dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of node steps in the path.  <a href="classvg_1_1VG.html#a3efe30807d096a6175373bc3f4863dd7">More...</a><br /></td></tr>
<tr class="separator:a3efe30807d096a6175373bc3f4863dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb73599cc743a392650a7002c8dc2906"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#acb73599cc743a392650a7002c8dc2906">get_handle_of_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:acb73599cc743a392650a7002c8dc2906"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a node handle (node ID and orientation) from a handle to an step on a path.  <a href="classvg_1_1VG.html#acb73599cc743a392650a7002c8dc2906">More...</a><br /></td></tr>
<tr class="separator:acb73599cc743a392650a7002c8dc2906"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae55721d38d4db3068ca93b4aac8e962"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aae55721d38d4db3068ca93b4aac8e962">get_path_handle_of_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:aae55721d38d4db3068ca93b4aac8e962"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a handle to the path that an step is on.  <a href="classvg_1_1VG.html#aae55721d38d4db3068ca93b4aac8e962">More...</a><br /></td></tr>
<tr class="separator:aae55721d38d4db3068ca93b4aac8e962"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0fc3a05ce45e0100fb82812c5b1e35d"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af0fc3a05ce45e0100fb82812c5b1e35d">path_begin</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="separator:af0fc3a05ce45e0100fb82812c5b1e35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f532a7aeb7765b99c6c4e43ba961fdb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2f532a7aeb7765b99c6c4e43ba961fdb">path_end</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="separator:a2f532a7aeb7765b99c6c4e43ba961fdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1af5ef2df0289b964cab09d9400344c5"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1af5ef2df0289b964cab09d9400344c5">path_back</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="separator:a1af5ef2df0289b964cab09d9400344c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1a4d7c14f1aaf601e9a6e231b6b7d3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5e1a4d7c14f1aaf601e9a6e231b6b7d3">path_front_end</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="separator:a5e1a4d7c14f1aaf601e9a6e231b6b7d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a144fb8b69eb2274b8dcea914898919f0"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a144fb8b69eb2274b8dcea914898919f0">get_next_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="separator:a144fb8b69eb2274b8dcea914898919f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d4b19a83f11ac6244855f86555fe76"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a95d4b19a83f11ac6244855f86555fe76">get_previous_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="separator:a95d4b19a83f11ac6244855f86555fe76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add23d09d2925d505f793979f7fe35921"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#add23d09d2925d505f793979f7fe35921">has_next_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:add23d09d2925d505f793979f7fe35921"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the step is not the last step in a non-circular path.  <a href="classvg_1_1VG.html#add23d09d2925d505f793979f7fe35921">More...</a><br /></td></tr>
<tr class="separator:add23d09d2925d505f793979f7fe35921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f9ec61fe7a32e3756e4b7fc77939ba"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac5f9ec61fe7a32e3756e4b7fc77939ba">has_previous_step</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;step_handle) const</td></tr>
<tr class="memdesc:ac5f9ec61fe7a32e3756e4b7fc77939ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the step is not the first step in a non-circular path.  <a href="classvg_1_1VG.html#ac5f9ec61fe7a32e3756e4b7fc77939ba">More...</a><br /></td></tr>
<tr class="separator:ac5f9ec61fe7a32e3756e4b7fc77939ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527e1ab441e93f73902b7a02b29c1bd6"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a527e1ab441e93f73902b7a02b29c1bd6">for_each_path_handle_impl</a> (const function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="memdesc:a527e1ab441e93f73902b7a02b29c1bd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Execute a function on each path in the graph.  <a href="classvg_1_1VG.html#a527e1ab441e93f73902b7a02b29c1bd6">More...</a><br /></td></tr>
<tr class="separator:a527e1ab441e93f73902b7a02b29c1bd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68b4c3665812b5be48d01677367382fd"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a68b4c3665812b5be48d01677367382fd">for_each_step_on_handle_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const function&lt; bool(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="memdesc:a68b4c3665812b5be48d01677367382fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Loop over the steps of a handle in paths.  <a href="classvg_1_1VG.html#a68b4c3665812b5be48d01677367382fd">More...</a><br /></td></tr>
<tr class="separator:a68b4c3665812b5be48d01677367382fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54ad97e46dc1297b1a65a32697e2d37e"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a54ad97e46dc1297b1a65a32697e2d37e">create_handle</a> (const string &amp;sequence)</td></tr>
<tr class="separator:a54ad97e46dc1297b1a65a32697e2d37e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a292614805cec28a1d863bbdb494d1c04"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a292614805cec28a1d863bbdb494d1c04">create_handle</a> (const string &amp;sequence, const <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &amp;<a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="separator:a292614805cec28a1d863bbdb494d1c04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e52875d37f046daeaf9e7b301ad59ff"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3e52875d37f046daeaf9e7b301ad59ff">destroy_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="separator:a3e52875d37f046daeaf9e7b301ad59ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8922810d5228ab5c4619eb2ddc16e78b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8922810d5228ab5c4619eb2ddc16e78b">create_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right)</td></tr>
<tr class="memdesc:a8922810d5228ab5c4619eb2ddc16e78b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create an edge connecting the given handles in the given order and orientations.  <a href="classvg_1_1VG.html#a8922810d5228ab5c4619eb2ddc16e78b">More...</a><br /></td></tr>
<tr class="separator:a8922810d5228ab5c4619eb2ddc16e78b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d4264e39e3826ded714992361ab879e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a9d4264e39e3826ded714992361ab879e">destroy_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right)</td></tr>
<tr class="memdesc:a9d4264e39e3826ded714992361ab879e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove the edge connecting the given handles in the given order and orientations.  <a href="classvg_1_1VG.html#a9d4264e39e3826ded714992361ab879e">More...</a><br /></td></tr>
<tr class="separator:a9d4264e39e3826ded714992361ab879e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1eb3332c0a99a25c75681da485297e5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa1eb3332c0a99a25c75681da485297e5">clear</a> ()</td></tr>
<tr class="memdesc:aa1eb3332c0a99a25c75681da485297e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all nodes and edges. Does not update any stored paths.  <a href="classvg_1_1VG.html#aa1eb3332c0a99a25c75681da485297e5">More...</a><br /></td></tr>
<tr class="separator:aa1eb3332c0a99a25c75681da485297e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4db6ea2a99bda9a48411491aa6ed4e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3d4db6ea2a99bda9a48411491aa6ed4e">swap_handles</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;a, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;b)</td></tr>
<tr class="separator:a3d4db6ea2a99bda9a48411491aa6ed4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5ee06ac168f037f2cff3b332079b49c"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab5ee06ac168f037f2cff3b332079b49c">apply_orientation</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="separator:ab5ee06ac168f037f2cff3b332079b49c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a5dbc95fa80e7fe3dc04d62ac6d7b3c"><td class="memItemLeft" align="right" valign="top">virtual vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7a5dbc95fa80e7fe3dc04d62ac6d7b3c">divide_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const vector&lt; size_t &gt; &amp;offsets)</td></tr>
<tr class="separator:a7a5dbc95fa80e7fe3dc04d62ac6d7b3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4fa1970f08f3e4d0cf2f8c33a967a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0b4fa1970f08f3e4d0cf2f8c33a967a5">optimize</a> (bool allow_id_reassignment=true)</td></tr>
<tr class="separator:a0b4fa1970f08f3e4d0cf2f8c33a967a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af87ad4202f541fd560d67badcde09610"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af87ad4202f541fd560d67badcde09610">apply_ordering</a> (const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;order, bool <a class="el" href="classvg_1_1VG.html#a161ef56bd0eeee937602f60b8617f24d">compact_ids</a>=false)</td></tr>
<tr class="separator:af87ad4202f541fd560d67badcde09610"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebe71b82645b85e73342366cea0a4549"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aebe71b82645b85e73342366cea0a4549">set_id_increment</a> (const <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &amp;min_id)</td></tr>
<tr class="memdesc:aebe71b82645b85e73342366cea0a4549"><td class="mdescLeft">&#160;</td><td class="mdescRight">No-op function (required by MutableHandleGraph interface)  <a href="classvg_1_1VG.html#aebe71b82645b85e73342366cea0a4549">More...</a><br /></td></tr>
<tr class="separator:aebe71b82645b85e73342366cea0a4549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86b3ecdf29d100a8d43f6aaccd6f2e0e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a86b3ecdf29d100a8d43f6aaccd6f2e0e">increment_node_ids</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> increment)</td></tr>
<tr class="memdesc:a86b3ecdf29d100a8d43f6aaccd6f2e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the given value to all node IDs. Preserves the paths.  <a href="classvg_1_1VG.html#a86b3ecdf29d100a8d43f6aaccd6f2e0e">More...</a><br /></td></tr>
<tr class="separator:a86b3ecdf29d100a8d43f6aaccd6f2e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4a358ff4c7f387c1c6d5d239499a07"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aca4a358ff4c7f387c1c6d5d239499a07">reassign_node_ids</a> (const std::function&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>(const <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &amp;)&gt; &amp;get_new_id)</td></tr>
<tr class="memdesc:aca4a358ff4c7f387c1c6d5d239499a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reassign all node IDs as specified by the old-&gt;new mapping function.  <a href="classvg_1_1VG.html#aca4a358ff4c7f387c1c6d5d239499a07">More...</a><br /></td></tr>
<tr class="separator:aca4a358ff4c7f387c1c6d5d239499a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb25bd1fdb9e36c55157c5be864ca403"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#adb25bd1fdb9e36c55157c5be864ca403">destroy_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path)</td></tr>
<tr class="memdesc:adb25bd1fdb9e36c55157c5be864ca403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the given path. Invalidates handles to the path and its node steps.  <a href="classvg_1_1VG.html#adb25bd1fdb9e36c55157c5be864ca403">More...</a><br /></td></tr>
<tr class="separator:adb25bd1fdb9e36c55157c5be864ca403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7c99e48723b360eb2b1315b2c5af7cc"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af7c99e48723b360eb2b1315b2c5af7cc">create_path_handle</a> (const string &amp;<a class="el" href="classvg_1_1VG.html#a1f6fcd5a907e9bee524cf37a62ad5be2">name</a>, bool is_circular=false)</td></tr>
<tr class="memdesc:af7c99e48723b360eb2b1315b2c5af7cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a path with the given name.  <a href="classvg_1_1VG.html#af7c99e48723b360eb2b1315b2c5af7cc">More...</a><br /></td></tr>
<tr class="separator:af7c99e48723b360eb2b1315b2c5af7cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad11c8a716733fce2aa9dab94b42286bd"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad11c8a716733fce2aa9dab94b42286bd">append_step</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;to_append)</td></tr>
<tr class="memdesc:ad11c8a716733fce2aa9dab94b42286bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a visit to a node to the given path.  <a href="classvg_1_1VG.html#ad11c8a716733fce2aa9dab94b42286bd">More...</a><br /></td></tr>
<tr class="separator:ad11c8a716733fce2aa9dab94b42286bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c2858dc8e80ba160359ccf5e1508d2"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a43c2858dc8e80ba160359ccf5e1508d2">prepend_step</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;to_prepend)</td></tr>
<tr class="memdesc:a43c2858dc8e80ba160359ccf5e1508d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a visit to a node to the given path.  <a href="classvg_1_1VG.html#a43c2858dc8e80ba160359ccf5e1508d2">More...</a><br /></td></tr>
<tr class="separator:a43c2858dc8e80ba160359ccf5e1508d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb2dc75f200cfb7480e671fd55207410"><td class="memItemLeft" align="right" valign="top">virtual pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#abb2dc75f200cfb7480e671fd55207410">rewrite_segment</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;segment_begin, const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;segment_end, const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;new_segment)</td></tr>
<tr class="separator:abb2dc75f200cfb7480e671fd55207410"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73c97ce0157b90f95b888e4b6983f5c8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a73c97ce0157b90f95b888e4b6983f5c8">set_circularity</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, bool circular)</td></tr>
<tr class="separator:a73c97ce0157b90f95b888e4b6983f5c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1131c1ff0a94ed2ec9ef35cb678801b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae1131c1ff0a94ed2ec9ef35cb678801b">set_edge</a> (<a class="el" href="structvg_1_1Edge.html">Edge</a> *)</td></tr>
<tr class="separator:ae1131c1ff0a94ed2ec9ef35cb678801b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b659686076f3d6b7b63ec9678d76a93"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2b659686076f3d6b7b63ec9678d76a93">print_edges</a> (void)</td></tr>
<tr class="separator:a2b659686076f3d6b7b63ec9678d76a93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3032de0eb7258c9e2db4a27f16a8604c"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3032de0eb7258c9e2db4a27f16a8604c">edges_start</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a3032de0eb7258c9e2db4a27f16a8604c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get nodes and backward flags following edges that attach to this node's start.  <a href="classvg_1_1VG.html#a3032de0eb7258c9e2db4a27f16a8604c">More...</a><br /></td></tr>
<tr class="separator:a3032de0eb7258c9e2db4a27f16a8604c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee2439ec8f0d8ee87becac3f6fbf13bb"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aee2439ec8f0d8ee87becac3f6fbf13bb">edges_start</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:aee2439ec8f0d8ee87becac3f6fbf13bb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get nodes and backward flags following edges that attach to this node's start.  <a href="classvg_1_1VG.html#aee2439ec8f0d8ee87becac3f6fbf13bb">More...</a><br /></td></tr>
<tr class="separator:aee2439ec8f0d8ee87becac3f6fbf13bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a37e4df96356dbf4f7e78da9eb8fd89"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a9a37e4df96356dbf4f7e78da9eb8fd89">edges_end</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a9a37e4df96356dbf4f7e78da9eb8fd89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get nodes and backward flags following edges that attach to this node's end.  <a href="classvg_1_1VG.html#a9a37e4df96356dbf4f7e78da9eb8fd89">More...</a><br /></td></tr>
<tr class="separator:a9a37e4df96356dbf4f7e78da9eb8fd89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaaae0ba5428a83ece038f506c9c5df54"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aaaae0ba5428a83ece038f506c9c5df54">edges_end</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:aaaae0ba5428a83ece038f506c9c5df54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get nodes and backward flags following edges that attach to this node's end.  <a href="classvg_1_1VG.html#aaaae0ba5428a83ece038f506c9c5df54">More...</a><br /></td></tr>
<tr class="separator:aaaae0ba5428a83ece038f506c9c5df54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e3720ce267c8167ce679a015063dab6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a9e3720ce267c8167ce679a015063dab6">size</a> (void)</td></tr>
<tr class="memdesc:a9e3720ce267c8167ce679a015063dab6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of nodes.  <a href="classvg_1_1VG.html#a9e3720ce267c8167ce679a015063dab6">More...</a><br /></td></tr>
<tr class="separator:a9e3720ce267c8167ce679a015063dab6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23641dedefa2b6d573939515fcf5974c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a23641dedefa2b6d573939515fcf5974c">length</a> (void)</td></tr>
<tr class="memdesc:a23641dedefa2b6d573939515fcf5974c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Total sequence length.  <a href="classvg_1_1VG.html#a23641dedefa2b6d573939515fcf5974c">More...</a><br /></td></tr>
<tr class="separator:a23641dedefa2b6d573939515fcf5974c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2399de59931e282fb1f4d3da9a8dcb1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac2399de59931e282fb1f4d3da9a8dcb1">VG</a> (void)</td></tr>
<tr class="memdesc:ac2399de59931e282fb1f4d3da9a8dcb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classvg_1_1VG.html#ac2399de59931e282fb1f4d3da9a8dcb1">More...</a><br /></td></tr>
<tr class="separator:ac2399de59931e282fb1f4d3da9a8dcb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc9648985454d3aedd9a477ff0c52b2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2dc9648985454d3aedd9a477ff0c52b2">VG</a> (istream &amp;in, bool showp=false, bool warn_on_duplicates=true)</td></tr>
<tr class="memdesc:a2dc9648985454d3aedd9a477ff0c52b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from <a class="el" href="structvg_1_1Graph.html">Graph</a> objects serialized in a tagged group stream.  <a href="classvg_1_1VG.html#a2dc9648985454d3aedd9a477ff0c52b2">More...</a><br /></td></tr>
<tr class="separator:a2dc9648985454d3aedd9a477ff0c52b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c22829197fc65ced4dd2e0f53cb20ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3c22829197fc65ced4dd2e0f53cb20ff">from_istream</a> (istream &amp;in, bool showp=false, bool warn_on_duplicates=true)</td></tr>
<tr class="separator:a3c22829197fc65ced4dd2e0f53cb20ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fbb777fd8ab6050124a6eaf9eca9133"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0fbb777fd8ab6050124a6eaf9eca9133">VG</a> (const function&lt; void(const function&lt; void(<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;)&gt; &amp;)&gt; &amp;send_graphs, bool showp=false, bool warn_on_duplicates=true)</td></tr>
<tr class="separator:a0fbb777fd8ab6050124a6eaf9eca9133"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d321b31b873153431c261090d052af"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af4d321b31b873153431c261090d052af">VG</a> (const <a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;from, bool showp=false, bool warn_on_duplicates=true)</td></tr>
<tr class="memdesc:af4d321b31b873153431c261090d052af"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct from a single Protobuf graph. The same as making an empty <a class="el" href="classvg_1_1VG.html">VG</a> and using <a class="el" href="classvg_1_1VG.html#a2519c3b939f48bca226e6fdea4c91f9d">extend()</a>.  <a href="classvg_1_1VG.html#af4d321b31b873153431c261090d052af">More...</a><br /></td></tr>
<tr class="separator:af4d321b31b873153431c261090d052af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeafee2d3bc6e0039e99fccdea10f4f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#abeafee2d3bc6e0039e99fccdea10f4f9">VG</a> (set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes, set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;edges)</td></tr>
<tr class="separator:abeafee2d3bc6e0039e99fccdea10f4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52fa15aebd7d190eb743311f31037e55"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, vcflib::Variant &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a52fa15aebd7d190eb743311f31037e55">get_node_nid_to_variant</a> (vcflib::VariantCallFile vfile)</td></tr>
<tr class="separator:a52fa15aebd7d190eb743311f31037e55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c8890bbc32c99bba8ca17f24a11d343"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2c8890bbc32c99bba8ca17f24a11d343">dagify</a> (uint32_t expand_scc_steps, unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt; &amp;node_translation, size_t target_min_walk_length=0, size_t component_length_max=0)</td></tr>
<tr class="separator:a2c8890bbc32c99bba8ca17f24a11d343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6552b9da8cff82802ee24090064eb3a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a6552b9da8cff82802ee24090064eb3a8">unfold</a> (uint32_t max_length, unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt; &amp;node_translation)</td></tr>
<tr class="separator:a6552b9da8cff82802ee24090064eb3a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82185028afbc17aaf60b294297507fd2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a82185028afbc17aaf60b294297507fd2">reverse_complement_graph</a> (unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt;&gt; &amp;node_translation)</td></tr>
<tr class="memdesc:a82185028afbc17aaf60b294297507fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create the reverse complemented graph with topology preserved. Record translation in provided map.  <a href="classvg_1_1VG.html#a82185028afbc17aaf60b294297507fd2">More...</a><br /></td></tr>
<tr class="separator:a82185028afbc17aaf60b294297507fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab015755dc8b427f4e226f920eb26c428"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab015755dc8b427f4e226f920eb26c428">identity_translation</a> (unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt;&gt; &amp;node_translation)</td></tr>
<tr class="memdesc:ab015755dc8b427f4e226f920eb26c428"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record the translation of this graph into itself in the provided map.  <a href="classvg_1_1VG.html#ab015755dc8b427f4e226f920eb26c428">More...</a><br /></td></tr>
<tr class="separator:ab015755dc8b427f4e226f920eb26c428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b314bb2021525e60a0ad23e99fb994"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae9b314bb2021525e60a0ad23e99fb994">overlay_node_translations</a> (const unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt; &amp;over, const unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt; &amp;under)</td></tr>
<tr class="memdesc:ae9b314bb2021525e60a0ad23e99fb994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assume two node translations, the over is based on the under; merge them.  <a href="classvg_1_1VG.html#ae9b314bb2021525e60a0ad23e99fb994">More...</a><br /></td></tr>
<tr class="separator:ae9b314bb2021525e60a0ad23e99fb994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cb2d6686e0bb92d7f0b632fc813702"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a93cb2d6686e0bb92d7f0b632fc813702">break_cycles</a> (void)</td></tr>
<tr class="separator:a93cb2d6686e0bb92d7f0b632fc813702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad517da731d2bf9c81cc28e0a1367af33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad517da731d2bf9c81cc28e0a1367af33">remove_non_path</a> (void)</td></tr>
<tr class="memdesc:ad517da731d2bf9c81cc28e0a1367af33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove pieces of the graph which are not part of any path.  <a href="classvg_1_1VG.html#ad517da731d2bf9c81cc28e0a1367af33">More...</a><br /></td></tr>
<tr class="separator:ad517da731d2bf9c81cc28e0a1367af33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30c369b4c1b0dfa4e9fbc0d3bce82648"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a30c369b4c1b0dfa4e9fbc0d3bce82648">remove_path</a> (void)</td></tr>
<tr class="memdesc:a30c369b4c1b0dfa4e9fbc0d3bce82648"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove pieces of the graph which are part of some path.  <a href="classvg_1_1VG.html#a30c369b4c1b0dfa4e9fbc0d3bce82648">More...</a><br /></td></tr>
<tr class="separator:a30c369b4c1b0dfa4e9fbc0d3bce82648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f160750dfed33c16a257bd5cbecddf"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a26f160750dfed33c16a257bd5cbecddf">get_path_edges</a> (void)</td></tr>
<tr class="memdesc:a26f160750dfed33c16a257bd5cbecddf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all of the edges that are on any path.  <a href="classvg_1_1VG.html#a26f160750dfed33c16a257bd5cbecddf">More...</a><br /></td></tr>
<tr class="separator:a26f160750dfed33c16a257bd5cbecddf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5079416ab826cbc8a5eea3869eb892"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8e5079416ab826cbc8a5eea3869eb892">flip_doubly_reversed_edges</a> (void)</td></tr>
<tr class="memdesc:a8e5079416ab826cbc8a5eea3869eb892"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert edges that are both from_start and to_end to "regular" ones from end to start.  <a href="classvg_1_1VG.html#a8e5079416ab826cbc8a5eea3869eb892">More...</a><br /></td></tr>
<tr class="separator:a8e5079416ab826cbc8a5eea3869eb892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8aef48163c0dd4267d24b629de8a04c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8aef48163c0dd4267d24b629de8a04c8">from_turtle</a> (string filename, string baseuri, bool showp=false)</td></tr>
<tr class="memdesc:a8aef48163c0dd4267d24b629de8a04c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Build a graph from a Turtle stream.  <a href="classvg_1_1VG.html#a8aef48163c0dd4267d24b629de8a04c8">More...</a><br /></td></tr>
<tr class="separator:a8aef48163c0dd4267d24b629de8a04c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7513ddb88aeb58bd85a810c2a2ccdf67"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7513ddb88aeb58bd85a810c2a2ccdf67">~VG</a> (void)</td></tr>
<tr class="memdesc:a7513ddb88aeb58bd85a810c2a2ccdf67"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classvg_1_1VG.html#a7513ddb88aeb58bd85a810c2a2ccdf67">More...</a><br /></td></tr>
<tr class="separator:a7513ddb88aeb58bd85a810c2a2ccdf67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3148455330df9ac055c6bd1eb7da3167"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3148455330df9ac055c6bd1eb7da3167">VG</a> (const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;other)</td></tr>
<tr class="memdesc:a3148455330df9ac055c6bd1eb7da3167"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classvg_1_1VG.html#a3148455330df9ac055c6bd1eb7da3167">More...</a><br /></td></tr>
<tr class="separator:a3148455330df9ac055c6bd1eb7da3167"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8365ccd6a093ec50f7d54b1c7a7c672"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab8365ccd6a093ec50f7d54b1c7a7c672">VG</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:ab8365ccd6a093ec50f7d54b1c7a7c672"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move constructor.  <a href="classvg_1_1VG.html#ab8365ccd6a093ec50f7d54b1c7a7c672">More...</a><br /></td></tr>
<tr class="separator:ab8365ccd6a093ec50f7d54b1c7a7c672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46f1fe88897cfe4d62625cffd3db5ebb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a46f1fe88897cfe4d62625cffd3db5ebb">operator=</a> (const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;other)</td></tr>
<tr class="memdesc:a46f1fe88897cfe4d62625cffd3db5ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="classvg_1_1VG.html#a46f1fe88897cfe4d62625cffd3db5ebb">More...</a><br /></td></tr>
<tr class="separator:a46f1fe88897cfe4d62625cffd3db5ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b3efbadb9fd3923bbc7e8f0b73c524f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3b3efbadb9fd3923bbc7e8f0b73c524f">operator=</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a3b3efbadb9fd3923bbc7e8f0b73c524f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="classvg_1_1VG.html#a3b3efbadb9fd3923bbc7e8f0b73c524f">More...</a><br /></td></tr>
<tr class="separator:a3b3efbadb9fd3923bbc7e8f0b73c524f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f71911fe2c652dc11aec0a0d705b1e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7f71911fe2c652dc11aec0a0d705b1e4">build_indexes</a> (void)</td></tr>
<tr class="separator:a7f71911fe2c652dc11aec0a0d705b1e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5156da43d4175597d7a8b1d88b5179af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5156da43d4175597d7a8b1d88b5179af">build_node_indexes</a> (void)</td></tr>
<tr class="separator:a5156da43d4175597d7a8b1d88b5179af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fb2cb59474393ac822847033f185d17"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3fb2cb59474393ac822847033f185d17">build_edge_indexes</a> (void)</td></tr>
<tr class="separator:a3fb2cb59474393ac822847033f185d17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa78095fb5d27e182c5cc4d5c10d3da39"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa78095fb5d27e182c5cc4d5c10d3da39">build_indexes_no_init_size</a> (void)</td></tr>
<tr class="separator:aa78095fb5d27e182c5cc4d5c10d3da39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca442744267b08609887cd842ca543d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0ca442744267b08609887cd842ca543d">build_node_indexes_no_init_size</a> (void)</td></tr>
<tr class="separator:a0ca442744267b08609887cd842ca543d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63d4a22a3baa5b21623128b81a14872"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af63d4a22a3baa5b21623128b81a14872">build_edge_indexes_no_init_size</a> (void)</td></tr>
<tr class="separator:af63d4a22a3baa5b21623128b81a14872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a212a2d1028f28046088a86e128b40559"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a212a2d1028f28046088a86e128b40559">clear_node_indexes</a> (void)</td></tr>
<tr class="separator:a212a2d1028f28046088a86e128b40559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51220e88887adf92d7cff25dad5cd91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af51220e88887adf92d7cff25dad5cd91">clear_node_indexes_no_resize</a> (void)</td></tr>
<tr class="separator:af51220e88887adf92d7cff25dad5cd91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10d4b49633db2aef463e0070e0af64a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a10d4b49633db2aef463e0070e0af64a0">clear_edge_indexes</a> (void)</td></tr>
<tr class="separator:a10d4b49633db2aef463e0070e0af64a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5195712f8aa650417d93324ff1c89ecf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5195712f8aa650417d93324ff1c89ecf">clear_edge_indexes_no_resize</a> (void)</td></tr>
<tr class="separator:a5195712f8aa650417d93324ff1c89ecf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae960ce1d640fadc4772795f6d0ff5b5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aae960ce1d640fadc4772795f6d0ff5b5">clear_indexes</a> (void)</td></tr>
<tr class="separator:aae960ce1d640fadc4772795f6d0ff5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a103c69bad02121590779530338861374"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a103c69bad02121590779530338861374">clear_indexes_no_resize</a> (void)</td></tr>
<tr class="separator:a103c69bad02121590779530338861374"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8879b1e6aab38b9a246deba0f05ccfe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af8879b1e6aab38b9a246deba0f05ccfe">resize_indexes</a> (void)</td></tr>
<tr class="separator:af8879b1e6aab38b9a246deba0f05ccfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63d4e45a9a410c451b1cad44ef7068ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a63d4e45a9a410c451b1cad44ef7068ad">rebuild_indexes</a> (void)</td></tr>
<tr class="separator:a63d4e45a9a410c451b1cad44ef7068ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6541146b6410cec4be3e2a7379ea3bcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a6541146b6410cec4be3e2a7379ea3bcf">rebuild_edge_indexes</a> (void)</td></tr>
<tr class="separator:a6541146b6410cec4be3e2a7379ea3bcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0abc84684faea29b49032ec254d5e13b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0abc84684faea29b49032ec254d5e13b">merge</a> (<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;g)</td></tr>
<tr class="memdesc:a0abc84684faea29b49032ec254d5e13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Literally merge protobufs.  <a href="classvg_1_1VG.html#a0abc84684faea29b49032ec254d5e13b">More...</a><br /></td></tr>
<tr class="separator:a0abc84684faea29b49032ec254d5e13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40f22f6bb4a3e7a2aea7b3887237faec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a40f22f6bb4a3e7a2aea7b3887237faec">merge</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g)</td></tr>
<tr class="memdesc:a40f22f6bb4a3e7a2aea7b3887237faec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Literally merge protobufs.  <a href="classvg_1_1VG.html#a40f22f6bb4a3e7a2aea7b3887237faec">More...</a><br /></td></tr>
<tr class="separator:a40f22f6bb4a3e7a2aea7b3887237faec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e534461834b2937b7f0b0c2420b899"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa4e534461834b2937b7f0b0c2420b899">clear_paths</a> (void)</td></tr>
<tr class="memdesc:aa4e534461834b2937b7f0b0c2420b899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the paths object (which indexes the graph.paths) and the graph paths themselves.  <a href="classvg_1_1VG.html#aa4e534461834b2937b7f0b0c2420b899">More...</a><br /></td></tr>
<tr class="separator:aa4e534461834b2937b7f0b0c2420b899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a124188a9e0cd68c87c2bc009ea7bd799"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a124188a9e0cd68c87c2bc009ea7bd799">sync_paths</a> (void)</td></tr>
<tr class="memdesc:a124188a9e0cd68c87c2bc009ea7bd799"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize in-memory indexes and protobuf graph.  <a href="classvg_1_1VG.html#a124188a9e0cd68c87c2bc009ea7bd799">More...</a><br /></td></tr>
<tr class="separator:a124188a9e0cd68c87c2bc009ea7bd799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aff716eee0bf720b3836caa761d48be"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5aff716eee0bf720b3836caa761d48be">merge_union</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g)</td></tr>
<tr class="separator:a5aff716eee0bf720b3836caa761d48be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33424c3be8c3e088631dfb37c48773d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a33424c3be8c3e088631dfb37c48773d3">remove_duplicated_in</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g)</td></tr>
<tr class="memdesc:a33424c3be8c3e088631dfb37c48773d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper to merge_union.  <a href="classvg_1_1VG.html#a33424c3be8c3e088631dfb37c48773d3">More...</a><br /></td></tr>
<tr class="separator:a33424c3be8c3e088631dfb37c48773d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba9fb73c326ecfab70e35e44dff6a937"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aba9fb73c326ecfab70e35e44dff6a937">remove_duplicates</a> (void)</td></tr>
<tr class="memdesc:aba9fb73c326ecfab70e35e44dff6a937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove duplicated nodes and edges.  <a href="classvg_1_1VG.html#aba9fb73c326ecfab70e35e44dff6a937">More...</a><br /></td></tr>
<tr class="separator:aba9fb73c326ecfab70e35e44dff6a937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3187dd6ce750583f6b1a7c32f278d2a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad3187dd6ce750583f6b1a7c32f278d2a">serialize_to_function</a> (const function&lt; void(<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;)&gt; &amp;emit, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> chunk_size=1000)</td></tr>
<tr class="separator:ad3187dd6ce750583f6b1a7c32f278d2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59121c0226c3fd8c328641490bf2fac6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a59121c0226c3fd8c328641490bf2fac6">serialize_to_emitter</a> (<a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; <a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &gt; &amp;emitter, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> chunk_size=1000)</td></tr>
<tr class="separator:a59121c0226c3fd8c328641490bf2fac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e67b525bca0f766d7f0170759ed1d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a70e67b525bca0f766d7f0170759ed1d0">serialize_to_ostream</a> (ostream &amp;out, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> chunk_size=1000)</td></tr>
<tr class="separator:a70e67b525bca0f766d7f0170759ed1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3522042a3a00ac802d6738d0bec6269c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3522042a3a00ac802d6738d0bec6269c">serialize_to_file</a> (const string &amp;file_name, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> chunk_size=1000)</td></tr>
<tr class="separator:a3522042a3a00ac802d6738d0bec6269c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161ef56bd0eeee937602f60b8617f24d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a161ef56bd0eeee937602f60b8617f24d">compact_ids</a> (void)</td></tr>
<tr class="memdesc:a161ef56bd0eeee937602f60b8617f24d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Squish the node IDs down into as small a space as possible. Fixes up paths itself.  <a href="classvg_1_1VG.html#a161ef56bd0eeee937602f60b8617f24d">More...</a><br /></td></tr>
<tr class="separator:a161ef56bd0eeee937602f60b8617f24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae931543bdeed5e60edcf6225489e3ceb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae931543bdeed5e60edcf6225489e3ceb">compact_ids</a> (<a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;new_id)</td></tr>
<tr class="separator:ae931543bdeed5e60edcf6225489e3ceb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae60b30eaa432d73f91dc28283679a18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aae60b30eaa432d73f91dc28283679a18">decrement_node_ids</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> decrement)</td></tr>
<tr class="memdesc:aae60b30eaa432d73f91dc28283679a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subtract the given value from all the node IDs. Must not create a node with 0 or negative IDs. Invalidates the paths.  <a href="classvg_1_1VG.html#aae60b30eaa432d73f91dc28283679a18">More...</a><br /></td></tr>
<tr class="separator:aae60b30eaa432d73f91dc28283679a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afee31880eaf65a1a6d1a250663271b54"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#afee31880eaf65a1a6d1a250663271b54">swap_node_id</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> node_id, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> new_id)</td></tr>
<tr class="separator:afee31880eaf65a1a6d1a250663271b54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63f2ffa39d84f80e5ab8068a25a03ee9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a63f2ffa39d84f80e5ab8068a25a03ee9">swap_node_id</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> new_id)</td></tr>
<tr class="separator:a63f2ffa39d84f80e5ab8068a25a03ee9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a902d516631c77d074aa2a11ae70a6957"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a902d516631c77d074aa2a11ae70a6957">sort</a> ()</td></tr>
<tr class="separator:a902d516631c77d074aa2a11ae70a6957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1aecdffe7759a1e14248e00f2866b84"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab1aecdffe7759a1e14248e00f2866b84">id_sort</a> ()</td></tr>
<tr class="memdesc:ab1aecdffe7759a1e14248e00f2866b84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Order the backing graph data structure by node ID.  <a href="classvg_1_1VG.html#ab1aecdffe7759a1e14248e00f2866b84">More...</a><br /></td></tr>
<tr class="separator:ab1aecdffe7759a1e14248e00f2866b84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2519c3b939f48bca226e6fdea4c91f9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2519c3b939f48bca226e6fdea4c91f9d">extend</a> (const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;g, bool warn_on_duplicates=false)</td></tr>
<tr class="separator:a2519c3b939f48bca226e6fdea4c91f9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e517214b33812b16f195a1f87841c0d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5e517214b33812b16f195a1f87841c0d">extend</a> (const <a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;<a class="el" href="classvg_1_1VG.html#a4772c77ed932bfed4d21e247918381a4">graph</a>, bool warn_on_duplicates=false)</td></tr>
<tr class="separator:a5e517214b33812b16f195a1f87841c0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5272032c1e57d839176fc8e39bd87e18"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5272032c1e57d839176fc8e39bd87e18">append</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g)</td></tr>
<tr class="separator:a5272032c1e57d839176fc8e39bd87e18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d06218f137184c366de80df755ae001"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7d06218f137184c366de80df755ae001">combine</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g)</td></tr>
<tr class="separator:a7d06218f137184c366de80df755ae001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e4dac76edcf0218f9749352c19acae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a66e4dac76edcf0218f9749352c19acae">include</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="memdesc:a66e4dac76edcf0218f9749352c19acae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Edit the graph to include the path.  <a href="classvg_1_1VG.html#a66e4dac76edcf0218f9749352c19acae">More...</a><br /></td></tr>
<tr class="separator:a66e4dac76edcf0218f9749352c19acae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5962aa939727f27cb7c62b2ce2706fe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5962aa939727f27cb7c62b2ce2706fe9">edit</a> (vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;paths_to_add, vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; *out_translations=nullptr, bool save_paths=false, bool update_paths=false, bool break_at_ends=false)</td></tr>
<tr class="separator:a5962aa939727f27cb7c62b2ce2706fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa800d382b361f1bdad0e5855dd4c05ca"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa800d382b361f1bdad0e5855dd4c05ca">edit</a> (const string &amp;paths_to_add_path, vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; *out_translations=nullptr, bool save_paths=false, const string &amp;out_gam_path=&quot;&quot;, bool break_at_ends=false, bool remove_softclips=false)</td></tr>
<tr class="separator:aa800d382b361f1bdad0e5855dd4c05ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78f70eb7eddb0245be7cdfc048616638"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a78f70eb7eddb0245be7cdfc048616638">edit_fast</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;dangling, size_t max_node_size=1024)</td></tr>
<tr class="separator:a78f70eb7eddb0245be7cdfc048616638"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3e265ee441758d81fdb7c038e2fa8cc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad3e265ee441758d81fdb7c038e2fa8cc">add_node</a> (const <a class="el" href="structvg_1_1Node.html">Node</a> &amp;node)</td></tr>
<tr class="memdesc:ad3e265ee441758d81fdb7c038e2fa8cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given node, by value.  <a href="classvg_1_1VG.html#ad3e265ee441758d81fdb7c038e2fa8cc">More...</a><br /></td></tr>
<tr class="separator:ad3e265ee441758d81fdb7c038e2fa8cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae71d30b767f067a874c933f13f6c34e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae71d30b767f067a874c933f13f6c34e5">add_nodes</a> (const vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:ae71d30b767f067a874c933f13f6c34e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given nodes, by value.  <a href="classvg_1_1VG.html#ae71d30b767f067a874c933f13f6c34e5">More...</a><br /></td></tr>
<tr class="separator:ae71d30b767f067a874c933f13f6c34e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613c931c81518212917053d07e9bf8a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a613c931c81518212917053d07e9bf8a8">add_edge</a> (const <a class="el" href="structvg_1_1Edge.html">Edge</a> &amp;edge)</td></tr>
<tr class="memdesc:a613c931c81518212917053d07e9bf8a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given edge, by value.  <a href="classvg_1_1VG.html#a613c931c81518212917053d07e9bf8a8">More...</a><br /></td></tr>
<tr class="separator:a613c931c81518212917053d07e9bf8a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f23cdd532ca7b8d3c0bb9cceff3d378"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7f23cdd532ca7b8d3c0bb9cceff3d378">add_edges</a> (const vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; &amp;edges)</td></tr>
<tr class="memdesc:a7f23cdd532ca7b8d3c0bb9cceff3d378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given edges, by value.  <a href="classvg_1_1VG.html#a7f23cdd532ca7b8d3c0bb9cceff3d378">More...</a><br /></td></tr>
<tr class="separator:a7f23cdd532ca7b8d3c0bb9cceff3d378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a679e39a7c1771c3ecc7204bd3b999583"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a679e39a7c1771c3ecc7204bd3b999583">add_edges</a> (const vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;edges)</td></tr>
<tr class="memdesc:a679e39a7c1771c3ecc7204bd3b999583"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given edges, by value.  <a href="classvg_1_1VG.html#a679e39a7c1771c3ecc7204bd3b999583">More...</a><br /></td></tr>
<tr class="separator:a679e39a7c1771c3ecc7204bd3b999583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab796330d50fdff47f5c080e251efea68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab796330d50fdff47f5c080e251efea68">add_nodes</a> (const set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes)</td></tr>
<tr class="memdesc:ab796330d50fdff47f5c080e251efea68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given nodes, by value.  <a href="classvg_1_1VG.html#ab796330d50fdff47f5c080e251efea68">More...</a><br /></td></tr>
<tr class="separator:ab796330d50fdff47f5c080e251efea68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb8712eefbfd373c45f54d6bac8188c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#acb8712eefbfd373c45f54d6bac8188c6">add_edges</a> (const set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;edges)</td></tr>
<tr class="memdesc:acb8712eefbfd373c45f54d6bac8188c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add in the given edges, by value.  <a href="classvg_1_1VG.html#acb8712eefbfd373c45f54d6bac8188c6">More...</a><br /></td></tr>
<tr class="separator:acb8712eefbfd373c45f54d6bac8188c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3e9e655bcaad0bc522307743acd6a0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#abb3e9e655bcaad0bc522307743acd6a0">node_count</a> (void) const</td></tr>
<tr class="memdesc:abb3e9e655bcaad0bc522307743acd6a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of nodes in the graph.  <a href="classvg_1_1VG.html#abb3e9e655bcaad0bc522307743acd6a0">More...</a><br /></td></tr>
<tr class="separator:abb3e9e655bcaad0bc522307743acd6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25ef81b910a6fc47c9a6ba4c1636cf83"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a25ef81b910a6fc47c9a6ba4c1636cf83">edge_count</a> (void) const</td></tr>
<tr class="memdesc:a25ef81b910a6fc47c9a6ba4c1636cf83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the number of edges in the graph.  <a href="classvg_1_1VG.html#a25ef81b910a6fc47c9a6ba4c1636cf83">More...</a><br /></td></tr>
<tr class="separator:a25ef81b910a6fc47c9a6ba4c1636cf83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0202180fa7153f464c3b1d3ff70dc9cb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0202180fa7153f464c3b1d3ff70dc9cb">node_rank</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a0202180fa7153f464c3b1d3ff70dc9cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rank of the node in the protobuf array that backs the graph.  <a href="classvg_1_1VG.html#a0202180fa7153f464c3b1d3ff70dc9cb">More...</a><br /></td></tr>
<tr class="separator:a0202180fa7153f464c3b1d3ff70dc9cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ac4861a64a07f344c21cf2f41b91f1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad7ac4861a64a07f344c21cf2f41b91f1">node_rank</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:ad7ac4861a64a07f344c21cf2f41b91f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rank of the node in the protobuf array that backs the graph.  <a href="classvg_1_1VG.html#ad7ac4861a64a07f344c21cf2f41b91f1">More...</a><br /></td></tr>
<tr class="separator:ad7ac4861a64a07f344c21cf2f41b91f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff00edd627e3445eee7f43927bb1518"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1ff00edd627e3445eee7f43927bb1518">start_degree</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a1ff00edd627e3445eee7f43927bb1518"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges attached to the start of a node.  <a href="classvg_1_1VG.html#a1ff00edd627e3445eee7f43927bb1518">More...</a><br /></td></tr>
<tr class="separator:a1ff00edd627e3445eee7f43927bb1518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3cf82dca43799a03d93b199133f1d4b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af3cf82dca43799a03d93b199133f1d4b">end_degree</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:af3cf82dca43799a03d93b199133f1d4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges attached to the end of a node.  <a href="classvg_1_1VG.html#af3cf82dca43799a03d93b199133f1d4b">More...</a><br /></td></tr>
<tr class="separator:af3cf82dca43799a03d93b199133f1d4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ac6e61dfa9350459dbb9586088c4a5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af9ac6e61dfa9350459dbb9586088c4a5">left_degree</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node)</td></tr>
<tr class="memdesc:af9ac6e61dfa9350459dbb9586088c4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges attached to the left side of a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>.  <a href="classvg_1_1VG.html#af9ac6e61dfa9350459dbb9586088c4a5">More...</a><br /></td></tr>
<tr class="separator:af9ac6e61dfa9350459dbb9586088c4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23622195177dff4c7c8416edffb7fc93"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a23622195177dff4c7c8416edffb7fc93">right_degree</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node)</td></tr>
<tr class="memdesc:a23622195177dff4c7c8416edffb7fc93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of edges attached to the right side of a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>.  <a href="classvg_1_1VG.html#a23622195177dff4c7c8416edffb7fc93">More...</a><br /></td></tr>
<tr class="separator:a23622195177dff4c7c8416edffb7fc93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b6a5e92afb1a70d9c63a1848a01f241"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5b6a5e92afb1a70d9c63a1848a01f241">edges_of_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;edges)</td></tr>
<tr class="separator:a5b6a5e92afb1a70d9c63a1848a01f241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1bf5492e5c6d586cd266d2a48f792df"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa1bf5492e5c6d586cd266d2a48f792df">edges_of</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:aa1bf5492e5c6d586cd266d2a48f792df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edges of the specified node.  <a href="classvg_1_1VG.html#aa1bf5492e5c6d586cd266d2a48f792df">More...</a><br /></td></tr>
<tr class="separator:aa1bf5492e5c6d586cd266d2a48f792df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1a7e0aa663eadc0ebdaaf13b667323e"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae1a7e0aa663eadc0ebdaaf13b667323e">edges_from</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:ae1a7e0aa663eadc0ebdaaf13b667323e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edges from the specified node.  <a href="classvg_1_1VG.html#ae1a7e0aa663eadc0ebdaaf13b667323e">More...</a><br /></td></tr>
<tr class="separator:ae1a7e0aa663eadc0ebdaaf13b667323e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3789cf6561f2d3da5ef85f23b5c6454f"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3789cf6561f2d3da5ef85f23b5c6454f">edges_to</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a3789cf6561f2d3da5ef85f23b5c6454f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edges to the specified node.  <a href="classvg_1_1VG.html#a3789cf6561f2d3da5ef85f23b5c6454f">More...</a><br /></td></tr>
<tr class="separator:a3789cf6561f2d3da5ef85f23b5c6454f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2d900fc42cffe079c3ba3897717eae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3b2d900fc42cffe079c3ba3897717eae">edges_of_nodes</a> (set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes, set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;edges)</td></tr>
<tr class="memdesc:a3b2d900fc42cffe079c3ba3897717eae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edges of the specified set of nodes, and add them to the given set of edge pointers.  <a href="classvg_1_1VG.html#a3b2d900fc42cffe079c3ba3897717eae">More...</a><br /></td></tr>
<tr class="separator:a3b2d900fc42cffe079c3ba3897717eae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a156ac1e1fde520bae82850105c6c66"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1a156ac1e1fde520bae82850105c6c66">sides_to</a> (<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> side)</td></tr>
<tr class="memdesc:a1a156ac1e1fde520bae82850105c6c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sides on the other side of edges to this side of the node.  <a href="classvg_1_1VG.html#a1a156ac1e1fde520bae82850105c6c66">More...</a><br /></td></tr>
<tr class="separator:a1a156ac1e1fde520bae82850105c6c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac670f3c729f93ebaa7c8bd5063225597"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac670f3c729f93ebaa7c8bd5063225597">sides_from</a> (<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> side)</td></tr>
<tr class="memdesc:ac670f3c729f93ebaa7c8bd5063225597"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sides on the other side of edges from this side of the node.  <a href="classvg_1_1VG.html#ac670f3c729f93ebaa7c8bd5063225597">More...</a><br /></td></tr>
<tr class="separator:ac670f3c729f93ebaa7c8bd5063225597"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95c975ed419a0873c894cef7a2f2d3ba"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a95c975ed419a0873c894cef7a2f2d3ba">sides_from</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a95c975ed419a0873c894cef7a2f2d3ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sides from both sides of the node.  <a href="classvg_1_1VG.html#a95c975ed419a0873c894cef7a2f2d3ba">More...</a><br /></td></tr>
<tr class="separator:a95c975ed419a0873c894cef7a2f2d3ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68733706482bf7b2627be32438160af3"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a68733706482bf7b2627be32438160af3">sides_to</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a68733706482bf7b2627be32438160af3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sides to both sides of the node.  <a href="classvg_1_1VG.html#a68733706482bf7b2627be32438160af3">More...</a><br /></td></tr>
<tr class="separator:a68733706482bf7b2627be32438160af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a030b75d2ad50905cc01fe4b7223cbb83"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a030b75d2ad50905cc01fe4b7223cbb83">sides_of</a> (<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> side)</td></tr>
<tr class="memdesc:a030b75d2ad50905cc01fe4b7223cbb83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Union of sides_to and sides_from.  <a href="classvg_1_1VG.html#a030b75d2ad50905cc01fe4b7223cbb83">More...</a><br /></td></tr>
<tr class="separator:a030b75d2ad50905cc01fe4b7223cbb83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad363c6c82e88dcb1b88d05ff55074ed6"><td class="memItemLeft" align="right" valign="top">set&lt; pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad363c6c82e88dcb1b88d05ff55074ed6">sides_context</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> node_id)</td></tr>
<tr class="memdesc:ad363c6c82e88dcb1b88d05ff55074ed6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all sides connecting to this node.  <a href="classvg_1_1VG.html#ad363c6c82e88dcb1b88d05ff55074ed6">More...</a><br /></td></tr>
<tr class="separator:ad363c6c82e88dcb1b88d05ff55074ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96f99984ada5a3a13332ddb2ab0a1c97"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a96f99984ada5a3a13332ddb2ab0a1c97">same_context</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> id1, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> id2)</td></tr>
<tr class="memdesc:a96f99984ada5a3a13332ddb2ab0a1c97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use sides_from an sides_to to determine if both nodes have the same context.  <a href="classvg_1_1VG.html#a96f99984ada5a3a13332ddb2ab0a1c97">More...</a><br /></td></tr>
<tr class="separator:a96f99984ada5a3a13332ddb2ab0a1c97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25215a67c3eac7570e2ab62e825ae169"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a25215a67c3eac7570e2ab62e825ae169">is_ancestor_prev</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> node_id, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> candidate_id)</td></tr>
<tr class="memdesc:a25215a67c3eac7570e2ab62e825ae169"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the node is a prev ancestor of this one.  <a href="classvg_1_1VG.html#a25215a67c3eac7570e2ab62e825ae169">More...</a><br /></td></tr>
<tr class="separator:a25215a67c3eac7570e2ab62e825ae169"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6699fe9d747f761f6efae39c3c0501c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae6699fe9d747f761f6efae39c3c0501c">is_ancestor_prev</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> node_id, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> candidate_id, set&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;seen, size_t steps=64)</td></tr>
<tr class="memdesc:ae6699fe9d747f761f6efae39c3c0501c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the node is a prev ancestor of this one by trying to find it in a given number of steps.  <a href="classvg_1_1VG.html#ae6699fe9d747f761f6efae39c3c0501c">More...</a><br /></td></tr>
<tr class="separator:ae6699fe9d747f761f6efae39c3c0501c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7903acd7a977a85fdd78d306f2063252"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7903acd7a977a85fdd78d306f2063252">is_ancestor_next</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> node_id, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> candidate_id)</td></tr>
<tr class="memdesc:a7903acd7a977a85fdd78d306f2063252"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the node is a next ancestor of this one.  <a href="classvg_1_1VG.html#a7903acd7a977a85fdd78d306f2063252">More...</a><br /></td></tr>
<tr class="separator:a7903acd7a977a85fdd78d306f2063252"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab919097a72a96dada04310b2aaf019f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab919097a72a96dada04310b2aaf019f8">is_ancestor_next</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> node_id, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> candidate_id, set&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;seen, size_t steps=64)</td></tr>
<tr class="memdesc:ab919097a72a96dada04310b2aaf019f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the node is a next ancestor of this one by trying to find it in a given number of steps.  <a href="classvg_1_1VG.html#ab919097a72a96dada04310b2aaf019f8">More...</a><br /></td></tr>
<tr class="separator:ab919097a72a96dada04310b2aaf019f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3ba20713228cb76fa4b982d967654aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab3ba20713228cb76fa4b982d967654aa">common_ancestor_prev</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> id1, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> id2, size_t steps=64)</td></tr>
<tr class="memdesc:ab3ba20713228cb76fa4b982d967654aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a common ancestor by walking back up to steps from the first node.  <a href="classvg_1_1VG.html#ab3ba20713228cb76fa4b982d967654aa">More...</a><br /></td></tr>
<tr class="separator:ab3ba20713228cb76fa4b982d967654aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e1708efaeceace87615bb67715d60fa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2e1708efaeceace87615bb67715d60fa">common_ancestor_next</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> id1, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> id2, size_t steps=64)</td></tr>
<tr class="memdesc:a2e1708efaeceace87615bb67715d60fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Try to find a common ancestor by walking forward up to steps from the first node.  <a href="classvg_1_1VG.html#a2e1708efaeceace87615bb67715d60fa">More...</a><br /></td></tr>
<tr class="separator:a2e1708efaeceace87615bb67715d60fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab213a64c6240d08603530982c0b75047"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab213a64c6240d08603530982c0b75047">adjacent</a> (const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos1, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos2)</td></tr>
<tr class="memdesc:ab213a64c6240d08603530982c0b75047"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if pos1 occurs directly before pos2.  <a href="classvg_1_1VG.html#ab213a64c6240d08603530982c0b75047">More...</a><br /></td></tr>
<tr class="separator:ab213a64c6240d08603530982c0b75047"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb95ac1c24c5263a962c13f3d6bc0c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8cb95ac1c24c5263a962c13f3d6bc0c3">create_node</a> (const string &amp;seq)</td></tr>
<tr class="memdesc:a8cb95ac1c24c5263a962c13f3d6bc0c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a node. Use the <a class="el" href="classvg_1_1VG.html">VG</a> class to generate ids.  <a href="classvg_1_1VG.html#a8cb95ac1c24c5263a962c13f3d6bc0c3">More...</a><br /></td></tr>
<tr class="separator:a8cb95ac1c24c5263a962c13f3d6bc0c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa25ac8acfa9407e8489b402f6317dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aefa25ac8acfa9407e8489b402f6317dc">create_node</a> (const string &amp;seq, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:aefa25ac8acfa9407e8489b402f6317dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a node. Use a specified, nonzero node ID.  <a href="classvg_1_1VG.html#aefa25ac8acfa9407e8489b402f6317dc">More...</a><br /></td></tr>
<tr class="separator:aefa25ac8acfa9407e8489b402f6317dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95223ec6984efc003e5cac69acd43445"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a95223ec6984efc003e5cac69acd43445">get_node</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a95223ec6984efc003e5cac69acd43445"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a particular node.  <a href="classvg_1_1VG.html#a95223ec6984efc003e5cac69acd43445">More...</a><br /></td></tr>
<tr class="separator:a95223ec6984efc003e5cac69acd43445"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa264e9386b98b57c3549a56870d8e29e"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa264e9386b98b57c3549a56870d8e29e">get_node</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>) const</td></tr>
<tr class="separator:aa264e9386b98b57c3549a56870d8e29e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44edad9ba2a6df332234b43715dd71db"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a44edad9ba2a6df332234b43715dd71db">nonoverlapping_node_context_without_paths</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;g)</td></tr>
<tr class="separator:a44edad9ba2a6df332234b43715dd71db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a525e3290d6968c79314c2500f13cc3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a6a525e3290d6968c79314c2500f13cc3">expand_context</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g, size_t distance, bool <a class="el" href="convert__main_8cpp.html#a094fbac0ecc5cde5c47dfc030da6c29e">add_paths</a>=true, bool use_steps=true)</td></tr>
<tr class="separator:a6a525e3290d6968c79314c2500f13cc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4ead561b46cd1cde77ada1f611befa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aca4ead561b46cd1cde77ada1f611befa">expand_context_by_steps</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g, size_t steps, bool <a class="el" href="convert__main_8cpp.html#a094fbac0ecc5cde5c47dfc030da6c29e">add_paths</a>=true)</td></tr>
<tr class="memdesc:aca4ead561b46cd1cde77ada1f611befa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the context of the given graph by the given number of steps.  <a href="classvg_1_1VG.html#aca4ead561b46cd1cde77ada1f611befa">More...</a><br /></td></tr>
<tr class="separator:aca4ead561b46cd1cde77ada1f611befa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba5a5416ee9eaf67c7ae5607fc7ae1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5ba5a5416ee9eaf67c7ae5607fc7ae1f">expand_context_by_length</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;g, size_t <a class="el" href="classvg_1_1VG.html#a23641dedefa2b6d573939515fcf5974c">length</a>, bool <a class="el" href="convert__main_8cpp.html#a094fbac0ecc5cde5c47dfc030da6c29e">add_paths</a>=true, bool reflect=false, const set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;barriers=set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;())</td></tr>
<tr class="separator:a5ba5a5416ee9eaf67c7ae5607fc7ae1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9cd34f3c968f90370c42e8692222619"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab9cd34f3c968f90370c42e8692222619">destroy_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:ab9cd34f3c968f90370c42e8692222619"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the node at the given pointer. This pointer must point to a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a> owned by the graph.  <a href="classvg_1_1VG.html#ab9cd34f3c968f90370c42e8692222619">More...</a><br /></td></tr>
<tr class="separator:ab9cd34f3c968f90370c42e8692222619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a983041950b8dc25a77bd828dd6c05a1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a983041950b8dc25a77bd828dd6c05a1b">destroy_node</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a983041950b8dc25a77bd828dd6c05a1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the node with the given ID.  <a href="classvg_1_1VG.html#a983041950b8dc25a77bd828dd6c05a1b">More...</a><br /></td></tr>
<tr class="separator:a983041950b8dc25a77bd828dd6c05a1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9339913ecff654569a9c81ae091ebfe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac9339913ecff654569a9c81ae091ebfe">has_node</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>) const</td></tr>
<tr class="memdesc:ac9339913ecff654569a9c81ae091ebfe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has a node with the given ID.  <a href="classvg_1_1VG.html#ac9339913ecff654569a9c81ae091ebfe">More...</a><br /></td></tr>
<tr class="separator:ac9339913ecff654569a9c81ae091ebfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a049bd863e2ac7e93aec79404d56b4a34"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a049bd863e2ac7e93aec79404d56b4a34">has_node</a> (const <a class="el" href="structvg_1_1Node.html">Node</a> *node) const</td></tr>
<tr class="memdesc:a049bd863e2ac7e93aec79404d56b4a34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph contains the given node.  <a href="classvg_1_1VG.html#a049bd863e2ac7e93aec79404d56b4a34">More...</a><br /></td></tr>
<tr class="separator:a049bd863e2ac7e93aec79404d56b4a34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab000649761c7201555284390dd8a4fa0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab000649761c7201555284390dd8a4fa0">has_node</a> (const <a class="el" href="structvg_1_1Node.html">Node</a> &amp;node) const</td></tr>
<tr class="memdesc:ab000649761c7201555284390dd8a4fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph contains the given node.  <a href="classvg_1_1VG.html#ab000649761c7201555284390dd8a4fa0">More...</a><br /></td></tr>
<tr class="separator:ab000649761c7201555284390dd8a4fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04774a86b07508e9e5955abfba2171ff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a04774a86b07508e9e5955abfba2171ff">find_node_by_name_or_add_new</a> (string <a class="el" href="classvg_1_1VG.html#a1f6fcd5a907e9bee524cf37a62ad5be2">name</a>)</td></tr>
<tr class="memdesc:a04774a86b07508e9e5955abfba2171ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find a node with the given name, or create a new one if none is found.  <a href="classvg_1_1VG.html#a04774a86b07508e9e5955abfba2171ff">More...</a><br /></td></tr>
<tr class="separator:a04774a86b07508e9e5955abfba2171ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af585f2161de09403d197e05fbcfb9a07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af585f2161de09403d197e05fbcfb9a07">for_each_node</a> (function&lt; void(<a class="el" href="structvg_1_1Node.html">Node</a> *)&gt; lambda)</td></tr>
<tr class="memdesc:af585f2161de09403d197e05fbcfb9a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the given function on every node.  <a href="classvg_1_1VG.html#af585f2161de09403d197e05fbcfb9a07">More...</a><br /></td></tr>
<tr class="separator:af585f2161de09403d197e05fbcfb9a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23b34b164590c0537bf704dd1b816760"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a23b34b164590c0537bf704dd1b816760">for_each_node</a> (function&lt; void(const <a class="el" href="structvg_1_1Node.html">Node</a> *)&gt; lambda) const</td></tr>
<tr class="separator:a23b34b164590c0537bf704dd1b816760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39790d52fe4c09804086d58164258fcf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a39790d52fe4c09804086d58164258fcf">for_each_node_parallel</a> (function&lt; void(<a class="el" href="structvg_1_1Node.html">Node</a> *)&gt; lambda)</td></tr>
<tr class="memdesc:a39790d52fe4c09804086d58164258fcf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the given function on every node in parallel.  <a href="classvg_1_1VG.html#a39790d52fe4c09804086d58164258fcf">More...</a><br /></td></tr>
<tr class="separator:a39790d52fe4c09804086d58164258fcf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a892abc4056e30044ae9ce0db9e4871f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a892abc4056e30044ae9ce0db9e4871f0">for_each_connected_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, function&lt; void(<a class="el" href="structvg_1_1Node.html">Node</a> *)&gt; lambda)</td></tr>
<tr class="memdesc:a892abc4056e30044ae9ce0db9e4871f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Go through all the nodes in the same connected component as the given node. Ignores relative orientation.  <a href="classvg_1_1VG.html#a892abc4056e30044ae9ce0db9e4871f0">More...</a><br /></td></tr>
<tr class="separator:a892abc4056e30044ae9ce0db9e4871f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec0db609d022b3c3183403600970238f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aec0db609d022b3c3183403600970238f">dfs</a> (const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;node_begin_fn, const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;node_end_fn, const function&lt; bool(void)&gt; &amp;break_fn, const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;edge_fn, const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;tree_fn, const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;edge_curr_fn, const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;edge_cross_fn, const vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *sources, const unordered_set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *sinks)</td></tr>
<tr class="separator:aec0db609d022b3c3183403600970238f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a287e5d12ba0bc0823d1b6e0fa56af3d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a287e5d12ba0bc0823d1b6e0fa56af3d6">dfs</a> (const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;node_begin_fn, const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;node_end_fn, const vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *sources=NULL, const unordered_set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *sinks=NULL)</td></tr>
<tr class="memdesc:a287e5d12ba0bc0823d1b6e0fa56af3d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of dfs for only handling nodes.  <a href="classvg_1_1VG.html#a287e5d12ba0bc0823d1b6e0fa56af3d6">More...</a><br /></td></tr>
<tr class="separator:a287e5d12ba0bc0823d1b6e0fa56af3d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee80f3ce939643d59157e1a1d707068"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8ee80f3ce939643d59157e1a1d707068">dfs</a> (const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;node_begin_fn, const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;node_end_fn, const function&lt; bool(void)&gt; &amp;break_fn)</td></tr>
<tr class="memdesc:a8ee80f3ce939643d59157e1a1d707068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of dfs for only handling nodes + break function.  <a href="classvg_1_1VG.html#a8ee80f3ce939643d59157e1a1d707068">More...</a><br /></td></tr>
<tr class="separator:a8ee80f3ce939643d59157e1a1d707068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d7f84de5d99fe0ce51186fcbea420c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a42d7f84de5d99fe0ce51186fcbea420c">empty</a> (void) const</td></tr>
<tr class="memdesc:a42d7f84de5d99fe0ce51186fcbea420c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the graph empty?  <a href="classvg_1_1VG.html#a42d7f84de5d99fe0ce51186fcbea420c">More...</a><br /></td></tr>
<tr class="separator:a42d7f84de5d99fe0ce51186fcbea420c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b75ca400f858be77b0716ab7c68dfcb"><td class="memItemLeft" align="right" valign="top">const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2b75ca400f858be77b0716ab7c68dfcb">hash</a> (void)</td></tr>
<tr class="memdesc:a2b75ca400f858be77b0716ab7c68dfcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generate a digest of the serialized graph.  <a href="classvg_1_1VG.html#a2b75ca400f858be77b0716ab7c68dfcb">More...</a><br /></td></tr>
<tr class="separator:a2b75ca400f858be77b0716ab7c68dfcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b107027697644d771eb529037201f71"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a9b107027697644d771eb529037201f71">remove_null_nodes</a> (void)</td></tr>
<tr class="separator:a9b107027697644d771eb529037201f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92694e7fd89275603c967739e60e0d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab92694e7fd89275603c967739e60e0d2">remove_node_forwarding_edges</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:ab92694e7fd89275603c967739e60e0d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove a node but connect all of its predecessor and successor nodes with new edges.  <a href="classvg_1_1VG.html#ab92694e7fd89275603c967739e60e0d2">More...</a><br /></td></tr>
<tr class="separator:ab92694e7fd89275603c967739e60e0d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e887a7b2cfc666f2210889a2dec791b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0e887a7b2cfc666f2210889a2dec791b">remove_null_nodes_forwarding_edges</a> (void)</td></tr>
<tr class="memdesc:a0e887a7b2cfc666f2210889a2dec791b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove null nodes but connect predecessors and successors, preserving structure.  <a href="classvg_1_1VG.html#a0e887a7b2cfc666f2210889a2dec791b">More...</a><br /></td></tr>
<tr class="separator:a0e887a7b2cfc666f2210889a2dec791b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40dd9bc0458a4948afd676374ae8d1f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a40dd9bc0458a4948afd676374ae8d1f0">remove_orphan_edges</a> (void)</td></tr>
<tr class="memdesc:a40dd9bc0458a4948afd676374ae8d1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove edges for which one of the nodes is not present.  <a href="classvg_1_1VG.html#a40dd9bc0458a4948afd676374ae8d1f0">More...</a><br /></td></tr>
<tr class="separator:a40dd9bc0458a4948afd676374ae8d1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76005ed499eea217c9f778028751137c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a76005ed499eea217c9f778028751137c">remove_inverting_edges</a> (void)</td></tr>
<tr class="memdesc:a76005ed499eea217c9f778028751137c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove edges representing an inversion and edges on the reverse complement.  <a href="classvg_1_1VG.html#a76005ed499eea217c9f778028751137c">More...</a><br /></td></tr>
<tr class="separator:a76005ed499eea217c9f778028751137c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d1dbb49df52e016746829776ca0f952"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8d1dbb49df52e016746829776ca0f952">has_inverting_edges</a> (void)</td></tr>
<tr class="memdesc:a8d1dbb49df52e016746829776ca0f952"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has inversions.  <a href="classvg_1_1VG.html#a8d1dbb49df52e016746829776ca0f952">More...</a><br /></td></tr>
<tr class="separator:a8d1dbb49df52e016746829776ca0f952"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2aa9d438bcec4d7facbfcc44abea8fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac2aa9d438bcec4d7facbfcc44abea8fd">keep_paths</a> (const set&lt; string &gt; &amp;path_names, set&lt; string &gt; &amp;kept_names)</td></tr>
<tr class="separator:ac2aa9d438bcec4d7facbfcc44abea8fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65cc16f52f478a25e84c6f1fc2805915"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a65cc16f52f478a25e84c6f1fc2805915">keep_path</a> (const string &amp;path_name)</td></tr>
<tr class="separator:a65cc16f52f478a25e84c6f1fc2805915"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1df72d85d8a72524b76abca972f33d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5f1df72d85d8a72524b76abca972f33d">path_edge_count</a> (list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;path, int32_t <a class="el" href="namespacevg.html#a416939020600ce2996331c350f1fe68c">offset</a>, int path_length)</td></tr>
<tr class="separator:a5f1df72d85d8a72524b76abca972f33d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f45b42614f4ac36c8060634ec0d9805"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8f45b42614f4ac36c8060634ec0d9805">path_end_node_offset</a> (list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;path, int32_t <a class="el" href="namespacevg.html#a416939020600ce2996331c350f1fe68c">offset</a>, int path_length)</td></tr>
<tr class="separator:a8f45b42614f4ac36c8060634ec0d9805"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871d05e0a2d0b76092e20fe86bd12e2b"><td class="memItemLeft" align="right" valign="top">const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a871d05e0a2d0b76092e20fe86bd12e2b">paths_as_alignments</a> (void)</td></tr>
<tr class="memdesc:a871d05e0a2d0b76092e20fe86bd12e2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the stored paths in this graph to alignments.  <a href="classvg_1_1VG.html#a871d05e0a2d0b76092e20fe86bd12e2b">More...</a><br /></td></tr>
<tr class="separator:a871d05e0a2d0b76092e20fe86bd12e2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ce6fe02b243b4f0f82bbf801fd507fa"><td class="memItemLeft" align="right" valign="top">const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a4ce6fe02b243b4f0f82bbf801fd507fa">path_sequence</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="memdesc:a4ce6fe02b243b4f0f82bbf801fd507fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return sequence string of path.  <a href="classvg_1_1VG.html#a4ce6fe02b243b4f0f82bbf801fd507fa">More...</a><br /></td></tr>
<tr class="separator:a4ce6fe02b243b4f0f82bbf801fd507fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9bd4133841d1d781fb0df4171773139"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad9bd4133841d1d781fb0df4171773139">path_identity</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path1, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path2)</td></tr>
<tr class="separator:ad9bd4133841d1d781fb0df4171773139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57296ecbcfce10f95b86233e10c35d7d"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a57296ecbcfce10f95b86233e10c35d7d">trav_sequence</a> (const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;trav)</td></tr>
<tr class="memdesc:a57296ecbcfce10f95b86233e10c35d7d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the sequence of a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>.  <a href="classvg_1_1VG.html#a57296ecbcfce10f95b86233e10c35d7d">More...</a><br /></td></tr>
<tr class="separator:a57296ecbcfce10f95b86233e10c35d7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07462d3f895e77cb407695e6c8e85727"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a07462d3f895e77cb407695e6c8e85727">get_node_at_nucleotide</a> (string pathname, int nuc)</td></tr>
<tr class="separator:a07462d3f895e77cb407695e6c8e85727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ecb9833a1b3e7d5ca41fcaa96000976"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8ecb9833a1b3e7d5ca41fcaa96000976">create_edge</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *from, <a class="el" href="structvg_1_1Node.html">Node</a> *to, bool from_start=false, bool to_end=false)</td></tr>
<tr class="separator:a8ecb9833a1b3e7d5ca41fcaa96000976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf766c692dc78334d6b7568f1a9d972b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#abf766c692dc78334d6b7568f1a9d972b">create_edge</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> from, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> to, bool from_start=false, bool to_end=false)</td></tr>
<tr class="separator:abf766c692dc78334d6b7568f1a9d972b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd0565d5133a239856444049783edcd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8fd0565d5133a239856444049783edcd">create_edge</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> left, <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> right)</td></tr>
<tr class="separator:a8fd0565d5133a239856444049783edcd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2cd4705aa5b919f349d02089c97cbc2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac2cd4705aa5b919f349d02089c97cbc2">create_edge</a> (<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> side1, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> side2)</td></tr>
<tr class="separator:ac2cd4705aa5b919f349d02089c97cbc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8668ddc84b9abe4fe9cb5acb3efd877b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8668ddc84b9abe4fe9cb5acb3efd877b">get_edge</a> (const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side1, const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side2)</td></tr>
<tr class="separator:a8668ddc84b9abe4fe9cb5acb3efd877b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a227023072262f46f7c423d30cf8bc443"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a227023072262f46f7c423d30cf8bc443">get_edge</a> (const pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;sides)</td></tr>
<tr class="separator:a227023072262f46f7c423d30cf8bc443"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af63d7ba7b69594ee99f3ad99dd394171"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af63d7ba7b69594ee99f3ad99dd394171">get_edge</a> (const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;left, const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;right)</td></tr>
<tr class="memdesc:af63d7ba7b69594ee99f3ad99dd394171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edge connecting the given oriented nodes in the given order.  <a href="classvg_1_1VG.html#af63d7ba7b69594ee99f3ad99dd394171">More...</a><br /></td></tr>
<tr class="separator:af63d7ba7b69594ee99f3ad99dd394171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a284327157f9d4b82224fc856179a668d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a284327157f9d4b82224fc856179a668d">destroy_edge</a> (<a class="el" href="structvg_1_1Edge.html">Edge</a> *edge)</td></tr>
<tr class="memdesc:a284327157f9d4b82224fc856179a668d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the edge at the given pointer. This pointer must point to an edge owned by the graph.  <a href="classvg_1_1VG.html#a284327157f9d4b82224fc856179a668d">More...</a><br /></td></tr>
<tr class="separator:a284327157f9d4b82224fc856179a668d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6b91020abf39815d28995eceac4e2d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#abe6b91020abf39815d28995eceac4e2d">destroy_edge</a> (const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side1, const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side2)</td></tr>
<tr class="memdesc:abe6b91020abf39815d28995eceac4e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the edge between the given sides of nodes. These can be in either order.  <a href="classvg_1_1VG.html#abe6b91020abf39815d28995eceac4e2d">More...</a><br /></td></tr>
<tr class="separator:abe6b91020abf39815d28995eceac4e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fd2744b37b62862df68e82cbe7b6b59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7fd2744b37b62862df68e82cbe7b6b59">destroy_edge</a> (const pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;sides)</td></tr>
<tr class="memdesc:a7fd2744b37b62862df68e82cbe7b6b59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the edge between the given sides of nodes. This can take sides in any order.  <a href="classvg_1_1VG.html#a7fd2744b37b62862df68e82cbe7b6b59">More...</a><br /></td></tr>
<tr class="separator:a7fd2744b37b62862df68e82cbe7b6b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0b7db8d3043747e8b9a44cba4eaac9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1c0b7db8d3043747e8b9a44cba4eaac9">unindex_edge_by_node_sides</a> (const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side1, const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side2)</td></tr>
<tr class="separator:a1c0b7db8d3043747e8b9a44cba4eaac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5677da9ff22052f6c6a85bfe66e1256d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5677da9ff22052f6c6a85bfe66e1256d">unindex_edge_by_node_sides</a> (<a class="el" href="structvg_1_1Edge.html">Edge</a> *edge)</td></tr>
<tr class="separator:a5677da9ff22052f6c6a85bfe66e1256d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53ff7033966852f5fb3852716cab21a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a53ff7033966852f5fb3852716cab21a9">index_edge_by_node_sides</a> (<a class="el" href="structvg_1_1Edge.html">Edge</a> *edge)</td></tr>
<tr class="separator:a53ff7033966852f5fb3852716cab21a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a447d717e83131c526d26e6d2f0a091a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a447d717e83131c526d26e6d2f0a091a6">has_edge</a> (const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side1, const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;side2) const</td></tr>
<tr class="memdesc:a447d717e83131c526d26e6d2f0a091a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the edge between the given node sides, which can be in either order.  <a href="classvg_1_1VG.html#a447d717e83131c526d26e6d2f0a091a6">More...</a><br /></td></tr>
<tr class="separator:a447d717e83131c526d26e6d2f0a091a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7ff3b6f9cfca2c21e1a8d1c848fc01"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1c7ff3b6f9cfca2c21e1a8d1c848fc01">has_edge</a> (const pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;sides) const</td></tr>
<tr class="memdesc:a1c7ff3b6f9cfca2c21e1a8d1c848fc01"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an edge. This can take sides in any order.  <a href="classvg_1_1VG.html#a1c7ff3b6f9cfca2c21e1a8d1c848fc01">More...</a><br /></td></tr>
<tr class="separator:a1c7ff3b6f9cfca2c21e1a8d1c848fc01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69701fcb4bf9e8b593681ba1d818571"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa69701fcb4bf9e8b593681ba1d818571">has_edge</a> (<a class="el" href="structvg_1_1Edge.html">Edge</a> *edge) const</td></tr>
<tr class="memdesc:aa69701fcb4bf9e8b593681ba1d818571"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an edge. This can take sides in any order.  <a href="classvg_1_1VG.html#aa69701fcb4bf9e8b593681ba1d818571">More...</a><br /></td></tr>
<tr class="separator:aa69701fcb4bf9e8b593681ba1d818571"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2c85fad61f57260c913bc565a549832"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab2c85fad61f57260c913bc565a549832">has_edge</a> (const <a class="el" href="structvg_1_1Edge.html">Edge</a> &amp;edge) const</td></tr>
<tr class="memdesc:ab2c85fad61f57260c913bc565a549832"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an edge. This can take sides in any order.  <a href="classvg_1_1VG.html#ab2c85fad61f57260c913bc565a549832">More...</a><br /></td></tr>
<tr class="separator:ab2c85fad61f57260c913bc565a549832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49fb4de3494407b800c3efda254851cf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a49fb4de3494407b800c3efda254851cf">has_inverting_edge</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *n)</td></tr>
<tr class="memdesc:a49fb4de3494407b800c3efda254851cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an inverting edge on the given node.  <a href="classvg_1_1VG.html#a49fb4de3494407b800c3efda254851cf">More...</a><br /></td></tr>
<tr class="separator:a49fb4de3494407b800c3efda254851cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b7bbf066c6608211e7527ba50b23e48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7b7bbf066c6608211e7527ba50b23e48">has_inverting_edge_from</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *n)</td></tr>
<tr class="memdesc:a7b7bbf066c6608211e7527ba50b23e48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an inverting edge from the given node.  <a href="classvg_1_1VG.html#a7b7bbf066c6608211e7527ba50b23e48">More...</a><br /></td></tr>
<tr class="separator:a7b7bbf066c6608211e7527ba50b23e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63088ee0039a8e1f5cf6b5a3b23f745a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a63088ee0039a8e1f5cf6b5a3b23f745a">has_inverting_edge_to</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *n)</td></tr>
<tr class="memdesc:a63088ee0039a8e1f5cf6b5a3b23f745a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph has an inverting edge to the given node.  <a href="classvg_1_1VG.html#a63088ee0039a8e1f5cf6b5a3b23f745a">More...</a><br /></td></tr>
<tr class="separator:a63088ee0039a8e1f5cf6b5a3b23f745a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7fdd8c951cbf8b25e116435b5e1e0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3d7fdd8c951cbf8b25e116435b5e1e0e">for_each_edge</a> (function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; lambda)</td></tr>
<tr class="memdesc:a3d7fdd8c951cbf8b25e116435b5e1e0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the given function for each edge.  <a href="classvg_1_1VG.html#a3d7fdd8c951cbf8b25e116435b5e1e0e">More...</a><br /></td></tr>
<tr class="separator:a3d7fdd8c951cbf8b25e116435b5e1e0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed86f57c2e9766da9757e18ef543d35d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aed86f57c2e9766da9757e18ef543d35d">for_each_edge</a> (function&lt; void(const <a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; lambda) const</td></tr>
<tr class="separator:aed86f57c2e9766da9757e18ef543d35d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46a20aa427767a27fd15d181ccca8c42"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a46a20aa427767a27fd15d181ccca8c42">for_each_edge_parallel</a> (function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; lambda)</td></tr>
<tr class="memdesc:a46a20aa427767a27fd15d181ccca8c42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Run the given function for each edge, in parallel.  <a href="classvg_1_1VG.html#a46a20aa427767a27fd15d181ccca8c42">More...</a><br /></td></tr>
<tr class="separator:a46a20aa427767a27fd15d181ccca8c42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e2649b8ef5de75db451146c7ac92e92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1e2649b8ef5de75db451146c7ac92e92">circularize</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> head, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> tail)</td></tr>
<tr class="memdesc:a1e2649b8ef5de75db451146c7ac92e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Circularize a subgraph / path using the head / tail nodes.  <a href="classvg_1_1VG.html#a1e2649b8ef5de75db451146c7ac92e92">More...</a><br /></td></tr>
<tr class="separator:a1e2649b8ef5de75db451146c7ac92e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96ff883534a13b28b18cd84dd094e72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad96ff883534a13b28b18cd84dd094e72">circularize</a> (vector&lt; string &gt; pathnames)</td></tr>
<tr class="separator:ad96ff883534a13b28b18cd84dd094e72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad68d2bfaa6627686967add4ca7fb5f4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad68d2bfaa6627686967add4ca7fb5f4c">connect_node_to_nodes</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node, vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="separator:ad68d2bfaa6627686967add4ca7fb5f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8189716ecbb9eeeefec8be64e34a9e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab8189716ecbb9eeeefec8be64e34a9e3">connect_node_to_nodes</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes, bool from_start=false)</td></tr>
<tr class="separator:ab8189716ecbb9eeeefec8be64e34a9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee6066424793dfcda9097419f03b568"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7ee6066424793dfcda9097419f03b568">connect_nodes_to_node</a> (vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes, <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node)</td></tr>
<tr class="separator:a7ee6066424793dfcda9097419f03b568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc4db5878a40e8dc7d2d2b25ff62ff1e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#acc4db5878a40e8dc7d2d2b25ff62ff1e">connect_nodes_to_node</a> (vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes, <a class="el" href="structvg_1_1Node.html">Node</a> *node, bool to_end=false)</td></tr>
<tr class="memdesc:acc4db5878a40e8dc7d2d2b25ff62ff1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">connect nodes -&gt; node.  <a href="classvg_1_1VG.html#acc4db5878a40e8dc7d2d2b25ff62ff1e">More...</a><br /></td></tr>
<tr class="separator:acc4db5878a40e8dc7d2d2b25ff62ff1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad06f0fcad4bf5b1c29cf937a870a58b4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad06f0fcad4bf5b1c29cf937a870a58b4">divide_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, int pos, <a class="el" href="structvg_1_1Node.html">Node</a> *&amp;left, <a class="el" href="structvg_1_1Node.html">Node</a> *&amp;right)</td></tr>
<tr class="separator:ad06f0fcad4bf5b1c29cf937a870a58b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bee7317e4f7e42d85d8e7ef8d07273a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7bee7317e4f7e42d85d8e7ef8d07273a">divide_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, vector&lt; int &gt; &amp;positions, vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;parts)</td></tr>
<tr class="memdesc:a7bee7317e4f7e42d85d8e7ef8d07273a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a node at a given internal position. This version works on a collection of internal positions, in linear time.  <a href="classvg_1_1VG.html#a7bee7317e4f7e42d85d8e7ef8d07273a">More...</a><br /></td></tr>
<tr class="separator:a7bee7317e4f7e42d85d8e7ef8d07273a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0466bd1a92042266f6a99aa306d387c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0466bd1a92042266f6a99aa306d387c9">divide_path</a> (map&lt; long, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;path, long pos, <a class="el" href="structvg_1_1Node.html">Node</a> *&amp;left, <a class="el" href="structvg_1_1Node.html">Node</a> *&amp;right)</td></tr>
<tr class="memdesc:a0466bd1a92042266f6a99aa306d387c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Divide a path at a position. Also invalidates stored rank information.  <a href="classvg_1_1VG.html#a0466bd1a92042266f6a99aa306d387c9">More...</a><br /></td></tr>
<tr class="separator:a0466bd1a92042266f6a99aa306d387c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af502bd29a58e62ff70f8f963d47401a4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af502bd29a58e62ff70f8f963d47401a4">to_dot</a> (ostream &amp;out, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; alignments={}, vector&lt; <a class="el" href="structvg_1_1Locus.html">Locus</a> &gt; loci={}, bool show_paths=false, bool walk_paths=false, bool annotate_paths=false, bool show_mappings=false, bool simple_mode=false, bool noseq_mode=false, bool invert_edge_ports=false, bool color_variants=false, bool ultrabubble_labeling=false, bool skip_missing_nodes=false, bool ascii_labels=false, int random_seed=0)</td></tr>
<tr class="memdesc:af502bd29a58e62ff70f8f963d47401a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the graph to Dot format.  <a href="classvg_1_1VG.html#af502bd29a58e62ff70f8f963d47401a4">More...</a><br /></td></tr>
<tr class="separator:af502bd29a58e62ff70f8f963d47401a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a582500a3d49fe231faa49a5c2e467cc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a582500a3d49fe231faa49a5c2e467cc8">to_turtle</a> (ostream &amp;out, const string &amp;rdf_base_uri, bool precompress)</td></tr>
<tr class="memdesc:a582500a3d49fe231faa49a5c2e467cc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the graph to Turtle format.  <a href="classvg_1_1VG.html#a582500a3d49fe231faa49a5c2e467cc8">More...</a><br /></td></tr>
<tr class="separator:a582500a3d49fe231faa49a5c2e467cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77d93fdf76698460ce509ea5dcde954"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa77d93fdf76698460ce509ea5dcde954">is_valid</a> (bool check_nodes=true, bool check_edges=true, bool check_paths=true, bool check_orphans=true)</td></tr>
<tr class="memdesc:aa77d93fdf76698460ce509ea5dcde954"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if the graph is valid or not, according to the specified criteria.  <a href="classvg_1_1VG.html#aa77d93fdf76698460ce509ea5dcde954">More...</a><br /></td></tr>
<tr class="separator:aa77d93fdf76698460ce509ea5dcde954"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa402d1cf817f83ca44f72f6112b6a2e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa402d1cf817f83ca44f72f6112b6a2e3">swap_nodes</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *a, <a class="el" href="structvg_1_1Node.html">Node</a> *b)</td></tr>
<tr class="memdesc:aa402d1cf817f83ca44f72f6112b6a2e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Swap the given nodes. TODO: what does that mean?  <a href="classvg_1_1VG.html#aa402d1cf817f83ca44f72f6112b6a2e3">More...</a><br /></td></tr>
<tr class="separator:aa402d1cf817f83ca44f72f6112b6a2e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac17b237e99636d20e12e4c1b94f9110b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac17b237e99636d20e12e4c1b94f9110b">align</a> (const string &amp;sequence, const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *aligner, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0)</td></tr>
<tr class="separator:ac17b237e99636d20e12e4c1b94f9110b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09fa1d70c31c354915773e59a1a9b55c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a09fa1d70c31c354915773e59a1a9b55c">align</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *aligner, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0)</td></tr>
<tr class="separator:a09fa1d70c31c354915773e59a1a9b55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6b16848db51add920b025829e2a5d55"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae6b16848db51add920b025829e2a5d55">align</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *aligner, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0)</td></tr>
<tr class="separator:ae6b16848db51add920b025829e2a5d55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4e6f3f52479b59a73b04c58945277b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3d4e6f3f52479b59a73b04c58945277b">align</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0)</td></tr>
<tr class="separator:a3d4e6f3f52479b59a73b04c58945277b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81a72bb91912cabbec795e17c311dc9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af81a72bb91912cabbec795e17c311dc9">align</a> (const string &amp;sequence, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0)</td></tr>
<tr class="separator:af81a72bb91912cabbec795e17c311dc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5532978af43e5c4e5e4f471069e53344"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a5532978af43e5c4e5e4f471069e53344">align_qual_adjusted</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *qual_adj_aligner, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0)</td></tr>
<tr class="separator:a5532978af43e5c4e5e4f471069e53344"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b135ccb439e99ef1f509a11ea9ea9ce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2b135ccb439e99ef1f509a11ea9ea9ce">align_qual_adjusted</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *qual_adj_aligner, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0)</td></tr>
<tr class="separator:a2b135ccb439e99ef1f509a11ea9ea9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58919649b2a29d36fd965ba453046baf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a58919649b2a29d36fd965ba453046baf">align_qual_adjusted</a> (const string &amp;sequence, const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *qual_adj_aligner, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0)</td></tr>
<tr class="separator:a58919649b2a29d36fd965ba453046baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8dc8d762d07088089247b632c835a19d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8dc8d762d07088089247b632c835a19d">paths_between</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *from, <a class="el" href="structvg_1_1Node.html">Node</a> *to, vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;<a class="el" href="classvg_1_1VG.html#a7c5150aba84e7ed2bde7986462a79989">paths</a>)</td></tr>
<tr class="separator:a8dc8d762d07088089247b632c835a19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a5a5cb1bac139c5a3a947a0d5a3313d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0a5a5cb1bac139c5a3a947a0d5a3313d">paths_between</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> from, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> to, vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;<a class="el" href="classvg_1_1VG.html#a7c5150aba84e7ed2bde7986462a79989">paths</a>)</td></tr>
<tr class="separator:a0a5a5cb1bac139c5a3a947a0d5a3313d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada5821862279a350885f5368a54a5cba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ada5821862279a350885f5368a54a5cba">likelihoods</a> (vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alignments, vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;<a class="el" href="classvg_1_1VG.html#a7c5150aba84e7ed2bde7986462a79989">paths</a>, vector&lt; long double &gt; &amp;likelihoods)</td></tr>
<tr class="separator:ada5821862279a350885f5368a54a5cba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac08e778396904ad3b3f20f605f54628d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac08e778396904ad3b3f20f605f54628d">nodes_prev</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> n, vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:ac08e778396904ad3b3f20f605f54628d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nodes attached to the left side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations.  <a href="classvg_1_1VG.html#ac08e778396904ad3b3f20f605f54628d">More...</a><br /></td></tr>
<tr class="separator:ac08e778396904ad3b3f20f605f54628d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f3e69ced0c3135f3f363c14bf752aad"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0f3e69ced0c3135f3f363c14bf752aad">nodes_prev</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> n)</td></tr>
<tr class="memdesc:a0f3e69ced0c3135f3f363c14bf752aad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nodes attached to the left side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations.  <a href="classvg_1_1VG.html#a0f3e69ced0c3135f3f363c14bf752aad">More...</a><br /></td></tr>
<tr class="separator:a0f3e69ced0c3135f3f363c14bf752aad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a962957210c079fa242b383d5c65de3"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0a962957210c079fa242b383d5c65de3">travs_to</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node)</td></tr>
<tr class="memdesc:a0a962957210c079fa242b383d5c65de3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get traversals before this node on the same strand. Same as nodes_prev but using set.  <a href="classvg_1_1VG.html#a0a962957210c079fa242b383d5c65de3">More...</a><br /></td></tr>
<tr class="separator:a0a962957210c079fa242b383d5c65de3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b084d958fd8069839884dc3a01ed745"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a0b084d958fd8069839884dc3a01ed745">nodes_next</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> n, vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:a0b084d958fd8069839884dc3a01ed745"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nodes attached to the right side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations.  <a href="classvg_1_1VG.html#a0b084d958fd8069839884dc3a01ed745">More...</a><br /></td></tr>
<tr class="separator:a0b084d958fd8069839884dc3a01ed745"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62f1bb7fa27d4d4312017b113aab099a"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a62f1bb7fa27d4d4312017b113aab099a">nodes_next</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> n)</td></tr>
<tr class="memdesc:a62f1bb7fa27d4d4312017b113aab099a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the nodes attached to the right side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations.  <a href="classvg_1_1VG.html#a62f1bb7fa27d4d4312017b113aab099a">More...</a><br /></td></tr>
<tr class="separator:a62f1bb7fa27d4d4312017b113aab099a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34a493a0628857a3bfae181295ba541d"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a34a493a0628857a3bfae181295ba541d">travs_from</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node)</td></tr>
<tr class="memdesc:a34a493a0628857a3bfae181295ba541d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get traversals after this node on the same strand. Same as nodes_next but using set.  <a href="classvg_1_1VG.html#a34a493a0628857a3bfae181295ba541d">More...</a><br /></td></tr>
<tr class="separator:a34a493a0628857a3bfae181295ba541d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae065082f817e9bc0e278cf71f31af1e2"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae065082f817e9bc0e278cf71f31af1e2">travs_of</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> node)</td></tr>
<tr class="memdesc:ae065082f817e9bc0e278cf71f31af1e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get traversals either before or after this node on the same strand.  <a href="classvg_1_1VG.html#ae065082f817e9bc0e278cf71f31af1e2">More...</a><br /></td></tr>
<tr class="separator:ae065082f817e9bc0e278cf71f31af1e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1091113608fae5b9cbafc87cf4cf82a2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1091113608fae5b9cbafc87cf4cf82a2">node_count_prev</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> n)</td></tr>
<tr class="memdesc:a1091113608fae5b9cbafc87cf4cf82a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the nodes attached to the left side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>.  <a href="classvg_1_1VG.html#a1091113608fae5b9cbafc87cf4cf82a2">More...</a><br /></td></tr>
<tr class="separator:a1091113608fae5b9cbafc87cf4cf82a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c614759c77b4b0a95b25360c2fa1fa0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a4c614759c77b4b0a95b25360c2fa1fa0">node_count_next</a> (<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> n)</td></tr>
<tr class="memdesc:a4c614759c77b4b0a95b25360c2fa1fa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Count the nodes attached to the right side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>.  <a href="classvg_1_1VG.html#a4c614759c77b4b0a95b25360c2fa1fa0">More...</a><br /></td></tr>
<tr class="separator:a4c614759c77b4b0a95b25360c2fa1fa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3195bfadb7e65e4952c4b98d51e862f1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3195bfadb7e65e4952c4b98d51e862f1">create_path</a> (const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:a3195bfadb7e65e4952c4b98d51e862f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a path.  <a href="classvg_1_1VG.html#a3195bfadb7e65e4952c4b98d51e862f1">More...</a><br /></td></tr>
<tr class="separator:a3195bfadb7e65e4952c4b98d51e862f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc07ec73a57485a700e621517c962b8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#adc07ec73a57485a700e621517c962b8b">create_path</a> (const vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;nodes)</td></tr>
<tr class="memdesc:adc07ec73a57485a700e621517c962b8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a path.  <a href="classvg_1_1VG.html#adc07ec73a57485a700e621517c962b8b">More...</a><br /></td></tr>
<tr class="separator:adc07ec73a57485a700e621517c962b8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9273361525befc57536dc96a762c29d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aa9273361525befc57536dc96a762c29d">expand_path</a> (const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;path, vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;expanded)</td></tr>
<tr class="memdesc:aa9273361525befc57536dc96a762c29d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand a path. TODO: what does that mean?  <a href="classvg_1_1VG.html#aa9273361525befc57536dc96a762c29d">More...</a><br /></td></tr>
<tr class="separator:aa9273361525befc57536dc96a762c29d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a093f4e4dffe0d03806df32edc33cdb9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a093f4e4dffe0d03806df32edc33cdb9a">node_starts_in_path</a> (const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;path, map&lt; <a class="el" href="structvg_1_1Node.html">Node</a> *, int &gt; &amp;<a class="el" href="namespacevg.html#a30f5b0dc3732e48a6d9b8d1c895cd8d1">node_start</a>)</td></tr>
<tr class="separator:a093f4e4dffe0d03806df32edc33cdb9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd555e66c8fa99984c8cb24aef0ab6f9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#acd555e66c8fa99984c8cb24aef0ab6f9">mapping_is_total_match</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="memdesc:acd555e66c8fa99984c8cb24aef0ab6f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if the mapping completely covers the node it maps to and is a perfect match.  <a href="classvg_1_1VG.html#acd555e66c8fa99984c8cb24aef0ab6f9">More...</a><br /></td></tr>
<tr class="separator:acd555e66c8fa99984c8cb24aef0ab6f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a150341270e41f42db2578a2897e48c1b"><td class="memItemLeft" align="right" valign="top">map&lt; string, vector&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a150341270e41f42db2578a2897e48c1b">concat_mappings_for_node_pair</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> id1, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> id2)</td></tr>
<tr class="memdesc:a150341270e41f42db2578a2897e48c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Concatenate the mappings for a pair of nodes; handles multiple mappings per path.  <a href="classvg_1_1VG.html#a150341270e41f42db2578a2897e48c1b">More...</a><br /></td></tr>
<tr class="separator:a150341270e41f42db2578a2897e48c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae151983cac753c02ce3852274798f8d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ae151983cac753c02ce3852274798f8d5">expand_path</a> (list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;path, vector&lt; list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;::iterator &gt; &amp;expanded)</td></tr>
<tr class="separator:ae151983cac753c02ce3852274798f8d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac27c591957478a17605c2453749f7d20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac27c591957478a17605c2453749f7d20">node_starts_in_path</a> (list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;path, map&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> *, int &gt; &amp;<a class="el" href="namespacevg.html#a30f5b0dc3732e48a6d9b8d1c895cd8d1">node_start</a>)</td></tr>
<tr class="separator:ac27c591957478a17605c2453749f7d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8452af466a3e1ad4b0b463ea0d5da933"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8452af466a3e1ad4b0b463ea0d5da933">random_read</a> (size_t read_len, mt19937 &amp;rng, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> min_id, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> max_id, bool either_strand)</td></tr>
<tr class="separator:a8452af466a3e1ad4b0b463ea0d5da933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eecc0bd555c31d1c541c3ce44b421c3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7eecc0bd555c31d1c541c3ce44b421c3">head_nodes</a> (vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes)</td></tr>
<tr class="memdesc:a7eecc0bd555c31d1c541c3ce44b421c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the head nodes (nodes with edges only to their right sides). These are required to be oriented forward.  <a href="classvg_1_1VG.html#a7eecc0bd555c31d1c541c3ce44b421c3">More...</a><br /></td></tr>
<tr class="separator:a7eecc0bd555c31d1c541c3ce44b421c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a44c415fb5882c184e2f35bb3999700"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a3a44c415fb5882c184e2f35bb3999700">head_nodes</a> (void)</td></tr>
<tr class="memdesc:a3a44c415fb5882c184e2f35bb3999700"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the head nodes (nodes with edges only to their right sides). These are required to be oriented forward.  <a href="classvg_1_1VG.html#a3a44c415fb5882c184e2f35bb3999700">More...</a><br /></td></tr>
<tr class="separator:a3a44c415fb5882c184e2f35bb3999700"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80438f4ab98e10b68caab27fdece09ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a80438f4ab98e10b68caab27fdece09ab">is_head_node</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a80438f4ab98e10b68caab27fdece09ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a node is a head node.  <a href="classvg_1_1VG.html#a80438f4ab98e10b68caab27fdece09ab">More...</a><br /></td></tr>
<tr class="separator:a80438f4ab98e10b68caab27fdece09ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bc3866468d5eb941fa6ba010ccce2ec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1bc3866468d5eb941fa6ba010ccce2ec">is_head_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a1bc3866468d5eb941fa6ba010ccce2ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a node is a head node.  <a href="classvg_1_1VG.html#a1bc3866468d5eb941fa6ba010ccce2ec">More...</a><br /></td></tr>
<tr class="separator:a1bc3866468d5eb941fa6ba010ccce2ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25bd74b77e139691555c8d48ecf67d9f"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a25bd74b77e139691555c8d48ecf67d9f">tail_nodes</a> (void)</td></tr>
<tr class="memdesc:a25bd74b77e139691555c8d48ecf67d9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tail nodes (nodes with edges only to their left sides). These are required to be oriented forward.  <a href="classvg_1_1VG.html#a25bd74b77e139691555c8d48ecf67d9f">More...</a><br /></td></tr>
<tr class="separator:a25bd74b77e139691555c8d48ecf67d9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fbc525ed5e9f2a7b00c333f03fe6c8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a47fbc525ed5e9f2a7b00c333f03fe6c8">tail_nodes</a> (vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes)</td></tr>
<tr class="memdesc:a47fbc525ed5e9f2a7b00c333f03fe6c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the tail nodes (nodes with edges only to their left sides). These are required to be oriented forward.  <a href="classvg_1_1VG.html#a47fbc525ed5e9f2a7b00c333f03fe6c8">More...</a><br /></td></tr>
<tr class="separator:a47fbc525ed5e9f2a7b00c333f03fe6c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a660692b8769618259f69be25bfed0bc3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a660692b8769618259f69be25bfed0bc3">is_tail_node</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a660692b8769618259f69be25bfed0bc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a node is a tail node.  <a href="classvg_1_1VG.html#a660692b8769618259f69be25bfed0bc3">More...</a><br /></td></tr>
<tr class="separator:a660692b8769618259f69be25bfed0bc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af58b227f21324d30be531088ed49b0f1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#af58b227f21324d30be531088ed49b0f1">is_tail_node</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:af58b227f21324d30be531088ed49b0f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a node is a tail node.  <a href="classvg_1_1VG.html#af58b227f21324d30be531088ed49b0f1">More...</a><br /></td></tr>
<tr class="separator:af58b227f21324d30be531088ed49b0f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a688cbe42750d98695114ad4ad640c1d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a688cbe42750d98695114ad4ad640c1d3">collect_subgraph</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;subgraph)</td></tr>
<tr class="memdesc:a688cbe42750d98695114ad4ad640c1d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Collect the subgraph of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a>. TODO: what does that mean?  <a href="classvg_1_1VG.html#a688cbe42750d98695114ad4ad640c1d3">More...</a><br /></td></tr>
<tr class="separator:a688cbe42750d98695114ad4ad640c1d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a817384b8d147371448ad60e1db097b52"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a817384b8d147371448ad60e1db097b52">join_heads</a> (void)</td></tr>
<tr class="memdesc:a817384b8d147371448ad60e1db097b52"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join head nodes of graph to common null node, creating a new single head.  <a href="classvg_1_1VG.html#a817384b8d147371448ad60e1db097b52">More...</a><br /></td></tr>
<tr class="separator:a817384b8d147371448ad60e1db097b52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc40377520118436b729cd68be16d0ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#adc40377520118436b729cd68be16d0ba">join_heads</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, bool from_start=false)</td></tr>
<tr class="memdesc:adc40377520118436b729cd68be16d0ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join head nodes of graph to specified node. Optionally from the start/to the end of the new node.  <a href="classvg_1_1VG.html#adc40377520118436b729cd68be16d0ba">More...</a><br /></td></tr>
<tr class="separator:adc40377520118436b729cd68be16d0ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e3f7942afd3ca82bfb78083c245146"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a33e3f7942afd3ca82bfb78083c245146">join_tails</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node, bool to_end=false)</td></tr>
<tr class="memdesc:a33e3f7942afd3ca82bfb78083c245146"><td class="mdescLeft">&#160;</td><td class="mdescRight">Join tail nodes of graph to specified node. Optionally from the start/to the end of the new node.  <a href="classvg_1_1VG.html#a33e3f7942afd3ca82bfb78083c245146">More...</a><br /></td></tr>
<tr class="separator:a33e3f7942afd3ca82bfb78083c245146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2239c89d6ac7e9dec0d76325c2a68f97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2239c89d6ac7e9dec0d76325c2a68f97">wrap_with_null_nodes</a> (void)</td></tr>
<tr class="memdesc:a2239c89d6ac7e9dec0d76325c2a68f97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add singular head and tail null nodes to graph.  <a href="classvg_1_1VG.html#a2239c89d6ac7e9dec0d76325c2a68f97">More...</a><br /></td></tr>
<tr class="separator:a2239c89d6ac7e9dec0d76325c2a68f97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91eaa395f197ca65f38c6139bc57d161"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a91eaa395f197ca65f38c6139bc57d161">add_start_end_markers</a> (int <a class="el" href="classvg_1_1VG.html#a23641dedefa2b6d573939515fcf5974c">length</a>, char start_char, char end_char, <a class="el" href="structvg_1_1Node.html">Node</a> *&amp;start_node, <a class="el" href="structvg_1_1Node.html">Node</a> *&amp;end_node, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &amp;start_id, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &amp;end_id)</td></tr>
<tr class="separator:a91eaa395f197ca65f38c6139bc57d161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1Progressive"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1Progressive')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1Progressive.html">vg::Progressive</a></td></tr>
<tr class="memitem:a4eb5050eb36ed519cbfa398748ef183b inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a4eb5050eb36ed519cbfa398748ef183b">preload_progress</a> (const string &amp;message)</td></tr>
<tr class="separator:a4eb5050eb36ed519cbfa398748ef183b inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cce3f715516ed2bbb4ce3a312b01e02 inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a1cce3f715516ed2bbb4ce3a312b01e02">create_progress</a> (const string &amp;message, long count)</td></tr>
<tr class="separator:a1cce3f715516ed2bbb4ce3a312b01e02 inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75d4e92a36a277be5bc0cee5d01f5ca1 inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a75d4e92a36a277be5bc0cee5d01f5ca1">create_progress</a> (long count)</td></tr>
<tr class="separator:a75d4e92a36a277be5bc0cee5d01f5ca1 inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d64e6aa69bc094c163f4827602a302c inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a0d64e6aa69bc094c163f4827602a302c">update_progress</a> (long i)</td></tr>
<tr class="separator:a0d64e6aa69bc094c163f4827602a302c inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1de11917caf25974a02e2f5c3946280 inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#ab1de11917caf25974a02e2f5c3946280">increment_progress</a> ()</td></tr>
<tr class="separator:ab1de11917caf25974a02e2f5c3946280 inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab8c6ae92870077bb59f86a15c8d18f inherit pub_methods_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#aaab8c6ae92870077bb59f86a15c8d18f">destroy_progress</a> (void)</td></tr>
<tr class="separator:aaab8c6ae92870077bb59f86a15c8d18f inherit pub_methods_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1MutablePathDeletableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1MutablePathDeletableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html">handlegraph::MutablePathDeletableHandleGraph</a></td></tr>
<tr class="memitem:a2d936ce540af42363619ebb77c60a4ff inherit pub_methods_classhandlegraph_1_1MutablePathDeletableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html#a2d936ce540af42363619ebb77c60a4ff">~MutablePathDeletableHandleGraph</a> ()=default</td></tr>
<tr class="separator:a2d936ce540af42363619ebb77c60a4ff inherit pub_methods_classhandlegraph_1_1MutablePathDeletableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1MutablePathMutableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1MutablePathMutableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">handlegraph::MutablePathMutableHandleGraph</a></td></tr>
<tr class="memitem:a55379ced0e4f2952ca3353c558affc44 inherit pub_methods_classhandlegraph_1_1MutablePathMutableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html#a55379ced0e4f2952ca3353c558affc44">~MutablePathMutableHandleGraph</a> ()=default</td></tr>
<tr class="separator:a55379ced0e4f2952ca3353c558affc44 inherit pub_methods_classhandlegraph_1_1MutablePathMutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1MutablePathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html">handlegraph::MutablePathHandleGraph</a></td></tr>
<tr class="memitem:a3b9b032ce45f87e1abd5c175db6f5275 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a3b9b032ce45f87e1abd5c175db6f5275">~MutablePathHandleGraph</a> ()=default</td></tr>
<tr class="separator:a3b9b032ce45f87e1abd5c175db6f5275 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0873a6eb776bb2557a5b8453dbf13824 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a0873a6eb776bb2557a5b8453dbf13824">create_path_handle</a> (const std::string &amp;name, bool is_circular=false)=0</td></tr>
<tr class="separator:a0873a6eb776bb2557a5b8453dbf13824 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95370bd388b2c113cf0556f266993418 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a95370bd388b2c113cf0556f266993418">rename_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle, const std::string &amp;new_name)</td></tr>
<tr class="separator:a95370bd388b2c113cf0556f266993418 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67c8bfd58c5ed8136c9324f427037a7a inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a67c8bfd58c5ed8136c9324f427037a7a">pop_front_step</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle)</td></tr>
<tr class="separator:a67c8bfd58c5ed8136c9324f427037a7a inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2db5e7a66ccee26fa257c50e0d084c59 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a2db5e7a66ccee26fa257c50e0d084c59">pop_back_step</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle)</td></tr>
<tr class="separator:a2db5e7a66ccee26fa257c50e0d084c59 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af28f1372aa6dad2654a22eb8463e2a07 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#af28f1372aa6dad2654a22eb8463e2a07">rewrite_segment</a> (const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;segment_begin, const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;segment_end, const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;new_segment)=0</td></tr>
<tr class="separator:af28f1372aa6dad2654a22eb8463e2a07 inherit pub_methods_classhandlegraph_1_1MutablePathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1PathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1PathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">handlegraph::PathHandleGraph</a></td></tr>
<tr class="memitem:a49fe5658c5ef27e1d7aba69cd3d7159b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a49fe5658c5ef27e1d7aba69cd3d7159b">~PathHandleGraph</a> ()=default</td></tr>
<tr class="separator:a49fe5658c5ef27e1d7aba69cd3d7159b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7de11c1e994bc104378c4b798013430 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#ab7de11c1e994bc104378c4b798013430">has_path</a> (const std::string &amp;path_name) const =0</td></tr>
<tr class="memdesc:ab7de11c1e994bc104378c4b798013430 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine if a path name exists and is legal to get a path handle for.  <a href="classhandlegraph_1_1PathHandleGraph.html#ab7de11c1e994bc104378c4b798013430">More...</a><br /></td></tr>
<tr class="separator:ab7de11c1e994bc104378c4b798013430 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6059d716882a80e3982de17011866e inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a5d6059d716882a80e3982de17011866e">get_path_handle</a> (const std::string &amp;path_name) const =0</td></tr>
<tr class="separator:a5d6059d716882a80e3982de17011866e inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3a31f0c19054cd2908525119869b80 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a6d3a31f0c19054cd2908525119869b80">get_step_count</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a6d3a31f0c19054cd2908525119869b80 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of node steps on a handle.  <a href="classhandlegraph_1_1PathHandleGraph.html#a6d3a31f0c19054cd2908525119869b80">More...</a><br /></td></tr>
<tr class="separator:a6d3a31f0c19054cd2908525119869b80 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3f1d0595543d760322042770201297c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:aa3f1d0595543d760322042770201297c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#aa3f1d0595543d760322042770201297c">for_each_path_handle</a> (const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:aa3f1d0595543d760322042770201297c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a006a8e3ab9e2783ef7bf80b98b35959c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a006a8e3ab9e2783ef7bf80b98b35959c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a006a8e3ab9e2783ef7bf80b98b35959c">for_each_step_on_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a006a8e3ab9e2783ef7bf80b98b35959c inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a015b050f33861cbc8e2a0efaaf771a30 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a015b050f33861cbc8e2a0efaaf771a30">steps_of_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool match_orientation=false) const</td></tr>
<tr class="separator:a015b050f33861cbc8e2a0efaaf771a30 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3f2c04d1e315e485460dcd902467cb inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#aef3f2c04d1e315e485460dcd902467cb">is_empty</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle) const</td></tr>
<tr class="memdesc:aef3f2c04d1e315e485460dcd902467cb inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the given path is empty, and false otherwise.  <a href="classhandlegraph_1_1PathHandleGraph.html#aef3f2c04d1e315e485460dcd902467cb">More...</a><br /></td></tr>
<tr class="separator:aef3f2c04d1e315e485460dcd902467cb inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa071f31a10a02d8231b029d0a7ddef0b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhandlegraph_1_1PathForEachSocket.html">PathForEachSocket</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#aa071f31a10a02d8231b029d0a7ddef0b">scan_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path) const</td></tr>
<tr class="separator:aa071f31a10a02d8231b029d0a7ddef0b inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a184353db571dd2086d79e4e31f2f97f1 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a184353db571dd2086d79e4e31f2f97f1 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a184353db571dd2086d79e4e31f2f97f1">for_each_step_in_path</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a184353db571dd2086d79e4e31f2f97f1 inherit pub_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1HandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1HandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1HandleGraph.html">handlegraph::HandleGraph</a></td></tr>
<tr class="memitem:a24fb796441c9ad8c870fdb716a82b305 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a24fb796441c9ad8c870fdb716a82b305">~HandleGraph</a> ()=default</td></tr>
<tr class="separator:a24fb796441c9ad8c870fdb716a82b305 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d21f30e62ad0b0c5919b2fe95e6f8aa inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a4d21f30e62ad0b0c5919b2fe95e6f8aa inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a4d21f30e62ad0b0c5919b2fe95e6f8aa">follow_edges</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a4d21f30e62ad0b0c5919b2fe95e6f8aa inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928bdeabd328d357b538e30590164ab4 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a928bdeabd328d357b538e30590164ab4 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a928bdeabd328d357b538e30590164ab4">for_each_handle</a> (const Iteratee &amp;iteratee, bool parallel=false) const</td></tr>
<tr class="separator:a928bdeabd328d357b538e30590164ab4 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6171cdd6036c73623c96656f8b44fe9d inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a6171cdd6036c73623c96656f8b44fe9d">has_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge) const</td></tr>
<tr class="memdesc:a6171cdd6036c73623c96656f8b44fe9d inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper of has_edge for edge_t argument.  <a href="classhandlegraph_1_1HandleGraph.html#a6171cdd6036c73623c96656f8b44fe9d">More...</a><br /></td></tr>
<tr class="separator:a6171cdd6036c73623c96656f8b44fe9d inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c98da99e0d32ebcc9fd31be4b779e29 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a4c98da99e0d32ebcc9fd31be4b779e29">get_total_length</a> () const</td></tr>
<tr class="separator:a4c98da99e0d32ebcc9fd31be4b779e29 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e946bb4ed53f9423072955cdaab6386 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a9e946bb4ed53f9423072955cdaab6386">forward</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a9e946bb4ed53f9423072955cdaab6386 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the locally forward version of a handle.  <a href="classhandlegraph_1_1HandleGraph.html#a9e946bb4ed53f9423072955cdaab6386">More...</a><br /></td></tr>
<tr class="separator:a9e946bb4ed53f9423072955cdaab6386 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3766f1aca1cbdbf827f2a12aaf2078ec inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a3766f1aca1cbdbf827f2a12aaf2078ec">edge_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const</td></tr>
<tr class="separator:a3766f1aca1cbdbf827f2a12aaf2078ec inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af167b0664299cfd4eac610f129fa5fee inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#af167b0664299cfd4eac610f129fa5fee">traverse_edge_handle</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left) const</td></tr>
<tr class="separator:af167b0664299cfd4eac610f129fa5fee inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61570ded026f825d62ea7608a1e92349 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a61570ded026f825d62ea7608a1e92349 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a61570ded026f825d62ea7608a1e92349">for_each_edge</a> (const Iteratee &amp;iteratee, bool parallel=false) const</td></tr>
<tr class="separator:a61570ded026f825d62ea7608a1e92349 inherit pub_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1PathMetadata"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1PathMetadata')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1PathMetadata.html">handlegraph::PathMetadata</a></td></tr>
<tr class="memitem:aee403b8c1269b11877df67ff42b759f3 inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#aee403b8c1269b11877df67ff42b759f3">~PathMetadata</a> ()=default</td></tr>
<tr class="separator:aee403b8c1269b11877df67ff42b759f3 inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f48aa025a3f5fe67a18642b57bedc9c inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classhandlegraph_1_1PathMetadata.html#a55d5f006ac51ae68361a1a230b5bcea8">Sense</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#a9f48aa025a3f5fe67a18642b57bedc9c">get_sense</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a9f48aa025a3f5fe67a18642b57bedc9c inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="mdescLeft">&#160;</td><td class="mdescRight">What is the given path meant to be representing?  <a href="classhandlegraph_1_1PathMetadata.html#a9f48aa025a3f5fe67a18642b57bedc9c">More...</a><br /></td></tr>
<tr class="separator:a9f48aa025a3f5fe67a18642b57bedc9c inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7fda320c3b28c0fb642d7e4a789045 inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#ada7fda320c3b28c0fb642d7e4a789045">get_sample_name</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;handle) const</td></tr>
<tr class="separator:ada7fda320c3b28c0fb642d7e4a789045 inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeea07376b756bc5410dacf86f2c3983d inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#aeea07376b756bc5410dacf86f2c3983d">get_locus_name</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;handle) const</td></tr>
<tr class="separator:aeea07376b756bc5410dacf86f2c3983d inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9868f510b6dad98e4115ec8b267955f4 inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#a9868f510b6dad98e4115ec8b267955f4">get_haplotype</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;handle) const</td></tr>
<tr class="separator:a9868f510b6dad98e4115ec8b267955f4 inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a949f7289b392b0afa018a52239062756 inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">virtual int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#a949f7289b392b0afa018a52239062756">get_phase_block</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;handle) const</td></tr>
<tr class="separator:a949f7289b392b0afa018a52239062756 inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcfb8f9ebdc8a6109f21efe4e00c6e89 inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">virtual std::pair&lt; int64_t, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#afcfb8f9ebdc8a6109f21efe4e00c6e89">get_subrange</a> (const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;handle) const</td></tr>
<tr class="separator:afcfb8f9ebdc8a6109f21efe4e00c6e89 inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8a70bac7762fc72a86bb1c9579d82c7 inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:af8a70bac7762fc72a86bb1c9579d82c7 inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#af8a70bac7762fc72a86bb1c9579d82c7">for_each_path_of_sense</a> (const <a class="el" href="classhandlegraph_1_1PathMetadata.html#a55d5f006ac51ae68361a1a230b5bcea8">Sense</a> &amp;sense, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:af8a70bac7762fc72a86bb1c9579d82c7 inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01becc6f1373c256aebdb41cab2e1e2a inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a01becc6f1373c256aebdb41cab2e1e2a inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#a01becc6f1373c256aebdb41cab2e1e2a">for_each_path_of_sample</a> (const std::string &amp;sample, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a01becc6f1373c256aebdb41cab2e1e2a inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25426a5377c651d841552e0e4c4bd779 inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a25426a5377c651d841552e0e4c4bd779 inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#a25426a5377c651d841552e0e4c4bd779">for_each_path_matching</a> (const std::unordered_set&lt; <a class="el" href="classhandlegraph_1_1PathMetadata.html#a55d5f006ac51ae68361a1a230b5bcea8">PathMetadata::Sense</a> &gt; *senses, const std::unordered_set&lt; std::string &gt; *samples, const std::unordered_set&lt; std::string &gt; *loci, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a25426a5377c651d841552e0e4c4bd779 inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e803fad414f5c6d5754a7588ca9f03f inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a2e803fad414f5c6d5754a7588ca9f03f inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#a2e803fad414f5c6d5754a7588ca9f03f">for_each_path_matching</a> (const std::unordered_set&lt; <a class="el" href="classhandlegraph_1_1PathMetadata.html#a55d5f006ac51ae68361a1a230b5bcea8">PathMetadata::Sense</a> &gt; &amp;senses, const std::unordered_set&lt; std::string &gt; &amp;samples, const std::unordered_set&lt; std::string &gt; &amp;loci, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a2e803fad414f5c6d5754a7588ca9f03f inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a070e1847b16e83cc55fd8b5fc016f4aa inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a070e1847b16e83cc55fd8b5fc016f4aa inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#a070e1847b16e83cc55fd8b5fc016f4aa">for_each_step_of_sense</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;visited, const <a class="el" href="classhandlegraph_1_1PathMetadata.html#a55d5f006ac51ae68361a1a230b5bcea8">Sense</a> &amp;sense, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a070e1847b16e83cc55fd8b5fc016f4aa inherit pub_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1MutablePathMetadata"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1MutablePathMetadata')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1MutablePathMetadata.html">handlegraph::MutablePathMetadata</a></td></tr>
<tr class="memitem:a8be356ab572a35e496b6306a17db4a7e inherit pub_methods_classhandlegraph_1_1MutablePathMetadata"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathMetadata.html#a8be356ab572a35e496b6306a17db4a7e">~MutablePathMetadata</a> ()=default</td></tr>
<tr class="separator:a8be356ab572a35e496b6306a17db4a7e inherit pub_methods_classhandlegraph_1_1MutablePathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a705602f0bfadacb4e334c2d9ecacb00b inherit pub_methods_classhandlegraph_1_1MutablePathMetadata"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutablePathMetadata.html#a705602f0bfadacb4e334c2d9ecacb00b">create_path</a> (const <a class="el" href="classhandlegraph_1_1PathMetadata.html#a55d5f006ac51ae68361a1a230b5bcea8">PathMetadata::Sense</a> &amp;sense, const std::string &amp;sample, const std::string &amp;locus, const int64_t &amp;haplotype, const int64_t &amp;phase_block, const std::pair&lt; int64_t, int64_t &gt; &amp;subrange, bool is_circular=false)</td></tr>
<tr class="separator:a705602f0bfadacb4e334c2d9ecacb00b inherit pub_methods_classhandlegraph_1_1MutablePathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1MutableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1MutableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">handlegraph::MutableHandleGraph</a></td></tr>
<tr class="memitem:ace50b9ed07cbbe94f7da963ff02d4141 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#ace50b9ed07cbbe94f7da963ff02d4141">~MutableHandleGraph</a> ()=default</td></tr>
<tr class="separator:ace50b9ed07cbbe94f7da963ff02d4141 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c9d8ca8160a9b94a57000eab3e97aaa inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a8c9d8ca8160a9b94a57000eab3e97aaa">create_handle</a> (const std::string &amp;sequence)=0</td></tr>
<tr class="separator:a8c9d8ca8160a9b94a57000eab3e97aaa inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae844fce457858cd2dc54dde786f79e5c inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#ae844fce457858cd2dc54dde786f79e5c">create_handle</a> (const std::string &amp;sequence, const <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">nid_t</a> &amp;id)=0</td></tr>
<tr class="separator:ae844fce457858cd2dc54dde786f79e5c inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff0a0f9497da3498170fdfc2ce97797 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a3ff0a0f9497da3498170fdfc2ce97797">create_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge)</td></tr>
<tr class="memdesc:a3ff0a0f9497da3498170fdfc2ce97797 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper for create_edge.  <a href="classhandlegraph_1_1MutableHandleGraph.html#a3ff0a0f9497da3498170fdfc2ce97797">More...</a><br /></td></tr>
<tr class="separator:a3ff0a0f9497da3498170fdfc2ce97797 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca166406fa2000778552ed77c41a5e4c inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#aca166406fa2000778552ed77c41a5e4c">divide_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const std::vector&lt; size_t &gt; &amp;offsets)=0</td></tr>
<tr class="separator:aca166406fa2000778552ed77c41a5e4c inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05c38787f0ff4a2695e61d98cb402175 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">std::pair&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a05c38787f0ff4a2695e61d98cb402175">divide_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t offset)</td></tr>
<tr class="memdesc:a05c38787f0ff4a2695e61d98cb402175 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specialization of divide_handle for a single division point.  <a href="classhandlegraph_1_1MutableHandleGraph.html#a05c38787f0ff4a2695e61d98cb402175">More...</a><br /></td></tr>
<tr class="separator:a05c38787f0ff4a2695e61d98cb402175 inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a877dc8c0ae9a584907d45328512720cc inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a877dc8c0ae9a584907d45328512720cc">increment_node_ids</a> (long increment)</td></tr>
<tr class="memdesc:a877dc8c0ae9a584907d45328512720cc inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">This specialization for long appears to be needed to avoid confusion about nid_t.  <a href="classhandlegraph_1_1MutableHandleGraph.html#a877dc8c0ae9a584907d45328512720cc">More...</a><br /></td></tr>
<tr class="separator:a877dc8c0ae9a584907d45328512720cc inherit pub_methods_classhandlegraph_1_1MutableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classhandlegraph_1_1DeletableHandleGraph')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">handlegraph::DeletableHandleGraph</a></td></tr>
<tr class="memitem:a62ed805e124ceb05cfa98d4e631a9ebd inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a62ed805e124ceb05cfa98d4e631a9ebd">~DeletableHandleGraph</a> ()=default</td></tr>
<tr class="separator:a62ed805e124ceb05cfa98d4e631a9ebd inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65cef3b3261f8d1bc2057c5f2ee100a inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#aa65cef3b3261f8d1bc2057c5f2ee100a">truncate_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool trunc_left, size_t offset)</td></tr>
<tr class="separator:aa65cef3b3261f8d1bc2057c5f2ee100a inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec2b397c1b4ec7f9c75ccc5b9ce06564 inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#aec2b397c1b4ec7f9c75ccc5b9ce06564">destroy_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge)</td></tr>
<tr class="memdesc:aec2b397c1b4ec7f9c75ccc5b9ce06564 inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper for destroy_edge.  <a href="classhandlegraph_1_1DeletableHandleGraph.html#aec2b397c1b4ec7f9c75ccc5b9ce06564">More...</a><br /></td></tr>
<tr class="separator:aec2b397c1b4ec7f9c75ccc5b9ce06564 inherit pub_methods_classhandlegraph_1_1DeletableHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4772c77ed932bfed4d21e247918381a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a4772c77ed932bfed4d21e247918381a4">graph</a></td></tr>
<tr class="memdesc:a4772c77ed932bfed4d21e247918381a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Protobuf-based representation.  <a href="classvg_1_1VG.html#a4772c77ed932bfed4d21e247918381a4">More...</a><br /></td></tr>
<tr class="separator:a4772c77ed932bfed4d21e247918381a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c5150aba84e7ed2bde7986462a79989"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Paths.html">Paths</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7c5150aba84e7ed2bde7986462a79989">paths</a></td></tr>
<tr class="separator:a7c5150aba84e7ed2bde7986462a79989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f6fcd5a907e9bee524cf37a62ad5be2"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a1f6fcd5a907e9bee524cf37a62ad5be2">name</a></td></tr>
<tr class="memdesc:a1f6fcd5a907e9bee524cf37a62ad5be2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Name of the graph.  <a href="classvg_1_1VG.html#a1f6fcd5a907e9bee524cf37a62ad5be2">More...</a><br /></td></tr>
<tr class="separator:a1f6fcd5a907e9bee524cf37a62ad5be2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f4b0cfbadab3cebace110733565d38"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a68f4b0cfbadab3cebace110733565d38">current_id</a></td></tr>
<tr class="memdesc:a68f4b0cfbadab3cebace110733565d38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current id for <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a> to be added next.  <a href="classvg_1_1VG.html#a68f4b0cfbadab3cebace110733565d38">More...</a><br /></td></tr>
<tr class="separator:a68f4b0cfbadab3cebace110733565d38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad84c5c18cddf1ef2c469e0db0fd7b9dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad84c5c18cddf1ef2c469e0db0fd7b9dc">node_by_id</a></td></tr>
<tr class="memdesc:ad84c5c18cddf1ef2c469e0db0fd7b9dc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code><a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a></code>s by id.  <a href="classvg_1_1VG.html#ad84c5c18cddf1ef2c469e0db0fd7b9dc">More...</a><br /></td></tr>
<tr class="separator:ad84c5c18cddf1ef2c469e0db0fd7b9dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab754d45647580a21216bd010b72c6815"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1pair__hash__map.html">pair_hash_map</a>&lt; pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;, <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ab754d45647580a21216bd010b72c6815">edge_by_sides</a></td></tr>
<tr class="separator:ab754d45647580a21216bd010b72c6815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ce9aecf57e0684821ee277d983eb248"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="structvg_1_1Node.html">Node</a> *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2ce9aecf57e0684821ee277d983eb248">node_index</a></td></tr>
<tr class="separator:a2ce9aecf57e0684821ee277d983eb248"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e2c02a8216f0bb9b3a78e985845ea1b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> *, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2e2c02a8216f0bb9b3a78e985845ea1b">edge_index</a></td></tr>
<tr class="separator:a2e2c02a8216f0bb9b3a78e985845ea1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00590435d38e7ddf8a77b731d8a1a755"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, vector&lt; pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a00590435d38e7ddf8a77b731d8a1a755">edges_on_start</a></td></tr>
<tr class="memdesc:a00590435d38e7ddf8a77b731d8a1a755"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the destinations and backward flags for edges attached to the starts of nodes (whether that node is "from" or "to").  <a href="classvg_1_1VG.html#a00590435d38e7ddf8a77b731d8a1a755">More...</a><br /></td></tr>
<tr class="separator:a00590435d38e7ddf8a77b731d8a1a755"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a678bafc48a8e02155efc591991201122"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, vector&lt; pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a678bafc48a8e02155efc591991201122">edges_on_end</a></td></tr>
<tr class="memdesc:a678bafc48a8e02155efc591991201122"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores the destinations and backward flags for edges attached to the ends of nodes (whether that node is "from" or "to").  <a href="classvg_1_1VG.html#a678bafc48a8e02155efc591991201122">More...</a><br /></td></tr>
<tr class="separator:a678bafc48a8e02155efc591991201122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac697184acf2edadca58ddc776f9f4e7e"><td class="memItemLeft" align="right" valign="top">map&lt; string, <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac697184acf2edadca58ddc776f9f4e7e">variant_to_traversal</a></td></tr>
<tr class="separator:ac697184acf2edadca58ddc776f9f4e7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classvg_1_1Progressive"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classvg_1_1Progressive')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classvg_1_1Progressive.html">vg::Progressive</a></td></tr>
<tr class="memitem:a6653625f496832c4cb8711185d5e04cb inherit pub_attribs_classvg_1_1Progressive"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html#a6653625f496832c4cb8711185d5e04cb">show_progress</a> = false</td></tr>
<tr class="separator:a6653625f496832c4cb8711185d5e04cb inherit pub_attribs_classvg_1_1Progressive"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ad09549b6cfab8e1097dd207e01e57812"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ad09549b6cfab8e1097dd207e01e57812">is_self_looping</a> (<a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:ad09549b6cfab8e1097dd207e01e57812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the specified node have any self-loops?  <a href="classvg_1_1VG.html#ad09549b6cfab8e1097dd207e01e57812">More...</a><br /></td></tr>
<tr class="separator:ad09549b6cfab8e1097dd207e01e57812"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e506d51db427b617cc334a791c7f594"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a2e506d51db427b617cc334a791c7f594">merge_nodes</a> (const list&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;nodes)</td></tr>
<tr class="memdesc:a2e506d51db427b617cc334a791c7f594"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use the orientation of the first node as the basis.  <a href="classvg_1_1VG.html#a2e506d51db427b617cc334a791c7f594">More...</a><br /></td></tr>
<tr class="separator:a2e506d51db427b617cc334a791c7f594"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf5016c5e5d28db6db32aa7626440238"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aaf5016c5e5d28db6db32aa7626440238">_for_each_kmer</a> (int kmer_size, bool path_only, int edge_max, function&lt; void(string &amp;, list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;::iterator, int, list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;)&gt; lambda, bool parallel, int stride, bool allow_dups, bool allow_negatives, <a class="el" href="structvg_1_1Node.html">Node</a> *node=nullptr)</td></tr>
<tr class="separator:aaf5016c5e5d28db6db32aa7626440238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24d1defbcca2158cda5fbd272fadae0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#ac24d1defbcca2158cda5fbd272fadae0">align</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *aligner, const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *qual_adj_aligner, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, bool traceback=true, bool acyclic_and_sorted=false, size_t max_query_graph_ratio=0, bool pinned_alignment=false, bool pin_left=false, bool banded_global=false, size_t band_padding_override=0, size_t max_span=0, size_t unroll_length=0, int xdrop_alignment=0)</td></tr>
<tr class="separator:ac24d1defbcca2158cda5fbd272fadae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafd0f191fe33bd4590f15f309d0fd89c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#aafd0f191fe33bd4590f15f309d0fd89c">init</a> (void)</td></tr>
<tr class="separator:aafd0f191fe33bd4590f15f309d0fd89c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a071f0034788bdcd778d5d0c76ba4f6b6"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a071f0034788bdcd778d5d0c76ba4f6b6">empty_ids</a></td></tr>
<tr class="memdesc:a071f0034788bdcd778d5d0c76ba4f6b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for functions that sometimes need to be passed an empty vector.  <a href="classvg_1_1VG.html#a071f0034788bdcd778d5d0c76ba4f6b6">More...</a><br /></td></tr>
<tr class="separator:a071f0034788bdcd778d5d0c76ba4f6b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d18d29606bbdb7875f7d8a8042dd29a"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a7d18d29606bbdb7875f7d8a8042dd29a">empty_edge_ends</a></td></tr>
<tr class="memdesc:a7d18d29606bbdb7875f7d8a8042dd29a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Placeholder for functions that sometimes need to be passed an empty vector.  <a href="classvg_1_1VG.html#a7d18d29606bbdb7875f7d8a8042dd29a">More...</a><br /></td></tr>
<tr class="separator:a7d18d29606bbdb7875f7d8a8042dd29a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0519dc706937b8b593f803f3d8eac4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html#a8f0519dc706937b8b593f803f3d8eac4">warned_about_rewrites</a> = false</td></tr>
<tr class="separator:a8f0519dc706937b8b593f803f3d8eac4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_types_classhandlegraph_1_1PathMetadata"><td colspan="2" onclick="javascript:toggleInherit('pub_types_classhandlegraph_1_1PathMetadata')"><img src="closed.png" alt="-"/>&#160;Public Types inherited from <a class="el" href="classhandlegraph_1_1PathMetadata.html">handlegraph::PathMetadata</a></td></tr>
<tr class="memitem:a55d5f006ac51ae68361a1a230b5bcea8 inherit pub_types_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#a55d5f006ac51ae68361a1a230b5bcea8">Sense</a> { <a class="el" href="classhandlegraph_1_1PathMetadata.html#a55d5f006ac51ae68361a1a230b5bcea8a95048a60a23cf70a86c3f88c975bfabb">SENSE_GENERIC</a>, 
<a class="el" href="classhandlegraph_1_1PathMetadata.html#a55d5f006ac51ae68361a1a230b5bcea8af5ddd6594978ecd300b028eb2362ab3e">SENSE_REFERENCE</a>, 
<a class="el" href="classhandlegraph_1_1PathMetadata.html#a55d5f006ac51ae68361a1a230b5bcea8a86118ecb392ad1f8a39885ab4f7326a6">SENSE_HAPLOTYPE</a>
 }</td></tr>
<tr class="memdesc:a55d5f006ac51ae68361a1a230b5bcea8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Each path always has just one sense.  <a href="classhandlegraph_1_1PathMetadata.html#a55d5f006ac51ae68361a1a230b5bcea8">More...</a><br /></td></tr>
<tr class="separator:a55d5f006ac51ae68361a1a230b5bcea8 inherit pub_types_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_methods_classhandlegraph_1_1PathMetadata"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classhandlegraph_1_1PathMetadata')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classhandlegraph_1_1PathMetadata.html">handlegraph::PathMetadata</a></td></tr>
<tr class="memitem:aa6d0ba71c7a9069cd3e85080affb14c9 inherit pub_static_methods_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classhandlegraph_1_1PathMetadata.html#a55d5f006ac51ae68361a1a230b5bcea8">Sense</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#aa6d0ba71c7a9069cd3e85080affb14c9">parse_sense</a> (const std::string &amp;path_name)</td></tr>
<tr class="separator:aa6d0ba71c7a9069cd3e85080affb14c9 inherit pub_static_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbc675d9d41c36eebb174b4871c42435 inherit pub_static_methods_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#acbc675d9d41c36eebb174b4871c42435">parse_sample_name</a> (const std::string &amp;path_name)</td></tr>
<tr class="separator:acbc675d9d41c36eebb174b4871c42435 inherit pub_static_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a978b48ca96f8817f7099587dae77b8b4 inherit pub_static_methods_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#a978b48ca96f8817f7099587dae77b8b4">parse_locus_name</a> (const std::string &amp;path_name)</td></tr>
<tr class="separator:a978b48ca96f8817f7099587dae77b8b4 inherit pub_static_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca47bddcca3927247cd3ac587ced9dcd inherit pub_static_methods_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#aca47bddcca3927247cd3ac587ced9dcd">parse_haplotype</a> (const std::string &amp;path_name)</td></tr>
<tr class="separator:aca47bddcca3927247cd3ac587ced9dcd inherit pub_static_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca763712de20ff3b4451ffe75915a356 inherit pub_static_methods_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">static int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#aca763712de20ff3b4451ffe75915a356">parse_phase_block</a> (const std::string &amp;path_name)</td></tr>
<tr class="separator:aca763712de20ff3b4451ffe75915a356 inherit pub_static_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2da77a1c4efb85d520184c4d4ca7f02 inherit pub_static_methods_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">static std::pair&lt; int64_t, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#ab2da77a1c4efb85d520184c4d4ca7f02">parse_subrange</a> (const std::string &amp;path_name)</td></tr>
<tr class="separator:ab2da77a1c4efb85d520184c4d4ca7f02 inherit pub_static_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091d90f4eccbc743888ae2c3eb4f5d2f inherit pub_static_methods_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#a091d90f4eccbc743888ae2c3eb4f5d2f">parse_path_name</a> (const std::string &amp;path_name, <a class="el" href="classhandlegraph_1_1PathMetadata.html#a55d5f006ac51ae68361a1a230b5bcea8">PathMetadata::Sense</a> &amp;sense, std::string &amp;sample, std::string &amp;locus, int64_t &amp;haplotype, int64_t &amp;phase_block, std::pair&lt; int64_t, int64_t &gt; &amp;subrange)</td></tr>
<tr class="memdesc:a091d90f4eccbc743888ae2c3eb4f5d2f inherit pub_static_methods_classhandlegraph_1_1PathMetadata"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompose a formatted path name into metadata.  <a href="classhandlegraph_1_1PathMetadata.html#a091d90f4eccbc743888ae2c3eb4f5d2f">More...</a><br /></td></tr>
<tr class="separator:a091d90f4eccbc743888ae2c3eb4f5d2f inherit pub_static_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5632d26d764fce9adbb6e3b52e399dac inherit pub_static_methods_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#a5632d26d764fce9adbb6e3b52e399dac">create_path_name</a> (const <a class="el" href="classhandlegraph_1_1PathMetadata.html#a55d5f006ac51ae68361a1a230b5bcea8">PathMetadata::Sense</a> &amp;sense, const std::string &amp;sample, const std::string &amp;locus, const int64_t &amp;haplotype, const int64_t &amp;phase_block, const std::pair&lt; int64_t, int64_t &gt; &amp;subrange)</td></tr>
<tr class="separator:a5632d26d764fce9adbb6e3b52e399dac inherit pub_static_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_static_attribs_classhandlegraph_1_1PathMetadata"><td colspan="2" onclick="javascript:toggleInherit('pub_static_attribs_classhandlegraph_1_1PathMetadata')"><img src="closed.png" alt="-"/>&#160;Static Public Attributes inherited from <a class="el" href="classhandlegraph_1_1PathMetadata.html">handlegraph::PathMetadata</a></td></tr>
<tr class="memitem:a9770508967dec07997d8ad31dbbe5a95 inherit pub_static_attribs_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#a9770508967dec07997d8ad31dbbe5a95">NO_SAMPLE_NAME</a> = &quot;&quot;</td></tr>
<tr class="separator:a9770508967dec07997d8ad31dbbe5a95 inherit pub_static_attribs_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7ee0795aa13f7ad34189f2982d64c42 inherit pub_static_attribs_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">static const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#ae7ee0795aa13f7ad34189f2982d64c42">NO_LOCUS_NAME</a> = &quot;&quot;</td></tr>
<tr class="separator:ae7ee0795aa13f7ad34189f2982d64c42 inherit pub_static_attribs_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391d1aac1ee4234e7da8dde53aea93a6 inherit pub_static_attribs_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">static const int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#a391d1aac1ee4234e7da8dde53aea93a6">NO_HAPLOTYPE</a> = -1</td></tr>
<tr class="separator:a391d1aac1ee4234e7da8dde53aea93a6 inherit pub_static_attribs_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f466c78ef10dc196703a71d8de18df0 inherit pub_static_attribs_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">static const int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#a4f466c78ef10dc196703a71d8de18df0">NO_PHASE_BLOCK</a> = -1</td></tr>
<tr class="separator:a4f466c78ef10dc196703a71d8de18df0 inherit pub_static_attribs_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05262aea39fa1af3fd8fcaf769ca152c inherit pub_static_attribs_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">static const std::pair&lt; int64_t, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#a05262aea39fa1af3fd8fcaf769ca152c">NO_SUBRANGE</a> {-1, <a class="el" href="classhandlegraph_1_1PathMetadata.html#a14624e49419f849b5f33e6ddfb51cf1c">PathMetadata::NO_END_POSITION</a>}</td></tr>
<tr class="separator:a05262aea39fa1af3fd8fcaf769ca152c inherit pub_static_attribs_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14624e49419f849b5f33e6ddfb51cf1c inherit pub_static_attribs_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">static const int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#a14624e49419f849b5f33e6ddfb51cf1c">NO_END_POSITION</a> = -1</td></tr>
<tr class="separator:a14624e49419f849b5f33e6ddfb51cf1c inherit pub_static_attribs_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classhandlegraph_1_1PathHandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classhandlegraph_1_1PathHandleGraph')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">handlegraph::PathHandleGraph</a></td></tr>
<tr class="memitem:a79f48793555f6be311f6df6603324e7b inherit pro_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a79f48793555f6be311f6df6603324e7b">for_each_path_handle_impl</a> (const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; &amp;iteratee) const =0</td></tr>
<tr class="separator:a79f48793555f6be311f6df6603324e7b inherit pro_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bbdf56b268001c629cf000f5bd8bb9a inherit pro_methods_classhandlegraph_1_1PathHandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a2bbdf56b268001c629cf000f5bd8bb9a">for_each_step_on_handle_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;iteratee) const =0</td></tr>
<tr class="separator:a2bbdf56b268001c629cf000f5bd8bb9a inherit pro_methods_classhandlegraph_1_1PathHandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classhandlegraph_1_1HandleGraph"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classhandlegraph_1_1HandleGraph')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classhandlegraph_1_1HandleGraph.html">handlegraph::HandleGraph</a></td></tr>
<tr class="memitem:a89bbc118fe1e8e1acb162c14be33e8b5 inherit pro_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a89bbc118fe1e8e1acb162c14be33e8b5">follow_edges_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee) const =0</td></tr>
<tr class="separator:a89bbc118fe1e8e1acb162c14be33e8b5 inherit pro_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48ba081fcb810267dc50e3a3e7ad391 inherit pro_methods_classhandlegraph_1_1HandleGraph"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#af48ba081fcb810267dc50e3a3e7ad391">for_each_handle_impl</a> (const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee, bool parallel=false) const =0</td></tr>
<tr class="separator:af48ba081fcb810267dc50e3a3e7ad391 inherit pro_methods_classhandlegraph_1_1HandleGraph"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classhandlegraph_1_1PathMetadata"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classhandlegraph_1_1PathMetadata')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classhandlegraph_1_1PathMetadata.html">handlegraph::PathMetadata</a></td></tr>
<tr class="memitem:a75b258a204f7ae71543f08c27b28d7b2 inherit pro_methods_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#a75b258a204f7ae71543f08c27b28d7b2">for_each_path_matching_impl</a> (const std::unordered_set&lt; <a class="el" href="classhandlegraph_1_1PathMetadata.html#a55d5f006ac51ae68361a1a230b5bcea8">PathMetadata::Sense</a> &gt; *senses, const std::unordered_set&lt; std::string &gt; *samples, const std::unordered_set&lt; std::string &gt; *loci, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="separator:a75b258a204f7ae71543f08c27b28d7b2 inherit pro_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8fc46e6d32a78bb38458a2dbb148992 inherit pro_methods_classhandlegraph_1_1PathMetadata"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1PathMetadata.html#ad8fc46e6d32a78bb38458a2dbb148992">for_each_step_of_sense_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;visited, const <a class="el" href="classhandlegraph_1_1PathMetadata.html#a55d5f006ac51ae68361a1a230b5bcea8">Sense</a> &amp;sense, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;iteratee) const</td></tr>
<tr class="separator:ad8fc46e6d32a78bb38458a2dbb148992 inherit pro_methods_classhandlegraph_1_1PathMetadata"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a variation graph. Graphs consist of nodes, connected by edges. Graphs are bidirected and may be cyclic. Nodes carry forward-oriented sequences. Edges are directed, with a "from" and to" node, and are generally
used to connect the end of the "from" node to the start of the "to" node. However, edges can connect to either the start or end of either node. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ac2399de59931e282fb1f4d3da9a8dcb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2399de59931e282fb1f4d3da9a8dcb1">&#9670;&nbsp;</a></span>VG() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="a2dc9648985454d3aedd9a477ff0c52b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc9648985454d3aedd9a477ff0c52b2">&#9670;&nbsp;</a></span>VG() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showp</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn_on_duplicates</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from <a class="el" href="structvg_1_1Graph.html">Graph</a> objects serialized in a tagged group stream. </p>

</div>
</div>
<a id="a0fbb777fd8ab6050124a6eaf9eca9133"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fbb777fd8ab6050124a6eaf9eca9133">&#9670;&nbsp;</a></span>VG() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(const function&lt; void(<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>send_graphs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showp</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn_on_duplicates</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from an arbitrary source of <a class="el" href="structvg_1_1Graph.html">Graph</a> protobuf messages, with the message source in control of execution. Takes a function that takes a callback to call with each <a class="el" href="structvg_1_1Graph.html">Graph</a> object to incorporate. The <a class="el" href="structvg_1_1Graph.html">Graph</a> object may be moved by the <a class="el" href="classvg_1_1VG.html">VG</a>. </p>

</div>
</div>
<a id="af4d321b31b873153431c261090d052af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d321b31b873153431c261090d052af">&#9670;&nbsp;</a></span>VG() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showp</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn_on_duplicates</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct from a single Protobuf graph. The same as making an empty <a class="el" href="classvg_1_1VG.html">VG</a> and using <a class="el" href="classvg_1_1VG.html#a2519c3b939f48bca226e6fdea4c91f9d">extend()</a>. </p>

</div>
</div>
<a id="abeafee2d3bc6e0039e99fccdea10f4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeafee2d3bc6e0039e99fccdea10f4f9">&#9670;&nbsp;</a></span>VG() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype">set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct from sets of nodes and edges. For example, from a subgraph of another graph. </p>

</div>
</div>
<a id="a7513ddb88aeb58bd85a810c2a2ccdf67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7513ddb88aeb58bd85a810c2a2ccdf67">&#9670;&nbsp;</a></span>~VG()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::~VG </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<a id="a3148455330df9ac055c6bd1eb7da3167"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3148455330df9ac055c6bd1eb7da3167">&#9670;&nbsp;</a></span>VG() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="ab8365ccd6a093ec50f7d54b1c7a7c672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8365ccd6a093ec50f7d54b1c7a7c672">&#9670;&nbsp;</a></span>VG() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::VG::VG </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move constructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aaf5016c5e5d28db6db32aa7626440238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf5016c5e5d28db6db32aa7626440238">&#9670;&nbsp;</a></span>_for_each_kmer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::_for_each_kmer </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kmer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>path_only</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(string &amp;, list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;::iterator, int, list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_dups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negatives</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Call the given function on each kmer. If parallel is specified, goes through nodes one per thread. If node is not null, looks only at kmers of that specific node. </p>

</div>
</div>
<a id="a613c931c81518212917053d07e9bf8a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613c931c81518212917053d07e9bf8a8">&#9670;&nbsp;</a></span>add_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given edge, by value. </p>

</div>
</div>
<a id="acb8712eefbfd373c45f54d6bac8188c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb8712eefbfd373c45f54d6bac8188c6">&#9670;&nbsp;</a></span>add_edges() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_edges </td>
          <td>(</td>
          <td class="paramtype">const set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given edges, by value. </p>

</div>
</div>
<a id="a679e39a7c1771c3ecc7204bd3b999583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679e39a7c1771c3ecc7204bd3b999583">&#9670;&nbsp;</a></span>add_edges() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_edges </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given edges, by value. </p>

</div>
</div>
<a id="a7f23cdd532ca7b8d3c0bb9cceff3d378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f23cdd532ca7b8d3c0bb9cceff3d378">&#9670;&nbsp;</a></span>add_edges() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_edges </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given edges, by value. </p>

</div>
</div>
<a id="ad3e265ee441758d81fdb7c038e2fa8cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3e265ee441758d81fdb7c038e2fa8cc">&#9670;&nbsp;</a></span>add_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given node, by value. </p>

</div>
</div>
<a id="ab796330d50fdff47f5c080e251efea68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab796330d50fdff47f5c080e251efea68">&#9670;&nbsp;</a></span>add_nodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_nodes </td>
          <td>(</td>
          <td class="paramtype">const set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given nodes, by value. </p>

</div>
</div>
<a id="ae71d30b767f067a874c933f13f6c34e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae71d30b767f067a874c933f13f6c34e5">&#9670;&nbsp;</a></span>add_nodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_nodes </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add in the given nodes, by value. </p>

</div>
</div>
<a id="a91eaa395f197ca65f38c6139bc57d161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91eaa395f197ca65f38c6139bc57d161">&#9670;&nbsp;</a></span>add_start_end_markers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::add_start_end_markers </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>start_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>end_char</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>end_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>start_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>end_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a start node and an end node, where all existing heads in the graph are connected to the start node, and all existing tails in the graph are connected to the end node. Any connected components in the graph which do not have either are connected to the start at an arbitrary point, and the end node from nodes going to that arbitrary point. If start_node or end_node is null, a new node will be created. Otherwise, the passed node will be used. Note that this visits every node, to make sure it is attached to all connected components. Note that if a graph has, say, heads but no tails, the start node will be attached buut the end node will be free-floating. </p>

</div>
</div>
<a id="ab213a64c6240d08603530982c0b75047"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab213a64c6240d08603530982c0b75047">&#9670;&nbsp;</a></span>adjacent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::adjacent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if pos1 occurs directly before pos2. </p>

</div>
</div>
<a id="a3d4e6f3f52479b59a73b04c58945277b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4e6f3f52479b59a73b04c58945277b">&#9670;&nbsp;</a></span>align() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align with default <a class="el" href="classvg_1_1Aligner.html">Aligner</a>. Align to the graph. May modify the graph by re-ordering the nodes. May add nodes to the graph, but cleans them up afterward. </p>

</div>
</div>
<a id="ae6b16848db51add920b025829e2a5d55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6b16848db51add920b025829e2a5d55">&#9670;&nbsp;</a></span>align() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac24d1defbcca2158cda5fbd272fadae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24d1defbcca2158cda5fbd272fadae0">&#9670;&nbsp;</a></span>align() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td>
          <td class="paramname"><em>qual_adj_aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Private method to funnel other align functions into. max_span specifies the min distance to unfold the graph to, and is meant to be the longest path that the specified sequence could cover, accounting for deletions. If it's less than the sequence's length, the sequence's length is used. band_padding_override gives the band padding to use for banded global alignment. In banded global mode, if the band padding override is nonzero, permissive banding is not used, and instead the given band padding is provided. If the band padding override is not provided, the max span is used as the band padding and permissive banding is enabled. </p>

</div>
</div>
<a id="a09fa1d70c31c354915773e59a1a9b55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09fa1d70c31c354915773e59a1a9b55c">&#9670;&nbsp;</a></span>align() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align without base quality adjusted scores. Align to the graph. May modify the graph by re-ordering the nodes. May add nodes to the graph, but cleans them up afterward. </p>

</div>
</div>
<a id="af81a72bb91912cabbec795e17c311dc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af81a72bb91912cabbec795e17c311dc9">&#9670;&nbsp;</a></span>align() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align with default <a class="el" href="classvg_1_1Aligner.html">Aligner</a>. Align to the graph. May modify the graph by re-ordering the nodes. May add nodes to the graph, but cleans them up afterward. </p>

</div>
</div>
<a id="ac17b237e99636d20e12e4c1b94f9110b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac17b237e99636d20e12e4c1b94f9110b">&#9670;&nbsp;</a></span>align() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align without base quality adjusted scores. Align to the graph. May modify the graph by re-ordering the nodes. May add nodes to the graph, but cleans them up afterward. </p>

</div>
</div>
<a id="a2b135ccb439e99ef1f509a11ea9ea9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b135ccb439e99ef1f509a11ea9ea9ce">&#9670;&nbsp;</a></span>align_qual_adjusted() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align_qual_adjusted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td>
          <td class="paramname"><em>qual_adj_aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5532978af43e5c4e5e4f471069e53344"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5532978af43e5c4e5e4f471069e53344">&#9670;&nbsp;</a></span>align_qual_adjusted() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align_qual_adjusted </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td>
          <td class="paramname"><em>qual_adj_aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align with base quality adjusted scores. Align to the graph. May modify the graph by re-ordering the nodes. May add nodes to the graph, but cleans them up afterward. </p>

</div>
</div>
<a id="a58919649b2a29d36fd965ba453046baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58919649b2a29d36fd965ba453046baf">&#9670;&nbsp;</a></span>align_qual_adjusted() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::align_qual_adjusted </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td>
          <td class="paramname"><em>qual_adj_aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>traceback</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>acyclic_and_sorted</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_query_graph_ratio</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pinned_alignment</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>banded_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_override</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_span</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unroll_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>xdrop_alignment</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Align with base quality adjusted scores. Align to the graph. May modify the graph by re-ordering the nodes. May add nodes to the graph, but cleans them up afterward. </p>

</div>
</div>
<a id="a5272032c1e57d839176fc8e39bd87e18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5272032c1e57d839176fc8e39bd87e18">&#9670;&nbsp;</a></span>append()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::append </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add another graph into this graph, attaching tails to heads. Modify ids of the second graph to ensure we don't have conflicts. Then attach tails of this graph to the heads of the other, and extend(g). </p>

</div>
</div>
<a id="ad11c8a716733fce2aa9dab94b42286bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad11c8a716733fce2aa9dab94b42286bd">&#9670;&nbsp;</a></span>append_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::VG::append_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to_append</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a visit to a node to the given path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a83a4a14a629cde03d33e4eb3f6bb192d">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a id="af87ad4202f541fd560d67badcde09610"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af87ad4202f541fd560d67badcde09610">&#9670;&nbsp;</a></span>apply_ordering()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::apply_ordering </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compact_ids</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reorder the graph's internal structure to match that given. This sets the order that is used for iteration in functions like for_each_handle. If compact_ids is true, may (but will not necessarily) compact the id space of the graph to match the ordering, from 1-&gt;|ordering|. In other cases, node IDs will be preserved. This may be a no-op in the case of graph implementations that do not have any mechanism to maintain an ordering. This may invalidate outstanding handles. Returns true if node IDs actually were adjusted to match the given order, and false if they remain unchanged. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a588935d58708b33bc66014b254393940">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="ab5ee06ac168f037f2cff3b332079b49c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5ee06ac168f037f2cff3b332079b49c">&#9670;&nbsp;</a></span>apply_orientation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::VG::apply_orientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Alter the node that the given handle corresponds to so the orientation indicated by the handle becomes the node's local forward orientation. Rewrites all edges pointing to the node and the node's sequence to reflect this. Invalidates all handles to the node (including the one passed). Returns a new, valid handle to the node in its new forward orientation. Note that it is possible for the node's ID to change. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a71433449cb13e22dc19caaf544b6d7bc">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="a93cb2d6686e0bb92d7f0b632fc813702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93cb2d6686e0bb92d7f0b632fc813702">&#9670;&nbsp;</a></span>break_cycles()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> &gt; vg::VG::break_cycles </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use our topological sort to quickly break cycles in the graph, return the edges which are removed. Very non-optimal, but fast. </p>

</div>
</div>
<a id="a3fb2cb59474393ac822847033f185d17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fb2cb59474393ac822847033f185d17">&#9670;&nbsp;</a></span>build_edge_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::build_edge_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af63d4a22a3baa5b21623128b81a14872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63d4a22a3baa5b21623128b81a14872">&#9670;&nbsp;</a></span>build_edge_indexes_no_init_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::build_edge_indexes_no_init_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7f71911fe2c652dc11aec0a0d705b1e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f71911fe2c652dc11aec0a0d705b1e4">&#9670;&nbsp;</a></span>build_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::build_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa78095fb5d27e182c5cc4d5c10d3da39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa78095fb5d27e182c5cc4d5c10d3da39">&#9670;&nbsp;</a></span>build_indexes_no_init_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::build_indexes_no_init_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5156da43d4175597d7a8b1d88b5179af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5156da43d4175597d7a8b1d88b5179af">&#9670;&nbsp;</a></span>build_node_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::build_node_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ca442744267b08609887cd842ca543d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca442744267b08609887cd842ca543d">&#9670;&nbsp;</a></span>build_node_indexes_no_init_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::build_node_indexes_no_init_size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e2649b8ef5de75db451146c7ac92e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e2649b8ef5de75db451146c7ac92e92">&#9670;&nbsp;</a></span>circularize() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::circularize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Circularize a subgraph / path using the head / tail nodes. </p>

</div>
</div>
<a id="ad96ff883534a13b28b18cd84dd094e72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96ff883534a13b28b18cd84dd094e72">&#9670;&nbsp;</a></span>circularize() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::circularize </td>
          <td>(</td>
          <td class="paramtype">vector&lt; string &gt;&#160;</td>
          <td class="paramname"><em>pathnames</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1eb3332c0a99a25c75681da485297e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1eb3332c0a99a25c75681da485297e5">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove all nodes and edges. Does not update any stored paths. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a6e1a83e72b47643e43c6176f39d8db5e">handlegraph::DeletableHandleGraph</a>.</p>

</div>
</div>
<a id="a10d4b49633db2aef463e0070e0af64a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10d4b49633db2aef463e0070e0af64a0">&#9670;&nbsp;</a></span>clear_edge_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_edge_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5195712f8aa650417d93324ff1c89ecf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5195712f8aa650417d93324ff1c89ecf">&#9670;&nbsp;</a></span>clear_edge_indexes_no_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_edge_indexes_no_resize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aae960ce1d640fadc4772795f6d0ff5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae960ce1d640fadc4772795f6d0ff5b5">&#9670;&nbsp;</a></span>clear_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a103c69bad02121590779530338861374"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a103c69bad02121590779530338861374">&#9670;&nbsp;</a></span>clear_indexes_no_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_indexes_no_resize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a212a2d1028f28046088a86e128b40559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a212a2d1028f28046088a86e128b40559">&#9670;&nbsp;</a></span>clear_node_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_node_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af51220e88887adf92d7cff25dad5cd91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51220e88887adf92d7cff25dad5cd91">&#9670;&nbsp;</a></span>clear_node_indexes_no_resize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_node_indexes_no_resize </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4e534461834b2937b7f0b0c2420b899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e534461834b2937b7f0b0c2420b899">&#9670;&nbsp;</a></span>clear_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::clear_paths </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear the paths object (which indexes the graph.paths) and the graph paths themselves. </p>

</div>
</div>
<a id="a688cbe42750d98695114ad4ad640c1d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a688cbe42750d98695114ad4ad640c1d3">&#9670;&nbsp;</a></span>collect_subgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::collect_subgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Collect the subgraph of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a>. TODO: what does that mean? </p>

</div>
</div>
<a id="a7d06218f137184c366de80df755ae001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d06218f137184c366de80df755ae001">&#9670;&nbsp;</a></span>combine()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::combine </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add another graph into this graph. Don't append or join the nodes in the graphs; just ensure that ids are unique, then apply extend. </p>

</div>
</div>
<a id="a2e1708efaeceace87615bb67715d60fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e1708efaeceace87615bb67715d60fa">&#9670;&nbsp;</a></span>common_ancestor_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> vg::VG::common_ancestor_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>steps</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find a common ancestor by walking forward up to steps from the first node. </p>

</div>
</div>
<a id="ab3ba20713228cb76fa4b982d967654aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3ba20713228cb76fa4b982d967654aa">&#9670;&nbsp;</a></span>common_ancestor_prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> vg::VG::common_ancestor_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>steps</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Try to find a common ancestor by walking back up to steps from the first node. </p>

</div>
</div>
<a id="ae931543bdeed5e60edcf6225489e3ceb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae931543bdeed5e60edcf6225489e3ceb">&#9670;&nbsp;</a></span>compact_ids() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::compact_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Squish the node IDs down into as small a space as possible. Fixes up paths itself. Record translation in provided map. </p>

</div>
</div>
<a id="a161ef56bd0eeee937602f60b8617f24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161ef56bd0eeee937602f60b8617f24d">&#9670;&nbsp;</a></span>compact_ids() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::compact_ids </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Squish the node IDs down into as small a space as possible. Fixes up paths itself. </p>

</div>
</div>
<a id="a150341270e41f42db2578a2897e48c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a150341270e41f42db2578a2897e48c1b">&#9670;&nbsp;</a></span>concat_mappings_for_node_pair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;string, vector&lt;<a class="el" href="classvg_1_1mapping__t.html">mapping_t</a>&gt; &gt; vg::VG::concat_mappings_for_node_pair </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Concatenate the mappings for a pair of nodes; handles multiple mappings per path. </p>

</div>
</div>
<a id="ab8189716ecbb9eeeefec8be64e34a9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8189716ecbb9eeeefec8be64e34a9e3">&#9670;&nbsp;</a></span>connect_node_to_nodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::connect_node_to_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_start</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect node -&gt; nodes. You can optionally use the start of the first node instead of the end. </p>

</div>
</div>
<a id="ad68d2bfaa6627686967add4ca7fb5f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad68d2bfaa6627686967add4ca7fb5f4c">&#9670;&nbsp;</a></span>connect_node_to_nodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::connect_node_to_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Connect node -&gt; nodes. Connects from the right side of the first to the left side of the second. </p>

</div>
</div>
<a id="acc4db5878a40e8dc7d2d2b25ff62ff1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc4db5878a40e8dc7d2d2b25ff62ff1e">&#9670;&nbsp;</a></span>connect_nodes_to_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::connect_nodes_to_node </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_end</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>connect nodes -&gt; node. </p>

</div>
</div>
<a id="a7ee6066424793dfcda9097419f03b568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee6066424793dfcda9097419f03b568">&#9670;&nbsp;</a></span>connect_nodes_to_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::connect_nodes_to_node </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>connect nodes -&gt; node. Connects from the right side of the first to the left side of the second. </p>

</div>
</div>
<a id="a8922810d5228ab5c4619eb2ddc16e78b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8922810d5228ab5c4619eb2ddc16e78b">&#9670;&nbsp;</a></span>create_edge() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::create_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create an edge connecting the given handles in the given order and orientations. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a34a5e01f270713ba856a93c55039faf0">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="abf766c692dc78334d6b7568f1a9d972b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf766c692dc78334d6b7568f1a9d972b">&#9670;&nbsp;</a></span>create_edge() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::create_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_start</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_end</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an edge. If the given edge cannot be created, returns null. If the given edge already exists, returns the existing edge. </p>

</div>
</div>
<a id="a8ecb9833a1b3e7d5ca41fcaa96000976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ecb9833a1b3e7d5ca41fcaa96000976">&#9670;&nbsp;</a></span>create_edge() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::create_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_start</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_end</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create an edge. If the given edge cannot be created, returns null. If the given edge already exists, returns the existing edge. </p>

</div>
</div>
<a id="ac2cd4705aa5b919f349d02089c97cbc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2cd4705aa5b919f349d02089c97cbc2">&#9670;&nbsp;</a></span>create_edge() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::create_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td>
          <td class="paramname"><em>side1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td>
          <td class="paramname"><em>side2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make an edge connecting the given sides of nodes. If the given edge cannot be created, returns null. If the given edge already exists, returns the existing edge. </p>

</div>
</div>
<a id="a8fd0565d5133a239856444049783edcd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd0565d5133a239856444049783edcd">&#9670;&nbsp;</a></span>create_edge() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::create_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a left-to-right edge from the left <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> to the right one, respecting orientations. If the given edge cannot be created, returns null. If the given edge already exists, returns the existing edge. </p>

</div>
</div>
<a id="a54ad97e46dc1297b1a65a32697e2d37e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54ad97e46dc1297b1a65a32697e2d37e">&#9670;&nbsp;</a></span>create_handle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::VG::create_handle </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new node with the given sequence and return the handle. The sequence may not be empty. </p>

</div>
</div>
<a id="a292614805cec28a1d863bbdb494d1c04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a292614805cec28a1d863bbdb494d1c04">&#9670;&nbsp;</a></span>create_handle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::VG::create_handle </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new node with the given id and sequence, then return the handle. The sequence may not be empty. The ID must be strictly greater than 0. </p>

</div>
</div>
<a id="a8cb95ac1c24c5263a962c13f3d6bc0c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cb95ac1c24c5263a962c13f3d6bc0c3">&#9670;&nbsp;</a></span>create_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::create_node </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a node. Use the <a class="el" href="classvg_1_1VG.html">VG</a> class to generate ids. </p>

</div>
</div>
<a id="aefa25ac8acfa9407e8489b402f6317dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa25ac8acfa9407e8489b402f6317dc">&#9670;&nbsp;</a></span>create_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::create_node </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a node. Use a specified, nonzero node ID. </p>

</div>
</div>
<a id="a3195bfadb7e65e4952c4b98d51e862f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3195bfadb7e65e4952c4b98d51e862f1">&#9670;&nbsp;</a></span>create_path() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::VG::create_path </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a path. </p>

</div>
</div>
<a id="adc07ec73a57485a700e621517c962b8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc07ec73a57485a700e621517c962b8b">&#9670;&nbsp;</a></span>create_path() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::VG::create_path </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a path. </p>

</div>
</div>
<a id="af7c99e48723b360eb2b1315b2c5af7cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7c99e48723b360eb2b1315b2c5af7cc">&#9670;&nbsp;</a></span>create_path_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> vg::VG::create_path_handle </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_circular</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a path with the given name. </p>

</div>
</div>
<a id="a2c8890bbc32c99bba8ca17f24a11d343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c8890bbc32c99bba8ca17f24a11d343">&#9670;&nbsp;</a></span>dagify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> vg::VG::dagify </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>expand_scc_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>target_min_walk_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>component_length_max</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turn the graph into a dag by copying strongly connected components expand_scc_steps times and translating the edges in the component to flow through the copies in one direction. Assumes that all nodes in the graph are articulated on one consistent strand. Tolerates doubly-reversing edges in the input graph. </p>

</div>
</div>
<a id="aae60b30eaa432d73f91dc28283679a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae60b30eaa432d73f91dc28283679a18">&#9670;&nbsp;</a></span>decrement_node_ids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::decrement_node_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>decrement</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Subtract the given value from all the node IDs. Must not create a node with 0 or negative IDs. Invalidates the paths. </p>

</div>
</div>
<a id="a24359ba8e4ecbbd692bba5a517456659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24359ba8e4ecbbd692bba5a517456659">&#9670;&nbsp;</a></span>deserialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::deserialize </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Sets the contents of this graph to the contents of a serialized graph from an istream. The serialized graph must be from the same implementation of the HandleGraph interface as is calling <a class="el" href="classvg_1_1VG.html#a24359ba8e4ecbbd692bba5a517456659">deserialize()</a>. Can only be called by an empty graph. </p>

</div>
</div>
<a id="a9d4264e39e3826ded714992361ab879e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d4264e39e3826ded714992361ab879e">&#9670;&nbsp;</a></span>destroy_edge() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Remove the edge connecting the given handles in the given order and orientations. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a285ac35e805eab548c4106ee534d79f2">handlegraph::DeletableHandleGraph</a>.</p>

</div>
</div>
<a id="abe6b91020abf39815d28995eceac4e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6b91020abf39815d28995eceac4e2d">&#9670;&nbsp;</a></span>destroy_edge() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the edge between the given sides of nodes. These can be in either order. </p>

</div>
</div>
<a id="a7fd2744b37b62862df68e82cbe7b6b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fd2744b37b62862df68e82cbe7b6b59">&#9670;&nbsp;</a></span>destroy_edge() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_edge </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sides</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the edge between the given sides of nodes. This can take sides in any order. </p>

</div>
</div>
<a id="a284327157f9d4b82224fc856179a668d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a284327157f9d4b82224fc856179a668d">&#9670;&nbsp;</a></span>destroy_edge() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the edge at the given pointer. This pointer must point to an edge owned by the graph. </p>

</div>
</div>
<a id="a3e52875d37f046daeaf9e7b301ad59ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e52875d37f046daeaf9e7b301ad59ff">&#9670;&nbsp;</a></span>destroy_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Remove the node belonging to the given handle and all of its edges. Destroys any paths in which the node participates. Invalidates the destroyed handle. May be called during serial for_each_handle iteration <b>ONLY</b> on the node being iterated. May <b>NOT</b> be called during parallel for_each_handle iteration. May <b>NOT</b> be called on the node from which edges are being followed during follow_edges. May <b>NOT</b> be called during iteration over paths, if it would destroy a path. May <b>NOT</b> be called during iteration along a path, if it would destroy that path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html#a06d4d3ecda0694d5045c457f3eecd8e3">handlegraph::DeletableHandleGraph</a>.</p>

</div>
</div>
<a id="a983041950b8dc25a77bd828dd6c05a1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a983041950b8dc25a77bd828dd6c05a1b">&#9670;&nbsp;</a></span>destroy_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the node with the given ID. </p>

</div>
</div>
<a id="ab9cd34f3c968f90370c42e8692222619"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9cd34f3c968f90370c42e8692222619">&#9670;&nbsp;</a></span>destroy_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the node at the given pointer. This pointer must point to a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a> owned by the graph. </p>

</div>
</div>
<a id="adb25bd1fdb9e36c55157c5be864ca403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb25bd1fdb9e36c55157c5be864ca403">&#9670;&nbsp;</a></span>destroy_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::destroy_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destroy the given path. Invalidates handles to the path and its node steps. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a421fe49069d9a533db9ab682d4bec754">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a id="a8ee80f3ce939643d59157e1a1d707068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee80f3ce939643d59157e1a1d707068">&#9670;&nbsp;</a></span>dfs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::dfs </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_begin_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_end_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>break_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialization of dfs for only handling nodes + break function. </p>

</div>
</div>
<a id="aec0db609d022b3c3183403600970238f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec0db609d022b3c3183403600970238f">&#9670;&nbsp;</a></span>dfs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::dfs </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_begin_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_end_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>break_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>tree_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_curr_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_cross_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *&#160;</td>
          <td class="paramname"><em>sinks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do a DFS search of the bidirected graph. A bidirected DFS starts at some root node, and traverses first all the nodes found reading out the right of that node in their appropriate relative orientations (including the root), and then all the nodes found reading left out of that node in their appropriate orientations (including the root). If any unvisited nodes are left in other connected components, the process will repeat from one such node, until all nodes have been visited in each orientation. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">node_begin_fn</td><td>Called when node orientattion is first encountered. </td></tr>
    <tr><td class="paramname">node_end_fn</td><td>Called when node orientation goes out of scope. </td></tr>
    <tr><td class="paramname">break_fn</td><td>Called to check if we should stop the DFS. </td></tr>
    <tr><td class="paramname">edge_fn</td><td>Called when an edge is encountered. </td></tr>
    <tr><td class="paramname">tree_fn</td><td>Called when an edge forms part of the DFS spanning tree. </td></tr>
    <tr><td class="paramname">edge_curr_fn</td><td>Called when we meet an edge in the current tree component. </td></tr>
    <tr><td class="paramname">edge_cross_fn</td><td>Called when we meet an edge in an already-traversed tree component. </td></tr>
    <tr><td class="paramname">sources</td><td>Start only at these node traversals. </td></tr>
    <tr><td class="paramname">sinks</td><td>When hitting a sink, don't keep walking. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a287e5d12ba0bc0823d1b6e0fa56af3d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a287e5d12ba0bc0823d1b6e0fa56af3d6">&#9670;&nbsp;</a></span>dfs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::dfs </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_begin_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(<a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_end_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *&#160;</td>
          <td class="paramname"><em>sources</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; *&#160;</td>
          <td class="paramname"><em>sinks</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Specialization of dfs for only handling nodes. </p>

</div>
</div>
<a id="a7a5dbc95fa80e7fe3dc04d62ac6d7b3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a5dbc95fa80e7fe3dc04d62ac6d7b3c">&#9670;&nbsp;</a></span>divide_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; vg::VG::divide_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Split a handle's underlying node at the given offsets in the handle's orientation. Returns all of the handles to the parts. Other handles to the node being split may be invalidated. The split pieces stay in the same local forward orientation as the original node, but the returned handles come in the order and orientation appropriate for the handle passed in. </p>

</div>
</div>
<a id="ad06f0fcad4bf5b1c29cf937a870a58b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad06f0fcad4bf5b1c29cf937a870a58b4">&#9670;&nbsp;</a></span>divide_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::divide_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide a node at a given internal position. Inserts the new nodes in the correct paths, but can't update the ranks, so they need to be cleared and re-calculated by the caller. </p>

</div>
</div>
<a id="a7bee7317e4f7e42d85d8e7ef8d07273a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bee7317e4f7e42d85d8e7ef8d07273a">&#9670;&nbsp;</a></span>divide_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::divide_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>parts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide a node at a given internal position. This version works on a collection of internal positions, in linear time. </p>

</div>
</div>
<a id="a0466bd1a92042266f6a99aa306d387c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0466bd1a92042266f6a99aa306d387c9">&#9670;&nbsp;</a></span>divide_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::divide_path </td>
          <td>(</td>
          <td class="paramtype">map&lt; long, <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Divide a path at a position. Also invalidates stored rank information. </p>

</div>
</div>
<a id="a25ef81b910a6fc47c9a6ba4c1636cf83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25ef81b910a6fc47c9a6ba4c1636cf83">&#9670;&nbsp;</a></span>edge_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::edge_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the number of edges in the graph. </p>

</div>
</div>
<a id="aaaae0ba5428a83ece038f506c9c5df54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaaae0ba5428a83ece038f506c9c5df54">&#9670;&nbsp;</a></span>edges_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt; &amp; vg::VG::edges_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get nodes and backward flags following edges that attach to this node's end. </p>

</div>
</div>
<a id="a9a37e4df96356dbf4f7e78da9eb8fd89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a37e4df96356dbf4f7e78da9eb8fd89">&#9670;&nbsp;</a></span>edges_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt; &amp; vg::VG::edges_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get nodes and backward flags following edges that attach to this node's end. </p>

</div>
</div>
<a id="ae1a7e0aa663eadc0ebdaaf13b667323e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1a7e0aa663eadc0ebdaaf13b667323e">&#9670;&nbsp;</a></span>edges_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; vg::VG::edges_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edges from the specified node. </p>

</div>
</div>
<a id="aa1bf5492e5c6d586cd266d2a48f792df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1bf5492e5c6d586cd266d2a48f792df">&#9670;&nbsp;</a></span>edges_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; vg::VG::edges_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edges of the specified node. </p>

</div>
</div>
<a id="a5b6a5e92afb1a70d9c63a1848a01f241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b6a5e92afb1a70d9c63a1848a01f241">&#9670;&nbsp;</a></span>edges_of_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::edges_of_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the edges of the specified node, and add them to the given vector. Guaranteed to add each edge only once per call. </p>

</div>
</div>
<a id="a3b2d900fc42cffe079c3ba3897717eae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2d900fc42cffe079c3ba3897717eae">&#9670;&nbsp;</a></span>edges_of_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::edges_of_nodes </td>
          <td>(</td>
          <td class="paramtype">set&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edges of the specified set of nodes, and add them to the given set of edge pointers. </p>

</div>
</div>
<a id="aee2439ec8f0d8ee87becac3f6fbf13bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee2439ec8f0d8ee87becac3f6fbf13bb">&#9670;&nbsp;</a></span>edges_start() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt; &amp; vg::VG::edges_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get nodes and backward flags following edges that attach to this node's start. </p>

</div>
</div>
<a id="a3032de0eb7258c9e2db4a27f16a8604c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3032de0eb7258c9e2db4a27f16a8604c">&#9670;&nbsp;</a></span>edges_start() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt; &amp; vg::VG::edges_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get nodes and backward flags following edges that attach to this node's start. </p>

</div>
</div>
<a id="a3789cf6561f2d3da5ef85f23b5c6454f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3789cf6561f2d3da5ef85f23b5c6454f">&#9670;&nbsp;</a></span>edges_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; vg::VG::edges_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edges to the specified node. </p>

</div>
</div>
<a id="aa800d382b361f1bdad0e5855dd4c05ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa800d382b361f1bdad0e5855dd4c05ca">&#9670;&nbsp;</a></span>edit() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::edit </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>paths_to_add_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; *&#160;</td>
          <td class="paramname"><em>out_translations</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>save_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>out_gam_path</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>break_at_ends</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_softclips</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Streaming version of above. Instead of reading a list of paths into memory all at once, a file stream is opened from the given path and used to go one-by-one. Instead of an option to updtate the in-memory list, an optional output path for the paths is used</p>
<p>todo: duplicate less code between the two versions. <br  />
 </p>

</div>
</div>
<a id="a5962aa939727f27cb7c62b2ce2706fe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5962aa939727f27cb7c62b2ce2706fe9">&#9670;&nbsp;</a></span>edit() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::edit </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths_to_add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; *&#160;</td>
          <td class="paramname"><em>out_translations</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>save_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>update_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>break_at_ends</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Edit the graph to include all the sequence and edges added by the given paths. Can handle paths that visit nodes in any orientation. If out_translations is given, a vector of Translations will be written to it, one per node existing after the edit, describing how each new or conserved node is embedded in the old graph. Note that this method sorts the graph and rebuilds the path index, so it should not be called in a loop.</p>
<p>If update_paths is true, the paths will be modified to reflect their embedding in the modified graph. If save_paths is true, the paths as embedded in the graph will be added to the graph's set of paths. If break_at_ends is true (or save_paths is true), nodes will be broken at the ends of paths that start/end woth perfect matches, so the paths can be added to the vg graph's paths object. </p>

</div>
</div>
<a id="a78f70eb7eddb0245be7cdfc048616638"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78f70eb7eddb0245be7cdfc048616638">&#9670;&nbsp;</a></span>edit_fast()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; vg::VG::edit_fast </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dangling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_node_size</em> = <code>1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Edit the graph to include all the sequences and edges added by the given path. Returns a vector of Translations, one per original-node fragment. Completely novel nodes are not mentioned, and nodes with no Translations are assumed to be carried through unchanged. Invalidates the rank-based <a class="el" href="classvg_1_1Paths.html">Paths</a> index. Does not sort the graph. Suitable for calling in a loop.</p>
<p>Can attach newly created nodes on the left of the path to the given set of dangling NodeSides, and populates the set at the end with the <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> corresponding to the end of the path. This mechanism allows edits that hit the end of a node to be attached to what comes before/after the node by the caller, as this function doesn't handle that. </p>

</div>
</div>
<a id="a42d7f84de5d99fe0ce51186fcbea420c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d7f84de5d99fe0ce51186fcbea420c">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::empty </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the graph empty? </p>

</div>
</div>
<a id="af3cf82dca43799a03d93b199133f1d4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3cf82dca43799a03d93b199133f1d4b">&#9670;&nbsp;</a></span>end_degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::end_degree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of edges attached to the end of a node. </p>

</div>
</div>
<a id="a6a525e3290d6968c79314c2500f13cc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a525e3290d6968c79314c2500f13cc3">&#9670;&nbsp;</a></span>expand_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::expand_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_paths</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_steps</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expand the context of what's already in the given graph by the given distance, either in nodes or in bases. Pulls material from this graph. </p>

</div>
</div>
<a id="a5ba5a5416ee9eaf67c7ae5607fc7ae1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba5a5416ee9eaf67c7ae5607fc7ae1f">&#9670;&nbsp;</a></span>expand_context_by_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::expand_context_by_length </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_paths</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reflect</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>barriers</em> = <code>set&lt;<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&gt;()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expand the context of the given graph by the given number of bases. If reflect is true, bounce off the ends of nodes to get siblings of nodes you came from. Can take a set of NodeSides not to look out from, that act as barriers to context expansion. These barriers will have no edges attached to them in the final graph. </p>

</div>
</div>
<a id="aca4ead561b46cd1cde77ada1f611befa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4ead561b46cd1cde77ada1f611befa">&#9670;&nbsp;</a></span>expand_context_by_steps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::expand_context_by_steps </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>add_paths</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand the context of the given graph by the given number of steps. </p>

</div>
</div>
<a id="aa9273361525befc57536dc96a762c29d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9273361525befc57536dc96a762c29d">&#9670;&nbsp;</a></span>expand_path() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::expand_path </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>expanded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand a path. TODO: what does that mean? </p>

</div>
</div>
<a id="ae151983cac753c02ce3852274798f8d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae151983cac753c02ce3852274798f8d5">&#9670;&nbsp;</a></span>expand_path() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::expand_path </td>
          <td>(</td>
          <td class="paramtype">list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt;::iterator &gt; &amp;&#160;</td>
          <td class="paramname"><em>expanded</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Expand a path. TODO: what does that mean? These versions handle paths in which nodes can be traversed multiple times. Unfortunately since we're throwing non-const iterators around, we can't take the input path as const. </p>

</div>
</div>
<a id="a5e517214b33812b16f195a1f87841c0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e517214b33812b16f195a1f87841c0d">&#9670;&nbsp;</a></span>extend() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::extend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn_on_duplicates</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This version does not sort path mappings by rank. In order to preserve paths, call <a class="el" href="classvg_1_1Paths.html#a2970302cae3a54ef7f4296dbf49266fd">Paths::sort_by_mapping_rank()</a> and <a class="el" href="classvg_1_1Paths.html#a5f80df5846bdac0b502a70af97dc65de" title="Reassign ranks and rebuild indexes, treating the mapping lists in _paths as the truth.">Paths::rebuild_mapping_aux()</a> after you are done adding in graphs to this graph. </p>

</div>
</div>
<a id="a2519c3b939f48bca226e6fdea4c91f9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2519c3b939f48bca226e6fdea4c91f9d">&#9670;&nbsp;</a></span>extend() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::extend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn_on_duplicates</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iteratively add when nodes and edges are novel. Good when there are very many overlaps. TODO: If you are using this with warn on duplicates on, and you know there shouldn't be any duplicates, maybe you should use merge instead. This version sorts paths on rank after adding in the path mappings from the other graph. </p>

</div>
</div>
<a id="a04774a86b07508e9e5955abfba2171ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04774a86b07508e9e5955abfba2171ff">&#9670;&nbsp;</a></span>find_node_by_name_or_add_new()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::find_node_by_name_or_add_new </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a node with the given name, or create a new one if none is found. </p>

</div>
</div>
<a id="a48a5e160f098327f149b7a8a7a5b3558"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48a5e160f098327f149b7a8a7a5b3558">&#9670;&nbsp;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::VG::flip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert the orientation of a handle (potentially without getting its ID) </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#aaa3f94ae7e884408ef6e8ca8fd45c7d7">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a8e5079416ab826cbc8a5eea3869eb892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5079416ab826cbc8a5eea3869eb892">&#9670;&nbsp;</a></span>flip_doubly_reversed_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::flip_doubly_reversed_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert edges that are both from_start and to_end to "regular" ones from end to start. </p>

</div>
</div>
<a id="a4c1118bd664e83254db09ba3e8a3ec3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c1118bd664e83254db09ba3e8a3ec3f">&#9670;&nbsp;</a></span>follow_edges_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::follow_edges_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the handles to next/previous (right/left) nodes. Passes them to a callback which returns false to stop iterating and true to continue. Returns true if we finished and false if we stopped early. </p>

</div>
</div>
<a id="a892abc4056e30044ae9ce0db9e4871f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a892abc4056e30044ae9ce0db9e4871f0">&#9670;&nbsp;</a></span>for_each_connected_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_connected_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Node.html">Node</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Go through all the nodes in the same connected component as the given node. Ignores relative orientation. </p>

</div>
</div>
<a id="aed86f57c2e9766da9757e18ef543d35d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed86f57c2e9766da9757e18ef543d35d">&#9670;&nbsp;</a></span>for_each_edge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_edge </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(const <a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d7fdd8c951cbf8b25e116435b5e1e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7fdd8c951cbf8b25e116435b5e1e0e">&#9670;&nbsp;</a></span>for_each_edge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_edge </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the given function for each edge. </p>

</div>
</div>
<a id="a46a20aa427767a27fd15d181ccca8c42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46a20aa427767a27fd15d181ccca8c42">&#9670;&nbsp;</a></span>for_each_edge_parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_edge_parallel </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Edge.html">Edge</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the given function for each edge, in parallel. </p>

</div>
</div>
<a id="afa7a11323fdb8a632f4dc5e405e74848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7a11323fdb8a632f4dc5e405e74848">&#9670;&nbsp;</a></span>for_each_handle_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::for_each_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the nodes in the graph in their local forward orientations, in their internal stored order. Stop if the iteratee returns false. </p>

</div>
</div>
<a id="a23b34b164590c0537bf704dd1b816760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23b34b164590c0537bf704dd1b816760">&#9670;&nbsp;</a></span>for_each_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_node </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(const <a class="el" href="structvg_1_1Node.html">Node</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af585f2161de09403d197e05fbcfb9a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af585f2161de09403d197e05fbcfb9a07">&#9670;&nbsp;</a></span>for_each_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_node </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Node.html">Node</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the given function on every node. </p>

</div>
</div>
<a id="a39790d52fe4c09804086d58164258fcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39790d52fe4c09804086d58164258fcf">&#9670;&nbsp;</a></span>for_each_node_parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::for_each_node_parallel </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Node.html">Node</a> *)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Run the given function on every node in parallel. </p>

</div>
</div>
<a id="a527e1ab441e93f73902b7a02b29c1bd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527e1ab441e93f73902b7a02b29c1bd6">&#9670;&nbsp;</a></span>for_each_path_handle_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::for_each_path_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Execute a function on each path in the graph. </p>

</div>
</div>
<a id="a68b4c3665812b5be48d01677367382fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68b4c3665812b5be48d01677367382fd">&#9670;&nbsp;</a></span>for_each_step_on_handle_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::for_each_step_on_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Loop over the steps of a handle in paths. </p>

</div>
</div>
<a id="a3c22829197fc65ced4dd2e0f53cb20ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c22829197fc65ced4dd2e0f53cb20ff">&#9670;&nbsp;</a></span>from_istream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::from_istream </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showp</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>warn_on_duplicates</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8aef48163c0dd4267d24b629de8a04c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8aef48163c0dd4267d24b629de8a04c8">&#9670;&nbsp;</a></span>from_turtle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::from_turtle </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>baseuri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>showp</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Build a graph from a Turtle stream. </p>
<p>Add the paths that we parsed into the vg object</p>

</div>
</div>
<a id="a7cb582e352f75cc9d66e6eff0f4ba659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cb582e352f75cc9d66e6eff0f4ba659">&#9670;&nbsp;</a></span>get_base()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char vg::VG::get_base </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns one base of a handle's sequence, in the orientation of the handle. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#a64d58c3e26e9e7954dd25c3eff7af521">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="afc0ac00267e00156e04c849a10b1cb74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc0ac00267e00156e04c849a10b1cb74">&#9670;&nbsp;</a></span>get_degree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::get_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Efficiently get the number of edges attached to one side of a handle. Uses the <a class="el" href="classvg_1_1VG.html">VG</a> graph's internal degree index. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#ab259e3aba0da47b0ef1c9b5e43c7d209">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a8668ddc84b9abe4fe9cb5acb3efd877b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8668ddc84b9abe4fe9cb5acb3efd877b">&#9670;&nbsp;</a></span>get_edge() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::get_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the specified edge. This can take sides in any order. </p>

</div>
</div>
<a id="af63d7ba7b69594ee99f3ad99dd394171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af63d7ba7b69594ee99f3ad99dd394171">&#9670;&nbsp;</a></span>get_edge() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::get_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edge connecting the given oriented nodes in the given order. </p>

</div>
</div>
<a id="a227023072262f46f7c423d30cf8bc443"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a227023072262f46f7c423d30cf8bc443">&#9670;&nbsp;</a></span>get_edge() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edge.html">Edge</a> * vg::VG::get_edge </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sides</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a pointer to the specified edge. This can take sides in any order. </p>

</div>
</div>
<a id="ad4577be9213932c313efd3d016b88a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4577be9213932c313efd3d016b88a31">&#9670;&nbsp;</a></span>get_edge_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::get_edge_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the total number of edges in the graph. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#a20ff62014d7f0f0c01ada8a3d40a278d">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a70f50e6766af9262c732de26243658f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70f50e6766af9262c732de26243658f5">&#9670;&nbsp;</a></span>get_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::VG::get_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the handle for the node with the given ID in the given orientation. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a6dd9d70931835f5c75518b23a780b744">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="acb73599cc743a392650a7002c8dc2906"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb73599cc743a392650a7002c8dc2906">&#9670;&nbsp;</a></span>get_handle_of_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::VG::get_handle_of_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a node handle (node ID and orientation) from a handle to an step on a path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a339e690ce3e2bb8280dd1f3ea45abe42">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a6f4b9ac16f23eb0420544ce8357736a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6f4b9ac16f23eb0420544ce8357736a3">&#9670;&nbsp;</a></span>get_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> vg::VG::get_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID from a handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#adb7f6e144bf2a59679f7b2eddad934eb">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a1463f13c63b965a3663932e6fa87537e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1463f13c63b965a3663932e6fa87537e">&#9670;&nbsp;</a></span>get_is_circular()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::get_is_circular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up whether a path is circular. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a9391c34d9f0c16b21d5bb3bb7ec772e4">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a53e796617804bffe0203e422f2a23148"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e796617804bffe0203e422f2a23148">&#9670;&nbsp;</a></span>get_is_reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::get_is_reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the orientation of a handle. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a92773f90eb58f18adb9418a4440223c1">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="aff75e522e40559f5a5257a5cef776cdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff75e522e40559f5a5257a5cef776cdc">&#9670;&nbsp;</a></span>get_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::get_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of a node. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a569ff35fb85c725b0b6b6933ed303e49">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a144fb8b69eb2274b8dcea914898919f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a144fb8b69eb2274b8dcea914898919f0">&#9670;&nbsp;</a></span>get_next_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::VG::get_next_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a handle to the next step on the path. If the given step is the final step of a non-circular path, returns the past-the-last step that is also returned by path_end. In a circular path, the "last" step will loop around to the "first" (i.e. the one returned by path_begin). Note: to iterate over each step one time, even in a circular path, consider for_each_step_in_path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a209786f5c9e2c0210b383f2022ee221f">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a95223ec6984efc003e5cac69acd43445"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95223ec6984efc003e5cac69acd43445">&#9670;&nbsp;</a></span>get_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::get_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find a particular node. </p>

</div>
</div>
<a id="aa264e9386b98b57c3549a56870d8e29e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa264e9386b98b57c3549a56870d8e29e">&#9670;&nbsp;</a></span>get_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::get_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a07462d3f895e77cb407695e6c8e85727"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07462d3f895e77cb407695e6c8e85727">&#9670;&nbsp;</a></span>get_node_at_nucleotide()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> vg::VG::get_node_at_nucleotide </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>pathname</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>nuc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes in a pathname and the nucleotide position (like from a vcf) and returns the node id which contains that position. </p>

</div>
</div>
<a id="a495649c1646b865d6c88b8dc126589b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a495649c1646b865d6c88b8dc126589b0">&#9670;&nbsp;</a></span>get_node_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::get_node_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of nodes in the graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a9f95108e6c3f68f404fa93bd3306e4c6">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a52fa15aebd7d190eb743311f31037e55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52fa15aebd7d190eb743311f31037e55">&#9670;&nbsp;</a></span>get_node_nid_to_variant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, vcflib::Variant &gt; vg::VG::get_node_nid_to_variant </td>
          <td>(</td>
          <td class="paramtype">vcflib::VariantCallFile&#160;</td>
          <td class="paramname"><em>vfile</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes in a VCF file and returns a map [node] = vcflib::variant. Unfortunately this is specific to a given graph and VCF.</p>
<p>It will need to throw warnings if the node or variant is not in the graph.</p>
<p>This is useful for VCF masking: </p><pre class="fragment">if map.find(node) then mask variant
</pre><p>It's also useful for calling known variants </p><pre class="fragment">for m in alignment.mappings:
   node = m.Pos.nodeID
   if node in node_to_vcf:
       return (alignment supports variant)
</pre><p>It would be nice if this also supported edges (e.g. for inversions/transversions/breakpoints?). </p>

</div>
</div>
<a id="a7b20ecaa6a8a3155b5abb90a3139f6de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b20ecaa6a8a3155b5abb90a3139f6de">&#9670;&nbsp;</a></span>get_path_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::get_path_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of paths stored in the graph. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#acd5df753593ecdfb7aa8c411b98ebad9">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a26f160750dfed33c16a257bd5cbecddf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f160750dfed33c16a257bd5cbecddf">&#9670;&nbsp;</a></span>get_path_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; vg::VG::get_path_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all of the edges that are on any path. </p>

</div>
</div>
<a id="a6261550a7c6bbe7eb6ee0976639bc1d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6261550a7c6bbe7eb6ee0976639bc1d7">&#9670;&nbsp;</a></span>get_path_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> vg::VG::get_path_handle </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the path handle for the given path name. </p>

</div>
</div>
<a id="aae55721d38d4db3068ca93b4aac8e962"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae55721d38d4db3068ca93b4aac8e962">&#9670;&nbsp;</a></span>get_path_handle_of_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> vg::VG::get_path_handle_of_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a handle to the path that an step is on. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a1d1ca9865da585257709f54769f5d6a9">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a8ad62c3977b6f38f0b570ea78251dc6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ad62c3977b6f38f0b570ea78251dc6d">&#9670;&nbsp;</a></span>get_path_name()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::VG::get_path_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the name of a path from a handle to it. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a565f4312a42dfe77ae14c1ee9ed9f2ba">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a95d4b19a83f11ac6244855f86555fe76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d4b19a83f11ac6244855f86555fe76">&#9670;&nbsp;</a></span>get_previous_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::VG::get_previous_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a handle to the previous step on the path. If the given step is the first step of a non-circular path, this method has undefined behavior. In a circular path, it will loop around from the "first" step (i.e. the one returned by path_begin) to the "last" step. Note: to iterate over each step one time, even in a circular path, consider for_each_step_in_path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a71040226b29aa5046f4cc04c8c9aa9fb">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a353df9b2449ac859804359632283078b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a353df9b2449ac859804359632283078b">&#9670;&nbsp;</a></span>get_sequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::VG::get_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the sequence of a node, presented in the handle's local forward orientation. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a8cc2ab8a1292e30ba5e167a823f66d92">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a3efe30807d096a6175373bc3f4863dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3efe30807d096a6175373bc3f4863dd7">&#9670;&nbsp;</a></span>get_step_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::get_step_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of node steps in the path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#add91075c3490f8dc5acf667f2b26832c">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a45075c22efc7cfb1ed06a8996fec119c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45075c22efc7cfb1ed06a8996fec119c">&#9670;&nbsp;</a></span>get_subsequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::VG::get_subsequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a substring of a handle's sequence, in the orientation of the handle. If the indicated substring would extend beyond the end of the handle's sequence, the return value is truncated to the sequence's end. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#a74c6fcda357516b1160996c63ed40d63">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="ab2c85fad61f57260c913bc565a549832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2c85fad61f57260c913bc565a549832">&#9670;&nbsp;</a></span>has_edge() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edge.html">Edge</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an edge. This can take sides in any order. </p>

</div>
</div>
<a id="a501886a0c593ac3231cfcc6989911ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a501886a0c593ac3231cfcc6989911ced">&#9670;&nbsp;</a></span>has_edge() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Efficiently check for the existence of an edge using <a class="el" href="classvg_1_1VG.html">VG</a> graph's internal index of node sides. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1HandleGraph.html#a069448fbe58665b9ff531ad0b8c5af57">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a447d717e83131c526d26e6d2f0a091a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a447d717e83131c526d26e6d2f0a091a6">&#9670;&nbsp;</a></span>has_edge() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the edge between the given node sides, which can be in either order. </p>

</div>
</div>
<a id="a1c7ff3b6f9cfca2c21e1a8d1c848fc01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7ff3b6f9cfca2c21e1a8d1c848fc01">&#9670;&nbsp;</a></span>has_edge() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_edge </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sides</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an edge. This can take sides in any order. </p>

</div>
</div>
<a id="aa69701fcb4bf9e8b593681ba1d818571"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69701fcb4bf9e8b593681ba1d818571">&#9670;&nbsp;</a></span>has_edge() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an edge. This can take sides in any order. </p>

</div>
</div>
<a id="a49fb4de3494407b800c3efda254851cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49fb4de3494407b800c3efda254851cf">&#9670;&nbsp;</a></span>has_inverting_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_inverting_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an inverting edge on the given node. </p>

</div>
</div>
<a id="a7b7bbf066c6608211e7527ba50b23e48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b7bbf066c6608211e7527ba50b23e48">&#9670;&nbsp;</a></span>has_inverting_edge_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_inverting_edge_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an inverting edge from the given node. </p>

</div>
</div>
<a id="a63088ee0039a8e1f5cf6b5a3b23f745a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63088ee0039a8e1f5cf6b5a3b23f745a">&#9670;&nbsp;</a></span>has_inverting_edge_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_inverting_edge_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has an inverting edge to the given node. </p>

</div>
</div>
<a id="a8d1dbb49df52e016746829776ca0f952"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d1dbb49df52e016746829776ca0f952">&#9670;&nbsp;</a></span>has_inverting_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_inverting_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph has inversions. </p>

</div>
</div>
<a id="add23d09d2925d505f793979f7fe35921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add23d09d2925d505f793979f7fe35921">&#9670;&nbsp;</a></span>has_next_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_next_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the step is not the last step in a non-circular path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a81bf54cb4d07a0d47c84862ecebc349d">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="ab000649761c7201555284390dd8a4fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab000649761c7201555284390dd8a4fa0">&#9670;&nbsp;</a></span>has_node() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph contains the given node. </p>

</div>
</div>
<a id="a049bd863e2ac7e93aec79404d56b4a34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a049bd863e2ac7e93aec79404d56b4a34">&#9670;&nbsp;</a></span>has_node() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph contains the given node. </p>

</div>
</div>
<a id="ac9339913ecff654569a9c81ae091ebfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9339913ecff654569a9c81ae091ebfe">&#9670;&nbsp;</a></span>has_node() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if the graph has a node with the given ID. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a6e58a79001cd7d839ac1f1adaff34dfb">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a0328316df2438f0006349c71206810e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0328316df2438f0006349c71206810e6">&#9670;&nbsp;</a></span>has_path()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_path </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Determine if a path name exists and is legal to get a path handle for. </p>

</div>
</div>
<a id="ac5f9ec61fe7a32e3756e4b7fc77939ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f9ec61fe7a32e3756e4b7fc77939ba">&#9670;&nbsp;</a></span>has_previous_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::has_previous_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>step_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the step is not the first step in a non-circular path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a93a1ee451e750cb82f1711fd6c3db8cc">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a2b75ca400f858be77b0716ab7c68dfcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b75ca400f858be77b0716ab7c68dfcb">&#9670;&nbsp;</a></span>hash()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string vg::VG::hash </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generate a digest of the serialized graph. </p>

</div>
</div>
<a id="a7eecc0bd555c31d1c541c3ce44b421c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eecc0bd555c31d1c541c3ce44b421c3">&#9670;&nbsp;</a></span>head_nodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::head_nodes </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the head nodes (nodes with edges only to their right sides). These are required to be oriented forward. </p>

</div>
</div>
<a id="a3a44c415fb5882c184e2f35bb3999700"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a44c415fb5882c184e2f35bb3999700">&#9670;&nbsp;</a></span>head_nodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; vg::VG::head_nodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the head nodes (nodes with edges only to their right sides). These are required to be oriented forward. </p>

</div>
</div>
<a id="ab1aecdffe7759a1e14248e00f2866b84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1aecdffe7759a1e14248e00f2866b84">&#9670;&nbsp;</a></span>id_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::id_sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Order the backing graph data structure by node ID. </p>

</div>
</div>
<a id="ab015755dc8b427f4e226f920eb26c428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab015755dc8b427f4e226f920eb26c428">&#9670;&nbsp;</a></span>identity_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::identity_translation </td>
          <td>(</td>
          <td class="paramtype">unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Record the translation of this graph into itself in the provided map. </p>

</div>
</div>
<a id="a66e4dac76edcf0218f9749352c19acae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e4dac76edcf0218f9749352c19acae">&#9670;&nbsp;</a></span>include()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::include </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Edit the graph to include the path. </p>

</div>
</div>
<a id="a86b3ecdf29d100a8d43f6aaccd6f2e0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86b3ecdf29d100a8d43f6aaccd6f2e0e">&#9670;&nbsp;</a></span>increment_node_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::increment_node_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>increment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the given value to all node IDs. Preserves the paths. </p>

<p>Reimplemented from <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a902b211a1f86645818b3da1cb64af0be">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="a53ff7033966852f5fb3852716cab21a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53ff7033966852f5fb3852716cab21a9">&#9670;&nbsp;</a></span>index_edge_by_node_sides()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::index_edge_by_node_sides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an edge to the node side indexes. Doesn't touch the index of edges by node pairs or the graph; those must be updated seperately. </p>

</div>
</div>
<a id="aafd0f191fe33bd4590f15f309d0fd89c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafd0f191fe33bd4590f15f309d0fd89c">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::init </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>setup, ensures that gssw == NULL on startup </p>

</div>
</div>
<a id="a7903acd7a977a85fdd78d306f2063252"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7903acd7a977a85fdd78d306f2063252">&#9670;&nbsp;</a></span>is_ancestor_next() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_ancestor_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>candidate_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the node is a next ancestor of this one. </p>

</div>
</div>
<a id="ab919097a72a96dada04310b2aaf019f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab919097a72a96dada04310b2aaf019f8">&#9670;&nbsp;</a></span>is_ancestor_next() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_ancestor_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>candidate_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>steps</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the node is a next ancestor of this one by trying to find it in a given number of steps. </p>

</div>
</div>
<a id="a25215a67c3eac7570e2ab62e825ae169"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25215a67c3eac7570e2ab62e825ae169">&#9670;&nbsp;</a></span>is_ancestor_prev() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_ancestor_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>candidate_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the node is a prev ancestor of this one. </p>

</div>
</div>
<a id="ae6699fe9d747f761f6efae39c3c0501c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6699fe9d747f761f6efae39c3c0501c">&#9670;&nbsp;</a></span>is_ancestor_prev() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_ancestor_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>candidate_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>steps</em> = <code>64</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the node is a prev ancestor of this one by trying to find it in a given number of steps. </p>

</div>
</div>
<a id="a80438f4ab98e10b68caab27fdece09ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80438f4ab98e10b68caab27fdece09ab">&#9670;&nbsp;</a></span>is_head_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_head_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a node is a head node. </p>

</div>
</div>
<a id="a1bc3866468d5eb941fa6ba010ccce2ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bc3866468d5eb941fa6ba010ccce2ec">&#9670;&nbsp;</a></span>is_head_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_head_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a node is a head node. </p>

</div>
</div>
<a id="ad09549b6cfab8e1097dd207e01e57812"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad09549b6cfab8e1097dd207e01e57812">&#9670;&nbsp;</a></span>is_self_looping()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_self_looping </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Does the specified node have any self-loops? </p>

</div>
</div>
<a id="a660692b8769618259f69be25bfed0bc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a660692b8769618259f69be25bfed0bc3">&#9670;&nbsp;</a></span>is_tail_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_tail_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a node is a tail node. </p>

</div>
</div>
<a id="af58b227f21324d30be531088ed49b0f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af58b227f21324d30be531088ed49b0f1">&#9670;&nbsp;</a></span>is_tail_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_tail_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if a node is a tail node. </p>

</div>
</div>
<a id="aa77d93fdf76698460ce509ea5dcde954"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa77d93fdf76698460ce509ea5dcde954">&#9670;&nbsp;</a></span>is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::is_valid </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_nodes</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_edges</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_paths</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check_orphans</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine if the graph is valid or not, according to the specified criteria. </p>

</div>
</div>
<a id="adc40377520118436b729cd68be16d0ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc40377520118436b729cd68be16d0ba">&#9670;&nbsp;</a></span>join_heads() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::join_heads </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_start</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join head nodes of graph to specified node. Optionally from the start/to the end of the new node. </p>

</div>
</div>
<a id="a817384b8d147371448ad60e1db097b52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a817384b8d147371448ad60e1db097b52">&#9670;&nbsp;</a></span>join_heads() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a> * vg::VG::join_heads </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join head nodes of graph to common null node, creating a new single head. </p>

</div>
</div>
<a id="a33e3f7942afd3ca82bfb78083c245146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e3f7942afd3ca82bfb78083c245146">&#9670;&nbsp;</a></span>join_tails()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::join_tails </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_end</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Join tail nodes of graph to specified node. Optionally from the start/to the end of the new node. </p>

</div>
</div>
<a id="a65cc16f52f478a25e84c6f1fc2805915"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65cc16f52f478a25e84c6f1fc2805915">&#9670;&nbsp;</a></span>keep_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::keep_path </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac2aa9d438bcec4d7facbfcc44abea8fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2aa9d438bcec4d7facbfcc44abea8fd">&#9670;&nbsp;</a></span>keep_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::keep_paths </td>
          <td>(</td>
          <td class="paramtype">const set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>kept_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Keep paths in the given set of path names. Populates kept_names with the names of the paths it actually found to keep. The paths specified may not overlap. Removes all nodes and edges not used by one of the specified paths. </p>

</div>
</div>
<a id="af9ac6e61dfa9350459dbb9586088c4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ac6e61dfa9350459dbb9586088c4a5">&#9670;&nbsp;</a></span>left_degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::left_degree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of edges attached to the left side of a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>. </p>

</div>
</div>
<a id="a23641dedefa2b6d573939515fcf5974c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23641dedefa2b6d573939515fcf5974c">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::length </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Total sequence length. </p>

</div>
</div>
<a id="ada5821862279a350885f5368a54a5cba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada5821862279a350885f5368a54a5cba">&#9670;&nbsp;</a></span>likelihoods()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::likelihoods </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; long double &gt; &amp;&#160;</td>
          <td class="paramname"><em>likelihoods</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd555e66c8fa99984c8cb24aef0ab6f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd555e66c8fa99984c8cb24aef0ab6f9">&#9670;&nbsp;</a></span>mapping_is_total_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::mapping_is_total_match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if the mapping completely covers the node it maps to and is a perfect match. </p>

</div>
</div>
<a id="a5a03ad90e03794944c5e0d4d61780652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a03ad90e03794944c5e0d4d61780652">&#9670;&nbsp;</a></span>max_node_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> vg::VG::max_node_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the maximum node ID used in the graph, if any are used. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a5a2e2b1ea6a29b3f4b34a6abcb6dbc50">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="a0abc84684faea29b49032ec254d5e13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0abc84684faea29b49032ec254d5e13b">&#9670;&nbsp;</a></span>merge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Literally merge protobufs. </p>

</div>
</div>
<a id="a40f22f6bb4a3e7a2aea7b3887237faec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40f22f6bb4a3e7a2aea7b3887237faec">&#9670;&nbsp;</a></span>merge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Literally merge protobufs. </p>

</div>
</div>
<a id="a2e506d51db427b617cc334a791c7f594"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e506d51db427b617cc334a791c7f594">&#9670;&nbsp;</a></span>merge_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Node.html">Node</a>* vg::VG::merge_nodes </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Use the orientation of the first node as the basis. </p>

</div>
</div>
<a id="a5aff716eee0bf720b3836caa761d48be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aff716eee0bf720b3836caa761d48be">&#9670;&nbsp;</a></span>merge_union()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::merge_union </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge protobufs after removing overlaps. Good when there aren't many overlaps. </p>

</div>
</div>
<a id="ac27674d67445ddc135c3c8ab4d3d5231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27674d67445ddc135c3c8ab4d3d5231">&#9670;&nbsp;</a></span>min_node_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> vg::VG::min_node_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the minimum node ID used in the graph, if any are used. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1HandleGraph.html#a85c52fe4b5f483504ed142d0ad94a969">handlegraph::HandleGraph</a>.</p>

</div>
</div>
<a id="abb3e9e655bcaad0bc522307743acd6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb3e9e655bcaad0bc522307743acd6a0">&#9670;&nbsp;</a></span>node_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::node_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the number of nodes in the graph. </p>

</div>
</div>
<a id="a4c614759c77b4b0a95b25360c2fa1fa0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c614759c77b4b0a95b25360c2fa1fa0">&#9670;&nbsp;</a></span>node_count_next()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::node_count_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the nodes attached to the right side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>. </p>

</div>
</div>
<a id="a1091113608fae5b9cbafc87cf4cf82a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1091113608fae5b9cbafc87cf4cf82a2">&#9670;&nbsp;</a></span>node_count_prev()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::node_count_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Count the nodes attached to the left side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>. </p>

</div>
</div>
<a id="ad7ac4861a64a07f344c21cf2f41b91f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ac4861a64a07f344c21cf2f41b91f1">&#9670;&nbsp;</a></span>node_rank() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::node_rank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the rank of the node in the protobuf array that backs the graph. </p>

</div>
</div>
<a id="a0202180fa7153f464c3b1d3ff70dc9cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0202180fa7153f464c3b1d3ff70dc9cb">&#9670;&nbsp;</a></span>node_rank() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::node_rank </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the rank of the node in the protobuf array that backs the graph. </p>

</div>
</div>
<a id="a093f4e4dffe0d03806df32edc33cdb9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a093f4e4dffe0d03806df32edc33cdb9a">&#9670;&nbsp;</a></span>node_starts_in_path() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::node_starts_in_path </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; <a class="el" href="structvg_1_1Node.html">Node</a> *, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill in the node_start map with the first index along the path at which each node appears. Caller is responsible for dealing with orientations. </p>

</div>
</div>
<a id="ac27c591957478a17605c2453749f7d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac27c591957478a17605c2453749f7d20">&#9670;&nbsp;</a></span>node_starts_in_path() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::node_starts_in_path </td>
          <td>(</td>
          <td class="paramtype">list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> *, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find node starts in a path. TODO: what does that mean? To get the starts out of the map this produces, you need to dereference the iterator and then get the address of the <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> (stored in the list) that you are talking about. </p>

</div>
</div>
<a id="a62f1bb7fa27d4d4312017b113aab099a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62f1bb7fa27d4d4312017b113aab099a">&#9670;&nbsp;</a></span>nodes_next() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::nodes_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nodes attached to the right side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations. </p>

</div>
</div>
<a id="a0b084d958fd8069839884dc3a01ed745"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b084d958fd8069839884dc3a01ed745">&#9670;&nbsp;</a></span>nodes_next() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::nodes_next </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nodes attached to the right side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations. </p>

</div>
</div>
<a id="a0f3e69ced0c3135f3f363c14bf752aad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f3e69ced0c3135f3f363c14bf752aad">&#9670;&nbsp;</a></span>nodes_prev() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::nodes_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nodes attached to the left side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations. </p>

</div>
</div>
<a id="ac08e778396904ad3b3f20f605f54628d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac08e778396904ad3b3f20f605f54628d">&#9670;&nbsp;</a></span>nodes_prev() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::nodes_prev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the nodes attached to the left side of the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>, in their proper orientations. </p>

</div>
</div>
<a id="a44edad9ba2a6df332234b43715dd71db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44edad9ba2a6df332234b43715dd71db">&#9670;&nbsp;</a></span>nonoverlapping_node_context_without_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::nonoverlapping_node_context_without_paths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the subgraph of a node and all the edges it is responsible for (where it has the minimal ID) and add it into the given <a class="el" href="classvg_1_1VG.html">VG</a>. </p>

</div>
</div>
<a id="a46f1fe88897cfe4d62625cffd3db5ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46f1fe88897cfe4d62625cffd3db5ebb">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> &amp; vg::VG::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>

</div>
</div>
<a id="a3b3efbadb9fd3923bbc7e8f0b73c524f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b3efbadb9fd3923bbc7e8f0b73c524f">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> &amp; vg::VG::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>

</div>
</div>
<a id="a0b4fa1970f08f3e4d0cf2f8c33a967a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4fa1970f08f3e4d0cf2f8c33a967a5">&#9670;&nbsp;</a></span>optimize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::optimize </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_id_reassignment</em> = <code>true</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Adjust the representation of the graph in memory to improve performance. Optionally, allow the node IDs to be reassigned to further improve performance. Note: Ideally, this method is called one time once there is expected to be few graph modifications in the future. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a195c81fa446b62d94fda8841eaa3bb85">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="ae9b314bb2021525e60a0ad23e99fb994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9b314bb2021525e60a0ad23e99fb994">&#9670;&nbsp;</a></span>overlay_node_translations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt; vg::VG::overlay_node_translations </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>over</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>under</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assume two node translations, the over is based on the under; merge them. </p>

</div>
</div>
<a id="a1af5ef2df0289b964cab09d9400344c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1af5ef2df0289b964cab09d9400344c5">&#9670;&nbsp;</a></span>path_back()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::VG::path_back </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to the last step, which will be an arbitrary step in a circular path that we consider "last" based on our construction of the path. If the path is empty then the implementation must return the same value as <a class="el" href="classvg_1_1VG.html#a5e1a4d7c14f1aaf601e9a6e231b6b7d3">path_front_end()</a>. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a31bb33a87ad8efd68876fc5ae1deeb09">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="af0fc3a05ce45e0100fb82812c5b1e35d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0fc3a05ce45e0100fb82812c5b1e35d">&#9670;&nbsp;</a></span>path_begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::VG::path_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to the first step, or in a circular path to an arbitrary step considered "first". If the path is empty, returns the past-the-last step returned by path_end. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a815759484087ed92214c2c1c6b9d1a11">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a5f1df72d85d8a72524b76abca972f33d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f1df72d85d8a72524b76abca972f33d">&#9670;&nbsp;</a></span>path_edge_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::path_edge_count </td>
          <td>(</td>
          <td class="paramtype">list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>path_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structvg_1_1Path.html">Path</a> stats. Starting from offset in the first node, how many edges do we cross? path must be nonempty and longer than the given length. offset is interpreted as relative to the first node in its on-path orientation, and is inclusive. </p>

</div>
</div>
<a id="a2f532a7aeb7765b99c6c4e43ba961fdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f532a7aeb7765b99c6c4e43ba961fdb">&#9670;&nbsp;</a></span>path_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::VG::path_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to a fictitious position past the end of a path. This position is return by get_next_step for the final step in a path in a non-circular path. Note that get_next_step will <em>NEVER</em> return this value for a circular path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#a5c3a5e04838d9e4a0a0ddf574c4de827">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="a8f45b42614f4ac36c8060634ec0d9805"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f45b42614f4ac36c8060634ec0d9805">&#9670;&nbsp;</a></span>path_end_node_offset()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::path_end_node_offset </td>
          <td>(</td>
          <td class="paramtype">list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>path_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine the offset in its last node at which the path starting at this offset in its first node ends. path must be nonempty and longer than the given length. offset is interpreted as relative to the first node in its on-path orientation, and is inclusive. Returned offset is remaining unused length in the last node touched. </p>

</div>
</div>
<a id="a5e1a4d7c14f1aaf601e9a6e231b6b7d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1a4d7c14f1aaf601e9a6e231b6b7d3">&#9670;&nbsp;</a></span>path_front_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::VG::path_front_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get a handle to a fictitious position before the beginning of a path. This position is return by get_previous_step for the first step in a path in a non-circular path. Note: get_previous_step will <em>NEVER</em> return this value for a circular path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1PathHandleGraph.html#ad7412bf19084f2b38ffec42517a6a9e9">handlegraph::PathHandleGraph</a>.</p>

</div>
</div>
<a id="ad9bd4133841d1d781fb0df4171773139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9bd4133841d1d781fb0df4171773139">&#9670;&nbsp;</a></span>path_identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::VG::path_identity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return percent identity between two paths (# matches / (#matches + #mismatches)). Note: uses ssw aligner, so will only work on small paths. </p>

</div>
</div>
<a id="a4ce6fe02b243b4f0f82bbf801fd507fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ce6fe02b243b4f0f82bbf801fd507fa">&#9670;&nbsp;</a></span>path_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string vg::VG::path_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return sequence string of path. </p>

</div>
</div>
<a id="a871d05e0a2d0b76092e20fe86bd12e2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871d05e0a2d0b76092e20fe86bd12e2b">&#9670;&nbsp;</a></span>paths_as_alignments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::VG::paths_as_alignments </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the stored paths in this graph to alignments. </p>

</div>
</div>
<a id="a0a5a5cb1bac139c5a3a947a0d5a3313d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a5a5cb1bac139c5a3a947a0d5a3313d">&#9670;&nbsp;</a></span>paths_between() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::paths_between </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8dc8d762d07088089247b632c835a19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dc8d762d07088089247b632c835a19d">&#9670;&nbsp;</a></span>paths_between() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::paths_between </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43c2858dc8e80ba160359ccf5e1508d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c2858dc8e80ba160359ccf5e1508d2">&#9670;&nbsp;</a></span>prepend_step()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> vg::VG::prepend_step </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to_prepend</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a visit to a node to the given path. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#aed17038a0104017d37ff74e15f7f436a">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a id="a2b659686076f3d6b7b63ec9678d76a93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b659686076f3d6b7b63ec9678d76a93">&#9670;&nbsp;</a></span>print_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::print_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8452af466a3e1ad4b0b463ea0d5da933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8452af466a3e1ad4b0b463ea0d5da933">&#9670;&nbsp;</a></span>random_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::VG::random_read </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>read_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mt19937 &amp;&#160;</td>
          <td class="paramname"><em>rng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>min_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>max_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>either_strand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Generate random reads. Note that even if either_strand is false, having backward nodes in the graph will result in some reads from the global reverse strand. </p>

</div>
</div>
<a id="aca4a358ff4c7f387c1c6d5d239499a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4a358ff4c7f387c1c6d5d239499a07">&#9670;&nbsp;</a></span>reassign_node_ids()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::reassign_node_ids </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>(const <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>get_new_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reassign all node IDs as specified by the old-&gt;new mapping function. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#a4805d276a83a1dad2462e6b8dd2443dc">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="a6541146b6410cec4be3e2a7379ea3bcf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6541146b6410cec4be3e2a7379ea3bcf">&#9670;&nbsp;</a></span>rebuild_edge_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::rebuild_edge_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63d4e45a9a410c451b1cad44ef7068ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63d4e45a9a410c451b1cad44ef7068ad">&#9670;&nbsp;</a></span>rebuild_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::rebuild_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33424c3be8c3e088631dfb37c48773d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33424c3be8c3e088631dfb37c48773d3">&#9670;&nbsp;</a></span>remove_duplicated_in()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_duplicated_in </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Helper to merge_union. </p>

</div>
</div>
<a id="aba9fb73c326ecfab70e35e44dff6a937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba9fb73c326ecfab70e35e44dff6a937">&#9670;&nbsp;</a></span>remove_duplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_duplicates </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove duplicated nodes and edges. </p>

</div>
</div>
<a id="a76005ed499eea217c9f778028751137c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76005ed499eea217c9f778028751137c">&#9670;&nbsp;</a></span>remove_inverting_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_inverting_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove edges representing an inversion and edges on the reverse complement. </p>

</div>
</div>
<a id="ab92694e7fd89275603c967739e60e0d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92694e7fd89275603c967739e60e0d2">&#9670;&nbsp;</a></span>remove_node_forwarding_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_node_forwarding_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove a node but connect all of its predecessor and successor nodes with new edges. </p>

</div>
</div>
<a id="ad517da731d2bf9c81cc28e0a1367af33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad517da731d2bf9c81cc28e0a1367af33">&#9670;&nbsp;</a></span>remove_non_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_non_path </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove pieces of the graph which are not part of any path. </p>

</div>
</div>
<a id="a9b107027697644d771eb529037201f71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b107027697644d771eb529037201f71">&#9670;&nbsp;</a></span>remove_null_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_null_nodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove nodes with no sequence. These are created in some cases during the process of graph construction. </p>

</div>
</div>
<a id="a0e887a7b2cfc666f2210889a2dec791b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e887a7b2cfc666f2210889a2dec791b">&#9670;&nbsp;</a></span>remove_null_nodes_forwarding_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_null_nodes_forwarding_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove null nodes but connect predecessors and successors, preserving structure. </p>

</div>
</div>
<a id="a40dd9bc0458a4948afd676374ae8d1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40dd9bc0458a4948afd676374ae8d1f0">&#9670;&nbsp;</a></span>remove_orphan_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_orphan_edges </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove edges for which one of the nodes is not present. </p>

</div>
</div>
<a id="a30c369b4c1b0dfa4e9fbc0d3bce82648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30c369b4c1b0dfa4e9fbc0d3bce82648">&#9670;&nbsp;</a></span>remove_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::remove_path </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove pieces of the graph which are part of some path. </p>

</div>
</div>
<a id="af8879b1e6aab38b9a246deba0f05ccfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8879b1e6aab38b9a246deba0f05ccfe">&#9670;&nbsp;</a></span>resize_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::resize_indexes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82185028afbc17aaf60b294297507fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82185028afbc17aaf60b294297507fd2">&#9670;&nbsp;</a></span>reverse_complement_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> vg::VG::reverse_complement_graph </td>
          <td>(</td>
          <td class="paramtype">unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create the reverse complemented graph with topology preserved. Record translation in provided map. </p>

</div>
</div>
<a id="abb2dc75f200cfb7480e671fd55207410"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb2dc75f200cfb7480e671fd55207410">&#9670;&nbsp;</a></span>rewrite_segment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; vg::VG::rewrite_segment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>segment_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>segment_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>new_segment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Delete a segment of a path and rewrite it as some other sequence of steps. Returns a pair of step_handle_t's that indicate the range of the new segment in the path. </p>

</div>
</div>
<a id="a23622195177dff4c7c8416edffb7fc93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23622195177dff4c7c8416edffb7fc93">&#9670;&nbsp;</a></span>right_degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::right_degree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of edges attached to the right side of a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>. </p>

</div>
</div>
<a id="a96f99984ada5a3a13332ddb2ab0a1c97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96f99984ada5a3a13332ddb2ab0a1c97">&#9670;&nbsp;</a></span>same_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::same_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Use sides_from an sides_to to determine if both nodes have the same context. </p>

</div>
</div>
<a id="a0ee4603518e9cd5915a65e65c2d763b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ee4603518e9cd5915a65e65c2d763b2">&#9670;&nbsp;</a></span>serialize()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::serialize </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the contents of this graph to an ostream. </p>

</div>
</div>
<a id="a59121c0226c3fd8c328641490bf2fac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59121c0226c3fd8c328641490bf2fac6">&#9670;&nbsp;</a></span>serialize_to_emitter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::serialize_to_emitter </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; <a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>emitter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write chunked graphs to a ProtobufEmitter that will write them to a stream. Use when combining multiple <a class="el" href="classvg_1_1VG.html">VG</a> objects in a stream. <a class="el" href="structvg_1_1Graph.html">Graph</a> will be serialized in internal storage order. </p>

</div>
</div>
<a id="a3522042a3a00ac802d6738d0bec6269c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3522042a3a00ac802d6738d0bec6269c">&#9670;&nbsp;</a></span>serialize_to_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::serialize_to_file </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the graph to a file, with an EOF marker. <a class="el" href="structvg_1_1Graph.html">Graph</a> will be serialized in internal storage order. </p>

</div>
</div>
<a id="ad3187dd6ce750583f6b1a7c32f278d2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3187dd6ce750583f6b1a7c32f278d2a">&#9670;&nbsp;</a></span>serialize_to_function()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::serialize_to_function </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>emit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Send chunked graphs to a function that will write them somewhere. Used to internally implement saving to many destinations. <a class="el" href="structvg_1_1Graph.html">Graph</a> will be serialized in internal storage order. This is NOT const because it synchronizes path ranks before saving! We allow the emitted <a class="el" href="structvg_1_1Graph.html">Graph</a> to move. </p>

</div>
</div>
<a id="a70e67b525bca0f766d7f0170759ed1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e67b525bca0f766d7f0170759ed1d0">&#9670;&nbsp;</a></span>serialize_to_ostream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::serialize_to_ostream </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>chunk_size</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write to a stream in chunked graphs. Adds an EOF marker. Use when this <a class="el" href="classvg_1_1VG.html">VG</a> will be the only thing in the stream. <a class="el" href="structvg_1_1Graph.html">Graph</a> will be serialized in internal storage order. </p>

</div>
</div>
<a id="a73c97ce0157b90f95b888e4b6983f5c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73c97ce0157b90f95b888e4b6983f5c8">&#9670;&nbsp;</a></span>set_circularity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::set_circularity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>circular</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Make a path circular or non-circular. If the path is becoming circular, the last step is joined to the first step. If the path is becoming linear, the step considered "last" is unjoined from the step considered "first" according to the method path_begin. </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html#a9172694447503e35d50093d55e845eb8">handlegraph::MutablePathHandleGraph</a>.</p>

</div>
</div>
<a id="ae1131c1ff0a94ed2ec9ef35cb678801b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1131c1ff0a94ed2ec9ef35cb678801b">&#9670;&nbsp;</a></span>set_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::set_edge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the edge indexes through this function. Picks up the sides being connected by the edge automatically, and silently drops the edge if they are already connected. </p>

</div>
</div>
<a id="aebe71b82645b85e73342366cea0a4549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebe71b82645b85e73342366cea0a4549">&#9670;&nbsp;</a></span>set_id_increment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::set_id_increment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>min_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>No-op function (required by MutableHandleGraph interface) </p>

<p>Implements <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html#ab844ab426cd9f289414aca4d8b892ca9">handlegraph::MutableHandleGraph</a>.</p>

</div>
</div>
<a id="ad363c6c82e88dcb1b88d05ff55074ed6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad363c6c82e88dcb1b88d05ff55074ed6">&#9670;&nbsp;</a></span>sides_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, bool &gt; &gt; vg::VG::sides_context </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all sides connecting to this node. </p>

</div>
</div>
<a id="a95c975ed419a0873c894cef7a2f2d3ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95c975ed419a0873c894cef7a2f2d3ba">&#9670;&nbsp;</a></span>sides_from() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; vg::VG::sides_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sides from both sides of the node. </p>

</div>
</div>
<a id="ac670f3c729f93ebaa7c8bd5063225597"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac670f3c729f93ebaa7c8bd5063225597">&#9670;&nbsp;</a></span>sides_from() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; vg::VG::sides_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td>
          <td class="paramname"><em>side</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sides on the other side of edges from this side of the node. </p>

</div>
</div>
<a id="a030b75d2ad50905cc01fe4b7223cbb83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a030b75d2ad50905cc01fe4b7223cbb83">&#9670;&nbsp;</a></span>sides_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; vg::VG::sides_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td>
          <td class="paramname"><em>side</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Union of sides_to and sides_from. </p>

</div>
</div>
<a id="a68733706482bf7b2627be32438160af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68733706482bf7b2627be32438160af3">&#9670;&nbsp;</a></span>sides_to() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; vg::VG::sides_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sides to both sides of the node. </p>

</div>
</div>
<a id="a1a156ac1e1fde520bae82850105c6c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a156ac1e1fde520bae82850105c6c66">&#9670;&nbsp;</a></span>sides_to() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; vg::VG::sides_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td>
          <td class="paramname"><em>side</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sides on the other side of edges to this side of the node. </p>

</div>
</div>
<a id="a9e3720ce267c8167ce679a015063dab6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e3720ce267c8167ce679a015063dab6">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::VG::size </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of nodes. </p>

</div>
</div>
<a id="a902d516631c77d074aa2a11ae70a6957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a902d516631c77d074aa2a11ae70a6957">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::sort </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Topologically sort the graph, and then apply that sort to re- order the nodes in the backing data structure. The sort is guaranteed to be stable. This sort is well-defined on graphs that are not DAGs, but instead of finding a topological sort it does a heuristic sort to minimize a feedback arc set. </p>

</div>
</div>
<a id="a1ff00edd627e3445eee7f43927bb1518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff00edd627e3445eee7f43927bb1518">&#9670;&nbsp;</a></span>start_degree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::VG::start_degree </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of edges attached to the start of a node. </p>

</div>
</div>
<a id="a3d4db6ea2a99bda9a48411491aa6ed4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4db6ea2a99bda9a48411491aa6ed4e">&#9670;&nbsp;</a></span>swap_handles()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::swap_handles </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Swap the nodes corresponding to the given handles, in the ordering used by for_each_handle when looping over the graph. Other handles to the nodes being swapped must not be invalidated. </p>

</div>
</div>
<a id="afee31880eaf65a1a6d1a250663271b54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afee31880eaf65a1a6d1a250663271b54">&#9670;&nbsp;</a></span>swap_node_id() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::swap_node_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>new_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the ID of the node with the first id to the second, new ID not used by any node. Invalidates any paths containing the node, since they are not updated. </p>

</div>
</div>
<a id="a63f2ffa39d84f80e5ab8068a25a03ee9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63f2ffa39d84f80e5ab8068a25a03ee9">&#9670;&nbsp;</a></span>swap_node_id() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::swap_node_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>new_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Change the ID of the given node to the second, new ID not used by any node. Invalidates the paths. Invalidates any paths containing the node, since they are not updated. </p>

</div>
</div>
<a id="aa402d1cf817f83ca44f72f6112b6a2e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa402d1cf817f83ca44f72f6112b6a2e3">&#9670;&nbsp;</a></span>swap_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::swap_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Swap the given nodes. TODO: what does that mean? </p>

</div>
</div>
<a id="a124188a9e0cd68c87c2bc009ea7bd799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a124188a9e0cd68c87c2bc009ea7bd799">&#9670;&nbsp;</a></span>sync_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::sync_paths </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize in-memory indexes and protobuf graph. </p>

</div>
</div>
<a id="a47fbc525ed5e9f2a7b00c333f03fe6c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fbc525ed5e9f2a7b00c333f03fe6c8">&#9670;&nbsp;</a></span>tail_nodes() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::tail_nodes </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the tail nodes (nodes with edges only to their left sides). These are required to be oriented forward. </p>

</div>
</div>
<a id="a25bd74b77e139691555c8d48ecf67d9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25bd74b77e139691555c8d48ecf67d9f">&#9670;&nbsp;</a></span>tail_nodes() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Node.html">Node</a> * &gt; vg::VG::tail_nodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the tail nodes (nodes with edges only to their left sides). These are required to be oriented forward. </p>

</div>
</div>
<a id="af502bd29a58e62ff70f8f963d47401a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af502bd29a58e62ff70f8f963d47401a4">&#9670;&nbsp;</a></span>to_dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::to_dot </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td>
          <td class="paramname"><em>alignments</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Locus.html">Locus</a> &gt;&#160;</td>
          <td class="paramname"><em>loci</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>walk_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>annotate_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_mappings</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>simple_mode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>noseq_mode</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>invert_edge_ports</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>color_variants</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ultrabubble_labeling</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_missing_nodes</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ascii_labels</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>random_seed</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the graph to Dot format. </p>

</div>
</div>
<a id="a582500a3d49fe231faa49a5c2e467cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a582500a3d49fe231faa49a5c2e467cc8">&#9670;&nbsp;</a></span>to_turtle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::to_turtle </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>rdf_base_uri</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>precompress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the graph to Turtle format. </p>

</div>
</div>
<a id="a57296ecbcfce10f95b86233e10c35d7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57296ecbcfce10f95b86233e10c35d7d">&#9670;&nbsp;</a></span>trav_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::VG::trav_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>trav</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the sequence of a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>. </p>

</div>
</div>
<a id="a34a493a0628857a3bfae181295ba541d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34a493a0628857a3bfae181295ba541d">&#9670;&nbsp;</a></span>travs_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::travs_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get traversals after this node on the same strand. Same as nodes_next but using set. </p>

</div>
</div>
<a id="ae065082f817e9bc0e278cf71f31af1e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae065082f817e9bc0e278cf71f31af1e2">&#9670;&nbsp;</a></span>travs_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::travs_of </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get traversals either before or after this node on the same strand. </p>

</div>
</div>
<a id="a0a962957210c079fa242b383d5c65de3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a962957210c079fa242b383d5c65de3">&#9670;&nbsp;</a></span>travs_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; vg::VG::travs_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get traversals before this node on the same strand. Same as nodes_prev but using set. </p>

</div>
</div>
<a id="a6552b9da8cff82802ee24090064eb3a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6552b9da8cff82802ee24090064eb3a8">&#9670;&nbsp;</a></span>unfold()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> vg::VG::unfold </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>max_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Ensure that all traversals up to max_length are represented as a path on one strand or the other without taking an inverting edge. All inverting edges are converted to non-inverting edges to reverse complement nodes. If no inverting edges are present, the strandedness of all nodes is the same as the input graph. If inverting edges are present, node strandedness is arbitrary. </p>

</div>
</div>
<a id="a1c0b7db8d3043747e8b9a44cba4eaac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0b7db8d3043747e8b9a44cba4eaac9">&#9670;&nbsp;</a></span>unindex_edge_by_node_sides() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::unindex_edge_by_node_sides </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>side2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an edge from the node side indexes, so it doesn't show up when you ask for the edges connected to the side of a node. Makes the edge untraversable until the indexes are rebuilt. </p>

</div>
</div>
<a id="a5677da9ff22052f6c6a85bfe66e1256d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5677da9ff22052f6c6a85bfe66e1256d">&#9670;&nbsp;</a></span>unindex_edge_by_node_sides() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::unindex_edge_by_node_sides </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Edge.html">Edge</a> *&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove an edge from the node side indexes, so it doesn't show up when you ask for the edges connected to the side of a node. Makes the edge untraversable until the indexes are rebuilt. </p>

</div>
</div>
<a id="a2239c89d6ac7e9dec0d76325c2a68f97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2239c89d6ac7e9dec0d76325c2a68f97">&#9670;&nbsp;</a></span>wrap_with_null_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::VG::wrap_with_null_nodes </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add singular head and tail null nodes to graph. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a68f4b0cfbadab3cebace110733565d38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f4b0cfbadab3cebace110733565d38">&#9670;&nbsp;</a></span>current_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> vg::VG::current_id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Current id for <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a> to be added next. </p>

</div>
</div>
<a id="ab754d45647580a21216bd010b72c6815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab754d45647580a21216bd010b72c6815">&#9670;&nbsp;</a></span>edge_by_sides</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1pair__hash__map.html">pair_hash_map</a>&lt;pair&lt;<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&gt;, <a class="el" href="structvg_1_1Edge.html">Edge</a>*&gt; vg::VG::edge_by_sides</td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code><a class="el" href="structvg_1_1Edge.html">Edge</a></code>s by sides of <code><a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a></code>s they connect. Since duplicate edges are not permitted, two edges cannot connect the same pair of node sides. Each edge is indexed here with the smaller <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> first. The actual node order is recorded in the <a class="el" href="structvg_1_1Edge.html">Edge</a> object. </p>

</div>
</div>
<a id="a2e2c02a8216f0bb9b3a78e985845ea1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e2c02a8216f0bb9b3a78e985845ea1b">&#9670;&nbsp;</a></span>edge_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="structvg_1_1Edge.html">Edge</a>*, int&gt; vg::VG::edge_index</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a678bafc48a8e02155efc591991201122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a678bafc48a8e02155efc591991201122">&#9670;&nbsp;</a></span>edges_on_end</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, vector&lt;pair&lt;<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool&gt; &gt; &gt; vg::VG::edges_on_end</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the destinations and backward flags for edges attached to the ends of nodes (whether that node is "from" or "to"). </p>

</div>
</div>
<a id="a00590435d38e7ddf8a77b731d8a1a755"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00590435d38e7ddf8a77b731d8a1a755">&#9670;&nbsp;</a></span>edges_on_start</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, vector&lt;pair&lt;<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool&gt; &gt; &gt; vg::VG::edges_on_start</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stores the destinations and backward flags for edges attached to the starts of nodes (whether that node is "from" or "to"). </p>

</div>
</div>
<a id="a7d18d29606bbdb7875f7d8a8042dd29a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d18d29606bbdb7875f7d8a8042dd29a">&#9670;&nbsp;</a></span>empty_edge_ends</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;pair&lt;<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool&gt; &gt; vg::VG::empty_edge_ends</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Placeholder for functions that sometimes need to be passed an empty vector. </p>

</div>
</div>
<a id="a071f0034788bdcd778d5d0c76ba4f6b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a071f0034788bdcd778d5d0c76ba4f6b6">&#9670;&nbsp;</a></span>empty_ids</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&gt; vg::VG::empty_ids</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Placeholder for functions that sometimes need to be passed an empty vector. </p>

</div>
</div>
<a id="a4772c77ed932bfed4d21e247918381a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4772c77ed932bfed4d21e247918381a4">&#9670;&nbsp;</a></span>graph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> vg::VG::graph</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Protobuf-based representation. </p>

</div>
</div>
<a id="a1f6fcd5a907e9bee524cf37a62ad5be2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f6fcd5a907e9bee524cf37a62ad5be2">&#9670;&nbsp;</a></span>name</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::VG::name</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Name of the graph. </p>

</div>
</div>
<a id="ad84c5c18cddf1ef2c469e0db0fd7b9dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad84c5c18cddf1ef2c469e0db0fd7b9dc">&#9670;&nbsp;</a></span>node_by_id</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, <a class="el" href="structvg_1_1Node.html">Node</a>*&gt; vg::VG::node_by_id</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><code><a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a></code>s by id. </p>

</div>
</div>
<a id="a2ce9aecf57e0684821ee277d983eb248"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ce9aecf57e0684821ee277d983eb248">&#9670;&nbsp;</a></span>node_index</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="structvg_1_1Node.html">Node</a>*, int&gt; vg::VG::node_index</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>nodes by position in nodes repeated field. this is critical to allow fast deletion of nodes </p>

</div>
</div>
<a id="a7c5150aba84e7ed2bde7986462a79989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c5150aba84e7ed2bde7986462a79989">&#9670;&nbsp;</a></span>paths</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Paths.html">Paths</a> vg::VG::paths</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Manages paths of the graph. Initialized by setting paths._paths = graph.paths. </p>

</div>
</div>
<a id="ac697184acf2edadca58ddc776f9f4e7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac697184acf2edadca58ddc776f9f4e7e">&#9670;&nbsp;</a></span>variant_to_traversal</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;string, <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a>&gt; vg::VG::variant_to_traversal</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f0519dc706937b8b593f803f3d8eac4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0519dc706937b8b593f803f3d8eac4">&#9670;&nbsp;</a></span>warned_about_rewrites</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::VG::warned_about_rewrites = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="vg_8hpp.html">vg.hpp</a></li>
<li>src/<a class="el" href="vg_8cpp.html">vg.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
