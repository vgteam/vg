<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::io Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="namespacevg_1_1io.html">io</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">vg::io Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1AlignmentEmitter.html">AlignmentEmitter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipInputStream.html">BlockedGzipInputStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1BlockedGzipOutputStream.html">BlockedGzipOutputStream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ConvertedHashGraph.html">ConvertedHashGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1fdinbuf.html">fdinbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1fdistream.html">fdistream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1fdostream.html">fdostream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1fdoutbuf.html">fdoutbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1GafAlignmentEmitter.html">GafAlignmentEmitter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1io_1_1hFILE__cppstream.html">hFILE_cppstream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1JSONStreamHelper.html">JSONStreamHelper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageEmitter.html">MessageEmitter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1NullAlignmentEmitter.html">NullAlignmentEmitter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">ProtobufIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1Registry.html">Registry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1streaminbuf.html">streaminbuf</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1streamistream.html">streamistream</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1StreamMultiplexer.html">StreamMultiplexer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1TSVAlignmentEmitter.html">TSVAlignmentEmitter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VGAlignmentEmitter.html">VGAlignmentEmitter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1VPKG.html">VPKG</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3943ae5818e3556e216014f0df531502"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a3943ae5818e3556e216014f0df531502">handle_t</a> = <a class="el" href="structhandlegraph_1_1handle__t.html">handlegraph::handle_t</a></td></tr>
<tr class="separator:a3943ae5818e3556e216014f0df531502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c8209ab6c2c1d48c0ca50c24fd0d13"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a43c8209ab6c2c1d48c0ca50c24fd0d13">nid_t</a> = <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">handlegraph::nid_t</a></td></tr>
<tr class="separator:a43c8209ab6c2c1d48c0ca50c24fd0d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cab7a1a96fc203865d8ca67a372b24f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a5cab7a1a96fc203865d8ca67a372b24f">path_handle_t</a> = <a class="el" href="structhandlegraph_1_1path__handle__t.html">handlegraph::path_handle_t</a></td></tr>
<tr class="separator:a5cab7a1a96fc203865d8ca67a372b24f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5473f8a5ac351719453cfd62655beebb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a5473f8a5ac351719453cfd62655beebb">step_handle_t</a> = <a class="el" href="structhandlegraph_1_1step__handle__t.html">handlegraph::step_handle_t</a></td></tr>
<tr class="separator:a5473f8a5ac351719453cfd62655beebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e10b2bc70fa91b79b32c5aadeab4ff"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a51e10b2bc70fa91b79b32c5aadeab4ff">edge_t</a> = <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">handlegraph::edge_t</a></td></tr>
<tr class="separator:a51e10b2bc70fa91b79b32c5aadeab4ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a172e1fe036e09c51c5a60918463de08f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a172e1fe036e09c51c5a60918463de08f">HandleGraph</a> = <a class="el" href="classhandlegraph_1_1HandleGraph.html">handlegraph::HandleGraph</a></td></tr>
<tr class="separator:a172e1fe036e09c51c5a60918463de08f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a618e8c9e44f63328bb2c0742ab0e69c2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a618e8c9e44f63328bb2c0742ab0e69c2">message_consumer_function_t</a> = function&lt; void(const string &amp;)&gt;</td></tr>
<tr class="memdesc:a618e8c9e44f63328bb2c0742ab0e69c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of a function that can be fed a series of messages.  <a href="namespacevg_1_1io.html#a618e8c9e44f63328bb2c0742ab0e69c2">More...</a><br /></td></tr>
<tr class="separator:a618e8c9e44f63328bb2c0742ab0e69c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26ea41d1ec4cf44b436a345f1eefccf1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a26ea41d1ec4cf44b436a345f1eefccf1">message_sender_function_t</a> = function&lt; void(const <a class="el" href="namespacevg_1_1io.html#a618e8c9e44f63328bb2c0742ab0e69c2">message_consumer_function_t</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a26ea41d1ec4cf44b436a345f1eefccf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of a function that can be given a message consumer to feed messages to.  <a href="namespacevg_1_1io.html#a26ea41d1ec4cf44b436a345f1eefccf1">More...</a><br /></td></tr>
<tr class="separator:a26ea41d1ec4cf44b436a345f1eefccf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a645533291ad3ae31bd8db73e51b3ac31"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a645533291ad3ae31bd8db73e51b3ac31">load_function_t</a> = function&lt; void *(const <a class="el" href="namespacevg_1_1io.html#a26ea41d1ec4cf44b436a345f1eefccf1">message_sender_function_t</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a645533291ad3ae31bd8db73e51b3ac31"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of a function that can allocate and load an object of unspecified type from a message source.  <a href="namespacevg_1_1io.html#a645533291ad3ae31bd8db73e51b3ac31">More...</a><br /></td></tr>
<tr class="separator:a645533291ad3ae31bd8db73e51b3ac31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a161bd20a13c1fd9993bcddd7ea3cbe57"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a161bd20a13c1fd9993bcddd7ea3cbe57">save_function_t</a> = function&lt; void(const void *, const <a class="el" href="namespacevg_1_1io.html#a618e8c9e44f63328bb2c0742ab0e69c2">message_consumer_function_t</a> &amp;)&gt;</td></tr>
<tr class="memdesc:a161bd20a13c1fd9993bcddd7ea3cbe57"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of a function that can serialize an object of unspecified type to a message consumer.  <a href="namespacevg_1_1io.html#a161bd20a13c1fd9993bcddd7ea3cbe57">More...</a><br /></td></tr>
<tr class="separator:a161bd20a13c1fd9993bcddd7ea3cbe57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53e90871d34e2a1d10329d419f809cea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a53e90871d34e2a1d10329d419f809cea">bare_load_function_t</a> = function&lt; void *(istream &amp;)&gt;</td></tr>
<tr class="memdesc:a53e90871d34e2a1d10329d419f809cea"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of a function that can load an object of unspecified type from a bare input stream.  <a href="namespacevg_1_1io.html#a53e90871d34e2a1d10329d419f809cea">More...</a><br /></td></tr>
<tr class="separator:a53e90871d34e2a1d10329d419f809cea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a659a48880b52fc28b36e8cc51eb1ffd0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a659a48880b52fc28b36e8cc51eb1ffd0">bare_load_function_with_filename_t</a> = function&lt; void *(istream &amp;, const string &amp;)&gt;</td></tr>
<tr class="memdesc:a659a48880b52fc28b36e8cc51eb1ffd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like above, but keep track of an optional (can be empty) filename (ie where stream comes from)  <a href="namespacevg_1_1io.html#a659a48880b52fc28b36e8cc51eb1ffd0">More...</a><br /></td></tr>
<tr class="separator:a659a48880b52fc28b36e8cc51eb1ffd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8c1fde642062992c5179d67196ee4f2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#af8c1fde642062992c5179d67196ee4f2">bare_save_function_t</a> = function&lt; void(const void *, ostream &amp;)&gt;</td></tr>
<tr class="memdesc:af8c1fde642062992c5179d67196ee4f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of a function that can save an object of unspecified type to a bare output stream.  <a href="namespacevg_1_1io.html#af8c1fde642062992c5179d67196ee4f2">More...</a><br /></td></tr>
<tr class="separator:af8c1fde642062992c5179d67196ee4f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a550ead63070ee82e14eb16659099755b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a550ead63070ee82e14eb16659099755b">json2graph</a> (const std::string &amp;json, <a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *dest)</td></tr>
<tr class="memdesc:a550ead63070ee82e14eb16659099755b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a JSON string into a graph. The string must be a single JSON object.  <a href="namespacevg_1_1io.html#a550ead63070ee82e14eb16659099755b">More...</a><br /></td></tr>
<tr class="separator:a550ead63070ee82e14eb16659099755b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef1360dbaeba693008f3ee0d39dde30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#aeef1360dbaeba693008f3ee0d39dde30">load_proto_to_graph</a> (<a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">vg::MutablePathMutableHandleGraph</a> *destination, const <a class="el" href="namespacevg_1_1io.html#a26ea41d1ec4cf44b436a345f1eefccf1">vg::io::message_sender_function_t</a> &amp;for_each_message)</td></tr>
<tr class="separator:aeef1360dbaeba693008f3ee0d39dde30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad96a1414b35d7f181ddbb3194d6dcf6c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#ad96a1414b35d7f181ddbb3194d6dcf6c">load_proto_to_graph</a> (<a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">vg::MutablePathMutableHandleGraph</a> *destination, const function&lt; void(const function&lt; void(<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;)&gt; &amp;)&gt; &amp;chunk_sender)</td></tr>
<tr class="separator:ad96a1414b35d7f181ddbb3194d6dcf6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93f27be4f07ab9c6a91a1501b992f70"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#ad93f27be4f07ab9c6a91a1501b992f70">register_libvg_io</a> ()</td></tr>
<tr class="separator:ad93f27be4f07ab9c6a91a1501b992f70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a113c8011c25b00d36f77f49062726bbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a113c8011c25b00d36f77f49062726bbb">register_loader_params_json</a> ()</td></tr>
<tr class="separator:a113c8011c25b00d36f77f49062726bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45372f8f761a3bce9e7ef6e1422db47b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a45372f8f761a3bce9e7ef6e1422db47b">register_loader_saver_distance_index</a> ()</td></tr>
<tr class="separator:a45372f8f761a3bce9e7ef6e1422db47b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fc4c5122bf0f0810993822d194eb20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a47fc4c5122bf0f0810993822d194eb20">register_loader_saver_gbwt</a> ()</td></tr>
<tr class="separator:a47fc4c5122bf0f0810993822d194eb20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6143362abf3060042589f1ffb22ff498"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a6143362abf3060042589f1ffb22ff498">register_loader_saver_gbwtgraph</a> ()</td></tr>
<tr class="separator:a6143362abf3060042589f1ffb22ff498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb36b3bf6da822750c5c6c9cd2d987e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#adb36b3bf6da822750c5c6c9cd2d987e0">register_loader_saver_gbz</a> ()</td></tr>
<tr class="separator:adb36b3bf6da822750c5c6c9cd2d987e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81649e999e30d305e02187c16b257d07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a81649e999e30d305e02187c16b257d07">register_loader_saver_gbzgraph</a> ()</td></tr>
<tr class="separator:a81649e999e30d305e02187c16b257d07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affca170910f12393eb1381c4d72e4e73"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#affca170910f12393eb1381c4d72e4e73">register_loader_saver_gcsa</a> ()</td></tr>
<tr class="separator:affca170910f12393eb1381c4d72e4e73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fadf5a0f7d91d61c9d2c27d35987c6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a1fadf5a0f7d91d61c9d2c27d35987c6a">register_loader_saver_gfa</a> ()</td></tr>
<tr class="separator:a1fadf5a0f7d91d61c9d2c27d35987c6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49d41e6f52ad981f96d772396fd4eee5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a49d41e6f52ad981f96d772396fd4eee5">register_loader_saver_hash_graph</a> ()</td></tr>
<tr class="separator:a49d41e6f52ad981f96d772396fd4eee5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7df97a78891ada683647c88c6393eb9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#af7df97a78891ada683647c88c6393eb9">register_loader_saver_lcp</a> ()</td></tr>
<tr class="separator:af7df97a78891ada683647c88c6393eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa69bc026abe7a1db4530704dfc7e7b3f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#aa69bc026abe7a1db4530704dfc7e7b3f">register_loader_saver_minimizer</a> ()</td></tr>
<tr class="separator:aa69bc026abe7a1db4530704dfc7e7b3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a776b6490958856d44dc2d962d629440d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a776b6490958856d44dc2d962d629440d">register_loader_saver_packed_graph</a> ()</td></tr>
<tr class="separator:a776b6490958856d44dc2d962d629440d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce32e4ae1d4f5d244c0d80d3ac09beb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a6ce32e4ae1d4f5d244c0d80d3ac09beb">register_loader_saver_r_index</a> ()</td></tr>
<tr class="separator:a6ce32e4ae1d4f5d244c0d80d3ac09beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8072168ee8165f81afb2688ef0825ea8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a8072168ee8165f81afb2688ef0825ea8">register_loader_saver_snarl_manager</a> ()</td></tr>
<tr class="separator:a8072168ee8165f81afb2688ef0825ea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3485846033fd4accb221b0a866dfeb7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#ac3485846033fd4accb221b0a866dfeb7">register_loader_saver_vg</a> ()</td></tr>
<tr class="separator:ac3485846033fd4accb221b0a866dfeb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a23bf45ec66db4b724b7f8a9f223c33"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a7a23bf45ec66db4b724b7f8a9f223c33">register_loader_saver_xg</a> ()</td></tr>
<tr class="separator:a7a23bf45ec66db4b724b7f8a9f223c33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0521f6b9e5e9e78ab0837548bef8f0e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#ac0521f6b9e5e9e78ab0837548bef8f0e">register_loader_saver_zip_codes</a> ()</td></tr>
<tr class="separator:ac0521f6b9e5e9e78ab0837548bef8f0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3f5510bd6a0e5514d3083fcd2ffdd32"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#af3f5510bd6a0e5514d3083fcd2ffdd32">save_handle_graph</a> (<a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> *graph, ostream &amp;os)</td></tr>
<tr class="separator:af3f5510bd6a0e5514d3083fcd2ffdd32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571f402ff74b738d9070a598a41b58da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a571f402ff74b738d9070a598a41b58da">save_handle_graph</a> (<a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> *graph, const string &amp;dest_path)</td></tr>
<tr class="separator:a571f402ff74b738d9070a598a41b58da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd0bfdce54ff793cf2fae6b1122ec54"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#accd0bfdce54ff793cf2fae6b1122ec54">valid_output_format</a> (const string &amp;fmt_string)</td></tr>
<tr class="separator:accd0bfdce54ff793cf2fae6b1122ec54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b6ad53e3fc9e4c143221b213932db70"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a4b6ad53e3fc9e4c143221b213932db70"><td class="memTemplItemLeft" align="right" valign="top">unique_ptr&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a4b6ad53e3fc9e4c143221b213932db70">new_output_graph</a> (const string &amp;fmt_string)</td></tr>
<tr class="separator:a4b6ad53e3fc9e4c143221b213932db70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f9f4db8b0374c57d2963881784c40d3"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; <a class="el" href="classvg_1_1io_1_1AlignmentEmitter.html">AlignmentEmitter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a2f9f4db8b0374c57d2963881784c40d3">get_non_hts_alignment_emitter</a> (const string &amp;filename, const string &amp;format, const map&lt; string, int64_t &gt; &amp;path_length, size_t max_threads, const <a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> *graph, const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">handlegraph::NamedNodeBackTranslation</a> *translate_through)</td></tr>
<tr class="separator:a2f9f4db8b0374c57d2963881784c40d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa357ed5eaa447e495149c7bd7df356b9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#aa357ed5eaa447e495149c7bd7df356b9">get_next_record_from_gaf</a> (function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt; node_to_length, function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt; node_to_sequence, htsFile *fp, kstring_t &amp;s_buffer, <a class="el" href="structgafkluge_1_1GafRecord.html">gafkluge::GafRecord</a> &amp;record)</td></tr>
<tr class="separator:aa357ed5eaa447e495149c7bd7df356b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f27b2a472320e0e45a130b73827d1fd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a0f27b2a472320e0e45a130b73827d1fd">get_next_interleaved_record_pair_from_gaf</a> (function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt; node_to_length, function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt; node_to_sequence, htsFile *fp, kstring_t &amp;s_buffer, <a class="el" href="structgafkluge_1_1GafRecord.html">gafkluge::GafRecord</a> &amp;record1, <a class="el" href="structgafkluge_1_1GafRecord.html">gafkluge::GafRecord</a> &amp;record2)</td></tr>
<tr class="separator:a0f27b2a472320e0e45a130b73827d1fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d5011d88f6ef27ed8837957505284b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a83d5011d88f6ef27ed8837957505284b">gaf_unpaired_for_each</a> (function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt; node_to_length, function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt; node_to_sequence, const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:a83d5011d88f6ef27ed8837957505284b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4771a7ea674ee9d986af264ab3c00d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#ada4771a7ea674ee9d986af264ab3c00d">gaf_unpaired_for_each</a> (const <a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> &amp;graph, const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:ada4771a7ea674ee9d986af264ab3c00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1509c614371533861fa7552febf7af92"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a1509c614371533861fa7552febf7af92">gaf_paired_interleaved_for_each</a> (function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt; node_to_length, function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt; node_to_sequence, const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:a1509c614371533861fa7552febf7af92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad242e1399847a5c894201b9e32c13a6d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#ad242e1399847a5c894201b9e32c13a6d">gaf_paired_interleaved_for_each</a> (const <a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> &amp;graph, const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:ad242e1399847a5c894201b9e32c13a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88d2dffc472bbcfded0b1190fc5bc933"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a88d2dffc472bbcfded0b1190fc5bc933">gaf_unpaired_for_each_parallel</a> (function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt; node_to_length, function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt; node_to_sequence, const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda, uint64_t batch_size)</td></tr>
<tr class="separator:a88d2dffc472bbcfded0b1190fc5bc933"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add46b11d285f6b94896c1f5e91a405a7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#add46b11d285f6b94896c1f5e91a405a7">gaf_unpaired_for_each_parallel</a> (const <a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> &amp;graph, const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda, uint64_t batch_size)</td></tr>
<tr class="separator:add46b11d285f6b94896c1f5e91a405a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b473c9f170444107256aa76f522d27a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a7b473c9f170444107256aa76f522d27a">gaf_paired_interleaved_for_each_parallel</a> (function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt; node_to_length, function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt; node_to_sequence, const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda, uint64_t batch_size)</td></tr>
<tr class="separator:a7b473c9f170444107256aa76f522d27a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8662ca54b9e1f26e421884a43a4e0e21"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a8662ca54b9e1f26e421884a43a4e0e21">gaf_paired_interleaved_for_each_parallel</a> (const <a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> &amp;graph, const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda, uint64_t batch_size)</td></tr>
<tr class="separator:a8662ca54b9e1f26e421884a43a4e0e21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d7cb48aae7d9c3621fabc6b31faa6e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a44d7cb48aae7d9c3621fabc6b31faa6e">gaf_paired_interleaved_for_each_parallel_after_wait</a> (function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt; node_to_length, function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt; node_to_sequence, const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda, function&lt; bool(void)&gt; single_threaded_until_true, uint64_t batch_size)</td></tr>
<tr class="separator:a44d7cb48aae7d9c3621fabc6b31faa6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63b12354bf13d6a19b5addc71fc512c7"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a63b12354bf13d6a19b5addc71fc512c7">gaf_paired_interleaved_for_each_parallel_after_wait</a> (const <a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> &amp;graph, const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda, function&lt; bool(void)&gt; single_threaded_until_true, uint64_t batch_size)</td></tr>
<tr class="separator:a63b12354bf13d6a19b5addc71fc512c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7caf6e3e258fda58ef1bd8565074f4a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgafkluge_1_1GafRecord.html">gafkluge::GafRecord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#ac7caf6e3e258fda58ef1bd8565074f4a">alignment_to_gaf</a> (function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt; node_to_length, function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt; node_to_sequence, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">handlegraph::NamedNodeBackTranslation</a> *translate_through, bool cs_cigar, bool base_quals, bool frag_links)</td></tr>
<tr class="separator:ac7caf6e3e258fda58ef1bd8565074f4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a711294fa859b37aba71867a0dd9a035a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structgafkluge_1_1GafRecord.html">gafkluge::GafRecord</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a711294fa859b37aba71867a0dd9a035a">alignment_to_gaf</a> (const <a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> &amp;graph, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">handlegraph::NamedNodeBackTranslation</a> *translate_through, bool cs_cigar, bool base_quals, bool frag_links)</td></tr>
<tr class="separator:a711294fa859b37aba71867a0dd9a035a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44a872a40072dc128fa898a795eeff79"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a44a872a40072dc128fa898a795eeff79">gaf_to_alignment</a> (function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt; node_to_length, function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt; node_to_sequence, const <a class="el" href="structgafkluge_1_1GafRecord.html">gafkluge::GafRecord</a> &amp;gaf, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="memdesc:a44a872a40072dc128fa898a795eeff79"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a GAF alignment into a vg <a class="el" href="structvg_1_1Alignment.html">Alignment</a>. The alignment must be in node ID space.  <a href="namespacevg_1_1io.html#a44a872a40072dc128fa898a795eeff79">More...</a><br /></td></tr>
<tr class="separator:a44a872a40072dc128fa898a795eeff79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a363656cc5c1a09f178e3c83785488bad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a363656cc5c1a09f178e3c83785488bad">gaf_to_alignment</a> (const <a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> &amp;graph, const <a class="el" href="structgafkluge_1_1GafRecord.html">gafkluge::GafRecord</a> &amp;gaf, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="memdesc:a363656cc5c1a09f178e3c83785488bad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a GAF alignment into a vg <a class="el" href="structvg_1_1Alignment.html">Alignment</a>. The alignment must be in node ID space.  <a href="namespacevg_1_1io.html#a363656cc5c1a09f178e3c83785488bad">More...</a><br /></td></tr>
<tr class="separator:a363656cc5c1a09f178e3c83785488bad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f819396b817978940de263c04713f9"><td class="memItemLeft" align="right" valign="top">short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a64f819396b817978940de263c04713f9">quality_char_to_short</a> (char c)</td></tr>
<tr class="separator:a64f819396b817978940de263c04713f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62d15de4c2614e383b6bc00e34eefe15"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a62d15de4c2614e383b6bc00e34eefe15">quality_short_to_char</a> (short i)</td></tr>
<tr class="separator:a62d15de4c2614e383b6bc00e34eefe15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bc5a85334e06bd81e308c0f1fc9e192"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a7bc5a85334e06bd81e308c0f1fc9e192">alignment_quality_short_to_char</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:a7bc5a85334e06bd81e308c0f1fc9e192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f3f10cba44d4ab370628c9579f9ca4"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a33f3f10cba44d4ab370628c9579f9ca4">string_quality_short_to_char</a> (const string &amp;quality)</td></tr>
<tr class="separator:a33f3f10cba44d4ab370628c9579f9ca4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982211439438e0ef8a8fd7c7e54bddc1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a982211439438e0ef8a8fd7c7e54bddc1">alignment_quality_char_to_short</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:a982211439438e0ef8a8fd7c7e54bddc1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4450d95b60550d44cbfe712467e92947"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a4450d95b60550d44cbfe712467e92947">string_quality_char_to_short</a> (const string &amp;quality)</td></tr>
<tr class="separator:a4450d95b60550d44cbfe712467e92947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b6c55dd368ec0c3e85f51a87321ba2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a09b6c55dd368ec0c3e85f51a87321ba2">mergeGraphs</a> (<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;graph, const <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;part)</td></tr>
<tr class="separator:a09b6c55dd368ec0c3e85f51a87321ba2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a857cf3810d138ef43e25aa37f147ac25"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a857cf3810d138ef43e25aa37f147ac25">inputStream</a> (const string &amp;filename)</td></tr>
<tr class="separator:a857cf3810d138ef43e25aa37f147ac25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477841175891d3e770995307eea45f38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a477841175891d3e770995307eea45f38">outputStream</a> (const <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;g)</td></tr>
<tr class="separator:a477841175891d3e770995307eea45f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5af2def0a0ebdab4130882eab0f0851d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a5af2def0a0ebdab4130882eab0f0851d">edit_is_match</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e)</td></tr>
<tr class="separator:a5af2def0a0ebdab4130882eab0f0851d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d59f64a316fdbc91577079af83fbc4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a77d59f64a316fdbc91577079af83fbc4">edit_is_sub</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e)</td></tr>
<tr class="separator:a77d59f64a316fdbc91577079af83fbc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26c4d6dee35ff3ed8365a87e0125813e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a26c4d6dee35ff3ed8365a87e0125813e">edit_is_insertion</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e)</td></tr>
<tr class="separator:a26c4d6dee35ff3ed8365a87e0125813e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23faba545c4d2714c1c86c15db79433"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#af23faba545c4d2714c1c86c15db79433">edit_is_deletion</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e)</td></tr>
<tr class="separator:af23faba545c4d2714c1c86c15db79433"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a738f411081a82bfb4a1cb0d12bafc9bc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a738f411081a82bfb4a1cb0d12bafc9bc">edit_is_empty</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e)</td></tr>
<tr class="separator:a738f411081a82bfb4a1cb0d12bafc9bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98eb54b93dec04564efd8645db7ea0fc"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structvg_1_1Edit.html">Edit</a>, <a class="el" href="structvg_1_1Edit.html">Edit</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a98eb54b93dec04564efd8645db7ea0fc">cut_edit_at_to</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e, size_t to_off)</td></tr>
<tr class="separator:a98eb54b93dec04564efd8645db7ea0fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bca02992262d43640a5c1793a1a4e0"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structvg_1_1Edit.html">Edit</a>, <a class="el" href="structvg_1_1Edit.html">Edit</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#af7bca02992262d43640a5c1793a1a4e0">cut_edit_at_from</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e, size_t from_off)</td></tr>
<tr class="separator:af7bca02992262d43640a5c1793a1a4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52a77b52c33c165637fb00be3e9f54e0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Edit.html">Edit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a52a77b52c33c165637fb00be3e9f54e0">reverse_complement_edit</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e)</td></tr>
<tr class="separator:a52a77b52c33c165637fb00be3e9f54e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05438ce01e149360e263cb83346a5261"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a05438ce01e149360e263cb83346a5261">operator==</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e1, const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e2)</td></tr>
<tr class="separator:a05438ce01e149360e263cb83346a5261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62b10a042ea08faa5da35ff07183d49b"><td class="memItemLeft" align="right" valign="top">hFILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a62b10a042ea08faa5da35ff07183d49b">hfile_wrap</a> (std::istream &amp;input)</td></tr>
<tr class="memdesc:a62b10a042ea08faa5da35ff07183d49b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a C++ input stream as an hFILE* that can be read by BGZF.  <a href="namespacevg_1_1io.html#a62b10a042ea08faa5da35ff07183d49b">More...</a><br /></td></tr>
<tr class="separator:a62b10a042ea08faa5da35ff07183d49b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fa9b57a79b55cf4eeb10806be649ede"><td class="memItemLeft" align="right" valign="top">hFILE *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a4fa9b57a79b55cf4eeb10806be649ede">hfile_wrap</a> (std::ostream &amp;output)</td></tr>
<tr class="memdesc:a4fa9b57a79b55cf4eeb10806be649ede"><td class="mdescLeft">&#160;</td><td class="mdescRight">Wrap a C++ output stream as an hFILE* that can be written by BGZF.  <a href="namespacevg_1_1io.html#a4fa9b57a79b55cf4eeb10806be649ede">More...</a><br /></td></tr>
<tr class="separator:a4fa9b57a79b55cf4eeb10806be649ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36870772d6af0c6fbc0a099f6bed2caf"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a36870772d6af0c6fbc0a099f6bed2caf">wrap_bare_loader</a> (function&lt; void *(istream &amp;)&gt; istream_loader) -&gt; <a class="el" href="namespacevg_1_1io.html#a645533291ad3ae31bd8db73e51b3ac31">load_function_t</a></td></tr>
<tr class="separator:a36870772d6af0c6fbc0a099f6bed2caf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b1a63276edf814575b7afb3b2b9844d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a8b1a63276edf814575b7afb3b2b9844d">with_function_calling_stream</a> (const <a class="el" href="namespacevg_1_1io.html#a618e8c9e44f63328bb2c0742ab0e69c2">message_consumer_function_t</a> &amp;emit_message, const function&lt; void(ostream &amp;)&gt; &amp;use_stream)</td></tr>
<tr class="separator:a8b1a63276edf814575b7afb3b2b9844d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0cd97ec5478403a25e02c9805f3d286"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#ae0cd97ec5478403a25e02c9805f3d286">wrap_bare_saver</a> (function&lt; void(const void *, ostream &amp;)&gt; ostream_saver) -&gt; <a class="el" href="namespacevg_1_1io.html#a161bd20a13c1fd9993bcddd7ea3cbe57">save_function_t</a></td></tr>
<tr class="separator:ae0cd97ec5478403a25e02c9805f3d286"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b562b3e8bd001bb10bcd0353bf5a929"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a9b562b3e8bd001bb10bcd0353bf5a929">finish</a> (std::ostream &amp;out, bool compressed)</td></tr>
<tr class="separator:a9b562b3e8bd001bb10bcd0353bf5a929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff18a599bd6affc6e2709cb2cff9154c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#aff18a599bd6affc6e2709cb2cff9154c">get_stream_length</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:aff18a599bd6affc6e2709cb2cff9154c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of the input stream, or <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">std::numeric_limits&lt;size_t&gt;::max()</a> if unavailable.  <a href="namespacevg_1_1io.html#aff18a599bd6affc6e2709cb2cff9154c">More...</a><br /></td></tr>
<tr class="separator:aff18a599bd6affc6e2709cb2cff9154c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca3b265c558db37b69a837668d2fdf12"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#aca3b265c558db37b69a837668d2fdf12">get_stream_position</a> (std::istream &amp;in)</td></tr>
<tr class="memdesc:aca3b265c558db37b69a837668d2fdf12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current offset in the input stream, or std;:<a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">numeric_limits&lt;size_t&gt;::max()</a> if unavailable.  <a href="namespacevg_1_1io.html#aca3b265c558db37b69a837668d2fdf12">More...</a><br /></td></tr>
<tr class="separator:aca3b265c558db37b69a837668d2fdf12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3daebbee97f2451b25aec3c642c06c8"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac3daebbee97f2451b25aec3c642c06c8"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#ac3daebbee97f2451b25aec3c642c06c8">unpaired_for_each_parallel</a> (function&lt; bool(T &amp;)&gt; get_read_if_available, function&lt; void(T &amp;)&gt; lambda, uint64_t batch_size=<a class="el" href="namespacevg_1_1io.html#aba1d6c41cb6ff7b47e64b6b584af0363">DEFAULT_PARALLEL_BATCHSIZE</a>)</td></tr>
<tr class="separator:ac3daebbee97f2451b25aec3c642c06c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3c3dd4ad5c9b887fd3ee389e0b67ef6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:af3c3dd4ad5c9b887fd3ee389e0b67ef6"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#af3c3dd4ad5c9b887fd3ee389e0b67ef6">paired_for_each_parallel_after_wait</a> (function&lt; bool(T &amp;, T &amp;)&gt; get_pair_if_available, function&lt; void(T &amp;, T &amp;)&gt; lambda, function&lt; bool(void)&gt; single_threaded_until_true, uint64_t batch_size=<a class="el" href="namespacevg_1_1io.html#aba1d6c41cb6ff7b47e64b6b584af0363">DEFAULT_PARALLEL_BATCHSIZE</a>)</td></tr>
<tr class="separator:af3c3dd4ad5c9b887fd3ee389e0b67ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab11e877e850b127b8004e7223cc77247"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#ab11e877e850b127b8004e7223cc77247">get_next_record_pair_from_gaf</a> (function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt; node_to_length, function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt; node_to_sequence, htsFile *fp, kstring_t &amp;s_buffer, <a class="el" href="structgafkluge_1_1GafRecord.html">gafkluge::GafRecord</a> &amp;mate1, <a class="el" href="structgafkluge_1_1GafRecord.html">gafkluge::GafRecord</a> &amp;mate2)</td></tr>
<tr class="separator:ab11e877e850b127b8004e7223cc77247"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ab0e97965e5b5e461a997ed374423e"><td class="memTemplParams" colspan="2">template&lt;typename Item &gt; </td></tr>
<tr class="memitem:ae5ab0e97965e5b5e461a997ed374423e"><td class="memTemplItemLeft" align="right" valign="top">auto&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#ae5ab0e97965e5b5e461a997ed374423e">emit_to</a> (ostream &amp;out) -&gt; std::function&lt; void(const Item &amp;)&gt;</td></tr>
<tr class="separator:ae5ab0e97965e5b5e461a997ed374423e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b6b275aeefcf193d8d25a6b3b7b8f11"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1b6b275aeefcf193d8d25a6b3b7b8f11"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a1b6b275aeefcf193d8d25a6b3b7b8f11">write</a> (std::ostream &amp;out, size_t count, const std::function&lt; T &amp;(size_t)&gt; &amp;lambda, bool compressed=true)</td></tr>
<tr class="separator:a1b6b275aeefcf193d8d25a6b3b7b8f11"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4c230c8fd256d7a5dfd16aa2014a51f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa4c230c8fd256d7a5dfd16aa2014a51f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#aa4c230c8fd256d7a5dfd16aa2014a51f">write</a> (std::ostream &amp;out, size_t count, const std::function&lt; T(size_t)&gt; &amp;lambda, bool compressed=true)</td></tr>
<tr class="separator:aa4c230c8fd256d7a5dfd16aa2014a51f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a482c50dd5f56410de4988931f2510f57"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a482c50dd5f56410de4988931f2510f57"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a482c50dd5f56410de4988931f2510f57">write_buffered</a> (std::ostream &amp;out, std::vector&lt; T &gt; &amp;buffer, size_t buffer_limit, bool compressed=true)</td></tr>
<tr class="separator:a482c50dd5f56410de4988931f2510f57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88cb8e7bbebb78a2ef3bdce1c64ba077"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a88cb8e7bbebb78a2ef3bdce1c64ba077"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a88cb8e7bbebb78a2ef3bdce1c64ba077">write_to_file</a> (const T &amp;item, const string &amp;filename)</td></tr>
<tr class="memdesc:a88cb8e7bbebb78a2ef3bdce1c64ba077"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a single message to a file.  <a href="namespacevg_1_1io.html#a88cb8e7bbebb78a2ef3bdce1c64ba077">More...</a><br /></td></tr>
<tr class="separator:a88cb8e7bbebb78a2ef3bdce1c64ba077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08997ecc2a7d17c35a27418b5f21ab3d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a08997ecc2a7d17c35a27418b5f21ab3d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a08997ecc2a7d17c35a27418b5f21ab3d">for_each</a> (std::istream &amp;in, const std::function&lt; void(int64_t, T &amp;)&gt; &amp;lambda, const std::function&lt; void(size_t, size_t)&gt; &amp;progress=<a class="el" href="namespacevg_1_1io.html#a33939950704e2d4439b93cde15139172">NO_PROGRESS</a>)</td></tr>
<tr class="separator:a08997ecc2a7d17c35a27418b5f21ab3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e19f6d7cb7f7c3d6a396268dcbd8007"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6e19f6d7cb7f7c3d6a396268dcbd8007"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a6e19f6d7cb7f7c3d6a396268dcbd8007">for_each</a> (std::istream &amp;in, const std::function&lt; void(T &amp;)&gt; &amp;lambda, const std::function&lt; void(size_t, size_t)&gt; &amp;progress=<a class="el" href="namespacevg_1_1io.html#a33939950704e2d4439b93cde15139172">NO_PROGRESS</a>)</td></tr>
<tr class="separator:a6e19f6d7cb7f7c3d6a396268dcbd8007"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1347d6f25fb95f2e4fd6cf5d2ff7f92d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a1347d6f25fb95f2e4fd6cf5d2ff7f92d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a1347d6f25fb95f2e4fd6cf5d2ff7f92d">for_each_parallel_impl</a> (std::istream &amp;in, const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;lambda2, const std::function&lt; void(T &amp;)&gt; &amp;lambda1, const std::function&lt; bool(void)&gt; &amp;single_threaded_until_true, size_t batch_size, const std::function&lt; void(size_t, size_t)&gt; &amp;progress=<a class="el" href="namespacevg_1_1io.html#a33939950704e2d4439b93cde15139172">NO_PROGRESS</a>)</td></tr>
<tr class="separator:a1347d6f25fb95f2e4fd6cf5d2ff7f92d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb40cd1227130aa2b23a1a7c91aa7f2d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aeb40cd1227130aa2b23a1a7c91aa7f2d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#aeb40cd1227130aa2b23a1a7c91aa7f2d">for_each_interleaved_pair_parallel</a> (std::istream &amp;in, const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;lambda2, size_t batch_size=256, const std::function&lt; void(size_t, size_t)&gt; &amp;progress=<a class="el" href="namespacevg_1_1io.html#a33939950704e2d4439b93cde15139172">NO_PROGRESS</a>)</td></tr>
<tr class="separator:aeb40cd1227130aa2b23a1a7c91aa7f2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa420d6f551083405c508bee6242ef123"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa420d6f551083405c508bee6242ef123"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#aa420d6f551083405c508bee6242ef123">for_each_interleaved_pair_parallel_after_wait</a> (std::istream &amp;in, const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;lambda2, const std::function&lt; bool(void)&gt; &amp;single_threaded_until_true, size_t batch_size=256, const std::function&lt; void(size_t, size_t)&gt; &amp;progress=<a class="el" href="namespacevg_1_1io.html#a33939950704e2d4439b93cde15139172">NO_PROGRESS</a>)</td></tr>
<tr class="separator:aa420d6f551083405c508bee6242ef123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3c1dbfdd613d8d70e6354d680b342e"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2c3c1dbfdd613d8d70e6354d680b342e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a2c3c1dbfdd613d8d70e6354d680b342e">for_each_parallel</a> (std::istream &amp;in, const std::function&lt; void(T &amp;)&gt; &amp;lambda1, size_t batch_size=256, const std::function&lt; void(size_t, size_t)&gt; &amp;progress=<a class="el" href="namespacevg_1_1io.html#a33939950704e2d4439b93cde15139172">NO_PROGRESS</a>)</td></tr>
<tr class="separator:a2c3c1dbfdd613d8d70e6354d680b342e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:aba1d6c41cb6ff7b47e64b6b584af0363"><td class="memItemLeft" align="right" valign="top">const uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#aba1d6c41cb6ff7b47e64b6b584af0363">DEFAULT_PARALLEL_BATCHSIZE</a> = 512</td></tr>
<tr class="separator:aba1d6c41cb6ff7b47e64b6b584af0363"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4547db1ae9c6b6b3cf0ba9f4aed17e14"><td class="memTemplParams" colspan="2">template&lt;typename Item &gt; </td></tr>
<tr class="memitem:a4547db1ae9c6b6b3cf0ba9f4aed17e14"><td class="memTemplItemLeft" align="right" valign="top">std::function&lt; void(const Item &amp;)&gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a4547db1ae9c6b6b3cf0ba9f4aed17e14">emit_to</a> (ostream &amp;out)</td></tr>
<tr class="separator:a4547db1ae9c6b6b3cf0ba9f4aed17e14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33939950704e2d4439b93cde15139172"><td class="memItemLeft" align="right" valign="top">const std::function&lt; void(size_t, size_t)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a33939950704e2d4439b93cde15139172">NO_PROGRESS</a> = [](size_t, size_t) {}</td></tr>
<tr class="separator:a33939950704e2d4439b93cde15139172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21ec64ee292cf76a61bff68a727471e9"><td class="memItemLeft" align="right" valign="top">const std::function&lt; bool(void)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html#a21ec64ee292cf76a61bff68a727471e9">NO_WAIT</a> = []() { return true; }</td></tr>
<tr class="separator:a21ec64ee292cf76a61bff68a727471e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a53e90871d34e2a1d10329d419f809cea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53e90871d34e2a1d10329d419f809cea">&#9670;&nbsp;</a></span>bare_load_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg_1_1io.html#a53e90871d34e2a1d10329d419f809cea">vg::io::bare_load_function_t</a> = typedef function&lt;void*(istream&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type of a function that can load an object of unspecified type from a bare input stream. </p>

</div>
</div>
<a id="a659a48880b52fc28b36e8cc51eb1ffd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a659a48880b52fc28b36e8cc51eb1ffd0">&#9670;&nbsp;</a></span>bare_load_function_with_filename_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg_1_1io.html#a659a48880b52fc28b36e8cc51eb1ffd0">vg::io::bare_load_function_with_filename_t</a> = typedef function&lt;void*(istream&amp;, const string&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like above, but keep track of an optional (can be empty) filename (ie where stream comes from) </p>

</div>
</div>
<a id="af8c1fde642062992c5179d67196ee4f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8c1fde642062992c5179d67196ee4f2">&#9670;&nbsp;</a></span>bare_save_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg_1_1io.html#af8c1fde642062992c5179d67196ee4f2">vg::io::bare_save_function_t</a> = typedef function&lt;void(const void*, ostream&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type of a function that can save an object of unspecified type to a bare output stream. </p>

</div>
</div>
<a id="a51e10b2bc70fa91b79b32c5aadeab4ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e10b2bc70fa91b79b32c5aadeab4ff">&#9670;&nbsp;</a></span>edge_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">handlegraph::edge_t</a> <a class="el" href="namespacevg.html#a3de8fe5f38b1730a36af4ad9c4258963">vg::io::edge_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3943ae5818e3556e216014f0df531502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3943ae5818e3556e216014f0df531502">&#9670;&nbsp;</a></span>handle_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structhandlegraph_1_1handle__t.html">handlegraph::handle_t</a> <a class="el" href="structhandlegraph_1_1handle__t.html">vg::io::handle_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a172e1fe036e09c51c5a60918463de08f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a172e1fe036e09c51c5a60918463de08f">&#9670;&nbsp;</a></span>HandleGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="classhandlegraph_1_1HandleGraph.html">handlegraph::HandleGraph</a> <a class="el" href="classhandlegraph_1_1HandleGraph.html">vg::io::HandleGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a645533291ad3ae31bd8db73e51b3ac31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a645533291ad3ae31bd8db73e51b3ac31">&#9670;&nbsp;</a></span>load_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg_1_1io.html#a645533291ad3ae31bd8db73e51b3ac31">vg::io::load_function_t</a> = typedef function&lt;void*(const <a class="el" href="namespacevg_1_1io.html#a26ea41d1ec4cf44b436a345f1eefccf1">message_sender_function_t</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type of a function that can allocate and load an object of unspecified type from a message source. </p>

</div>
</div>
<a id="a618e8c9e44f63328bb2c0742ab0e69c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a618e8c9e44f63328bb2c0742ab0e69c2">&#9670;&nbsp;</a></span>message_consumer_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg_1_1io.html#a618e8c9e44f63328bb2c0742ab0e69c2">vg::io::message_consumer_function_t</a> = typedef function&lt;void(const string&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type of a function that can be fed a series of messages. </p>

</div>
</div>
<a id="a26ea41d1ec4cf44b436a345f1eefccf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26ea41d1ec4cf44b436a345f1eefccf1">&#9670;&nbsp;</a></span>message_sender_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg_1_1io.html#a26ea41d1ec4cf44b436a345f1eefccf1">vg::io::message_sender_function_t</a> = typedef function&lt;void(const <a class="el" href="namespacevg_1_1io.html#a618e8c9e44f63328bb2c0742ab0e69c2">message_consumer_function_t</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type of a function that can be given a message consumer to feed messages to. </p>

</div>
</div>
<a id="a43c8209ab6c2c1d48c0ca50c24fd0d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c8209ab6c2c1d48c0ca50c24fd0d13">&#9670;&nbsp;</a></span>nid_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">handlegraph::nid_t</a> <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">vg::io::nid_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5cab7a1a96fc203865d8ca67a372b24f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cab7a1a96fc203865d8ca67a372b24f">&#9670;&nbsp;</a></span>path_handle_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structhandlegraph_1_1path__handle__t.html">handlegraph::path_handle_t</a> <a class="el" href="structhandlegraph_1_1path__handle__t.html">vg::io::path_handle_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a161bd20a13c1fd9993bcddd7ea3cbe57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a161bd20a13c1fd9993bcddd7ea3cbe57">&#9670;&nbsp;</a></span>save_function_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg_1_1io.html#a161bd20a13c1fd9993bcddd7ea3cbe57">vg::io::save_function_t</a> = typedef function&lt;void(const void*, const <a class="el" href="namespacevg_1_1io.html#a618e8c9e44f63328bb2c0742ab0e69c2">message_consumer_function_t</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is the type of a function that can serialize an object of unspecified type to a message consumer. </p>

</div>
</div>
<a id="a5473f8a5ac351719453cfd62655beebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5473f8a5ac351719453cfd62655beebb">&#9670;&nbsp;</a></span>step_handle_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structhandlegraph_1_1step__handle__t.html">handlegraph::step_handle_t</a> <a class="el" href="structhandlegraph_1_1step__handle__t.html">vg::io::step_handle_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a982211439438e0ef8a8fd7c7e54bddc1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a982211439438e0ef8a8fd7c7e54bddc1">&#9670;&nbsp;</a></span>alignment_quality_char_to_short()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::alignment_quality_char_to_short </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7bc5a85334e06bd81e308c0f1fc9e192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bc5a85334e06bd81e308c0f1fc9e192">&#9670;&nbsp;</a></span>alignment_quality_short_to_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::alignment_quality_short_to_char </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a711294fa859b37aba71867a0dd9a035a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a711294fa859b37aba71867a0dd9a035a">&#9670;&nbsp;</a></span>alignment_to_gaf() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgafkluge_1_1GafRecord.html">gafkluge::GafRecord</a> vg::io::alignment_to_gaf </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">handlegraph::NamedNodeBackTranslation</a> *&#160;</td>
          <td class="paramname"><em>translate_through</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cs_cigar</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>base_quals</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>frag_links</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an alignment to GAF. The alignment must be in node ID space. If translate_through is set, output will be in segment name space. </p>

</div>
</div>
<a id="ac7caf6e3e258fda58ef1bd8565074f4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7caf6e3e258fda58ef1bd8565074f4a">&#9670;&nbsp;</a></span>alignment_to_gaf() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structgafkluge_1_1GafRecord.html">gafkluge::GafRecord</a> vg::io::alignment_to_gaf </td>
          <td>(</td>
          <td class="paramtype">function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt;&#160;</td>
          <td class="paramname"><em>node_to_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt;&#160;</td>
          <td class="paramname"><em>node_to_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">handlegraph::NamedNodeBackTranslation</a> *&#160;</td>
          <td class="paramname"><em>translate_through</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>cs_cigar</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>base_quals</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>frag_links</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an alignment to GAF. The alignment must be in node ID space. If translate_through is set, output will be in segment name space. </p>

</div>
</div>
<a id="af7bca02992262d43640a5c1793a1a4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bca02992262d43640a5c1793a1a4e0">&#9670;&nbsp;</a></span>cut_edit_at_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structvg_1_1Edit.html">Edit</a>, <a class="el" href="structvg_1_1Edit.html">Edit</a> &gt; vg::io::cut_edit_at_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>from_off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98eb54b93dec04564efd8645db7ea0fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98eb54b93dec04564efd8645db7ea0fc">&#9670;&nbsp;</a></span>cut_edit_at_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structvg_1_1Edit.html">Edit</a>, <a class="el" href="structvg_1_1Edit.html">Edit</a> &gt; vg::io::cut_edit_at_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>to_off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af23faba545c4d2714c1c86c15db79433"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23faba545c4d2714c1c86c15db79433">&#9670;&nbsp;</a></span>edit_is_deletion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::edit_is_deletion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a738f411081a82bfb4a1cb0d12bafc9bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a738f411081a82bfb4a1cb0d12bafc9bc">&#9670;&nbsp;</a></span>edit_is_empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::edit_is_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a26c4d6dee35ff3ed8365a87e0125813e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26c4d6dee35ff3ed8365a87e0125813e">&#9670;&nbsp;</a></span>edit_is_insertion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::edit_is_insertion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5af2def0a0ebdab4130882eab0f0851d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af2def0a0ebdab4130882eab0f0851d">&#9670;&nbsp;</a></span>edit_is_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::edit_is_match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77d59f64a316fdbc91577079af83fbc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d59f64a316fdbc91577079af83fbc4">&#9670;&nbsp;</a></span>edit_is_sub()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::edit_is_sub </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae5ab0e97965e5b5e461a997ed374423e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ab0e97965e5b5e461a997ed374423e">&#9670;&nbsp;</a></span>emit_to()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto vg::io::emit_to </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> -&gt; std::function&lt;void(const Item&amp;)&gt; </td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b562b3e8bd001bb10bcd0353bf5a929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b562b3e8bd001bb10bcd0353bf5a929">&#9670;&nbsp;</a></span>finish()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::finish </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write the EOF marker to the given stream, so that readers won't complain that it might be truncated when they read it in. Internal EOF markers MAY exist, but a file SHOULD have exactly one EOF marker at its end. Needs to know if the output stream is compressed or not. Note that uncompressed streams don't actually have nonempty EOF markers. </p>

</div>
</div>
<a id="a08997ecc2a7d17c35a27418b5f21ab3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08997ecc2a7d17c35a27418b5f21ab3d">&#9670;&nbsp;</a></span>for_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::for_each </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(int64_t, T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(size_t, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>progress</em> = <code><a class="el" href="namespacevg_1_1io.html#a33939950704e2d4439b93cde15139172">NO_PROGRESS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e19f6d7cb7f7c3d6a396268dcbd8007"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e19f6d7cb7f7c3d6a396268dcbd8007">&#9670;&nbsp;</a></span>for_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::for_each </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(size_t, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>progress</em> = <code><a class="el" href="namespacevg_1_1io.html#a33939950704e2d4439b93cde15139172">NO_PROGRESS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb40cd1227130aa2b23a1a7c91aa7f2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb40cd1227130aa2b23a1a7c91aa7f2d">&#9670;&nbsp;</a></span>for_each_interleaved_pair_parallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::for_each_interleaved_pair_parallel </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>256</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(size_t, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>progress</em> = <code><a class="el" href="namespacevg_1_1io.html#a33939950704e2d4439b93cde15139172">NO_PROGRESS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa420d6f551083405c508bee6242ef123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa420d6f551083405c508bee6242ef123">&#9670;&nbsp;</a></span>for_each_interleaved_pair_parallel_after_wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::for_each_interleaved_pair_parallel_after_wait </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>single_threaded_until_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>256</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(size_t, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>progress</em> = <code><a class="el" href="namespacevg_1_1io.html#a33939950704e2d4439b93cde15139172">NO_PROGRESS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c3c1dbfdd613d8d70e6354d680b342e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3c1dbfdd613d8d70e6354d680b342e">&#9670;&nbsp;</a></span>for_each_parallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code>256</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(size_t, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>progress</em> = <code><a class="el" href="namespacevg_1_1io.html#a33939950704e2d4439b93cde15139172">NO_PROGRESS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1347d6f25fb95f2e4fd6cf5d2ff7f92d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1347d6f25fb95f2e4fd6cf5d2ff7f92d">&#9670;&nbsp;</a></span>for_each_parallel_impl()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::for_each_parallel_impl </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;, T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(T &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>single_threaded_until_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>batch_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(size_t, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>progress</em> = <code><a class="el" href="namespacevg_1_1io.html#a33939950704e2d4439b93cde15139172">NO_PROGRESS</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad242e1399847a5c894201b9e32c13a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad242e1399847a5c894201b9e32c13a6d">&#9670;&nbsp;</a></span>gaf_paired_interleaved_for_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::gaf_paired_interleaved_for_each </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1509c614371533861fa7552febf7af92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1509c614371533861fa7552febf7af92">&#9670;&nbsp;</a></span>gaf_paired_interleaved_for_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::gaf_paired_interleaved_for_each </td>
          <td>(</td>
          <td class="paramtype">function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt;&#160;</td>
          <td class="paramname"><em>node_to_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt;&#160;</td>
          <td class="paramname"><em>node_to_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8662ca54b9e1f26e421884a43a4e0e21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8662ca54b9e1f26e421884a43a4e0e21">&#9670;&nbsp;</a></span>gaf_paired_interleaved_for_each_parallel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::gaf_paired_interleaved_for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>batch_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7b473c9f170444107256aa76f522d27a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b473c9f170444107256aa76f522d27a">&#9670;&nbsp;</a></span>gaf_paired_interleaved_for_each_parallel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::gaf_paired_interleaved_for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt;&#160;</td>
          <td class="paramname"><em>node_to_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt;&#160;</td>
          <td class="paramname"><em>node_to_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>batch_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63b12354bf13d6a19b5addc71fc512c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63b12354bf13d6a19b5addc71fc512c7">&#9670;&nbsp;</a></span>gaf_paired_interleaved_for_each_parallel_after_wait() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::gaf_paired_interleaved_for_each_parallel_after_wait </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; bool(void)&gt;&#160;</td>
          <td class="paramname"><em>single_threaded_until_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>batch_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a44d7cb48aae7d9c3621fabc6b31faa6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d7cb48aae7d9c3621fabc6b31faa6e">&#9670;&nbsp;</a></span>gaf_paired_interleaved_for_each_parallel_after_wait() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::gaf_paired_interleaved_for_each_parallel_after_wait </td>
          <td>(</td>
          <td class="paramtype">function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt;&#160;</td>
          <td class="paramname"><em>node_to_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt;&#160;</td>
          <td class="paramname"><em>node_to_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; bool(void)&gt;&#160;</td>
          <td class="paramname"><em>single_threaded_until_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>batch_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a363656cc5c1a09f178e3c83785488bad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a363656cc5c1a09f178e3c83785488bad">&#9670;&nbsp;</a></span>gaf_to_alignment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::gaf_to_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgafkluge_1_1GafRecord.html">gafkluge::GafRecord</a> &amp;&#160;</td>
          <td class="paramname"><em>gaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a GAF alignment into a vg <a class="el" href="structvg_1_1Alignment.html">Alignment</a>. The alignment must be in node ID space. </p>

</div>
</div>
<a id="a44a872a40072dc128fa898a795eeff79"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44a872a40072dc128fa898a795eeff79">&#9670;&nbsp;</a></span>gaf_to_alignment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::gaf_to_alignment </td>
          <td>(</td>
          <td class="paramtype">function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt;&#160;</td>
          <td class="paramname"><em>node_to_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt;&#160;</td>
          <td class="paramname"><em>node_to_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structgafkluge_1_1GafRecord.html">gafkluge::GafRecord</a> &amp;&#160;</td>
          <td class="paramname"><em>gaf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a GAF alignment into a vg <a class="el" href="structvg_1_1Alignment.html">Alignment</a>. The alignment must be in node ID space. </p>

</div>
</div>
<a id="ada4771a7ea674ee9d986af264ab3c00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4771a7ea674ee9d986af264ab3c00d">&#9670;&nbsp;</a></span>gaf_unpaired_for_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::gaf_unpaired_for_each </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a83d5011d88f6ef27ed8837957505284b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d5011d88f6ef27ed8837957505284b">&#9670;&nbsp;</a></span>gaf_unpaired_for_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::gaf_unpaired_for_each </td>
          <td>(</td>
          <td class="paramtype">function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt;&#160;</td>
          <td class="paramname"><em>node_to_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt;&#160;</td>
          <td class="paramname"><em>node_to_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add46b11d285f6b94896c1f5e91a405a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add46b11d285f6b94896c1f5e91a405a7">&#9670;&nbsp;</a></span>gaf_unpaired_for_each_parallel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::gaf_unpaired_for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>batch_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a88d2dffc472bbcfded0b1190fc5bc933"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88d2dffc472bbcfded0b1190fc5bc933">&#9670;&nbsp;</a></span>gaf_unpaired_for_each_parallel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::gaf_unpaired_for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt;&#160;</td>
          <td class="paramname"><em>node_to_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt;&#160;</td>
          <td class="paramname"><em>node_to_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>batch_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f27b2a472320e0e45a130b73827d1fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f27b2a472320e0e45a130b73827d1fd">&#9670;&nbsp;</a></span>get_next_interleaved_record_pair_from_gaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::get_next_interleaved_record_pair_from_gaf </td>
          <td>(</td>
          <td class="paramtype">function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt;&#160;</td>
          <td class="paramname"><em>node_to_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt;&#160;</td>
          <td class="paramname"><em>node_to_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">htsFile *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kstring_t &amp;&#160;</td>
          <td class="paramname"><em>s_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgafkluge_1_1GafRecord.html">gafkluge::GafRecord</a> &amp;&#160;</td>
          <td class="paramname"><em>record1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgafkluge_1_1GafRecord.html">gafkluge::GafRecord</a> &amp;&#160;</td>
          <td class="paramname"><em>record2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa357ed5eaa447e495149c7bd7df356b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa357ed5eaa447e495149c7bd7df356b9">&#9670;&nbsp;</a></span>get_next_record_from_gaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::get_next_record_from_gaf </td>
          <td>(</td>
          <td class="paramtype">function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt;&#160;</td>
          <td class="paramname"><em>node_to_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt;&#160;</td>
          <td class="paramname"><em>node_to_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">htsFile *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kstring_t &amp;&#160;</td>
          <td class="paramname"><em>s_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgafkluge_1_1GafRecord.html">gafkluge::GafRecord</a> &amp;&#160;</td>
          <td class="paramname"><em>record</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab11e877e850b127b8004e7223cc77247"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab11e877e850b127b8004e7223cc77247">&#9670;&nbsp;</a></span>get_next_record_pair_from_gaf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::get_next_record_pair_from_gaf </td>
          <td>(</td>
          <td class="paramtype">function&lt; size_t(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>)&gt;&#160;</td>
          <td class="paramname"><em>node_to_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; string(<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool)&gt;&#160;</td>
          <td class="paramname"><em>node_to_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">htsFile *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">kstring_t &amp;&#160;</td>
          <td class="paramname"><em>s_buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgafkluge_1_1GafRecord.html">gafkluge::GafRecord</a> &amp;&#160;</td>
          <td class="paramname"><em>mate1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structgafkluge_1_1GafRecord.html">gafkluge::GafRecord</a> &amp;&#160;</td>
          <td class="paramname"><em>mate2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f9f4db8b0374c57d2963881784c40d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f9f4db8b0374c57d2963881784c40d3">&#9670;&nbsp;</a></span>get_non_hts_alignment_emitter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classvg_1_1io_1_1AlignmentEmitter.html">AlignmentEmitter</a> &gt; vg::io::get_non_hts_alignment_emitter </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; string, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">handlegraph::NamedNodeBackTranslation</a> *&#160;</td>
          <td class="paramname"><em>translate_through</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an <a class="el" href="classvg_1_1io_1_1AlignmentEmitter.html">AlignmentEmitter</a> that can emit to the given file (or "-") in the given format. A table of contig lengths is required for HTSlib formats. Automatically applies per-thread buffering, but needs to know how many OMP threads will be in use.</p>
<p>If you want a generalization of this that supports hts, look for get_alignment_emitter in <a class="el" href="hts__alignment__emitter_8hpp.html">hts_alignment_emitter.hpp</a> </p>

</div>
</div>
<a id="aff18a599bd6affc6e2709cb2cff9154c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff18a599bd6affc6e2709cb2cff9154c">&#9670;&nbsp;</a></span>get_stream_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::get_stream_length </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the length of the input stream, or <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">std::numeric_limits&lt;size_t&gt;::max()</a> if unavailable. </p>

</div>
</div>
<a id="aca3b265c558db37b69a837668d2fdf12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca3b265c558db37b69a837668d2fdf12">&#9670;&nbsp;</a></span>get_stream_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::get_stream_position </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current offset in the input stream, or std;:<a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">numeric_limits&lt;size_t&gt;::max()</a> if unavailable. </p>

</div>
</div>
<a id="a62b10a042ea08faa5da35ff07183d49b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62b10a042ea08faa5da35ff07183d49b">&#9670;&nbsp;</a></span>hfile_wrap() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hFILE * vg::io::hfile_wrap </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;&#160;</td>
          <td class="paramname"><em>input</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap a C++ input stream as an hFILE* that can be read by BGZF. </p>
<p>Make the base struct, making sure it knows how big we are</p>

</div>
</div>
<a id="a4fa9b57a79b55cf4eeb10806be649ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fa9b57a79b55cf4eeb10806be649ede">&#9670;&nbsp;</a></span>hfile_wrap() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">hFILE * vg::io::hfile_wrap </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>output</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Wrap a C++ output stream as an hFILE* that can be written by BGZF. </p>
<p>Make the base struct, making sure it knows how big we are</p>

</div>
</div>
<a id="a857cf3810d138ef43e25aa37f147ac25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a857cf3810d138ef43e25aa37f147ac25">&#9670;&nbsp;</a></span>inputStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Graph.html">Graph</a> vg::io::inputStream </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a550ead63070ee82e14eb16659099755b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a550ead63070ee82e14eb16659099755b">&#9670;&nbsp;</a></span>json2graph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::json2graph </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>json</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load a JSON string into a graph. The string must be a single JSON object. </p>

</div>
</div>
<a id="ad96a1414b35d7f181ddbb3194d6dcf6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad96a1414b35d7f181ddbb3194d6dcf6c">&#9670;&nbsp;</a></span>load_proto_to_graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::load_proto_to_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">vg::MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const function&lt; void(<a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>chunk_sender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the given function with a callback which it can call with a series of Protobuf <a class="el" href="structvg_1_1Graph.html">Graph</a> objects, possibly in multiple threads. The Protobuf <a class="el" href="structvg_1_1Graph.html">Graph</a> objects may have dangling edges.</p>
<p>Resolves all the dangling edges and writes all the graph data into the given MutablePathMutableHandleGraph, with the destination graph being protected from concurrent modification. </p>

</div>
</div>
<a id="aeef1360dbaeba693008f3ee0d39dde30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef1360dbaeba693008f3ee0d39dde30">&#9670;&nbsp;</a></span>load_proto_to_graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::load_proto_to_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">vg::MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>destination</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg_1_1io.html#a26ea41d1ec4cf44b436a345f1eefccf1">vg::io::message_sender_function_t</a> &amp;&#160;</td>
          <td class="paramname"><em>for_each_message</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read all string messages supplied by the given message sender as Protobuf <a class="el" href="structvg_1_1Graph.html">Graph</a> objects, and create the specified graph in the destination graph.</p>
<p><a class="el" href="classvg_1_1Paths.html">Paths</a> need to be cached until the end for ranks to be respected. </p>

</div>
</div>
<a id="a09b6c55dd368ec0c3e85f51a87321ba2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b6c55dd368ec0c3e85f51a87321ba2">&#9670;&nbsp;</a></span>mergeGraphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::mergeGraphs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>part</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b6ad53e3fc9e4c143221b213932db70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b6ad53e3fc9e4c143221b213932db70">&#9670;&nbsp;</a></span>new_output_graph()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;T&gt; vg::io::new_output_graph </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>fmt_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05438ce01e149360e263cb83346a5261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05438ce01e149360e263cb83346a5261">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;&#160;</td>
          <td class="paramname"><em>e1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;&#160;</td>
          <td class="paramname"><em>e2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a477841175891d3e770995307eea45f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477841175891d3e770995307eea45f38">&#9670;&nbsp;</a></span>outputStream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::outputStream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3c3dd4ad5c9b887fd3ee389e0b67ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3c3dd4ad5c9b887fd3ee389e0b67ef6">&#9670;&nbsp;</a></span>paired_for_each_parallel_after_wait()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::paired_for_each_parallel_after_wait </td>
          <td>(</td>
          <td class="paramtype">function&lt; bool(T &amp;, T &amp;)&gt;&#160;</td>
          <td class="paramname"><em>get_pair_if_available</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(T &amp;, T &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; bool(void)&gt;&#160;</td>
          <td class="paramname"><em>single_threaded_until_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code><a class="el" href="namespacevg_1_1io.html#aba1d6c41cb6ff7b47e64b6b584af0363">DEFAULT_PARALLEL_BATCHSIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a64f819396b817978940de263c04713f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f819396b817978940de263c04713f9">&#9670;&nbsp;</a></span>quality_char_to_short()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">short vg::io::quality_char_to_short </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62d15de4c2614e383b6bc00e34eefe15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62d15de4c2614e383b6bc00e34eefe15">&#9670;&nbsp;</a></span>quality_short_to_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char vg::io::quality_short_to_char </td>
          <td>(</td>
          <td class="paramtype">short&#160;</td>
          <td class="paramname"><em>i</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad93f27be4f07ab9c6a91a1501b992f70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93f27be4f07ab9c6a91a1501b992f70">&#9670;&nbsp;</a></span>register_libvg_io()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::register_libvg_io </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register libvg types with libvgio. Must be called by library users before doing IO. Does not magically statically call itself. TODO: work out a way it can. Returns true on success. </p>

</div>
</div>
<a id="a113c8011c25b00d36f77f49062726bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a113c8011c25b00d36f77f49062726bbb">&#9670;&nbsp;</a></span>register_loader_params_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_params_json </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a45372f8f761a3bce9e7ef6e1422db47b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45372f8f761a3bce9e7ef6e1422db47b">&#9670;&nbsp;</a></span>register_loader_saver_distance_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_distance_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a47fc4c5122bf0f0810993822d194eb20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fc4c5122bf0f0810993822d194eb20">&#9670;&nbsp;</a></span>register_loader_saver_gbwt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_gbwt </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6143362abf3060042589f1ffb22ff498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6143362abf3060042589f1ffb22ff498">&#9670;&nbsp;</a></span>register_loader_saver_gbwtgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_gbwtgraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adb36b3bf6da822750c5c6c9cd2d987e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb36b3bf6da822750c5c6c9cd2d987e0">&#9670;&nbsp;</a></span>register_loader_saver_gbz()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_gbz </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81649e999e30d305e02187c16b257d07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81649e999e30d305e02187c16b257d07">&#9670;&nbsp;</a></span>register_loader_saver_gbzgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_gbzgraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="affca170910f12393eb1381c4d72e4e73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affca170910f12393eb1381c4d72e4e73">&#9670;&nbsp;</a></span>register_loader_saver_gcsa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_gcsa </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fadf5a0f7d91d61c9d2c27d35987c6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fadf5a0f7d91d61c9d2c27d35987c6a">&#9670;&nbsp;</a></span>register_loader_saver_gfa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_gfa </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a49d41e6f52ad981f96d772396fd4eee5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49d41e6f52ad981f96d772396fd4eee5">&#9670;&nbsp;</a></span>register_loader_saver_hash_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_hash_graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af7df97a78891ada683647c88c6393eb9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7df97a78891ada683647c88c6393eb9">&#9670;&nbsp;</a></span>register_loader_saver_lcp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_lcp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa69bc026abe7a1db4530704dfc7e7b3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa69bc026abe7a1db4530704dfc7e7b3f">&#9670;&nbsp;</a></span>register_loader_saver_minimizer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_minimizer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a776b6490958856d44dc2d962d629440d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a776b6490958856d44dc2d962d629440d">&#9670;&nbsp;</a></span>register_loader_saver_packed_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_packed_graph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ce32e4ae1d4f5d244c0d80d3ac09beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ce32e4ae1d4f5d244c0d80d3ac09beb">&#9670;&nbsp;</a></span>register_loader_saver_r_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_r_index </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8072168ee8165f81afb2688ef0825ea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8072168ee8165f81afb2688ef0825ea8">&#9670;&nbsp;</a></span>register_loader_saver_snarl_manager()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_snarl_manager </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3485846033fd4accb221b0a866dfeb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3485846033fd4accb221b0a866dfeb7">&#9670;&nbsp;</a></span>register_loader_saver_vg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_vg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a23bf45ec66db4b724b7f8a9f223c33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a23bf45ec66db4b724b7f8a9f223c33">&#9670;&nbsp;</a></span>register_loader_saver_xg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_xg </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0521f6b9e5e9e78ab0837548bef8f0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0521f6b9e5e9e78ab0837548bef8f0e">&#9670;&nbsp;</a></span>register_loader_saver_zip_codes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::register_loader_saver_zip_codes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52a77b52c33c165637fb00be3e9f54e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52a77b52c33c165637fb00be3e9f54e0">&#9670;&nbsp;</a></span>reverse_complement_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Edit.html">Edit</a> vg::io::reverse_complement_edit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a571f402ff74b738d9070a598a41b58da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571f402ff74b738d9070a598a41b58da">&#9670;&nbsp;</a></span>save_handle_graph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::save_handle_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>dest_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af3f5510bd6a0e5514d3083fcd2ffdd32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3f5510bd6a0e5514d3083fcd2ffdd32">&#9670;&nbsp;</a></span>save_handle_graph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::save_handle_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Save a handle graph. Todo: should this be somewhere else (ie in vgio with new types registered?) </p>

</div>
</div>
<a id="a4450d95b60550d44cbfe712467e92947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4450d95b60550d44cbfe712467e92947">&#9670;&nbsp;</a></span>string_quality_char_to_short()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::io::string_quality_char_to_short </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>quality</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33f3f10cba44d4ab370628c9579f9ca4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f3f10cba44d4ab370628c9579f9ca4">&#9670;&nbsp;</a></span>string_quality_short_to_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::io::string_quality_short_to_char </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>quality</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3daebbee97f2451b25aec3c642c06c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3daebbee97f2451b25aec3c642c06c8">&#9670;&nbsp;</a></span>unpaired_for_each_parallel()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::io::unpaired_for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">function&lt; bool(T &amp;)&gt;&#160;</td>
          <td class="paramname"><em>get_read_if_available</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(T &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>batch_size</em> = <code><a class="el" href="namespacevg_1_1io.html#aba1d6c41cb6ff7b47e64b6b584af0363">DEFAULT_PARALLEL_BATCHSIZE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="accd0bfdce54ff793cf2fae6b1122ec54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd0bfdce54ff793cf2fae6b1122ec54">&#9670;&nbsp;</a></span>valid_output_format()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::valid_output_format </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>fmt_string</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b1a63276edf814575b7afb3b2b9844d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b1a63276edf814575b7afb3b2b9844d">&#9670;&nbsp;</a></span>with_function_calling_stream()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::with_function_calling_stream </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg_1_1io.html#a618e8c9e44f63328bb2c0742ab0e69c2">message_consumer_function_t</a> &amp;&#160;</td>
          <td class="paramname"><em>emit_message</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(ostream &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>use_stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This calls the given stream-using callback with a stream that, when written to, calls the given emit_message function. The emit_message function and the stream-using callback will run in different threads. </p>

</div>
</div>
<a id="a36870772d6af0c6fbc0a099f6bed2caf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36870772d6af0c6fbc0a099f6bed2caf">&#9670;&nbsp;</a></span>wrap_bare_loader()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg_1_1io.html#a645533291ad3ae31bd8db73e51b3ac31">load_function_t</a> vg::io::wrap_bare_loader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg_1_1io.html#a53e90871d34e2a1d10329d419f809cea">bare_load_function_t</a>&#160;</td>
          <td class="paramname"><em>istream_loader</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We also have an adapter that takes a function from an istream&amp; to a void* object, and runs that in a thread to adapt it to the message consuming shape of interface. It captures the wrapped function by value. </p>

</div>
</div>
<a id="ae0cd97ec5478403a25e02c9805f3d286"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0cd97ec5478403a25e02c9805f3d286">&#9670;&nbsp;</a></span>wrap_bare_saver()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg_1_1io.html#a161bd20a13c1fd9993bcddd7ea3cbe57">save_function_t</a> vg::io::wrap_bare_saver </td>
          <td>(</td>
          <td class="paramtype">function&lt; void(const void *, ostream &amp;)&gt;&#160;</td>
          <td class="paramname"><em>ostream_saver</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We have an adapter that takes a function of void* and ostream&amp;, and adapts that to a message consumer destination. </p>

</div>
</div>
<a id="a1b6b275aeefcf193d8d25a6b3b7b8f11"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b6b275aeefcf193d8d25a6b3b7b8f11">&#9670;&nbsp;</a></span>write() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; T &amp;(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write objects. count should be equal to the number of objects to write. count is written before the objects, but if it is 0, it is not written. To get the objects, calls lambda with the index of the object to retrieve. If not all objects are written, return false, otherwise true. Needs to know whether to BGZF-compress the output or not. </p>

</div>
</div>
<a id="aa4c230c8fd256d7a5dfd16aa2014a51f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4c230c8fd256d7a5dfd16aa2014a51f">&#9670;&nbsp;</a></span>write() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::write </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; T(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write objects. count should be equal to the number of objects to write. count is written before the objects, but if it is 0, it is not written. To get the objects, calls lambda with the index of the object to retrieve. If not all objects are written, return false, otherwise true. This implementation takes a function that returns actual objects and not references. Needs to know whether to BGZF-compress the output or not. </p>

</div>
</div>
<a id="a482c50dd5f56410de4988931f2510f57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a482c50dd5f56410de4988931f2510f57">&#9670;&nbsp;</a></span>write_buffered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::io::write_buffered </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compressed</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start, continue, or finish a buffered stream of objects. If the length of the buffer is greater than the limit, writes the buffer out. Otherwise, leaves the objects in the buffer. Must be called with a buffer limit of 0 after all the objects have been produced, to flush the buffer. When called with a buffer limit of 0, automatically appends an EOF marker. Returns true unless an error occurs. Needs to know whether to BGZF-compress the output or not. </p>

</div>
</div>
<a id="a88cb8e7bbebb78a2ef3bdce1c64ba077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88cb8e7bbebb78a2ef3bdce1c64ba077">&#9670;&nbsp;</a></span>write_to_file()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::io::write_to_file </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a single message to a file. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="aba1d6c41cb6ff7b47e64b6b584af0363"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba1d6c41cb6ff7b47e64b6b584af0363">&#9670;&nbsp;</a></span>DEFAULT_PARALLEL_BATCHSIZE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const uint64_t vg::io::DEFAULT_PARALLEL_BATCHSIZE = 512</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4547db1ae9c6b6b3cf0ba9f4aed17e14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4547db1ae9c6b6b3cf0ba9f4aed17e14">&#9670;&nbsp;</a></span>emit_to</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;void(const Item&amp;)&gt; vg::io::emit_to(ostream &amp;out)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce an std::function that can be invoked with Protobuf objects and save them to the given stream. Easy way to get a dumping callback to feed to something that wants a callback. The passed stream must outlive the resulting function. </p>

</div>
</div>
<a id="a33939950704e2d4439b93cde15139172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33939950704e2d4439b93cde15139172">&#9670;&nbsp;</a></span>NO_PROGRESS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::function&lt;void(size_t, size_t)&gt; vg::io::NO_PROGRESS = [](size_t, size_t) {}</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21ec64ee292cf76a61bff68a727471e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21ec64ee292cf76a61bff68a727471e9">&#9670;&nbsp;</a></span>NO_WAIT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::function&lt;bool(void)&gt; vg::io::NO_WAIT = []() { return true; }</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
