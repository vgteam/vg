<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::ZipCodeTree Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1ZipCodeTree.html">ZipCodeTree</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classvg_1_1ZipCodeTree-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::ZipCodeTree Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;zip_code_tree.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ZipCodeTree_1_1oriented__seed__t.html">oriented_seed_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree_1_1seed__iterator.html">seed_iterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ZipCodeTree_1_1seed__result__t.html">seed_result_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ZipCodeTree_1_1tree__item__t.html">tree_item_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">One item in the zip code tree, representing a node or edge of the tree.  <a href="structvg_1_1ZipCodeTree_1_1tree__item__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:ad2249d10c3c707b5433b916d388117ad"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#ad2249d10c3c707b5433b916d388117ad">tree_item_type_t</a> { <br />
&#160;&#160;<a class="el" href="classvg_1_1ZipCodeTree.html#ad2249d10c3c707b5433b916d388117adab044c319f32f470727c5c2ba078487f5">SEED</a> =0, 
<a class="el" href="classvg_1_1ZipCodeTree.html#ad2249d10c3c707b5433b916d388117ada60080b65470ee6064c333eae0665001b">CHAIN_START</a>, 
<a class="el" href="classvg_1_1ZipCodeTree.html#ad2249d10c3c707b5433b916d388117ada7c7e392d74a0520922c3383f3aafd681">CHAIN_END</a>, 
<a class="el" href="classvg_1_1ZipCodeTree.html#ad2249d10c3c707b5433b916d388117adaa0bd6d0deb2e6c6f2b3c441346707376">EDGE</a>, 
<br />
&#160;&#160;<a class="el" href="classvg_1_1ZipCodeTree.html#ad2249d10c3c707b5433b916d388117adae2084766bf0efc386c2433d8e48438c2">CHAIN_COUNT</a>, 
<a class="el" href="classvg_1_1ZipCodeTree.html#ad2249d10c3c707b5433b916d388117adad9686e72ac57aa50bd713fce51da5666">SNARL_START</a>, 
<a class="el" href="classvg_1_1ZipCodeTree.html#ad2249d10c3c707b5433b916d388117adaaa317dff9d3024c633f537d3b8b08cc7">SNARL_END</a>
<br />
 }</td></tr>
<tr class="memdesc:ad2249d10c3c707b5433b916d388117ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">The type of an item in the zip code tree.  <a href="classvg_1_1ZipCodeTree.html#ad2249d10c3c707b5433b916d388117ad">More...</a><br /></td></tr>
<tr class="separator:ad2249d10c3c707b5433b916d388117ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a891b100128d123066ee70e97d1374f41"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#a891b100128d123066ee70e97d1374f41">ZipCodeTree</a> ()</td></tr>
<tr class="separator:a891b100128d123066ee70e97d1374f41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1207ebf8f31cd6f17593f100be3c7f00"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#a1207ebf8f31cd6f17593f100be3c7f00">get_tree_size</a> () const</td></tr>
<tr class="memdesc:a1207ebf8f31cd6f17593f100be3c7f00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of items in the tree.  <a href="classvg_1_1ZipCodeTree.html#a1207ebf8f31cd6f17593f100be3c7f00">More...</a><br /></td></tr>
<tr class="separator:a1207ebf8f31cd6f17593f100be3c7f00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66ff501bf5fa0044978550b188691068"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ZipCodeTree_1_1tree__item__t.html">tree_item_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#a66ff501bf5fa0044978550b188691068">get_item_at_index</a> (size_t index) const</td></tr>
<tr class="memdesc:a66ff501bf5fa0044978550b188691068"><td class="mdescLeft">&#160;</td><td class="mdescRight">Access the value at [index] in the zip_code_tree.  <a href="classvg_1_1ZipCodeTree.html#a66ff501bf5fa0044978550b188691068">More...</a><br /></td></tr>
<tr class="separator:a66ff501bf5fa0044978550b188691068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ba0ef9843d61c0b165d691797c85cac"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1ZipCodeTree_1_1oriented__seed__t.html">oriented_seed_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#a1ba0ef9843d61c0b165d691797c85cac">get_all_seeds</a> () const</td></tr>
<tr class="separator:a1ba0ef9843d61c0b165d691797c85cac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8cef3fdb0721e382bb9efcca89087a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#a1f8cef3fdb0721e382bb9efcca89087a">get_offset_to_seed</a> (size_t &amp;i, bool right_to_left) const</td></tr>
<tr class="separator:a1f8cef3fdb0721e382bb9efcca89087a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc1009bdf15f71ac1ba706b8effa047c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#abc1009bdf15f71ac1ba706b8effa047c">add_close_bound</a> (size_t start_index)</td></tr>
<tr class="separator:abc1009bdf15f71ac1ba706b8effa047c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af304009c9d53dcf5c2955826b6e802f9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1ZipCodeTree_1_1seed__iterator.html">seed_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#af304009c9d53dcf5c2955826b6e802f9">begin</a> () const</td></tr>
<tr class="memdesc:af304009c9d53dcf5c2955826b6e802f9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an iterator over indexes of seeds in the tree, left to right.  <a href="classvg_1_1ZipCodeTree.html#af304009c9d53dcf5c2955826b6e802f9">More...</a><br /></td></tr>
<tr class="separator:af304009c9d53dcf5c2955826b6e802f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e3a410e60c4ba68d4ef08212413e7b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1ZipCodeTree_1_1seed__iterator.html">seed_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#a2e3a410e60c4ba68d4ef08212413e7b3">end</a> () const</td></tr>
<tr class="separator:a2e3a410e60c4ba68d4ef08212413e7b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c22cae9d82e5d05e1e5592bc0692273"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#a3c22cae9d82e5d05e1e5592bc0692273">find_distances</a> (const <a class="el" href="classvg_1_1ZipCodeTree_1_1seed__iterator.html">seed_iterator</a> &amp;from, size_t distance_limit=std::numeric_limits&lt; size_t &gt;::max()) const</td></tr>
<tr class="memdesc:a3c22cae9d82e5d05e1e5592bc0692273"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a iterator starting from where a forward iterator is, up to a distance limit.  <a href="classvg_1_1ZipCodeTree.html#a3c22cae9d82e5d05e1e5592bc0692273">More...</a><br /></td></tr>
<tr class="separator:a3c22cae9d82e5d05e1e5592bc0692273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18e630074bf2c8913f8d2db9c8a2015"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#ae18e630074bf2c8913f8d2db9c8a2015">print_self</a> (const vector&lt; <a class="el" href="classvg_1_1ZipCodeTree.html#a50817b343d4ad6368df659e16b9a7549">Seed</a> &gt; *seeds) const</td></tr>
<tr class="separator:ae18e630074bf2c8913f8d2db9c8a2015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad12d46904662a2f622a2ec83567177f3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#ad12d46904662a2f622a2ec83567177f3">node_is_invalid</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, const SnarlDistanceIndex &amp;distance_index, size_t distance_limit=std::numeric_limits&lt; size_t &gt;::max()) const</td></tr>
<tr class="separator:ad12d46904662a2f622a2ec83567177f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae99837c7693b5ee6bdc2a2b0dd053ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#aae99837c7693b5ee6bdc2a2b0dd053ec">validate_zip_tree</a> (const SnarlDistanceIndex &amp;distance_index, const vector&lt; <a class="el" href="classvg_1_1ZipCodeTree.html#a50817b343d4ad6368df659e16b9a7549">Seed</a> &gt; *seeds, size_t distance_limit=std::numeric_limits&lt; size_t &gt;::max()) const</td></tr>
<tr class="separator:aae99837c7693b5ee6bdc2a2b0dd053ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c9ff7318626f88889a1599254634c21"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#a3c9ff7318626f88889a1599254634c21">validate_boundaries</a> (const SnarlDistanceIndex &amp;distance_index, const vector&lt; <a class="el" href="classvg_1_1ZipCodeTree.html#a50817b343d4ad6368df659e16b9a7549">Seed</a> &gt; *seeds, size_t distance_limit=std::numeric_limits&lt; size_t &gt;::max()) const</td></tr>
<tr class="separator:a3c9ff7318626f88889a1599254634c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a606f6d9f970816641a7b1d95b416f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#a5a606f6d9f970816641a7b1d95b416f2">validate_zip_tree_order</a> (const SnarlDistanceIndex &amp;distance_index, const vector&lt; <a class="el" href="classvg_1_1ZipCodeTree.html#a50817b343d4ad6368df659e16b9a7549">Seed</a> &gt; *seeds) const</td></tr>
<tr class="separator:a5a606f6d9f970816641a7b1d95b416f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589970bf164d56b5427a510bce7ace2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#a589970bf164d56b5427a510bce7ace2e">validate_seed_distances</a> (const SnarlDistanceIndex &amp;distance_index, const vector&lt; <a class="el" href="classvg_1_1ZipCodeTree.html#a50817b343d4ad6368df659e16b9a7549">Seed</a> &gt; *seeds, size_t distance_limit=std::numeric_limits&lt; size_t &gt;::max()) const</td></tr>
<tr class="separator:a589970bf164d56b5427a510bce7ace2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bc87c31f4a38df8d086bdf63c484015"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#a5bc87c31f4a38df8d086bdf63c484015">validate_snarl</a> (std::vector&lt; <a class="el" href="structvg_1_1ZipCodeTree_1_1tree__item__t.html">tree_item_t</a> &gt;::const_iterator &amp;zip_iterator, const SnarlDistanceIndex &amp;distance_index, const vector&lt; <a class="el" href="classvg_1_1ZipCodeTree.html#a50817b343d4ad6368df659e16b9a7549">Seed</a> &gt; *seeds, size_t distance_limit=std::numeric_limits&lt; size_t &gt;::max()) const</td></tr>
<tr class="separator:a5bc87c31f4a38df8d086bdf63c484015"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad598e20c110036b5b4558b699d857080"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#ad598e20c110036b5b4558b699d857080">validate_chain</a> (std::vector&lt; <a class="el" href="structvg_1_1ZipCodeTree_1_1tree__item__t.html">tree_item_t</a> &gt;::const_iterator &amp;zip_iterator, const SnarlDistanceIndex &amp;distance_index, const vector&lt; <a class="el" href="classvg_1_1ZipCodeTree.html#a50817b343d4ad6368df659e16b9a7549">Seed</a> &gt; *seeds, size_t distance_limit=std::numeric_limits&lt; size_t &gt;::max()) const</td></tr>
<tr class="separator:ad598e20c110036b5b4558b699d857080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63056cbe44227a17180e5fdaa6af9091"><td class="memItemLeft" align="right" valign="top">std::pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#a63056cbe44227a17180e5fdaa6af9091">dag_and_cyclic_snarl_count</a> () const</td></tr>
<tr class="separator:a63056cbe44227a17180e5fdaa6af9091"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a984f21c55ccaf7b053ce0e4fe77f91ff"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#a984f21c55ccaf7b053ce0e4fe77f91ff">seed_is_reversed_at_depth</a> (const <a class="el" href="classvg_1_1ZipCodeTree.html#a50817b343d4ad6368df659e16b9a7549">Seed</a> &amp;seed, size_t depth, const SnarlDistanceIndex &amp;distance_index)</td></tr>
<tr class="separator:a984f21c55ccaf7b053ce0e4fe77f91ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ad2ffc1171ce7791a9c047612efddeeaa"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1ZipCodeTree_1_1tree__item__t.html">tree_item_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#ad2ffc1171ce7791a9c047612efddeeaa">zip_code_tree</a></td></tr>
<tr class="memdesc:ad2ffc1171ce7791a9c047612efddeeaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">The actual tree structure.  <a href="classvg_1_1ZipCodeTree.html#ad2ffc1171ce7791a9c047612efddeeaa">More...</a><br /></td></tr>
<tr class="separator:ad2ffc1171ce7791a9c047612efddeeaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:a50817b343d4ad6368df659e16b9a7549"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html">SnarlDistanceIndexClusterer::Seed</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#a50817b343d4ad6368df659e16b9a7549">Seed</a></td></tr>
<tr class="separator:a50817b343d4ad6368df659e16b9a7549"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ae954dd8e2c990674b2293ddd18ae6517"><td class="memItemLeft" align="right" valign="top">class&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCodeTree.html#ae954dd8e2c990674b2293ddd18ae6517">ZipCodeForest</a></td></tr>
<tr class="separator:ae954dd8e2c990674b2293ddd18ae6517"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a50817b343d4ad6368df659e16b9a7549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50817b343d4ad6368df659e16b9a7549">&#9670;&nbsp;</a></span>Seed</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html">SnarlDistanceIndexClusterer::Seed</a> <a class="el" href="classvg_1_1ZipCodeTree.html#a50817b343d4ad6368df659e16b9a7549">vg::ZipCodeTree::Seed</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convenient alias for <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html" title="Seed information used in Giraffe.">SnarlDistanceIndexClusterer::Seed</a> Despite the name, these are used for graph positions, so they act more like minimizers </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="ad2249d10c3c707b5433b916d388117ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2249d10c3c707b5433b916d388117ad">&#9670;&nbsp;</a></span>tree_item_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classvg_1_1ZipCodeTree.html#ad2249d10c3c707b5433b916d388117ad">vg::ZipCodeTree::tree_item_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The type of an item in the zip code tree. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad2249d10c3c707b5433b916d388117adab044c319f32f470727c5c2ba078487f5"></a>SEED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2249d10c3c707b5433b916d388117ada60080b65470ee6064c333eae0665001b"></a>CHAIN_START&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2249d10c3c707b5433b916d388117ada7c7e392d74a0520922c3383f3aafd681"></a>CHAIN_END&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2249d10c3c707b5433b916d388117adaa0bd6d0deb2e6c6f2b3c441346707376"></a>EDGE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2249d10c3c707b5433b916d388117adae2084766bf0efc386c2433d8e48438c2"></a>CHAIN_COUNT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2249d10c3c707b5433b916d388117adad9686e72ac57aa50bd713fce51da5666"></a>SNARL_START&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad2249d10c3c707b5433b916d388117adaaa317dff9d3024c633f537d3b8b08cc7"></a>SNARL_END&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a891b100128d123066ee70e97d1374f41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a891b100128d123066ee70e97d1374f41">&#9670;&nbsp;</a></span>ZipCodeTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::ZipCodeTree::ZipCodeTree </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Empty constructor <a class="el" href="classvg_1_1ZipCodeTree.html">ZipCodeTree</a>'s get filled in by <a class="el" href="classvg_1_1ZipCodeForest.html">ZipCodeForest</a>'s </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abc1009bdf15f71ac1ba706b8effa047c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc1009bdf15f71ac1ba706b8effa047c">&#9670;&nbsp;</a></span>add_close_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeTree::add_close_bound </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add snarl or chain end of matching type and sets up their section_length values </p>

</div>
</div>
<a id="af304009c9d53dcf5c2955826b6e802f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af304009c9d53dcf5c2955826b6e802f9">&#9670;&nbsp;</a></span>begin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1ZipCodeTree_1_1seed__iterator.html">seed_iterator</a> vg::ZipCodeTree::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an iterator over indexes of seeds in the tree, left to right. </p>

</div>
</div>
<a id="a63056cbe44227a17180e5fdaa6af9091"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63056cbe44227a17180e5fdaa6af9091">&#9670;&nbsp;</a></span>dag_and_cyclic_snarl_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; size_t, size_t &gt; vg::ZipCodeTree::dag_and_cyclic_snarl_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count the number of snarls involved in the tree Returns a pair of &lt;dag count, cyclic count&gt; Assumes that the tree has already been filled in </p>

</div>
</div>
<a id="a2e3a410e60c4ba68d4ef08212413e7b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e3a410e60c4ba68d4ef08212413e7b3">&#9670;&nbsp;</a></span>end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1ZipCodeTree_1_1seed__iterator.html">seed_iterator</a> vg::ZipCodeTree::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the end iterator for seeds in the tree, left to right. (Note that the last element will never be a seed) </p>

</div>
</div>
<a id="a3c22cae9d82e5d05e1e5592bc0692273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c22cae9d82e5d05e1e5592bc0692273">&#9670;&nbsp;</a></span>find_distances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::ZipCodeTree::find_distances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1ZipCodeTree_1_1seed__iterator.html">seed_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance_limit</em> = <code>std::numeric_limits&lt;size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a iterator starting from where a forward iterator is, up to a distance limit. </p>

</div>
</div>
<a id="a1ba0ef9843d61c0b165d691797c85cac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ba0ef9843d61c0b165d691797c85cac">&#9670;&nbsp;</a></span>get_all_seeds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="structvg_1_1ZipCodeTree_1_1oriented__seed__t.html">oriented_seed_t</a>&gt; vg::ZipCodeTree::get_all_seeds </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get all the seeds in the tree, in left-to-right order Also returns their orientations Basically seed_itr but without all the extra baggage </p>

</div>
</div>
<a id="a66ff501bf5fa0044978550b188691068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66ff501bf5fa0044978550b188691068">&#9670;&nbsp;</a></span>get_item_at_index()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ZipCodeTree_1_1tree__item__t.html">tree_item_t</a> vg::ZipCodeTree::get_item_at_index </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Access the value at [index] in the zip_code_tree. </p>

</div>
</div>
<a id="a1f8cef3fdb0721e382bb9efcca89087a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8cef3fdb0721e382bb9efcca89087a">&#9670;&nbsp;</a></span>get_offset_to_seed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCodeTree::get_offset_to_seed </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>right_to_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper for add_distance_matrix() Essentially re-calculates chain.distances.first/second for seeds which are inside nested snarls</p>
<p>If the seed is in a nested snarl, this is the distance to snarl edge Otherwise it is 0 Moves i along to find the seed, and returns the offset If right_to_left is true, then search leftward for the last seed Otherwise, search rightward for the first seed </p>

</div>
</div>
<a id="a1207ebf8f31cd6f17593f100be3c7f00"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1207ebf8f31cd6f17593f100be3c7f00">&#9670;&nbsp;</a></span>get_tree_size()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCodeTree::get_tree_size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the number of items in the tree. </p>

</div>
</div>
<a id="ad12d46904662a2f622a2ec83567177f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad12d46904662a2f622a2ec83567177f3">&#9670;&nbsp;</a></span>node_is_invalid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCodeTree::node_is_invalid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance_limit</em> = <code>std::numeric_limits&lt;size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Is the given node in a multicomponent chain, looping chain, or anything else that would cause it to not have exact distances? The distances are only guaranteed to be correct up to the distance limit Cyclic snarls don't count as being invalid </p>

</div>
</div>
<a id="ae18e630074bf2c8913f8d2db9c8a2015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18e630074bf2c8913f8d2db9c8a2015">&#9670;&nbsp;</a></span>print_self()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeTree::print_self </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1ZipCodeTree.html#a50817b343d4ad6368df659e16b9a7549">Seed</a> &gt; *&#160;</td>
          <td class="paramname"><em>seeds</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Print the zip code tree to stderr ( and ) are used for the starts and ends of DAG snarls { and } are used for the starts and ends of cyclic snarls [ and ] are used for the starts and ends of chains seeds are printed as their positions </p>

</div>
</div>
<a id="a984f21c55ccaf7b053ce0e4fe77f91ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984f21c55ccaf7b053ce0e4fe77f91ff">&#9670;&nbsp;</a></span>seed_is_reversed_at_depth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCodeTree::seed_is_reversed_at_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1ZipCodeTree.html#a50817b343d4ad6368df659e16b9a7549">Seed</a> &amp;&#160;</td>
          <td class="paramname"><em>seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Helper function to get orientation of a snarl tree node at a given depth does the same thing as the zipcode decoder's get_is_reversed_in_parent, except it also considers chains that are children of irregular snarls.</p>
<p>We assume that all snarls are DAGs, so all children of snarls must only be traversable in one orientation through the snarl. This assumption doesn't work for cyclic snarls, but as their chains are traversed in both directions, their storage orientation doesn't matter.</p>
<p>In a start-to-end traversal of a snarl, each node will only be traversable start-to-end or end-to-start. If traversable end-to-start, then it is considered to be oriented backwards in its parent </p>

</div>
</div>
<a id="a3c9ff7318626f88889a1599254634c21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c9ff7318626f88889a1599254634c21">&#9670;&nbsp;</a></span>validate_boundaries()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeTree::validate_boundaries </td>
          <td>(</td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1ZipCodeTree.html#a50817b343d4ad6368df659e16b9a7549">Seed</a> &gt; *&#160;</td>
          <td class="paramname"><em>seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance_limit</em> = <code>std::numeric_limits&lt;size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function for <a class="el" href="classvg_1_1ZipCodeTree.html#aae99837c7693b5ee6bdc2a2b0dd053ec">validate_zip_tree()</a> to check snarl/chain boundaries Ensures that all boundaries are matched in type, and that pair indexes are set up correctly Also checks that there is at least one seed in the tree Calls <a class="el" href="classvg_1_1ZipCodeTree.html#a5bc87c31f4a38df8d086bdf63c484015">validate_snarl()</a> for each snarl in the top-level chain </p>

</div>
</div>
<a id="ad598e20c110036b5b4558b699d857080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad598e20c110036b5b4558b699d857080">&#9670;&nbsp;</a></span>validate_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeTree::validate_chain </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structvg_1_1ZipCodeTree_1_1tree__item__t.html">tree_item_t</a> &gt;::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>zip_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1ZipCodeTree.html#a50817b343d4ad6368df659e16b9a7549">Seed</a> &gt; *&#160;</td>
          <td class="paramname"><em>seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance_limit</em> = <code>std::numeric_limits&lt;size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function for validate_snarl for a chain zip_iterator is an iterator to the chain start At the end of the function, zip_iterator will be set to the chain end </p>

</div>
</div>
<a id="a589970bf164d56b5427a510bce7ace2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589970bf164d56b5427a510bce7ace2e">&#9670;&nbsp;</a></span>validate_seed_distances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeTree::validate_seed_distances </td>
          <td>(</td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1ZipCodeTree.html#a50817b343d4ad6368df659e16b9a7549">Seed</a> &gt; *&#160;</td>
          <td class="paramname"><em>seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance_limit</em> = <code>std::numeric_limits&lt;size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function for <a class="el" href="classvg_1_1ZipCodeTree.html#aae99837c7693b5ee6bdc2a2b0dd053ec">validate_zip_tree()</a> to check distance iteration Uses the same iterator logic that the main chaining code does and for each pair of seeds output by the <a class="el" href="classvg_1_1ZipCodeTree_1_1distance__iterator.html">distance_iterator</a>, compares their distance to the distance index </p>

</div>
</div>
<a id="a5bc87c31f4a38df8d086bdf63c484015"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bc87c31f4a38df8d086bdf63c484015">&#9670;&nbsp;</a></span>validate_snarl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeTree::validate_snarl </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structvg_1_1ZipCodeTree_1_1tree__item__t.html">tree_item_t</a> &gt;::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>zip_iterator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1ZipCodeTree.html#a50817b343d4ad6368df659e16b9a7549">Seed</a> &gt; *&#160;</td>
          <td class="paramname"><em>seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance_limit</em> = <code>std::numeric_limits&lt;size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function for validate_zip_tree for just a snarl zip_iterator is an iterator to the snarl start At the end of the function, zip_iterator will be set to the snarl end </p>

</div>
</div>
<a id="aae99837c7693b5ee6bdc2a2b0dd053ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae99837c7693b5ee6bdc2a2b0dd053ec">&#9670;&nbsp;</a></span>validate_zip_tree()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeTree::validate_zip_tree </td>
          <td>(</td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1ZipCodeTree.html#a50817b343d4ad6368df659e16b9a7549">Seed</a> &gt; *&#160;</td>
          <td class="paramname"><em>seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance_limit</em> = <code>std::numeric_limits&lt;size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check that the tree is correct:</p><ol type="1">
<li>All snarl/chain boundaries are closed properly</li>
<li>The order of the items is logical</li>
<li>The distances between seeds (as output by iteration) are correct </li>
</ol>

</div>
</div>
<a id="a5a606f6d9f970816641a7b1d95b416f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a606f6d9f970816641a7b1d95b416f2">&#9670;&nbsp;</a></span>validate_zip_tree_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCodeTree::validate_zip_tree_order </td>
          <td>(</td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1ZipCodeTree.html#a50817b343d4ad6368df659e16b9a7549">Seed</a> &gt; *&#160;</td>
          <td class="paramname"><em>seeds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper function for <a class="el" href="classvg_1_1ZipCodeTree.html#aae99837c7693b5ee6bdc2a2b0dd053ec">validate_zip_tree()</a> to check for a well-formed order</p><ol type="1">
<li>Do seeds have logical orientations relative to each other?</li>
<li>Do chains follow a [child, dist, child, dist, ... child] order?</li>
<li>Are there CHAIN_COUNTs right after each SNARL_START? </li>
</ol>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ae954dd8e2c990674b2293ddd18ae6517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae954dd8e2c990674b2293ddd18ae6517">&#9670;&nbsp;</a></span>ZipCodeForest</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">friend class <a class="el" href="classvg_1_1ZipCodeForest.html">ZipCodeForest</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad2ffc1171ce7791a9c047612efddeeaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ffc1171ce7791a9c047612efddeeaa">&#9670;&nbsp;</a></span>zip_code_tree</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="structvg_1_1ZipCodeTree_1_1tree__item__t.html">tree_item_t</a>&gt; vg::ZipCodeTree::zip_code_tree</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The actual tree structure. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="zip__code__tree_8hpp.html">zip_code_tree.hpp</a></li>
<li>src/<a class="el" href="zip__code__tree_8cpp.html">zip_code_tree.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
