<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::io::ProtobufIterator&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="namespacevg_1_1io.html">io</a></li><li class="navelem"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">ProtobufIterator</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1io_1_1ProtobufIterator-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::io::ProtobufIterator&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;protobuf_iterator.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0f2996a9653a98470e7c944879a69d70"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html#a0f2996a9653a98470e7c944879a69d70">ProtobufIterator</a> (istream &amp;in)</td></tr>
<tr class="separator:a0f2996a9653a98470e7c944879a69d70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ad0e8d7ee212617dbf9e456ea43e07"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html#a50ad0e8d7ee212617dbf9e456ea43e07">ProtobufIterator</a> ()=default</td></tr>
<tr class="memdesc:a50ad0e8d7ee212617dbf9e456ea43e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor for an end iterator.  <a href="classvg_1_1io_1_1ProtobufIterator.html#a50ad0e8d7ee212617dbf9e456ea43e07">More...</a><br /></td></tr>
<tr class="separator:a50ad0e8d7ee212617dbf9e456ea43e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab75942ce88acea7c4766895033c51c6f"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html#ab75942ce88acea7c4766895033c51c6f">operator*</a> ()</td></tr>
<tr class="separator:ab75942ce88acea7c4766895033c51c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6df5500c6398933f60d761188c68895b"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html#a6df5500c6398933f60d761188c68895b">operator*</a> () const</td></tr>
<tr class="separator:a6df5500c6398933f60d761188c68895b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a513fd9e86996eda664b8e5eef5d532e9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">ProtobufIterator</a>&lt; T &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html#a513fd9e86996eda664b8e5eef5d532e9">operator++</a> ()</td></tr>
<tr class="memdesc:a513fd9e86996eda664b8e5eef5d532e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">In-place pre-increment to advance the iterator.  <a href="classvg_1_1io_1_1ProtobufIterator.html#a513fd9e86996eda664b8e5eef5d532e9">More...</a><br /></td></tr>
<tr class="separator:a513fd9e86996eda664b8e5eef5d532e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad57a7afe6c7759074d1c9ffd3c31a4e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html#ad57a7afe6c7759074d1c9ffd3c31a4e0">operator==</a> (const <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">ProtobufIterator</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="separator:ad57a7afe6c7759074d1c9ffd3c31a4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f67a6fcda4cfa7d6d1b37bcdb74c0ac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html#a1f67a6fcda4cfa7d6d1b37bcdb74c0ac">operator!=</a> (const <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">ProtobufIterator</a>&lt; T &gt; &amp;other) const</td></tr>
<tr class="separator:a1f67a6fcda4cfa7d6d1b37bcdb74c0ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59294f819b65352528da9224ea39d973"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html#a59294f819b65352528da9224ea39d973">has_current</a> () const</td></tr>
<tr class="memdesc:a59294f819b65352528da9224ea39d973"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if dereferencing the iterator will produce a valid value, and false otherwise.  <a href="classvg_1_1io_1_1ProtobufIterator.html#a59294f819b65352528da9224ea39d973">More...</a><br /></td></tr>
<tr class="separator:a59294f819b65352528da9224ea39d973"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a300d8f5292f866bd4709c14615cdf9e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html#a300d8f5292f866bd4709c14615cdf9e0">advance</a> ()</td></tr>
<tr class="separator:a300d8f5292f866bd4709c14615cdf9e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32bfe2fea01e8bae7759dff71eb64db8"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html#a32bfe2fea01e8bae7759dff71eb64db8">take</a> ()</td></tr>
<tr class="memdesc:a32bfe2fea01e8bae7759dff71eb64db8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the current item, which must exist, and advance the iterator to the next one.  <a href="classvg_1_1io_1_1ProtobufIterator.html#a32bfe2fea01e8bae7759dff71eb64db8">More...</a><br /></td></tr>
<tr class="separator:a32bfe2fea01e8bae7759dff71eb64db8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b51328b5c897e36803b63a7058b6c61"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html#a6b51328b5c897e36803b63a7058b6c61">tell_group</a> () const</td></tr>
<tr class="separator:a6b51328b5c897e36803b63a7058b6c61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad5921d9a10314f8060b0835225fc3cd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html#aad5921d9a10314f8060b0835225fc3cd">seek_group</a> (int64_t virtual_offset)</td></tr>
<tr class="separator:aad5921d9a10314f8060b0835225fc3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:acf75c4c7a16e406f9bb860e3f0c7dae9"><td class="memItemLeft" align="right" valign="top">static pair&lt; <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">ProtobufIterator</a>&lt; T &gt;, <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">ProtobufIterator</a>&lt; T &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html#acf75c4c7a16e406f9bb860e3f0c7dae9">range</a> (istream &amp;in)</td></tr>
<tr class="memdesc:acf75c4c7a16e406f9bb860e3f0c7dae9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns iterators that act like begin() and end() for a stream containing messages.  <a href="classvg_1_1io_1_1ProtobufIterator.html#acf75c4c7a16e406f9bb860e3f0c7dae9">More...</a><br /></td></tr>
<tr class="separator:acf75c4c7a16e406f9bb860e3f0c7dae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37e50d3f1375c13a223a79938d5094d"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html#ab37e50d3f1375c13a223a79938d5094d">parse_from_string</a> (T &amp;dest, const string &amp;data)</td></tr>
<tr class="separator:ab37e50d3f1375c13a223a79938d5094d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:aec100b14b027d294e2a0aaaaad3b4abd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html#aec100b14b027d294e2a0aaaaad3b4abd">fill_value</a> ()</td></tr>
<tr class="separator:aec100b14b027d294e2a0aaaaad3b4abd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a787d06e13a1799b7e65ee1aa19ec3bb8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html#a787d06e13a1799b7e65ee1aa19ec3bb8">message_it</a></td></tr>
<tr class="separator:a787d06e13a1799b7e65ee1aa19ec3bb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa66494ab08ee29d36b1aa04f0213f566"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html#aa66494ab08ee29d36b1aa04f0213f566">value</a></td></tr>
<tr class="memdesc:aa66494ab08ee29d36b1aa04f0213f566"><td class="mdescLeft">&#160;</td><td class="mdescRight">We always maintain a parsed version of the current message.  <a href="classvg_1_1io_1_1ProtobufIterator.html#aa66494ab08ee29d36b1aa04f0213f566">More...</a><br /></td></tr>
<tr class="separator:aa66494ab08ee29d36b1aa04f0213f566"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class vg::io::ProtobufIterator&lt; T &gt;</h3>

<p>Refactored <a class="el" href="namespacevg_1_1io.html#a08997ecc2a7d17c35a27418b5f21ab3d">io::for_each</a> function that follows the unidirectional iterator interface. Also supports seeking and telling at the group level in bgzip files. Cannot be copied, but can be moved. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0f2996a9653a98470e7c944879a69d70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f2996a9653a98470e7c944879a69d70">&#9670;&nbsp;</a></span>ProtobufIterator() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">vg::io::ProtobufIterator</a>&lt; T &gt;::<a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">ProtobufIterator</a> </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classvg_1_1Constructor.html">Constructor</a>. Uses single-threaded decoding, so methods may be called on the given stream from other code while the <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">ProtobufIterator</a> exists, as long as no <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">ProtobufIterator</a> method is running. </p>

</div>
</div>
<a id="a50ad0e8d7ee212617dbf9e456ea43e07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ad0e8d7ee212617dbf9e456ea43e07">&#9670;&nbsp;</a></span>ProtobufIterator() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">vg::io::ProtobufIterator</a>&lt; T &gt;::<a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">ProtobufIterator</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor for an end iterator. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a300d8f5292f866bd4709c14615cdf9e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a300d8f5292f866bd4709c14615cdf9e0">&#9670;&nbsp;</a></span>advance()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">vg::io::ProtobufIterator</a>&lt; T &gt;::advance</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Advance the iterator to the next message, or the end if this was the last message. Basically the same as ++. </p>

</div>
</div>
<a id="aec100b14b027d294e2a0aaaaad3b4abd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec100b14b027d294e2a0aaaaad3b4abd">&#9670;&nbsp;</a></span>fill_value()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">vg::io::ProtobufIterator</a>&lt; T &gt;::fill_value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Fill in value, if message_it has a value of an appropriate tag. Scans through tag-only groups. </p>

</div>
</div>
<a id="a59294f819b65352528da9224ea39d973"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59294f819b65352528da9224ea39d973">&#9670;&nbsp;</a></span>has_current()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">vg::io::ProtobufIterator</a>&lt; T &gt;::has_current</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if dereferencing the iterator will produce a valid value, and false otherwise. </p>

</div>
</div>
<a id="a1f67a6fcda4cfa7d6d1b37bcdb74c0ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f67a6fcda4cfa7d6d1b37bcdb74c0ac">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">vg::io::ProtobufIterator</a>&lt; T &gt;::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">ProtobufIterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if two iterators are not equal. Since you can only have one on a stream, this only has two equality classes: iterators that have hit the end, and iterators that haven't. </p>

</div>
</div>
<a id="ab75942ce88acea7c4766895033c51c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab75942ce88acea7c4766895033c51c6f">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">vg::io::ProtobufIterator</a>&lt; T &gt;::operator*</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current item. Caller may move it away. Only legal to call if we are not an end iterator. </p>

</div>
</div>
<a id="a6df5500c6398933f60d761188c68895b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6df5500c6398933f60d761188c68895b">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">vg::io::ProtobufIterator</a>&lt; T &gt;::operator* </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the current item when we are const. Only legal to call if we are not an end iterator. </p>

</div>
</div>
<a id="a513fd9e86996eda664b8e5eef5d532e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a513fd9e86996eda664b8e5eef5d532e9">&#9670;&nbsp;</a></span>operator++()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">vg::io::ProtobufIterator</a>&lt; T &gt;::operator++</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In-place pre-increment to advance the iterator. </p>

</div>
</div>
<a id="ad57a7afe6c7759074d1c9ffd3c31a4e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad57a7afe6c7759074d1c9ffd3c31a4e0">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">vg::io::ProtobufIterator</a>&lt; T &gt;::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">ProtobufIterator</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if two iterators are equal. Since you can only have one on a stream, this only has two equality classes: iterators that have hit the end, and iterators that haven't. </p>

</div>
</div>
<a id="ab37e50d3f1375c13a223a79938d5094d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37e50d3f1375c13a223a79938d5094d">&#9670;&nbsp;</a></span>parse_from_string()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">vg::io::ProtobufIterator</a>&lt; T &gt;::parse_from_string </td>
          <td>(</td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Parse a Protobuf message that may be very large from a string. Use this instead of ParseFromString on the message itself.</p>
<p>Returns the result of the parse attempt (i.e. whether it succeeded). </p>

</div>
</div>
<a id="acf75c4c7a16e406f9bb860e3f0c7dae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf75c4c7a16e406f9bb860e3f0c7dae9">&#9670;&nbsp;</a></span>range()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">vg::io::ProtobufIterator</a>&lt; T &gt;::range </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns iterators that act like begin() and end() for a stream containing messages. </p>

</div>
</div>
<a id="aad5921d9a10314f8060b0835225fc3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad5921d9a10314f8060b0835225fc3cd">&#9670;&nbsp;</a></span>seek_group()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">vg::io::ProtobufIterator</a>&lt; T &gt;::seek_group </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>virtual_offset</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Seek to the given virtual offset and start reading the group that is there. The next value produced will be the first value in that group (or in the next group that actually has values). If already at the start of the group at the given virtual offset, does nothing. Return false if seeking is unsupported or the seek fails. </p>

</div>
</div>
<a id="a32bfe2fea01e8bae7759dff71eb64db8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32bfe2fea01e8bae7759dff71eb64db8">&#9670;&nbsp;</a></span>take()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">vg::io::ProtobufIterator</a>&lt; T &gt;::take</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Take the current item, which must exist, and advance the iterator to the next one. </p>

</div>
</div>
<a id="a6b51328b5c897e36803b63a7058b6c61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b51328b5c897e36803b63a7058b6c61">&#9670;&nbsp;</a></span>tell_group()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">vg::io::ProtobufIterator</a>&lt; T &gt;::tell_group</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the virtual offset of the group being currently read (i.e. the group to which the current message belongs), to seek back to. You can't seek back to the current message, just to the start of the group. Returns -1 instead if the underlying file doesn't support seek/tell. Returns the past-the-end virtual offset of the file if EOF is reached. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a787d06e13a1799b7e65ee1aa19ec3bb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787d06e13a1799b7e65ee1aa19ec3bb8">&#9670;&nbsp;</a></span>message_it</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">vg::io::ProtobufIterator</a>&lt; T &gt;::message_it</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Wrap a <a class="el" href="classvg_1_1io_1_1MessageIterator.html">MessageIterator</a> and just do Protobuf parsing on top of that. We always use one that is single-threaded. </p>

</div>
</div>
<a id="aa66494ab08ee29d36b1aa04f0213f566"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa66494ab08ee29d36b1aa04f0213f566">&#9670;&nbsp;</a></span>value</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classvg_1_1io_1_1ProtobufIterator.html">vg::io::ProtobufIterator</a>&lt; T &gt;::value</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We always maintain a parsed version of the current message. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>deps/libvgio/include/vg/io/<a class="el" href="protobuf__iterator_8hpp.html">protobuf_iterator.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
