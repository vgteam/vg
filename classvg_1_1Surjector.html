<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::Surjector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1Surjector.html">Surjector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classvg_1_1Surjector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::Surjector Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;surjector.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::Surjector:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1Surjector.png" usemap="#vg::Surjector_map" alt=""/>
  <map id="vg::Surjector_map" name="vg::Surjector_map">
<area href="classvg_1_1AlignerClient.html" alt="vg::AlignerClient" shape="rect" coords="0,0,105,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3ce06e344f93607bd066fd58d33fc7e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> = pair&lt; pair&lt; string::const_iterator, string::const_iterator &gt;, <a class="el" href="classvg_1_1path__t.html">path_t</a> &gt;</td></tr>
<tr class="memdesc:a3ce06e344f93607bd066fd58d33fc7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">a local type that represents a read interval matched to a portion of the alignment path  <a href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">More...</a><br /></td></tr>
<tr class="separator:a3ce06e344f93607bd066fd58d33fc7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4b083231c3ae02e3e14c3efb2a72eb1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a4b083231c3ae02e3e14c3efb2a72eb1d">Surjector</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>)</td></tr>
<tr class="separator:a4b083231c3ae02e3e14c3efb2a72eb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af039b6915be8799a74c3b75e25b0873d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#af039b6915be8799a74c3b75e25b0873d">set_alignment_scores</a> (const int8_t *score_matrix, int8_t gap_open, int8_t gap_extend, int8_t full_length_bonus)</td></tr>
<tr class="separator:af039b6915be8799a74c3b75e25b0873d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7896e3437d2027aac52c3a0d231bf095"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a7896e3437d2027aac52c3a0d231bf095">surject</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;paths, vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;positions_out, bool allow_negative_scores=false, bool preserve_deletions=false) const</td></tr>
<tr class="separator:a7896e3437d2027aac52c3a0d231bf095"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed6215f3860203803deb2f3078d93b4"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a0ed6215f3860203803deb2f3078d93b4">multi_surject</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;paths, vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;positions_out, bool allow_negative_scores=false, bool preserve_deletions=false) const</td></tr>
<tr class="memdesc:a0ed6215f3860203803deb2f3078d93b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but include alignments to all paths instead of only the optimal one.  <a href="classvg_1_1Surjector.html#a0ed6215f3860203803deb2f3078d93b4">More...</a><br /></td></tr>
<tr class="separator:a0ed6215f3860203803deb2f3078d93b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeefee1b3aab525cf4d45479a4ae5c7e3"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#aeefee1b3aab525cf4d45479a4ae5c7e3">surject</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;paths, bool allow_negative_scores=false, bool preserve_deletions=false) const</td></tr>
<tr class="separator:aeefee1b3aab525cf4d45479a4ae5c7e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b34cbb819829cd493bdc901a6e3060"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ab8b34cbb819829cd493bdc901a6e3060">multi_surject</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;paths, bool allow_negative_scores=false, bool preserve_deletions=false) const</td></tr>
<tr class="memdesc:ab8b34cbb819829cd493bdc901a6e3060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but include alignments to all paths instead of only the optimal one.  <a href="classvg_1_1Surjector.html#ab8b34cbb819829cd493bdc901a6e3060">More...</a><br /></td></tr>
<tr class="separator:ab8b34cbb819829cd493bdc901a6e3060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4dc2199ac1212f45076d27a8303b512"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#af4dc2199ac1212f45076d27a8303b512">surject</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;paths, vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;positions_out, bool allow_negative_scores=false, bool preserve_deletions=false) const</td></tr>
<tr class="separator:af4dc2199ac1212f45076d27a8303b512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943158332e4865de071dca68454a4d77"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a943158332e4865de071dca68454a4d77">multi_surject</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;paths, vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;positions_out, bool allow_negative_scores=false, bool preserve_deletions=false) const</td></tr>
<tr class="memdesc:a943158332e4865de071dca68454a4d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but include alignments to all paths instead of only the optimal one.  <a href="classvg_1_1Surjector.html#a943158332e4865de071dca68454a4d77">More...</a><br /></td></tr>
<tr class="separator:a943158332e4865de071dca68454a4d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe9672e0a82c6540c4d1360070725ec"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aafe9672e0a82c6540c4d1360070725ec"><td class="memTemplItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#aafe9672e0a82c6540c4d1360070725ec">get_score</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="separator:aafe9672e0a82c6540c4d1360070725ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df48f23da07159bb99bc6577d992938"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a4df48f23da07159bb99bc6577d992938"><td class="memTemplItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a4df48f23da07159bb99bc6577d992938">get_score</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;mp_aln)</td></tr>
<tr class="separator:a4df48f23da07159bb99bc6577d992938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680e04421cb7433a87ae1c8285a8f259"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a680e04421cb7433a87ae1c8285a8f259"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a680e04421cb7433a87ae1c8285a8f259">count_mismatches</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="separator:a680e04421cb7433a87ae1c8285a8f259"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac551fef3005e988489eb58382331f7f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aac551fef3005e988489eb58382331f7f"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#aac551fef3005e988489eb58382331f7f">count_mismatches</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;mp_aln)</td></tr>
<tr class="separator:aac551fef3005e988489eb58382331f7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add79a219dac0af10c425080bf2b1a2d6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:add79a219dac0af10c425080bf2b1a2d6"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; pair&lt; int, char &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#add79a219dac0af10c425080bf2b1a2d6">get_cigar</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;surjected, const tuple&lt; string, int64_t, bool &gt; &amp;position, const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, bool spliced) const</td></tr>
<tr class="separator:add79a219dac0af10c425080bf2b1a2d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa960d891ea079958367cd174836a6b8e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa960d891ea079958367cd174836a6b8e"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; pair&lt; int, char &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#aa960d891ea079958367cd174836a6b8e">get_cigar</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;surjected, const tuple&lt; string, int64_t, bool &gt; &amp;position, const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, bool spliced) const</td></tr>
<tr class="separator:aa960d891ea079958367cd174836a6b8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:a1fde3e4537147030d153d403fd04ec77 inherit pub_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a1fde3e4537147030d153d403fd04ec77">set_alignment_scores</a> (int8_t match, int8_t mismatch, int8_t gap_open, int8_t gap_extend, int8_t full_length_bonus)</td></tr>
<tr class="memdesc:a1fde3e4537147030d153d403fd04ec77 inherit pub_methods_classvg_1_1AlignerClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the aligner scoring parameters and create the stored aligner instances.  <a href="classvg_1_1AlignerClient.html#a1fde3e4537147030d153d403fd04ec77">More...</a><br /></td></tr>
<tr class="separator:a1fde3e4537147030d153d403fd04ec77 inherit pub_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdd2fabd7a36353526663aede3cb555 inherit pub_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#adbdd2fabd7a36353526663aede3cb555">set_alignment_scores</a> (std::istream &amp;matrix_stream, int8_t gap_open, int8_t gap_extend, int8_t full_length_bonus)</td></tr>
<tr class="separator:adbdd2fabd7a36353526663aede3cb555 inherit pub_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:aff0ca9cc154747c421ba325fa7048507"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classvg_1_1Aligner.html">Aligner</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#aff0ca9cc154747c421ba325fa7048507">dp_aligner</a></td></tr>
<tr class="memdesc:aff0ca9cc154747c421ba325fa7048507"><td class="mdescLeft">&#160;</td><td class="mdescRight">When doing DP alignments, we use slightly adjusted alignment scores, which need to live in their own <a class="el" href="classvg_1_1Aligner.html">Aligner</a>.  <a href="classvg_1_1Surjector.html#aff0ca9cc154747c421ba325fa7048507">More...</a><br /></td></tr>
<tr class="separator:aff0ca9cc154747c421ba325fa7048507"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9750e6f815ccbcb8ee14be2469f61886"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a9750e6f815ccbcb8ee14be2469f61886">dp_score_scale</a> = 10</td></tr>
<tr class="memdesc:a9750e6f815ccbcb8ee14be2469f61886"><td class="mdescLeft">&#160;</td><td class="mdescRight">When doing DP alignments, we multiply scores by this factor before slightly increasing gap open. (Changes won't take effect until <a class="el" href="classvg_1_1Surjector.html#af039b6915be8799a74c3b75e25b0873d">set_alignment_scores()</a> is called.)  <a href="classvg_1_1Surjector.html#a9750e6f815ccbcb8ee14be2469f61886">More...</a><br /></td></tr>
<tr class="separator:a9750e6f815ccbcb8ee14be2469f61886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0499e86d68aa7e47be96b18bf34a099c"><td class="memItemLeft" align="right" valign="top">int8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a0499e86d68aa7e47be96b18bf34a099c">dp_gap_open_extra_cost</a> = 0</td></tr>
<tr class="memdesc:a0499e86d68aa7e47be96b18bf34a099c"><td class="mdescLeft">&#160;</td><td class="mdescRight">When doing DP alignment, we increase gap open score by this much. (Changes won't take effect until <a class="el" href="classvg_1_1Surjector.html#af039b6915be8799a74c3b75e25b0873d">set_alignment_scores()</a> is called.)  <a href="classvg_1_1Surjector.html#a0499e86d68aa7e47be96b18bf34a099c">More...</a><br /></td></tr>
<tr class="separator:a0499e86d68aa7e47be96b18bf34a099c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9046bb2c7267f996a6636518e2747b89"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a9046bb2c7267f996a6636518e2747b89">min_splice_length</a> = 20</td></tr>
<tr class="memdesc:a9046bb2c7267f996a6636518e2747b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">the minimum length deletion that the spliced algorithm will interpret as a splice event  <a href="classvg_1_1Surjector.html#a9046bb2c7267f996a6636518e2747b89">More...</a><br /></td></tr>
<tr class="separator:a9046bb2c7267f996a6636518e2747b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7092128b309c97f00fc688d3311c14"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ace7092128b309c97f00fc688d3311c14">dominated_path_chunk_diff</a> = 10</td></tr>
<tr class="separator:ace7092128b309c97f00fc688d3311c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5048905a75d047631f3552632f58cd3"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ad5048905a75d047631f3552632f58cd3">min_splice_repair_length</a> = 250</td></tr>
<tr class="memdesc:ad5048905a75d047631f3552632f58cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">the minimum length apparent intron that we will try to repair  <a href="classvg_1_1Surjector.html#ad5048905a75d047631f3552632f58cd3">More...</a><br /></td></tr>
<tr class="separator:ad5048905a75d047631f3552632f58cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185cc3fad9b021b08f03880ae0119db6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a185cc3fad9b021b08f03880ae0119db6">max_tail_length</a> = 10000</td></tr>
<tr class="memdesc:a185cc3fad9b021b08f03880ae0119db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">the maximum length of a tail that we will try to align  <a href="classvg_1_1Surjector.html#a185cc3fad9b021b08f03880ae0119db6">More...</a><br /></td></tr>
<tr class="separator:a185cc3fad9b021b08f03880ae0119db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e22a6f6da976c0b505caa6c1ad10ed8"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a0e22a6f6da976c0b505caa6c1ad10ed8">max_band_cells</a> = 8000000000</td></tr>
<tr class="separator:a0e22a6f6da976c0b505caa6c1ad10ed8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14e20f641f120ca8fa5206ace84be331"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a14e20f641f120ca8fa5206ace84be331">max_subgraph_bases_per_read_base</a> = <a class="el" href="classvg_1_1Surjector.html#ac78645d41b2dfd88bece81c86a5b7090">DEFAULT_SUBGRAPH_LIMIT</a></td></tr>
<tr class="memdesc:a14e20f641f120ca8fa5206ace84be331"><td class="mdescLeft">&#160;</td><td class="mdescRight">How big of a graph (in graph bases per read base) should we ever try to align against for realigning surjection?  <a href="classvg_1_1Surjector.html#a14e20f641f120ca8fa5206ace84be331">More...</a><br /></td></tr>
<tr class="separator:a14e20f641f120ca8fa5206ace84be331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc730407e5de46f16c10fb5168a5b238"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#abc730407e5de46f16c10fb5168a5b238">min_absolute_align_size_to_refuse</a> = 1024</td></tr>
<tr class="memdesc:abc730407e5de46f16c10fb5168a5b238"><td class="mdescLeft">&#160;</td><td class="mdescRight">Don't refuse to align (graph size) * (read size) is at least this size (overrides max_subgraph_bases_per_read_base)  <a href="classvg_1_1Surjector.html#abc730407e5de46f16c10fb5168a5b238">More...</a><br /></td></tr>
<tr class="separator:abc730407e5de46f16c10fb5168a5b238"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21d8c91876c3522c56c4c1c2b8f8f58"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ac21d8c91876c3522c56c4c1c2b8f8f58">min_fold_coverage_for_downsample</a> = 8</td></tr>
<tr class="memdesc:ac21d8c91876c3522c56c4c1c2b8f8f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">in spliced surject, downsample if the base-wise average coverage by chunks is this high  <a href="classvg_1_1Surjector.html#ac21d8c91876c3522c56c4c1c2b8f8f58">More...</a><br /></td></tr>
<tr class="separator:ac21d8c91876c3522c56c4c1c2b8f8f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f599519246cb13464ffe2bbde8bccbe"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a9f599519246cb13464ffe2bbde8bccbe">downsample_coverage</a> = 16</td></tr>
<tr class="memdesc:a9f599519246cb13464ffe2bbde8bccbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">while downsampling, try to get down to this coverage on each base  <a href="classvg_1_1Surjector.html#a9f599519246cb13464ffe2bbde8bccbe">More...</a><br /></td></tr>
<tr class="separator:a9f599519246cb13464ffe2bbde8bccbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731d00674b2d71044a8e404be059c2cf"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a731d00674b2d71044a8e404be059c2cf">min_shift_for_prune</a> = 32 * 1024</td></tr>
<tr class="separator:a731d00674b2d71044a8e404be059c2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3768ca4fe69ba4c58cdbfe81343c56bd"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a3768ca4fe69ba4c58cdbfe81343c56bd">shift_prune_diff</a> = 16 * 1024</td></tr>
<tr class="separator:a3768ca4fe69ba4c58cdbfe81343c56bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb3a5676516b7042d5c2d08734ea3c8"><td class="memItemLeft" align="right" valign="top">atomic_flag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#affb3a5676516b7042d5c2d08734ea3c8">warned_about_subgraph_size</a> = ATOMIC_FLAG_INIT</td></tr>
<tr class="memdesc:affb3a5676516b7042d5c2d08734ea3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">And have we complained about hitting it?  <a href="classvg_1_1Surjector.html#affb3a5676516b7042d5c2d08734ea3c8">More...</a><br /></td></tr>
<tr class="separator:affb3a5676516b7042d5c2d08734ea3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01db9677cefc7952fee698f8ee2b672"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#af01db9677cefc7952fee698f8ee2b672">prune_suspicious_anchors</a> = false</td></tr>
<tr class="separator:af01db9677cefc7952fee698f8ee2b672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59034e11562bb0969c25defd215f166b"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a59034e11562bb0969c25defd215f166b">max_tail_anchor_prune</a> = 4</td></tr>
<tr class="separator:a59034e11562bb0969c25defd215f166b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e40286284b27ccef7fbcc028fc40142"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a0e40286284b27ccef7fbcc028fc40142">max_slide</a> = <a class="el" href="classvg_1_1Surjector.html#a3484c973d05e38e523cc45c85ee4d9f3">DEFAULT_MAX_SLIDE</a></td></tr>
<tr class="separator:a0e40286284b27ccef7fbcc028fc40142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df336db06fea7951c960f71265d513d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a1df336db06fea7951c960f71265d513d">low_complexity_p_value</a> = .0075</td></tr>
<tr class="separator:a1df336db06fea7951c960f71265d513d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f304005022b214c309ff60a1f186b1f"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a0f304005022b214c309ff60a1f186b1f">max_low_complexity_anchor_prune</a> = 40</td></tr>
<tr class="separator:a0f304005022b214c309ff60a1f186b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0cf333d85aef40eda8354075dfa01e"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a9c0cf333d85aef40eda8354075dfa01e">max_low_complexity_anchor_trim</a> = 65</td></tr>
<tr class="separator:a9c0cf333d85aef40eda8354075dfa01e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7231e0ecf35ed767417fc37184b0a806"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a7231e0ecf35ed767417fc37184b0a806">pad_suspicious_anchors_to_length</a> = 12</td></tr>
<tr class="separator:a7231e0ecf35ed767417fc37184b0a806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affc7c08128f0896d0f45637f569d4fd7"><td class="memItemLeft" align="right" valign="top">std::function&lt; size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#affc7c08128f0896d0f45637f569d4fd7">choose_band_padding</a></td></tr>
<tr class="separator:affc7c08128f0896d0f45637f569d4fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a735901a421d305e6cbf13a016fdc9d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a5a735901a421d305e6cbf13a016fdc9d">max_anchors</a> = std::numeric_limits&lt;size_t&gt;::max()</td></tr>
<tr class="separator:a5a735901a421d305e6cbf13a016fdc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c41bbc27465aad02c1d504fcc432064"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a5c41bbc27465aad02c1d504fcc432064">report_supplementary</a> = true</td></tr>
<tr class="memdesc:a5c41bbc27465aad02c1d504fcc432064"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should we report supplementary alignments?  <a href="classvg_1_1Surjector.html#a5c41bbc27465aad02c1d504fcc432064">More...</a><br /></td></tr>
<tr class="separator:a5c41bbc27465aad02c1d504fcc432064"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1746a8cd0e2aee838bc68d4756fc548e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a1746a8cd0e2aee838bc68d4756fc548e">read_length_prop_disjoint_gap</a> = 1.0</td></tr>
<tr class="memdesc:a1746a8cd0e2aee838bc68d4756fc548e"><td class="mdescLeft">&#160;</td><td class="mdescRight">What fraction of a read length separation should we expect before separating into supplementaries?  <a href="classvg_1_1Surjector.html#a1746a8cd0e2aee838bc68d4756fc548e">More...</a><br /></td></tr>
<tr class="separator:a1746a8cd0e2aee838bc68d4756fc548e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab001e8bcb443bd56afacf7ac4fdca7a4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ab001e8bcb443bd56afacf7ac4fdca7a4">max_disjoint_gap</a> = 10000</td></tr>
<tr class="memdesc:ab001e8bcb443bd56afacf7ac4fdca7a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The maximum gap size before we always separate into supplementary alignments.  <a href="classvg_1_1Surjector.html#ab001e8bcb443bd56afacf7ac4fdca7a4">More...</a><br /></td></tr>
<tr class="separator:ab001e8bcb443bd56afacf7ac4fdca7a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa38a6d1a4dd31d0861bebd63238a6536"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#aa38a6d1a4dd31d0861bebd63238a6536">min_disjoint_gap</a> = 50</td></tr>
<tr class="memdesc:aa38a6d1a4dd31d0861bebd63238a6536"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum gap size we should never separate into supplementary alignments.  <a href="classvg_1_1Surjector.html#aa38a6d1a4dd31d0861bebd63238a6536">More...</a><br /></td></tr>
<tr class="separator:aa38a6d1a4dd31d0861bebd63238a6536"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f1f408757b580bfc38a4189651eac85"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a2f1f408757b580bfc38a4189651eac85">disjoint_interval_allowable_overlap</a> = 4</td></tr>
<tr class="memdesc:a2f1f408757b580bfc38a4189651eac85"><td class="mdescLeft">&#160;</td><td class="mdescRight">The max size overlap on the read between supplementaries before we designate them as non-colinear.  <a href="classvg_1_1Surjector.html#a2f1f408757b580bfc38a4189651eac85">More...</a><br /></td></tr>
<tr class="separator:a2f1f408757b580bfc38a4189651eac85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99dc61c54ce73a8db8526b0f935a14c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a99dc61c54ce73a8db8526b0f935a14c9">annotate_with_all_path_scores</a> = false</td></tr>
<tr class="separator:a99dc61c54ce73a8db8526b0f935a14c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b070bccfd79546db5d7b355ec1c67e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a20b070bccfd79546db5d7b355ec1c67e">annotate_with_graph_alignment</a> = false</td></tr>
<tr class="separator:a20b070bccfd79546db5d7b355ec1c67e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:a25db3953c246e94a7e08ef59fc31b82f inherit pub_attribs_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a25db3953c246e94a7e08ef59fc31b82f">adjust_alignments_for_base_quality</a> = false</td></tr>
<tr class="separator:a25db3953c246e94a7e08ef59fc31b82f inherit pub_attribs_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a8af3e56b9463fbbf483e78477f4a7172"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a8af3e56b9463fbbf483e78477f4a7172">SPLICED_DEFAULT_SUBGRAPH_LIMIT</a> = 16 * 1024 * 1024 / 125.0</td></tr>
<tr class="memdesc:a8af3e56b9463fbbf483e78477f4a7172"><td class="mdescLeft">&#160;</td><td class="mdescRight">We have a different default max_subgraph_bases_per_read_base to use for spliced alignment.  <a href="classvg_1_1Surjector.html#a8af3e56b9463fbbf483e78477f4a7172">More...</a><br /></td></tr>
<tr class="separator:a8af3e56b9463fbbf483e78477f4a7172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac78645d41b2dfd88bece81c86a5b7090"><td class="memItemLeft" align="right" valign="top">static constexpr double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ac78645d41b2dfd88bece81c86a5b7090">DEFAULT_SUBGRAPH_LIMIT</a> = 100 * 1024 / 125.0</td></tr>
<tr class="memdesc:ac78645d41b2dfd88bece81c86a5b7090"><td class="mdescLeft">&#160;</td><td class="mdescRight">And an accessible default max_subgraph_bases_per_read_base for normal alignment.  <a href="classvg_1_1Surjector.html#ac78645d41b2dfd88bece81c86a5b7090">More...</a><br /></td></tr>
<tr class="separator:ac78645d41b2dfd88bece81c86a5b7090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3484c973d05e38e523cc45c85ee4d9f3"><td class="memItemLeft" align="right" valign="top">static constexpr int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a3484c973d05e38e523cc45c85ee4d9f3">DEFAULT_MAX_SLIDE</a> = 6</td></tr>
<tr class="separator:a3484c973d05e38e523cc45c85ee4d9f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6150307e30be3bb16531a0c28173bc9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a6150307e30be3bb16531a0c28173bc9d">set_dp_alignment_scores</a> (const int8_t *score_matrix, int8_t gap_open, int8_t gap_extend, int8_t full_length_bonus)</td></tr>
<tr class="memdesc:a6150307e30be3bb16531a0c28173bc9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do the extra score setup for the DP-only <a class="el" href="classvg_1_1Aligner.html">Aligner</a>.  <a href="classvg_1_1Surjector.html#a6150307e30be3bb16531a0c28173bc9d">More...</a><br /></td></tr>
<tr class="separator:a6150307e30be3bb16531a0c28173bc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6474f90fe3cf3ea098a553916bd47ae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a6474f90fe3cf3ea098a553916bd47ae9">surject_internal</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> *source_aln, const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> *source_mp_aln, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; *alns_out, vector&lt; <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &gt; *mp_alns_out, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;paths, vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;positions_out, bool all_paths, bool allow_negative_scores, bool preserve_deletions) const</td></tr>
<tr class="separator:a6474f90fe3cf3ea098a553916bd47ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0b6d8ce7d97f133486567ddab0fafdc"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a>, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ad0b6d8ce7d97f133486567ddab0fafdc">realigning_surject</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle, bool rev_strand, const vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, const vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, bool allow_negative_scores, bool preserve_N_alignments=false, bool sinks_are_anchors=false, bool sources_are_anchors=false, vector&lt; vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt;&gt; *all_path_ranges_out=nullptr, size_t override_read_length=0) const</td></tr>
<tr class="separator:ad0b6d8ce7d97f133486567ddab0fafdc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a787d31065db138e38a66701a4e2aaf73"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a>, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a787d31065db138e38a66701a4e2aaf73">spliced_surject</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *path_position_graph, const string &amp;src_sequence, const string &amp;src_quality, const int32_t src_mapping_quality, const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle, bool rev_strand, vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;connections, bool allow_negative_scores, bool deletions_as_splices) const</td></tr>
<tr class="separator:a787d31065db138e38a66701a4e2aaf73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b7099431a6a5334141760cc8922281"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, pair&lt; vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt;, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#af4b7099431a6a5334141760cc8922281">extract_overlapping_paths</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;surjection_paths) const</td></tr>
<tr class="memdesc:af4b7099431a6a5334141760cc8922281"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the chunks of the alignment path that follow the given reference paths  <a href="classvg_1_1Surjector.html#af4b7099431a6a5334141760cc8922281">More...</a><br /></td></tr>
<tr class="separator:af4b7099431a6a5334141760cc8922281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4dbb4ce6f48d755c91e4931028c6d8"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, pair&lt; vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt;, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#adc4dbb4ce6f48d755c91e4931028c6d8">extract_overlapping_paths</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;surjection_paths, unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt;&gt; &amp;connections_out) const</td></tr>
<tr class="memdesc:adc4dbb4ce6f48d755c91e4931028c6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">same semantics except for a multipath alignment  <a href="classvg_1_1Surjector.html#adc4dbb4ce6f48d755c91e4931028c6d8">More...</a><br /></td></tr>
<tr class="separator:adc4dbb4ce6f48d755c91e4931028c6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ef0f552e2bd46b48a773837cee6c7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ac1ef0f552e2bd46b48a773837cee6c7c">filter_redundant_path_chunks</a> (bool path_rev, vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;connections) const</td></tr>
<tr class="separator:ac1ef0f552e2bd46b48a773837cee6c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34c7f96fff02c5490477fc8ad643908"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ae34c7f96fff02c5490477fc8ad643908">prune_and_trim_anchors</a> (const string &amp;sequence, vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;step_ranges) const</td></tr>
<tr class="separator:ae34c7f96fff02c5490477fc8ad643908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c119adc7f4dc5118c3aaa3618556b0"><td class="memItemLeft" align="right" valign="top">pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a34c119adc7f4dc5118c3aaa3618556b0">compute_path_interval</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> path_handle, bool rev_strand, const vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, const vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, bool no_left_expansion, bool no_right_expansion) const</td></tr>
<tr class="separator:a34c119adc7f4dc5118c3aaa3618556b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca2dd5a5bc4cdf7f78beb068ffd0ab08"><td class="memItemLeft" align="right" valign="top">vector&lt; tuple&lt; size_t, size_t, vector&lt; size_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#aca2dd5a5bc4cdf7f78beb068ffd0ab08">compute_disjoint_path_intervals</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> path_handle, bool rev_strand, const vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, const vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, bool no_left_expansion, bool no_right_expansion, size_t max_gap) const</td></tr>
<tr class="separator:aca2dd5a5bc4cdf7f78beb068ffd0ab08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e7823cc2ce4b65bb8910ef2c1dcbee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ac4e7823cc2ce4b65bb8910ef2c1dcbee">set_path_position</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;init_surj_pos, const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;final_surj_pos, const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;range_begin, const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;range_end, bool rev_strand, string &amp;path_name_out, int64_t &amp;path_pos_out, bool &amp;path_rev_out) const</td></tr>
<tr class="memdesc:ac4e7823cc2ce4b65bb8910ef2c1dcbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">use the graph position bounds and the path range bounds to assign a path position to a surjected read  <a href="classvg_1_1Surjector.html#ac4e7823cc2ce4b65bb8910ef2c1dcbee">More...</a><br /></td></tr>
<tr class="separator:ac4e7823cc2ce4b65bb8910ef2c1dcbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a591ec19ab6c9da5bae0d0c0db5104699"><td class="memTemplParams" colspan="2">template&lt;class AlnType &gt; </td></tr>
<tr class="memitem:a591ec19ab6c9da5bae0d0c0db5104699"><td class="memTemplItemLeft" align="right" valign="top">string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a591ec19ab6c9da5bae0d0c0db5104699">path_score_annotations</a> (const unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, vector&lt; pair&lt; AlnType, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt;&gt;&gt; &amp;surjections) const</td></tr>
<tr class="separator:a591ec19ab6c9da5bae0d0c0db5104699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a630706a67da04c32566c26967c9e0abb"><td class="memTemplParams" colspan="2">template&lt;class AlnType &gt; </td></tr>
<tr class="memitem:a630706a67da04c32566c26967c9e0abb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a630706a67da04c32566c26967c9e0abb">choose_primary_internal</a> (vector&lt; pair&lt; AlnType, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt;&gt; &amp;surjections, const function&lt; void(AlnType &amp;)&gt; &amp;annotate_supplementary) const</td></tr>
<tr class="separator:a630706a67da04c32566c26967c9e0abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2ce924ffa9226c26639baa8173d225b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#aa2ce924ffa9226c26639baa8173d225b">choose_primary</a> (vector&lt; pair&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a>, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt;&gt; &amp;surjections) const</td></tr>
<tr class="separator:aa2ce924ffa9226c26639baa8173d225b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44912a16249b2dc1511346a3b4e95ede"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a44912a16249b2dc1511346a3b4e95ede">choose_primary</a> (vector&lt; pair&lt; <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a>, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt;&gt; &amp;surjections) const</td></tr>
<tr class="separator:a44912a16249b2dc1511346a3b4e95ede"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a4590dc59081d5628c00298dffb47de"><td class="memTemplParams" colspan="2">template&lt;class AlnType &gt; </td></tr>
<tr class="memitem:a8a4590dc59081d5628c00298dffb47de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a8a4590dc59081d5628c00298dffb47de">add_SA_tag_internal</a> (vector&lt; AlnType &gt; &amp;surjected, const vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;positions, const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, bool spliced, const function&lt; void(AlnType &amp;, const string &amp;)&gt; &amp;update_sa) const</td></tr>
<tr class="separator:a8a4590dc59081d5628c00298dffb47de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad880b08eebfd33375dd6e610a45198d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ad880b08eebfd33375dd6e610a45198d4">add_SA_tag</a> (vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;surjected, const vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;positions, const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, bool spliced) const</td></tr>
<tr class="separator:ad880b08eebfd33375dd6e610a45198d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaaeda42ebcfe50377c7f315d8f49a9f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#aeaaeda42ebcfe50377c7f315d8f49a9f">add_SA_tag</a> (vector&lt; <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &gt; &amp;surjected, const vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;positions, const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, bool spliced) const</td></tr>
<tr class="separator:aeaaeda42ebcfe50377c7f315d8f49a9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7270c7421c5b22f7958ac3266642438"><td class="memTemplParams" colspan="2">template&lt;class AlnType &gt; </td></tr>
<tr class="memitem:aa7270c7421c5b22f7958ac3266642438"><td class="memTemplItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#aa7270c7421c5b22f7958ac3266642438">total_overlap</a> (const vector&lt; pair&lt; AlnType, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt;&gt; &amp;surjections) const</td></tr>
<tr class="separator:aa7270c7421c5b22f7958ac3266642438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0a741e980153edb12539769a07cea3"><td class="memTemplParams" colspan="2">template&lt;class AlnType &gt; </td></tr>
<tr class="memitem:a3b0a741e980153edb12539769a07cea3"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a3b0a741e980153edb12539769a07cea3">supplementary_cover</a> (const unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, vector&lt; pair&lt; AlnType, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt;&gt;&gt; &amp;surjections) const</td></tr>
<tr class="separator:a3b0a741e980153edb12539769a07cea3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1b5ad4f031856c0743a25979da0f9e3"><td class="memTemplParams" colspan="2">template&lt;class AlnType &gt; </td></tr>
<tr class="memitem:ac1b5ad4f031856c0743a25979da0f9e3"><td class="memTemplItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ac1b5ad4f031856c0743a25979da0f9e3">choose_primary_strand</a> (const unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, vector&lt; pair&lt; AlnType, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt;&gt;&gt; &amp;surjections, const unordered_set&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;&gt; *among_strands=nullptr) const</td></tr>
<tr class="separator:ac1b5ad4f031856c0743a25979da0f9e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ca84936638bdcb054e3304b6f959f1"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a98ca84936638bdcb054e3304b6f959f1">reverse_adjacencies</a> (const vector&lt; vector&lt; size_t &gt;&gt; &amp;adj) const</td></tr>
<tr class="memdesc:a98ca84936638bdcb054e3304b6f959f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverses an adjacency list  <a href="classvg_1_1Surjector.html#a98ca84936638bdcb054e3304b6f959f1">More...</a><br /></td></tr>
<tr class="separator:a98ca84936638bdcb054e3304b6f959f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bc3c25f2466322fd6ffd67d66c6dfa"><td class="memItemLeft" align="right" valign="top">vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#af7bc3c25f2466322fd6ffd67d66c6dfa">connected_components</a> (const vector&lt; vector&lt; size_t &gt;&gt; &amp;adj, const vector&lt; vector&lt; size_t &gt;&gt; &amp;rev_adj, size_t *num_comps_out) const</td></tr>
<tr class="separator:af7bc3c25f2466322fd6ffd67d66c6dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2149d1e5e6aba2e07b92030e6afc617d"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a2149d1e5e6aba2e07b92030e6afc617d">transitive_reduction</a> (const vector&lt; vector&lt; size_t &gt;&gt; &amp;adj) const</td></tr>
<tr class="memdesc:a2149d1e5e6aba2e07b92030e6afc617d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the transitive reduction of a topologically sorted DAG's adjacency list  <a href="classvg_1_1Surjector.html#a2149d1e5e6aba2e07b92030e6afc617d">More...</a><br /></td></tr>
<tr class="separator:a2149d1e5e6aba2e07b92030e6afc617d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa4eb4d310ac530ed186170dc34dba9"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#aafa4eb4d310ac530ed186170dc34dba9">remove_dominated_chunks</a> (const string &amp;src_sequence, const vector&lt; vector&lt; size_t &gt;&gt; &amp;adj, vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;connections) const</td></tr>
<tr class="memdesc:aafa4eb4d310ac530ed186170dc34dba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">eliminate any path chunks that have the exact same colinearities as another but are much shorter  <a href="classvg_1_1Surjector.html#aafa4eb4d310ac530ed186170dc34dba9">More...</a><br /></td></tr>
<tr class="separator:aafa4eb4d310ac530ed186170dc34dba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59182d764335c01e1d6ce301179f039"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ac59182d764335c01e1d6ce301179f039">cut_anchors</a> (bool rev_strand, vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;connections) const</td></tr>
<tr class="memdesc:ac59182d764335c01e1d6ce301179f039"><td class="mdescLeft">&#160;</td><td class="mdescRight">if any anchors overlap each other, cut the second at the implied overlap position  <a href="classvg_1_1Surjector.html#ac59182d764335c01e1d6ce301179f039">More...</a><br /></td></tr>
<tr class="separator:ac59182d764335c01e1d6ce301179f039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dac1e9d5af63b0fe7c9513afa4909e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a2dac1e9d5af63b0fe7c9513afa4909e1">downsample_chunks</a> (const string &amp;src_sequence, vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;connections) const</td></tr>
<tr class="memdesc:a2dac1e9d5af63b0fe7c9513afa4909e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">if there are too many chunks, downsample to a given level  <a href="classvg_1_1Surjector.html#a2dac1e9d5af63b0fe7c9513afa4909e1">More...</a><br /></td></tr>
<tr class="separator:a2dac1e9d5af63b0fe7c9513afa4909e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b0b7fe9db83a6cfdbebf9dbeb81f04"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; vector&lt; size_t &gt;, vector&lt; size_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a54b0b7fe9db83a6cfdbebf9dbeb81f04">find_constriction_bicliques</a> (const vector&lt; vector&lt; size_t &gt;&gt; &amp;adj, const string &amp;src_sequence, const string &amp;src_quality, vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, const vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;connections) const</td></tr>
<tr class="separator:a54b0b7fe9db83a6cfdbebf9dbeb81f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65da876e448d86bc64985c0b14d3e78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ab65da876e448d86bc64985c0b14d3e78">prune_unconnectable</a> (vector&lt; vector&lt; size_t &gt;&gt; &amp;adj, vector&lt; vector&lt; tuple&lt; size_t, int32_t, bool &gt;&gt;&gt; &amp;splice_adj, vector&lt; size_t &gt; &amp;component, vector&lt; vector&lt; size_t &gt;&gt; &amp;comp_groups, vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks) const</td></tr>
<tr class="separator:ab65da876e448d86bc64985c0b14d3e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae70dd73663bac5290ae8bea071398687"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ae70dd73663bac5290ae8bea071398687">annotate_graph_cigar</a> (vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;surjections, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, bool rev_strand) const</td></tr>
<tr class="separator:ae70dd73663bac5290ae8bea071398687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63dbbe536119793928a5468ae1d6b4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#aa63dbbe536119793928a5468ae1d6b4d">annotate_graph_cigar</a> (vector&lt; <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &gt; &amp;surjections, const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;source, bool rev_strand) const</td></tr>
<tr class="separator:aa63dbbe536119793928a5468ae1d6b4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed30e68cefd8c6b71b74db1274bffffa"><td class="memTemplParams" colspan="2">template&lt;class AlnType &gt; </td></tr>
<tr class="memitem:aed30e68cefd8c6b71b74db1274bffffa"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; pair&lt; int, char &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#aed30e68cefd8c6b71b74db1274bffffa">get_cigar</a> (const AlnType &amp;surjected, const tuple&lt; string, int64_t, bool &gt; &amp;position, const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, bool spliced) const</td></tr>
<tr class="separator:aed30e68cefd8c6b71b74db1274bffffa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:a2f3a789bca074bfbbeb327e74992d9cc inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a2f3a789bca074bfbbeb327e74992d9cc">AlignerClient</a> (double <a class="el" href="classvg_1_1AlignerClient.html#a65428f092aaa5d894b709e247cf0121a">gc_content_estimate</a>=vg::default_gc_content)</td></tr>
<tr class="separator:a2f3a789bca074bfbbeb327e74992d9cc inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683c04ab96b613ea3459738beffe5982 inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a683c04ab96b613ea3459738beffe5982">get_aligner</a> (bool have_qualities=true) const</td></tr>
<tr class="separator:a683c04ab96b613ea3459738beffe5982 inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84332f52915c20b2f2db1e060736fb5 inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#aa84332f52915c20b2f2db1e060736fb5">get_qual_adj_aligner</a> () const</td></tr>
<tr class="separator:aa84332f52915c20b2f2db1e060736fb5 inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d4602ba9be4861136af507f8eacaec inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a60d4602ba9be4861136af507f8eacaec">get_regular_aligner</a> () const</td></tr>
<tr class="separator:a60d4602ba9be4861136af507f8eacaec inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:af8dbc45f01d2f644ea647693ee01478e"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#af8dbc45f01d2f644ea647693ee01478e">update_tag_string_for_SA</a> (const string &amp;tags, const string &amp;sa_val)</td></tr>
<tr class="separator:af8dbc45f01d2f644ea647693ee01478e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a139ffe849fc1164217e45ea5755fc518"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a139ffe849fc1164217e45ea5755fc518">make_null_alignment</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source)</td></tr>
<tr class="memdesc:a139ffe849fc1164217e45ea5755fc518"><td class="mdescLeft">&#160;</td><td class="mdescRight">make a sentinel meant to indicate an unmapped read  <a href="classvg_1_1Surjector.html#a139ffe849fc1164217e45ea5755fc518">More...</a><br /></td></tr>
<tr class="separator:a139ffe849fc1164217e45ea5755fc518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db137631f3315ede2f6887334a161b4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a7db137631f3315ede2f6887334a161b4">make_null_mp_alignment</a> (const string &amp;src_sequence, const string &amp;src_quality)</td></tr>
<tr class="separator:a7db137631f3315ede2f6887334a161b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d2fa6bd9590a02329f31666fbe0cd5"><td class="memTemplParams" colspan="2">template&lt;class AlnType &gt; </td></tr>
<tr class="memitem:a42d2fa6bd9590a02329f31666fbe0cd5"><td class="memTemplItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a42d2fa6bd9590a02329f31666fbe0cd5">get_score</a> (const AlnType &amp;aln)</td></tr>
<tr class="separator:a42d2fa6bd9590a02329f31666fbe0cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2ff0e63ab5c747529e56c38338e0d7"><td class="memTemplParams" colspan="2">template&lt;class AlnType &gt; </td></tr>
<tr class="memitem:a1a2ff0e63ab5c747529e56c38338e0d7"><td class="memTemplItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a1a2ff0e63ab5c747529e56c38338e0d7">count_mismatches</a> (const AlnType &amp;surjected)</td></tr>
<tr class="separator:a1a2ff0e63ab5c747529e56c38338e0d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a118010284d37b604a7bcd7eb8dd13537"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a> = nullptr</td></tr>
<tr class="memdesc:a118010284d37b604a7bcd7eb8dd13537"><td class="mdescLeft">&#160;</td><td class="mdescRight">the graph we're surjecting onto  <a href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">More...</a><br /></td></tr>
<tr class="separator:a118010284d37b604a7bcd7eb8dd13537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_attribs_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pro_attribs_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Protected Attributes inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:a65428f092aaa5d894b709e247cf0121a inherit pro_attribs_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a65428f092aaa5d894b709e247cf0121a">gc_content_estimate</a></td></tr>
<tr class="separator:a65428f092aaa5d894b709e247cf0121a inherit pro_attribs_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:a4a56c0bf099b670763c0f5ce3653811b inherit pub_static_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">static int8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a4a56c0bf099b670763c0f5ce3653811b">parse_matrix</a> (std::istream &amp;matrix_stream)</td></tr>
<tr class="memdesc:a4a56c0bf099b670763c0f5ce3653811b inherit pub_static_methods_classvg_1_1AlignerClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an array to hold a 4x4 substitution matrix and returns it.  <a href="classvg_1_1AlignerClient.html#a4a56c0bf099b670763c0f5ce3653811b">More...</a><br /></td></tr>
<tr class="separator:a4a56c0bf099b670763c0f5ce3653811b inherit pub_static_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Widget to surject alignments down to linear paths in the graph.</p>
<p>Assumes the alignments actually go with the graph; the caller is repsonsible for ensuring that e.g. all nodes referenced by the alignments actually exist. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3ce06e344f93607bd066fd58d33fc7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce06e344f93607bd066fd58d33fc7e0">&#9670;&nbsp;</a></span>path_chunk_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">vg::Surjector::path_chunk_t</a> =  pair&lt;pair&lt;string::const_iterator, string::const_iterator&gt;, <a class="el" href="classvg_1_1path__t.html">path_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a local type that represents a read interval matched to a portion of the alignment path </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4b083231c3ae02e3e14c3efb2a72eb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b083231c3ae02e3e14c3efb2a72eb1d">&#9670;&nbsp;</a></span>Surjector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::Surjector::Surjector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad880b08eebfd33375dd6e610a45198d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad880b08eebfd33375dd6e610a45198d4">&#9670;&nbsp;</a></span>add_SA_tag() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::add_SA_tag </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>surjected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>spliced</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeaaeda42ebcfe50377c7f315d8f49a9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaaeda42ebcfe50377c7f315d8f49a9f">&#9670;&nbsp;</a></span>add_SA_tag() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::add_SA_tag </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>surjected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>spliced</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a4590dc59081d5628c00298dffb47de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a4590dc59081d5628c00298dffb47de">&#9670;&nbsp;</a></span>add_SA_tag_internal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AlnType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::add_SA_tag_internal </td>
          <td>(</td>
          <td class="paramtype">vector&lt; AlnType &gt; &amp;&#160;</td>
          <td class="paramname"><em>surjected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>spliced</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(AlnType &amp;, const string &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>update_sa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae70dd73663bac5290ae8bea071398687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae70dd73663bac5290ae8bea071398687">&#9670;&nbsp;</a></span>annotate_graph_cigar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::annotate_graph_cigar </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>surjections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev_strand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa63dbbe536119793928a5468ae1d6b4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63dbbe536119793928a5468ae1d6b4d">&#9670;&nbsp;</a></span>annotate_graph_cigar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::annotate_graph_cigar </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>surjections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev_strand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2ce924ffa9226c26639baa8173d225b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2ce924ffa9226c26639baa8173d225b">&#9670;&nbsp;</a></span>choose_primary() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::choose_primary </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a>, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surjections</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44912a16249b2dc1511346a3b4e95ede"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44912a16249b2dc1511346a3b4e95ede">&#9670;&nbsp;</a></span>choose_primary() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::choose_primary </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a>, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surjections</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a630706a67da04c32566c26967c9e0abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a630706a67da04c32566c26967c9e0abb">&#9670;&nbsp;</a></span>choose_primary_internal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AlnType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::choose_primary_internal </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; AlnType, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surjections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(AlnType &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>annotate_supplementary</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac1b5ad4f031856c0743a25979da0f9e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1b5ad4f031856c0743a25979da0f9e3">&#9670;&nbsp;</a></span>choose_primary_strand()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AlnType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt; vg::Surjector::choose_primary_strand </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, vector&lt; pair&lt; AlnType, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surjections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;&gt; *&#160;</td>
          <td class="paramname"><em>among_strands</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aca2dd5a5bc4cdf7f78beb068ffd0ab08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca2dd5a5bc4cdf7f78beb068ffd0ab08">&#9670;&nbsp;</a></span>compute_disjoint_path_intervals()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; tuple&lt; size_t, size_t, vector&lt; size_t &gt; &gt; &gt; vg::Surjector::compute_disjoint_path_intervals </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td>
          <td class="paramname"><em>path_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev_strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_left_expansion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_right_expansion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_gap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute a set of end-inclusive intervals of path positions that the realign sequence could align to, and associate with each one a vector indexes into path_chunks to indicate which path chunks it contains. </p>

</div>
</div>
<a id="a34c119adc7f4dc5118c3aaa3618556b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c119adc7f4dc5118c3aaa3618556b0">&#9670;&nbsp;</a></span>compute_path_interval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;size_t, size_t&gt; vg::Surjector::compute_path_interval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td>
          <td class="paramname"><em>path_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev_strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_left_expansion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_right_expansion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the widest end-inclusive interval of path positions that the realigned sequence could align to, or an interval where start &gt; end if there are no path chunks. </p>

</div>
</div>
<a id="af7bc3c25f2466322fd6ffd67d66c6dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bc3c25f2466322fd6ffd67d66c6dfa">&#9670;&nbsp;</a></span>connected_components()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; size_t &gt; vg::Surjector::connected_components </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rev_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>num_comps_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns a vector assignming each node to a connectd component, requires both the forward and reverse adjacency lists. optionally also returns the total number of components </p>

</div>
</div>
<a id="a680e04421cb7433a87ae1c8285a8f259"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680e04421cb7433a87ae1c8285a8f259">&#9670;&nbsp;</a></span>count_mismatches() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::Surjector::count_mismatches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a2ff0e63ab5c747529e56c38338e0d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2ff0e63ab5c747529e56c38338e0d7">&#9670;&nbsp;</a></span>count_mismatches() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AlnType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static size_t vg::Surjector::count_mismatches </td>
          <td>(</td>
          <td class="paramtype">const AlnType &amp;&#160;</td>
          <td class="paramname"><em>surjected</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aac551fef3005e988489eb58382331f7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac551fef3005e988489eb58382331f7f">&#9670;&nbsp;</a></span>count_mismatches() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::Surjector::count_mismatches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mp_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac59182d764335c01e1d6ce301179f039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59182d764335c01e1d6ce301179f039">&#9670;&nbsp;</a></span>cut_anchors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::cut_anchors </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev_strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if any anchors overlap each other, cut the second at the implied overlap position </p>

</div>
</div>
<a id="a2dac1e9d5af63b0fe7c9513afa4909e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dac1e9d5af63b0fe7c9513afa4909e1">&#9670;&nbsp;</a></span>downsample_chunks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::downsample_chunks </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if there are too many chunks, downsample to a given level </p>

</div>
</div>
<a id="af4b7099431a6a5334141760cc8922281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b7099431a6a5334141760cc8922281">&#9670;&nbsp;</a></span>extract_overlapping_paths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, pair&lt; vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">Surjector::path_chunk_t</a> &gt;, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &gt; &gt; &gt; vg::Surjector::extract_overlapping_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>surjection_paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the chunks of the alignment path that follow the given reference paths </p>

</div>
</div>
<a id="adc4dbb4ce6f48d755c91e4931028c6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4dbb4ce6f48d755c91e4931028c6d8">&#9670;&nbsp;</a></span>extract_overlapping_paths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, pair&lt; vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">Surjector::path_chunk_t</a> &gt;, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &gt; &gt; &gt; vg::Surjector::extract_overlapping_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>surjection_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connections_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>same semantics except for a multipath alignment </p>

</div>
</div>
<a id="ac1ef0f552e2bd46b48a773837cee6c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ef0f552e2bd46b48a773837cee6c7c">&#9670;&nbsp;</a></span>filter_redundant_path_chunks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::filter_redundant_path_chunks </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>path_rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>remove any path chunks and corresponding ref chunks that are identical to a longer path chunk over the region where they overlap </p>

</div>
</div>
<a id="a54b0b7fe9db83a6cfdbebf9dbeb81f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b0b7fe9db83a6cfdbebf9dbeb81f04">&#9670;&nbsp;</a></span>find_constriction_bicliques()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; vector&lt; size_t &gt;, vector&lt; size_t &gt; &gt; &gt; vg::Surjector::find_constriction_bicliques </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_quality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns all sets of chunks such that 1) all of chunks on the left set abut all of the chunks on the right set on the read, 2) all source-to-sink paths in the connected component go through an edge between the left and right sides, 3) all of the chunks that do not have a connection between them are fully connected (i.e. form a biclique) </p>

</div>
</div>
<a id="add79a219dac0af10c425080bf2b1a2d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add79a219dac0af10c425080bf2b1a2d6">&#9670;&nbsp;</a></span>get_cigar() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;pair&lt;int, char&gt; &gt; vg::Surjector::get_cigar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>surjected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tuple&lt; string, int64_t, bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>spliced</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed30e68cefd8c6b71b74db1274bffffa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed30e68cefd8c6b71b74db1274bffffa">&#9670;&nbsp;</a></span>get_cigar() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AlnType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;pair&lt;int, char&gt; &gt; vg::Surjector::get_cigar </td>
          <td>(</td>
          <td class="paramtype">const AlnType &amp;&#160;</td>
          <td class="paramname"><em>surjected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tuple&lt; string, int64_t, bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>spliced</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa960d891ea079958367cd174836a6b8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa960d891ea079958367cd174836a6b8e">&#9670;&nbsp;</a></span>get_cigar() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;pair&lt;int, char&gt; &gt; vg::Surjector::get_cigar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>surjected</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tuple&lt; string, int64_t, bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>position</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>spliced</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aafe9672e0a82c6540c4d1360070725ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe9672e0a82c6540c4d1360070725ec">&#9670;&nbsp;</a></span>get_score() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::Surjector::get_score </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42d2fa6bd9590a02329f31666fbe0cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d2fa6bd9590a02329f31666fbe0cd5">&#9670;&nbsp;</a></span>get_score() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AlnType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t vg::Surjector::get_score </td>
          <td>(</td>
          <td class="paramtype">const AlnType &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4df48f23da07159bb99bc6577d992938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df48f23da07159bb99bc6577d992938">&#9670;&nbsp;</a></span>get_score() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::Surjector::get_score </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mp_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a139ffe849fc1164217e45ea5755fc518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139ffe849fc1164217e45ea5755fc518">&#9670;&nbsp;</a></span>make_null_alignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::Surjector::make_null_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>make a sentinel meant to indicate an unmapped read </p>

</div>
</div>
<a id="a7db137631f3315ede2f6887334a161b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db137631f3315ede2f6887334a161b4">&#9670;&nbsp;</a></span>make_null_mp_alignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> vg::Surjector::make_null_mp_alignment </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8b34cbb819829cd493bdc901a6e3060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b34cbb819829cd493bdc901a6e3060">&#9670;&nbsp;</a></span>multi_surject() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::Surjector::multi_surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_deletions</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above, but include alignments to all paths instead of only the optimal one. </p>

</div>
</div>
<a id="a0ed6215f3860203803deb2f3078d93b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed6215f3860203803deb2f3078d93b4">&#9670;&nbsp;</a></span>multi_surject() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::Surjector::multi_surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>positions_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_deletions</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above, but include alignments to all paths instead of only the optimal one. </p>

</div>
</div>
<a id="a943158332e4865de071dca68454a4d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943158332e4865de071dca68454a4d77">&#9670;&nbsp;</a></span>multi_surject() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &gt; vg::Surjector::multi_surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>positions_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_deletions</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above, but include alignments to all paths instead of only the optimal one. </p>

</div>
</div>
<a id="a591ec19ab6c9da5bae0d0c0db5104699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a591ec19ab6c9da5bae0d0c0db5104699">&#9670;&nbsp;</a></span>path_score_annotations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AlnType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::Surjector::path_score_annotations </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, vector&lt; pair&lt; AlnType, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surjections</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae34c7f96fff02c5490477fc8ad643908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34c7f96fff02c5490477fc8ad643908">&#9670;&nbsp;</a></span>prune_and_trim_anchors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::prune_and_trim_anchors </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>step_ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab65da876e448d86bc64985c0b14d3e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65da876e448d86bc64985c0b14d3e78">&#9670;&nbsp;</a></span>prune_unconnectable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::prune_unconnectable </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; tuple&lt; size_t, int32_t, bool &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>splice_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>comp_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0b6d8ce7d97f133486567ddab0fafdc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0b6d8ce7d97f133486567ddab0fafdc">&#9670;&nbsp;</a></span>realigning_surject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a>, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &gt; &gt; vg::Surjector::realigning_surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev_strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_N_alignments</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sinks_are_anchors</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sources_are_anchors</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt;&gt; *&#160;</td>
          <td class="paramname"><em>all_path_ranges_out</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>override_read_length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aafa4eb4d310ac530ed186170dc34dba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa4eb4d310ac530ed186170dc34dba9">&#9670;&nbsp;</a></span>remove_dominated_chunks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; size_t &gt; &gt; vg::Surjector::remove_dominated_chunks </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>eliminate any path chunks that have the exact same colinearities as another but are much shorter </p>

</div>
</div>
<a id="a98ca84936638bdcb054e3304b6f959f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ca84936638bdcb054e3304b6f959f1">&#9670;&nbsp;</a></span>reverse_adjacencies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; size_t &gt; &gt; vg::Surjector::reverse_adjacencies </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reverses an adjacency list </p>

</div>
</div>
<a id="af039b6915be8799a74c3b75e25b0873d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af039b6915be8799a74c3b75e25b0873d">&#9670;&nbsp;</a></span>set_alignment_scores()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::set_alignment_scores </td>
          <td>(</td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>score_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>gap_open</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>gap_extend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>full_length_bonus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Override alignment score setting to let DP use slightly adjusted scores. The provided scores will be adjusted to increase gap open cost slightly when doing DP, but output scores will be scored with the provided parameters. </p>

<p>Reimplemented from <a class="el" href="classvg_1_1AlignerClient.html#a79424f53b6e4f588da23ea531a600b84">vg::AlignerClient</a>.</p>

</div>
</div>
<a id="a6150307e30be3bb16531a0c28173bc9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6150307e30be3bb16531a0c28173bc9d">&#9670;&nbsp;</a></span>set_dp_alignment_scores()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::set_dp_alignment_scores </td>
          <td>(</td>
          <td class="paramtype">const int8_t *&#160;</td>
          <td class="paramname"><em>score_matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>gap_open</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>gap_extend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>full_length_bonus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Do the extra score setup for the DP-only <a class="el" href="classvg_1_1Aligner.html">Aligner</a>. </p>

</div>
</div>
<a id="ac4e7823cc2ce4b65bb8910ef2c1dcbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e7823cc2ce4b65bb8910ef2c1dcbee">&#9670;&nbsp;</a></span>set_path_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::set_path_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>init_surj_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>final_surj_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>range_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev_strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>path_name_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>path_pos_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>path_rev_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>use the graph position bounds and the path range bounds to assign a path position to a surjected read </p>

</div>
</div>
<a id="a787d31065db138e38a66701a4e2aaf73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a787d31065db138e38a66701a4e2aaf73">&#9670;&nbsp;</a></span>spliced_surject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a>, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &gt; &gt; vg::Surjector::spliced_surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>path_position_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_quality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>src_mapping_quality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev_strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deletions_as_splices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b0a741e980153edb12539769a07cea3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0a741e980153edb12539769a07cea3">&#9670;&nbsp;</a></span>supplementary_cover()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AlnType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt; &gt; vg::Surjector::supplementary_cover </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, vector&lt; pair&lt; AlnType, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surjections</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeefee1b3aab525cf4d45479a4ae5c7e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeefee1b3aab525cf4d45479a4ae5c7e3">&#9670;&nbsp;</a></span>surject() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::Surjector::surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_deletions</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the portions of an alignment that are on a chosen set of paths and try to align realign the portions that are off of the chosen paths to the intervening path segments to obtain an alignment that is fully restricted to the paths.</p>
<p>Replaces the alignment's refpos with the path name, position, and strand the alignment has been surjected to.</p>
<p>Optionally either allow softclips so that the alignment has a nonnegative score on the path or require the full-length alignment, possibly creating a negative score.</p>
<p>Also optionally leaves deletions against the reference path in the final alignment (useful for splicing). </p>

</div>
</div>
<a id="a7896e3437d2027aac52c3a0d231bf095"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7896e3437d2027aac52c3a0d231bf095">&#9670;&nbsp;</a></span>surject() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::Surjector::surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>positions_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_deletions</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the portions of an alignment that are on a chosen set of paths and try to align realign the portions thaet are off of the chosen paths to the intervening path segments to obtain an alignment that is fully restricted to the paths.</p>
<p>Also returns the path name, position, and strand of the new alignment.</p>
<p>Optionally either allow softclips so that the alignment has a nonnegative score on the path or require the full-length alignment, possibly creating a negative score.</p>
<p>Also optionally leaves deletions against the reference path in the final alignment (useful for splicing). </p>

</div>
</div>
<a id="af4dc2199ac1212f45076d27a8303b512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4dc2199ac1212f45076d27a8303b512">&#9670;&nbsp;</a></span>surject() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &gt; vg::Surjector::surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>positions_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_deletions</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same semantics as with alignments except that connections are always preserved as splices. The output consists of a multipath alignment with a single path, separated by splices (either from large deletions or from connections) </p>

</div>
</div>
<a id="a6474f90fe3cf3ea098a553916bd47ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6474f90fe3cf3ea098a553916bd47ae9">&#9670;&nbsp;</a></span>surject_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::surject_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> *&#160;</td>
          <td class="paramname"><em>source_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> *&#160;</td>
          <td class="paramname"><em>source_mp_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; *&#160;</td>
          <td class="paramname"><em>alns_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &gt; *&#160;</td>
          <td class="paramname"><em>mp_alns_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>positions_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_deletions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa7270c7421c5b22f7958ac3266642438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7270c7421c5b22f7958ac3266642438">&#9670;&nbsp;</a></span>total_overlap()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AlnType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::total_overlap </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; pair&lt; AlnType, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surjections</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2149d1e5e6aba2e07b92030e6afc617d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2149d1e5e6aba2e07b92030e6afc617d">&#9670;&nbsp;</a></span>transitive_reduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; size_t &gt; &gt; vg::Surjector::transitive_reduction </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the transitive reduction of a topologically sorted DAG's adjacency list </p>

</div>
</div>
<a id="af8dbc45f01d2f644ea647693ee01478e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8dbc45f01d2f644ea647693ee01478e">&#9670;&nbsp;</a></span>update_tag_string_for_SA()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::Surjector::update_tag_string_for_SA </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sa_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a99dc61c54ce73a8db8526b0f935a14c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99dc61c54ce73a8db8526b0f935a14c9">&#9670;&nbsp;</a></span>annotate_with_all_path_scores</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Surjector::annotate_with_all_path_scores = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a20b070bccfd79546db5d7b355ec1c67e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20b070bccfd79546db5d7b355ec1c67e">&#9670;&nbsp;</a></span>annotate_with_graph_alignment</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Surjector::annotate_with_graph_alignment = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="affc7c08128f0896d0f45637f569d4fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affc7c08128f0896d0f45637f569d4fd7">&#9670;&nbsp;</a></span>choose_band_padding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a>&amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a>&amp;)&gt; vg::Surjector::choose_band_padding</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3484c973d05e38e523cc45c85ee4d9f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3484c973d05e38e523cc45c85ee4d9f3">&#9670;&nbsp;</a></span>DEFAULT_MAX_SLIDE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr int64_t vg::Surjector::DEFAULT_MAX_SLIDE = 6</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac78645d41b2dfd88bece81c86a5b7090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac78645d41b2dfd88bece81c86a5b7090">&#9670;&nbsp;</a></span>DEFAULT_SUBGRAPH_LIMIT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double vg::Surjector::DEFAULT_SUBGRAPH_LIMIT = 100 * 1024 / 125.0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>And an accessible default max_subgraph_bases_per_read_base for normal alignment. </p>

</div>
</div>
<a id="a2f1f408757b580bfc38a4189651eac85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f1f408757b580bfc38a4189651eac85">&#9670;&nbsp;</a></span>disjoint_interval_allowable_overlap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::disjoint_interval_allowable_overlap = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The max size overlap on the read between supplementaries before we designate them as non-colinear. </p>

</div>
</div>
<a id="ace7092128b309c97f00fc688d3311c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7092128b309c97f00fc688d3311c14">&#9670;&nbsp;</a></span>dominated_path_chunk_diff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::dominated_path_chunk_diff = 10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f599519246cb13464ffe2bbde8bccbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f599519246cb13464ffe2bbde8bccbe">&#9670;&nbsp;</a></span>downsample_coverage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::downsample_coverage = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>while downsampling, try to get down to this coverage on each base </p>

</div>
</div>
<a id="aff0ca9cc154747c421ba325fa7048507"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff0ca9cc154747c421ba325fa7048507">&#9670;&nbsp;</a></span>dp_aligner</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt;<a class="el" href="classvg_1_1Aligner.html">Aligner</a>&gt; vg::Surjector::dp_aligner</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When doing DP alignments, we use slightly adjusted alignment scores, which need to live in their own <a class="el" href="classvg_1_1Aligner.html">Aligner</a>. </p>

</div>
</div>
<a id="a0499e86d68aa7e47be96b18bf34a099c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0499e86d68aa7e47be96b18bf34a099c">&#9670;&nbsp;</a></span>dp_gap_open_extra_cost</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t vg::Surjector::dp_gap_open_extra_cost = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When doing DP alignment, we increase gap open score by this much. (Changes won't take effect until <a class="el" href="classvg_1_1Surjector.html#af039b6915be8799a74c3b75e25b0873d">set_alignment_scores()</a> is called.) </p>

</div>
</div>
<a id="a9750e6f815ccbcb8ee14be2469f61886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9750e6f815ccbcb8ee14be2469f61886">&#9670;&nbsp;</a></span>dp_score_scale</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int8_t vg::Surjector::dp_score_scale = 10</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>When doing DP alignments, we multiply scores by this factor before slightly increasing gap open. (Changes won't take effect until <a class="el" href="classvg_1_1Surjector.html#af039b6915be8799a74c3b75e25b0873d">set_alignment_scores()</a> is called.) </p>

</div>
</div>
<a id="a118010284d37b604a7bcd7eb8dd13537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118010284d37b604a7bcd7eb8dd13537">&#9670;&nbsp;</a></span>graph</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a>* vg::Surjector::graph = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the graph we're surjecting onto </p>

</div>
</div>
<a id="a1df336db06fea7951c960f71265d513d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df336db06fea7951c960f71265d513d">&#9670;&nbsp;</a></span>low_complexity_p_value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::Surjector::low_complexity_p_value = .0075</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a735901a421d305e6cbf13a016fdc9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a735901a421d305e6cbf13a016fdc9d">&#9670;&nbsp;</a></span>max_anchors</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::Surjector::max_anchors = std::numeric_limits&lt;size_t&gt;::max()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>How many anchors (per path) will we use when surjecting using anchors? Excessive anchors will be pruned away. </p>

</div>
</div>
<a id="a0e22a6f6da976c0b505caa6c1ad10ed8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e22a6f6da976c0b505caa6c1ad10ed8">&#9670;&nbsp;</a></span>max_band_cells</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::Surjector::max_band_cells = 8000000000</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab001e8bcb443bd56afacf7ac4fdca7a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab001e8bcb443bd56afacf7ac4fdca7a4">&#9670;&nbsp;</a></span>max_disjoint_gap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::Surjector::max_disjoint_gap = 10000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The maximum gap size before we always separate into supplementary alignments. </p>

</div>
</div>
<a id="a0f304005022b214c309ff60a1f186b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f304005022b214c309ff60a1f186b1f">&#9670;&nbsp;</a></span>max_low_complexity_anchor_prune</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::max_low_complexity_anchor_prune = 40</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c0cf333d85aef40eda8354075dfa01e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0cf333d85aef40eda8354075dfa01e">&#9670;&nbsp;</a></span>max_low_complexity_anchor_trim</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::max_low_complexity_anchor_trim = 65</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0e40286284b27ccef7fbcc028fc40142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e40286284b27ccef7fbcc028fc40142">&#9670;&nbsp;</a></span>max_slide</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::max_slide = <a class="el" href="classvg_1_1Surjector.html#a3484c973d05e38e523cc45c85ee4d9f3">DEFAULT_MAX_SLIDE</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Declare an anchor suspicious if it appears again at any offset up to this limit or the anchor length. </p>

</div>
</div>
<a id="a14e20f641f120ca8fa5206ace84be331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14e20f641f120ca8fa5206ace84be331">&#9670;&nbsp;</a></span>max_subgraph_bases_per_read_base</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::Surjector::max_subgraph_bases_per_read_base = <a class="el" href="classvg_1_1Surjector.html#ac78645d41b2dfd88bece81c86a5b7090">DEFAULT_SUBGRAPH_LIMIT</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How big of a graph (in graph bases per read base) should we ever try to align against for realigning surjection? </p>

</div>
</div>
<a id="a59034e11562bb0969c25defd215f166b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59034e11562bb0969c25defd215f166b">&#9670;&nbsp;</a></span>max_tail_anchor_prune</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::max_tail_anchor_prune = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a185cc3fad9b021b08f03880ae0119db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185cc3fad9b021b08f03880ae0119db6">&#9670;&nbsp;</a></span>max_tail_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::Surjector::max_tail_length = 10000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the maximum length of a tail that we will try to align </p>

</div>
</div>
<a id="abc730407e5de46f16c10fb5168a5b238"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc730407e5de46f16c10fb5168a5b238">&#9670;&nbsp;</a></span>min_absolute_align_size_to_refuse</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::min_absolute_align_size_to_refuse = 1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Don't refuse to align (graph size) * (read size) is at least this size (overrides max_subgraph_bases_per_read_base) </p>

</div>
</div>
<a id="aa38a6d1a4dd31d0861bebd63238a6536"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa38a6d1a4dd31d0861bebd63238a6536">&#9670;&nbsp;</a></span>min_disjoint_gap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::Surjector::min_disjoint_gap = 50</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The minimum gap size we should never separate into supplementary alignments. </p>

</div>
</div>
<a id="ac21d8c91876c3522c56c4c1c2b8f8f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21d8c91876c3522c56c4c1c2b8f8f58">&#9670;&nbsp;</a></span>min_fold_coverage_for_downsample</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::min_fold_coverage_for_downsample = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>in spliced surject, downsample if the base-wise average coverage by chunks is this high </p>

</div>
</div>
<a id="a731d00674b2d71044a8e404be059c2cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731d00674b2d71044a8e404be059c2cf">&#9670;&nbsp;</a></span>min_shift_for_prune</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::min_shift_for_prune = 32 * 1024</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9046bb2c7267f996a6636518e2747b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9046bb2c7267f996a6636518e2747b89">&#9670;&nbsp;</a></span>min_splice_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::min_splice_length = 20</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the minimum length deletion that the spliced algorithm will interpret as a splice event </p>

</div>
</div>
<a id="ad5048905a75d047631f3552632f58cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5048905a75d047631f3552632f58cd3">&#9670;&nbsp;</a></span>min_splice_repair_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::min_splice_repair_length = 250</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the minimum length apparent intron that we will try to repair </p>

</div>
</div>
<a id="a7231e0ecf35ed767417fc37184b0a806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7231e0ecf35ed767417fc37184b0a806">&#9670;&nbsp;</a></span>pad_suspicious_anchors_to_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::pad_suspicious_anchors_to_length = 12</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When examining anchors for low complexity, try and make them at least this long. To ensure orientation symmetry, we will make anchors with the oppsite parity (even if this is odd, or odd if this is even) 1bp longer. </p>

</div>
</div>
<a id="af01db9677cefc7952fee698f8ee2b672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01db9677cefc7952fee698f8ee2b672">&#9670;&nbsp;</a></span>prune_suspicious_anchors</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Surjector::prune_suspicious_anchors = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1746a8cd0e2aee838bc68d4756fc548e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1746a8cd0e2aee838bc68d4756fc548e">&#9670;&nbsp;</a></span>read_length_prop_disjoint_gap</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::Surjector::read_length_prop_disjoint_gap = 1.0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>What fraction of a read length separation should we expect before separating into supplementaries? </p>

</div>
</div>
<a id="a5c41bbc27465aad02c1d504fcc432064"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c41bbc27465aad02c1d504fcc432064">&#9670;&nbsp;</a></span>report_supplementary</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Surjector::report_supplementary = true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Should we report supplementary alignments? </p>

</div>
</div>
<a id="a3768ca4fe69ba4c58cdbfe81343c56bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3768ca4fe69ba4c58cdbfe81343c56bd">&#9670;&nbsp;</a></span>shift_prune_diff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::shift_prune_diff = 16 * 1024</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8af3e56b9463fbbf483e78477f4a7172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8af3e56b9463fbbf483e78477f4a7172">&#9670;&nbsp;</a></span>SPLICED_DEFAULT_SUBGRAPH_LIMIT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr double vg::Surjector::SPLICED_DEFAULT_SUBGRAPH_LIMIT = 16 * 1024 * 1024 / 125.0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We have a different default max_subgraph_bases_per_read_base to use for spliced alignment. </p>

</div>
</div>
<a id="affb3a5676516b7042d5c2d08734ea3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb3a5676516b7042d5c2d08734ea3c8">&#9670;&nbsp;</a></span>warned_about_subgraph_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">atomic_flag vg::Surjector::warned_about_subgraph_size = ATOMIC_FLAG_INIT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>And have we complained about hitting it? </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="surjector_8hpp.html">surjector.hpp</a></li>
<li>src/<a class="el" href="surjector_8cpp.html">surjector.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
