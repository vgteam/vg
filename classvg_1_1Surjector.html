<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::Surjector Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1Surjector.html">Surjector</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classvg_1_1Surjector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::Surjector Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;surjector.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::Surjector:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1Surjector.png" usemap="#vg::Surjector_map" alt=""/>
  <map id="vg::Surjector_map" name="vg::Surjector_map">
<area href="classvg_1_1AlignerClient.html" alt="vg::AlignerClient" shape="rect" coords="0,0,105,24"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3ce06e344f93607bd066fd58d33fc7e0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> = pair&lt; pair&lt; string::const_iterator, string::const_iterator &gt;, <a class="el" href="classvg_1_1path__t.html">path_t</a> &gt;</td></tr>
<tr class="memdesc:a3ce06e344f93607bd066fd58d33fc7e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">a local type that represents a read interval matched to a portion of the alignment path  <a href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">More...</a><br /></td></tr>
<tr class="separator:a3ce06e344f93607bd066fd58d33fc7e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4b083231c3ae02e3e14c3efb2a72eb1d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a4b083231c3ae02e3e14c3efb2a72eb1d">Surjector</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>)</td></tr>
<tr class="separator:a4b083231c3ae02e3e14c3efb2a72eb1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e4e4c28b1313850e647f4d258a0ea82"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a4e4e4c28b1313850e647f4d258a0ea82">surject</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;paths, string &amp;path_name_out, int64_t &amp;path_pos_out, bool &amp;path_rev_out, bool allow_negative_scores=false, bool preserve_deletions=false) const</td></tr>
<tr class="separator:a4e4e4c28b1313850e647f4d258a0ea82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed6215f3860203803deb2f3078d93b4"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a0ed6215f3860203803deb2f3078d93b4">multi_surject</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;paths, vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;positions_out, bool allow_negative_scores=false, bool preserve_deletions=false) const</td></tr>
<tr class="memdesc:a0ed6215f3860203803deb2f3078d93b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but include alignments to all paths instead of only the optimal one.  <a href="classvg_1_1Surjector.html#a0ed6215f3860203803deb2f3078d93b4">More...</a><br /></td></tr>
<tr class="separator:a0ed6215f3860203803deb2f3078d93b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265cf90a6fb12021a70b87ec647c0867"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a265cf90a6fb12021a70b87ec647c0867">surject</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;paths, bool allow_negative_scores=false, bool preserve_deletions=false) const</td></tr>
<tr class="separator:a265cf90a6fb12021a70b87ec647c0867"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8b34cbb819829cd493bdc901a6e3060"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ab8b34cbb819829cd493bdc901a6e3060">multi_surject</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;paths, bool allow_negative_scores=false, bool preserve_deletions=false) const</td></tr>
<tr class="memdesc:ab8b34cbb819829cd493bdc901a6e3060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but include alignments to all paths instead of only the optimal one.  <a href="classvg_1_1Surjector.html#ab8b34cbb819829cd493bdc901a6e3060">More...</a><br /></td></tr>
<tr class="separator:ab8b34cbb819829cd493bdc901a6e3060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80afa331fde9e8bcff66c4e87400217a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a80afa331fde9e8bcff66c4e87400217a">surject</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;paths, string &amp;path_name_out, int64_t &amp;path_pos_out, bool &amp;path_rev_out, bool allow_negative_scores=false, bool preserve_deletions=false) const</td></tr>
<tr class="separator:a80afa331fde9e8bcff66c4e87400217a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a943158332e4865de071dca68454a4d77"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a943158332e4865de071dca68454a4d77">multi_surject</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;paths, vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;positions_out, bool allow_negative_scores=false, bool preserve_deletions=false) const</td></tr>
<tr class="memdesc:a943158332e4865de071dca68454a4d77"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as above, but include alignments to all paths instead of only the optimal one.  <a href="classvg_1_1Surjector.html#a943158332e4865de071dca68454a4d77">More...</a><br /></td></tr>
<tr class="separator:a943158332e4865de071dca68454a4d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafe9672e0a82c6540c4d1360070725ec"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aafe9672e0a82c6540c4d1360070725ec"><td class="memTemplItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#aafe9672e0a82c6540c4d1360070725ec">get_score</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="separator:aafe9672e0a82c6540c4d1360070725ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4df48f23da07159bb99bc6577d992938"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a4df48f23da07159bb99bc6577d992938"><td class="memTemplItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a4df48f23da07159bb99bc6577d992938">get_score</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;mp_aln)</td></tr>
<tr class="separator:a4df48f23da07159bb99bc6577d992938"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:a1fde3e4537147030d153d403fd04ec77 inherit pub_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a1fde3e4537147030d153d403fd04ec77">set_alignment_scores</a> (int8_t match, int8_t mismatch, int8_t gap_open, int8_t gap_extend, int8_t full_length_bonus)</td></tr>
<tr class="memdesc:a1fde3e4537147030d153d403fd04ec77 inherit pub_methods_classvg_1_1AlignerClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the aligner scoring parameters and create the stored aligner instances.  <a href="classvg_1_1AlignerClient.html#a1fde3e4537147030d153d403fd04ec77">More...</a><br /></td></tr>
<tr class="separator:a1fde3e4537147030d153d403fd04ec77 inherit pub_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbdd2fabd7a36353526663aede3cb555 inherit pub_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#adbdd2fabd7a36353526663aede3cb555">set_alignment_scores</a> (std::istream &amp;matrix_stream, int8_t gap_open, int8_t gap_extend, int8_t full_length_bonus)</td></tr>
<tr class="separator:adbdd2fabd7a36353526663aede3cb555 inherit pub_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79424f53b6e4f588da23ea531a600b84 inherit pub_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a79424f53b6e4f588da23ea531a600b84">set_alignment_scores</a> (const int8_t *score_matrix, int8_t gap_open, int8_t gap_extend, int8_t full_length_bonus)</td></tr>
<tr class="separator:a79424f53b6e4f588da23ea531a600b84 inherit pub_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a9046bb2c7267f996a6636518e2747b89"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a9046bb2c7267f996a6636518e2747b89">min_splice_length</a> = 20</td></tr>
<tr class="memdesc:a9046bb2c7267f996a6636518e2747b89"><td class="mdescLeft">&#160;</td><td class="mdescRight">the minimum length deletion that the spliced algorithm will interpret as a splice event  <a href="classvg_1_1Surjector.html#a9046bb2c7267f996a6636518e2747b89">More...</a><br /></td></tr>
<tr class="separator:a9046bb2c7267f996a6636518e2747b89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace7092128b309c97f00fc688d3311c14"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ace7092128b309c97f00fc688d3311c14">dominated_path_chunk_diff</a> = 10</td></tr>
<tr class="separator:ace7092128b309c97f00fc688d3311c14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5048905a75d047631f3552632f58cd3"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ad5048905a75d047631f3552632f58cd3">min_splice_repair_length</a> = 250</td></tr>
<tr class="memdesc:ad5048905a75d047631f3552632f58cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">the minimum length apparent intron that we will try to repair  <a href="classvg_1_1Surjector.html#ad5048905a75d047631f3552632f58cd3">More...</a><br /></td></tr>
<tr class="separator:ad5048905a75d047631f3552632f58cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a185cc3fad9b021b08f03880ae0119db6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a185cc3fad9b021b08f03880ae0119db6">max_tail_length</a> = 10000</td></tr>
<tr class="memdesc:a185cc3fad9b021b08f03880ae0119db6"><td class="mdescLeft">&#160;</td><td class="mdescRight">the maximum length of a tail that we will try to align  <a href="classvg_1_1Surjector.html#a185cc3fad9b021b08f03880ae0119db6">More...</a><br /></td></tr>
<tr class="separator:a185cc3fad9b021b08f03880ae0119db6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77d7a865fffb0ebbc979ba8139f026c5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a77d7a865fffb0ebbc979ba8139f026c5">max_subgraph_bases</a> = 100 * 1024</td></tr>
<tr class="memdesc:a77d7a865fffb0ebbc979ba8139f026c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">How big of a graph in bp should we ever try to align against for realigning surjection?  <a href="classvg_1_1Surjector.html#a77d7a865fffb0ebbc979ba8139f026c5">More...</a><br /></td></tr>
<tr class="separator:a77d7a865fffb0ebbc979ba8139f026c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac21d8c91876c3522c56c4c1c2b8f8f58"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ac21d8c91876c3522c56c4c1c2b8f8f58">min_fold_coverage_for_downsample</a> = 8</td></tr>
<tr class="memdesc:ac21d8c91876c3522c56c4c1c2b8f8f58"><td class="mdescLeft">&#160;</td><td class="mdescRight">in spliced surject, downsample if the base-wise average coverage by chunks is this high  <a href="classvg_1_1Surjector.html#ac21d8c91876c3522c56c4c1c2b8f8f58">More...</a><br /></td></tr>
<tr class="separator:ac21d8c91876c3522c56c4c1c2b8f8f58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f599519246cb13464ffe2bbde8bccbe"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a9f599519246cb13464ffe2bbde8bccbe">downsample_coverage</a> = 16</td></tr>
<tr class="memdesc:a9f599519246cb13464ffe2bbde8bccbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">while downsampling, try to get down to this coverage on each base  <a href="classvg_1_1Surjector.html#a9f599519246cb13464ffe2bbde8bccbe">More...</a><br /></td></tr>
<tr class="separator:a9f599519246cb13464ffe2bbde8bccbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a731d00674b2d71044a8e404be059c2cf"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a731d00674b2d71044a8e404be059c2cf">min_shift_for_prune</a> = 32 * 1024</td></tr>
<tr class="separator:a731d00674b2d71044a8e404be059c2cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3768ca4fe69ba4c58cdbfe81343c56bd"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a3768ca4fe69ba4c58cdbfe81343c56bd">shift_prune_diff</a> = 16 * 1024</td></tr>
<tr class="separator:a3768ca4fe69ba4c58cdbfe81343c56bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb3a5676516b7042d5c2d08734ea3c8"><td class="memItemLeft" align="right" valign="top">atomic_flag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#affb3a5676516b7042d5c2d08734ea3c8">warned_about_subgraph_size</a> = ATOMIC_FLAG_INIT</td></tr>
<tr class="memdesc:affb3a5676516b7042d5c2d08734ea3c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">And have we complained about hitting it?  <a href="classvg_1_1Surjector.html#affb3a5676516b7042d5c2d08734ea3c8">More...</a><br /></td></tr>
<tr class="separator:affb3a5676516b7042d5c2d08734ea3c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01db9677cefc7952fee698f8ee2b672"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#af01db9677cefc7952fee698f8ee2b672">prune_suspicious_anchors</a> = false</td></tr>
<tr class="separator:af01db9677cefc7952fee698f8ee2b672"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59034e11562bb0969c25defd215f166b"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a59034e11562bb0969c25defd215f166b">max_tail_anchor_prune</a> = 4</td></tr>
<tr class="separator:a59034e11562bb0969c25defd215f166b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1df336db06fea7951c960f71265d513d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a1df336db06fea7951c960f71265d513d">low_complexity_p_value</a> = .0075</td></tr>
<tr class="separator:a1df336db06fea7951c960f71265d513d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f304005022b214c309ff60a1f186b1f"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a0f304005022b214c309ff60a1f186b1f">max_low_complexity_anchor_prune</a> = 32</td></tr>
<tr class="separator:a0f304005022b214c309ff60a1f186b1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7231e0ecf35ed767417fc37184b0a806"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a7231e0ecf35ed767417fc37184b0a806">pad_suspicious_anchors_to_length</a> = 10</td></tr>
<tr class="separator:a7231e0ecf35ed767417fc37184b0a806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a735901a421d305e6cbf13a016fdc9d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a5a735901a421d305e6cbf13a016fdc9d">max_anchors</a> = std::numeric_limits&lt;size_t&gt;::max()</td></tr>
<tr class="separator:a5a735901a421d305e6cbf13a016fdc9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99dc61c54ce73a8db8526b0f935a14c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a99dc61c54ce73a8db8526b0f935a14c9">annotate_with_all_path_scores</a> = false</td></tr>
<tr class="separator:a99dc61c54ce73a8db8526b0f935a14c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:a25db3953c246e94a7e08ef59fc31b82f inherit pub_attribs_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a25db3953c246e94a7e08ef59fc31b82f">adjust_alignments_for_base_quality</a> = false</td></tr>
<tr class="separator:a25db3953c246e94a7e08ef59fc31b82f inherit pub_attribs_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a6474f90fe3cf3ea098a553916bd47ae9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a6474f90fe3cf3ea098a553916bd47ae9">surject_internal</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> *source_aln, const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> *source_mp_aln, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; *alns_out, vector&lt; <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &gt; *mp_alns_out, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;paths, vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;positions_out, bool all_paths, bool allow_negative_scores, bool preserve_deletions) const</td></tr>
<tr class="separator:a6474f90fe3cf3ea098a553916bd47ae9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2629f80135104fb8486ef823f525b843"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a2629f80135104fb8486ef823f525b843">realigning_surject</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle, bool rev_strand, const vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, const vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &amp;path_range_out, bool allow_negative_scores, bool preserve_N_alignments=false, bool sinks_are_anchors=false, bool sources_are_anchors=false, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; *all_path_ranges_out=nullptr) const</td></tr>
<tr class="separator:a2629f80135104fb8486ef823f525b843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8418e7a55b6b53456c80cbcf937406b5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a8418e7a55b6b53456c80cbcf937406b5">spliced_surject</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *path_position_graph, const string &amp;src_sequence, const string &amp;src_quality, const int32_t src_mapping_quality, const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path_handle, bool rev_strand, vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;connections, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &amp;path_range_out, bool allow_negative_scores, bool deletions_as_splices) const</td></tr>
<tr class="separator:a8418e7a55b6b53456c80cbcf937406b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4b7099431a6a5334141760cc8922281"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, pair&lt; vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt;, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#af4b7099431a6a5334141760cc8922281">extract_overlapping_paths</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;surjection_paths) const</td></tr>
<tr class="memdesc:af4b7099431a6a5334141760cc8922281"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the chunks of the alignment path that follow the given reference paths  <a href="classvg_1_1Surjector.html#af4b7099431a6a5334141760cc8922281">More...</a><br /></td></tr>
<tr class="separator:af4b7099431a6a5334141760cc8922281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc4dbb4ce6f48d755c91e4931028c6d8"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, pair&lt; vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt;, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#adc4dbb4ce6f48d755c91e4931028c6d8">extract_overlapping_paths</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;source, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;surjection_paths, unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt;&gt; &amp;connections_out) const</td></tr>
<tr class="memdesc:adc4dbb4ce6f48d755c91e4931028c6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">same semantics except for a multipath alignment  <a href="classvg_1_1Surjector.html#adc4dbb4ce6f48d755c91e4931028c6d8">More...</a><br /></td></tr>
<tr class="separator:adc4dbb4ce6f48d755c91e4931028c6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ef0f552e2bd46b48a773837cee6c7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ac1ef0f552e2bd46b48a773837cee6c7c">filter_redundant_path_chunks</a> (bool path_rev, vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;connections) const</td></tr>
<tr class="separator:ac1ef0f552e2bd46b48a773837cee6c7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae34c7f96fff02c5490477fc8ad643908"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ae34c7f96fff02c5490477fc8ad643908">prune_and_trim_anchors</a> (const string &amp;sequence, vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;step_ranges) const</td></tr>
<tr class="separator:ae34c7f96fff02c5490477fc8ad643908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf6d3d9d2bec77f147192b05fc4df18b"><td class="memItemLeft" align="right" valign="top">pair&lt; size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#adf6d3d9d2bec77f147192b05fc4df18b">compute_path_interval</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source, <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> path_handle, bool rev_strand, const vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, const vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, bool no_left_expansion, bool no_right_expansion) const</td></tr>
<tr class="separator:adf6d3d9d2bec77f147192b05fc4df18b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac4e7823cc2ce4b65bb8910ef2c1dcbee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ac4e7823cc2ce4b65bb8910ef2c1dcbee">set_path_position</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *<a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a>, const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;init_surj_pos, const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;final_surj_pos, const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;range_begin, const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;range_end, bool rev_strand, string &amp;path_name_out, int64_t &amp;path_pos_out, bool &amp;path_rev_out) const</td></tr>
<tr class="memdesc:ac4e7823cc2ce4b65bb8910ef2c1dcbee"><td class="mdescLeft">&#160;</td><td class="mdescRight">use the graph position bounds and the path range bounds to assign a path position to a surjected read  <a href="classvg_1_1Surjector.html#ac4e7823cc2ce4b65bb8910ef2c1dcbee">More...</a><br /></td></tr>
<tr class="separator:ac4e7823cc2ce4b65bb8910ef2c1dcbee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a83875480f04c8dad0207ead58003b8"><td class="memTemplParams" colspan="2">template&lt;class AlnType &gt; </td></tr>
<tr class="memitem:a9a83875480f04c8dad0207ead58003b8"><td class="memTemplItemLeft" align="right" valign="top">string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a9a83875480f04c8dad0207ead58003b8">path_score_annotations</a> (const unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, pair&lt; AlnType, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt;&gt; &amp;surjections) const</td></tr>
<tr class="separator:a9a83875480f04c8dad0207ead58003b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98ca84936638bdcb054e3304b6f959f1"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a98ca84936638bdcb054e3304b6f959f1">reverse_adjacencies</a> (const vector&lt; vector&lt; size_t &gt;&gt; &amp;adj) const</td></tr>
<tr class="memdesc:a98ca84936638bdcb054e3304b6f959f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">reverses an adjacency list  <a href="classvg_1_1Surjector.html#a98ca84936638bdcb054e3304b6f959f1">More...</a><br /></td></tr>
<tr class="separator:a98ca84936638bdcb054e3304b6f959f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7bc3c25f2466322fd6ffd67d66c6dfa"><td class="memItemLeft" align="right" valign="top">vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#af7bc3c25f2466322fd6ffd67d66c6dfa">connected_components</a> (const vector&lt; vector&lt; size_t &gt;&gt; &amp;adj, const vector&lt; vector&lt; size_t &gt;&gt; &amp;rev_adj, size_t *num_comps_out) const</td></tr>
<tr class="separator:af7bc3c25f2466322fd6ffd67d66c6dfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2149d1e5e6aba2e07b92030e6afc617d"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a2149d1e5e6aba2e07b92030e6afc617d">transitive_reduction</a> (const vector&lt; vector&lt; size_t &gt;&gt; &amp;adj) const</td></tr>
<tr class="memdesc:a2149d1e5e6aba2e07b92030e6afc617d"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the transitive reduction of a topologically sorted DAG's adjacency list  <a href="classvg_1_1Surjector.html#a2149d1e5e6aba2e07b92030e6afc617d">More...</a><br /></td></tr>
<tr class="separator:a2149d1e5e6aba2e07b92030e6afc617d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafa4eb4d310ac530ed186170dc34dba9"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#aafa4eb4d310ac530ed186170dc34dba9">remove_dominated_chunks</a> (const string &amp;src_sequence, const vector&lt; vector&lt; size_t &gt;&gt; &amp;adj, vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;connections) const</td></tr>
<tr class="memdesc:aafa4eb4d310ac530ed186170dc34dba9"><td class="mdescLeft">&#160;</td><td class="mdescRight">eliminate any path chunks that have the exact same colinearities as another but are much shorter  <a href="classvg_1_1Surjector.html#aafa4eb4d310ac530ed186170dc34dba9">More...</a><br /></td></tr>
<tr class="separator:aafa4eb4d310ac530ed186170dc34dba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59182d764335c01e1d6ce301179f039"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ac59182d764335c01e1d6ce301179f039">cut_anchors</a> (bool rev_strand, vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;connections) const</td></tr>
<tr class="memdesc:ac59182d764335c01e1d6ce301179f039"><td class="mdescLeft">&#160;</td><td class="mdescRight">if any anchors overlap each other, cut the second at the implied overlap position  <a href="classvg_1_1Surjector.html#ac59182d764335c01e1d6ce301179f039">More...</a><br /></td></tr>
<tr class="separator:ac59182d764335c01e1d6ce301179f039"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dac1e9d5af63b0fe7c9513afa4909e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a2dac1e9d5af63b0fe7c9513afa4909e1">downsample_chunks</a> (const string &amp;src_sequence, vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;connections) const</td></tr>
<tr class="memdesc:a2dac1e9d5af63b0fe7c9513afa4909e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">if there are too many chunks, downsample to a given level  <a href="classvg_1_1Surjector.html#a2dac1e9d5af63b0fe7c9513afa4909e1">More...</a><br /></td></tr>
<tr class="separator:a2dac1e9d5af63b0fe7c9513afa4909e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b0b7fe9db83a6cfdbebf9dbeb81f04"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; vector&lt; size_t &gt;, vector&lt; size_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a54b0b7fe9db83a6cfdbebf9dbeb81f04">find_constriction_bicliques</a> (const vector&lt; vector&lt; size_t &gt;&gt; &amp;adj, const string &amp;src_sequence, const string &amp;src_quality, vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks, const vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;connections) const</td></tr>
<tr class="separator:a54b0b7fe9db83a6cfdbebf9dbeb81f04"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65da876e448d86bc64985c0b14d3e78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#ab65da876e448d86bc64985c0b14d3e78">prune_unconnectable</a> (vector&lt; vector&lt; size_t &gt;&gt; &amp;adj, vector&lt; vector&lt; tuple&lt; size_t, int32_t, bool &gt;&gt;&gt; &amp;splice_adj, vector&lt; size_t &gt; &amp;component, vector&lt; vector&lt; size_t &gt;&gt; &amp;comp_groups, vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;path_chunks, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;ref_chunks) const</td></tr>
<tr class="separator:ab65da876e448d86bc64985c0b14d3e78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:a2f3a789bca074bfbbeb327e74992d9cc inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a2f3a789bca074bfbbeb327e74992d9cc">AlignerClient</a> (double <a class="el" href="classvg_1_1AlignerClient.html#a65428f092aaa5d894b709e247cf0121a">gc_content_estimate</a>=vg::default_gc_content)</td></tr>
<tr class="separator:a2f3a789bca074bfbbeb327e74992d9cc inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683c04ab96b613ea3459738beffe5982 inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a683c04ab96b613ea3459738beffe5982">get_aligner</a> (bool have_qualities=true) const</td></tr>
<tr class="separator:a683c04ab96b613ea3459738beffe5982 inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84332f52915c20b2f2db1e060736fb5 inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#aa84332f52915c20b2f2db1e060736fb5">get_qual_adj_aligner</a> () const</td></tr>
<tr class="separator:aa84332f52915c20b2f2db1e060736fb5 inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60d4602ba9be4861136af507f8eacaec inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a60d4602ba9be4861136af507f8eacaec">get_regular_aligner</a> () const</td></tr>
<tr class="separator:a60d4602ba9be4861136af507f8eacaec inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a139ffe849fc1164217e45ea5755fc518"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a139ffe849fc1164217e45ea5755fc518">make_null_alignment</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;source)</td></tr>
<tr class="memdesc:a139ffe849fc1164217e45ea5755fc518"><td class="mdescLeft">&#160;</td><td class="mdescRight">make a sentinel meant to indicate an unmapped read  <a href="classvg_1_1Surjector.html#a139ffe849fc1164217e45ea5755fc518">More...</a><br /></td></tr>
<tr class="separator:a139ffe849fc1164217e45ea5755fc518"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7db137631f3315ede2f6887334a161b4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a7db137631f3315ede2f6887334a161b4">make_null_mp_alignment</a> (const string &amp;src_sequence, const string &amp;src_quality)</td></tr>
<tr class="separator:a7db137631f3315ede2f6887334a161b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42d2fa6bd9590a02329f31666fbe0cd5"><td class="memTemplParams" colspan="2">template&lt;class AlnType &gt; </td></tr>
<tr class="memitem:a42d2fa6bd9590a02329f31666fbe0cd5"><td class="memTemplItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a42d2fa6bd9590a02329f31666fbe0cd5">get_score</a> (const AlnType &amp;aln)</td></tr>
<tr class="separator:a42d2fa6bd9590a02329f31666fbe0cd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a118010284d37b604a7bcd7eb8dd13537"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">graph</a> = nullptr</td></tr>
<tr class="memdesc:a118010284d37b604a7bcd7eb8dd13537"><td class="mdescLeft">&#160;</td><td class="mdescRight">the graph we're surjecting onto  <a href="classvg_1_1Surjector.html#a118010284d37b604a7bcd7eb8dd13537">More...</a><br /></td></tr>
<tr class="separator:a118010284d37b604a7bcd7eb8dd13537"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="inherited"></a>
Additional Inherited Members</h2></td></tr>
<tr class="inherit_header pub_static_methods_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pub_static_methods_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Static Public Member Functions inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:a4a56c0bf099b670763c0f5ce3653811b inherit pub_static_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">static int8_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a4a56c0bf099b670763c0f5ce3653811b">parse_matrix</a> (std::istream &amp;matrix_stream)</td></tr>
<tr class="memdesc:a4a56c0bf099b670763c0f5ce3653811b inherit pub_static_methods_classvg_1_1AlignerClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates an array to hold a 4x4 substitution matrix and returns it.  <a href="classvg_1_1AlignerClient.html#a4a56c0bf099b670763c0f5ce3653811b">More...</a><br /></td></tr>
<tr class="separator:a4a56c0bf099b670763c0f5ce3653811b inherit pub_static_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3ce06e344f93607bd066fd58d33fc7e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce06e344f93607bd066fd58d33fc7e0">&#9670;&nbsp;</a></span>path_chunk_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">vg::Surjector::path_chunk_t</a> =  pair&lt;pair&lt;string::const_iterator, string::const_iterator&gt;, <a class="el" href="classvg_1_1path__t.html">path_t</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>a local type that represents a read interval matched to a portion of the alignment path </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a4b083231c3ae02e3e14c3efb2a72eb1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b083231c3ae02e3e14c3efb2a72eb1d">&#9670;&nbsp;</a></span>Surjector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::Surjector::Surjector </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="adf6d3d9d2bec77f147192b05fc4df18b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf6d3d9d2bec77f147192b05fc4df18b">&#9670;&nbsp;</a></span>compute_path_interval()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; size_t, size_t &gt; vg::Surjector::compute_path_interval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td>
          <td class="paramname"><em>path_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev_strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_left_expansion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>no_right_expansion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the widest end-inclusive interval of path positions that the realigned sequence could align to, or an interval where start &gt; end if there are no path chunks. </p>

</div>
</div>
<a id="af7bc3c25f2466322fd6ffd67d66c6dfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7bc3c25f2466322fd6ffd67d66c6dfa">&#9670;&nbsp;</a></span>connected_components()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; size_t &gt; vg::Surjector::connected_components </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>rev_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t *&#160;</td>
          <td class="paramname"><em>num_comps_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns a vector assignming each node to a connectd component, requires both the forward and reverse adjacency lists. optionally also returns the total number of components </p>

</div>
</div>
<a id="ac59182d764335c01e1d6ce301179f039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59182d764335c01e1d6ce301179f039">&#9670;&nbsp;</a></span>cut_anchors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::cut_anchors </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev_strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if any anchors overlap each other, cut the second at the implied overlap position </p>

</div>
</div>
<a id="a2dac1e9d5af63b0fe7c9513afa4909e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dac1e9d5af63b0fe7c9513afa4909e1">&#9670;&nbsp;</a></span>downsample_chunks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::downsample_chunks </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>if there are too many chunks, downsample to a given level </p>

</div>
</div>
<a id="af4b7099431a6a5334141760cc8922281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4b7099431a6a5334141760cc8922281">&#9670;&nbsp;</a></span>extract_overlapping_paths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, pair&lt; vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">Surjector::path_chunk_t</a> &gt;, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &gt; &gt; &gt; vg::Surjector::extract_overlapping_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>surjection_paths</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the chunks of the alignment path that follow the given reference paths </p>

</div>
</div>
<a id="adc4dbb4ce6f48d755c91e4931028c6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc4dbb4ce6f48d755c91e4931028c6d8">&#9670;&nbsp;</a></span>extract_overlapping_paths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, pair&lt; vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">Surjector::path_chunk_t</a> &gt;, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &gt; &gt; &gt; vg::Surjector::extract_overlapping_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>surjection_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connections_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>same semantics except for a multipath alignment </p>

</div>
</div>
<a id="ac1ef0f552e2bd46b48a773837cee6c7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ef0f552e2bd46b48a773837cee6c7c">&#9670;&nbsp;</a></span>filter_redundant_path_chunks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::filter_redundant_path_chunks </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>path_rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>remove any path chunks and corresponding ref chunks that are identical to a longer path chunk over the region where they overlap </p>

</div>
</div>
<a id="a54b0b7fe9db83a6cfdbebf9dbeb81f04"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b0b7fe9db83a6cfdbebf9dbeb81f04">&#9670;&nbsp;</a></span>find_constriction_bicliques()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; vector&lt; size_t &gt;, vector&lt; size_t &gt; &gt; &gt; vg::Surjector::find_constriction_bicliques </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_quality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>returns all sets of chunks such that 1) all of chunks on the left set abut all of the chunks on the right set on the read, 2) all source-to-sink paths in the connected component go through an edge between the left and right sides, 3) all of the chunks that do not have a connection between them are fully connected (i.e. form a biclique) </p>

</div>
</div>
<a id="aafe9672e0a82c6540c4d1360070725ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafe9672e0a82c6540c4d1360070725ec">&#9670;&nbsp;</a></span>get_score() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::Surjector::get_score </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a42d2fa6bd9590a02329f31666fbe0cd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42d2fa6bd9590a02329f31666fbe0cd5">&#9670;&nbsp;</a></span>get_score() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AlnType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t vg::Surjector::get_score </td>
          <td>(</td>
          <td class="paramtype">const AlnType &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4df48f23da07159bb99bc6577d992938"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4df48f23da07159bb99bc6577d992938">&#9670;&nbsp;</a></span>get_score() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::Surjector::get_score </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mp_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a139ffe849fc1164217e45ea5755fc518"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a139ffe849fc1164217e45ea5755fc518">&#9670;&nbsp;</a></span>make_null_alignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::Surjector::make_null_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>make a sentinel meant to indicate an unmapped read </p>

</div>
</div>
<a id="a7db137631f3315ede2f6887334a161b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7db137631f3315ede2f6887334a161b4">&#9670;&nbsp;</a></span>make_null_mp_alignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> vg::Surjector::make_null_mp_alignment </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8b34cbb819829cd493bdc901a6e3060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8b34cbb819829cd493bdc901a6e3060">&#9670;&nbsp;</a></span>multi_surject() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::Surjector::multi_surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_deletions</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above, but include alignments to all paths instead of only the optimal one. </p>

</div>
</div>
<a id="a0ed6215f3860203803deb2f3078d93b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed6215f3860203803deb2f3078d93b4">&#9670;&nbsp;</a></span>multi_surject() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::Surjector::multi_surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>positions_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_deletions</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above, but include alignments to all paths instead of only the optimal one. </p>

</div>
</div>
<a id="a943158332e4865de071dca68454a4d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a943158332e4865de071dca68454a4d77">&#9670;&nbsp;</a></span>multi_surject() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &gt; vg::Surjector::multi_surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>positions_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_deletions</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as above, but include alignments to all paths instead of only the optimal one. </p>

</div>
</div>
<a id="a9a83875480f04c8dad0207ead58003b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a83875480f04c8dad0207ead58003b8">&#9670;&nbsp;</a></span>path_score_annotations()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class AlnType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::Surjector::path_score_annotations </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; pair&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, bool &gt;, pair&lt; AlnType, pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>surjections</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae34c7f96fff02c5490477fc8ad643908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae34c7f96fff02c5490477fc8ad643908">&#9670;&nbsp;</a></span>prune_and_trim_anchors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::prune_and_trim_anchors </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>step_ranges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab65da876e448d86bc64985c0b14d3e78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65da876e448d86bc64985c0b14d3e78">&#9670;&nbsp;</a></span>prune_unconnectable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::prune_unconnectable </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; tuple&lt; size_t, int32_t, bool &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>splice_adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>comp_groups</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2629f80135104fb8486ef823f525b843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2629f80135104fb8486ef823f525b843">&#9670;&nbsp;</a></span>realigning_surject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::Surjector::realigning_surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev_strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_range_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_N_alignments</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sinks_are_anchors</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sources_are_anchors</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; *&#160;</td>
          <td class="paramname"><em>all_path_ranges_out</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aafa4eb4d310ac530ed186170dc34dba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafa4eb4d310ac530ed186170dc34dba9">&#9670;&nbsp;</a></span>remove_dominated_chunks()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; size_t &gt; &gt; vg::Surjector::remove_dominated_chunks </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connections</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>eliminate any path chunks that have the exact same colinearities as another but are much shorter </p>

</div>
</div>
<a id="a98ca84936638bdcb054e3304b6f959f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98ca84936638bdcb054e3304b6f959f1">&#9670;&nbsp;</a></span>reverse_adjacencies()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; size_t &gt; &gt; vg::Surjector::reverse_adjacencies </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>reverses an adjacency list </p>

</div>
</div>
<a id="ac4e7823cc2ce4b65bb8910ef2c1dcbee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e7823cc2ce4b65bb8910ef2c1dcbee">&#9670;&nbsp;</a></span>set_path_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::set_path_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>init_surj_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>final_surj_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>range_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>range_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev_strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>path_name_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>path_pos_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>path_rev_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>use the graph position bounds and the path range bounds to assign a path position to a surjected read </p>

</div>
</div>
<a id="a8418e7a55b6b53456c80cbcf937406b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8418e7a55b6b53456c80cbcf937406b5">&#9670;&nbsp;</a></span>spliced_surject()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> vg::Surjector::spliced_surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>path_position_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>src_quality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>src_mapping_quality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev_strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1Surjector.html#a3ce06e344f93607bd066fd58d33fc7e0">path_chunk_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; size_t, size_t, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>connections</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pair&lt; <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_range_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>deletions_as_splices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a265cf90a6fb12021a70b87ec647c0867"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265cf90a6fb12021a70b87ec647c0867">&#9670;&nbsp;</a></span>surject() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::Surjector::surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_deletions</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the portions of an alignment that are on a chosen set of paths and try to align realign the portions that are off of the chosen paths to the intervening path segments to obtain an alignment that is fully restricted to the paths.</p>
<p>Replaces the alignment's refpos with the path name, position, and strand the alignment has been surjected to.</p>
<p>Optionally either allow softclips so that the alignment has a nonnegative score on the path or require the full-length alignment, possibly creating a negative score.</p>
<p>Also optionally leaves deletions against the reference path in the final alignment (useful for splicing). </p>

</div>
</div>
<a id="a4e4e4c28b1313850e647f4d258a0ea82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e4e4c28b1313850e647f4d258a0ea82">&#9670;&nbsp;</a></span>surject() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::Surjector::surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>path_name_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>path_pos_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>path_rev_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_deletions</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the portions of an alignment that are on a chosen set of paths and try to align realign the portions that are off of the chosen paths to the intervening path segments to obtain an alignment that is fully restricted to the paths.</p>
<p>Also returns the path name, position, and strand of the new alignment.</p>
<p>Optionally either allow softclips so that the alignment has a nonnegative score on the path or require the full-length alignment, possibly creating a negative score.</p>
<p>Also optionally leaves deletions against the reference path in the final alignment (useful for splicing). </p>

</div>
</div>
<a id="a80afa331fde9e8bcff66c4e87400217a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80afa331fde9e8bcff66c4e87400217a">&#9670;&nbsp;</a></span>surject() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> vg::Surjector::surject </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>path_name_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>path_pos_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>path_rev_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_deletions</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same semantics as with alignments except that connections are always preserved as splices. The output consists of a multipath alignment with a single path, separated by splices (either from large deletions or from connections) </p>

</div>
</div>
<a id="a6474f90fe3cf3ea098a553916bd47ae9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6474f90fe3cf3ea098a553916bd47ae9">&#9670;&nbsp;</a></span>surject_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Surjector::surject_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> *&#160;</td>
          <td class="paramname"><em>source_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> *&#160;</td>
          <td class="paramname"><em>source_mp_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; *&#160;</td>
          <td class="paramname"><em>alns_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &gt; *&#160;</td>
          <td class="paramname"><em>mp_alns_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; tuple&lt; string, int64_t, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>positions_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>all_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_deletions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2149d1e5e6aba2e07b92030e6afc617d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2149d1e5e6aba2e07b92030e6afc617d">&#9670;&nbsp;</a></span>transitive_reduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; size_t &gt; &gt; vg::Surjector::transitive_reduction </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>adj</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the transitive reduction of a topologically sorted DAG's adjacency list </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a99dc61c54ce73a8db8526b0f935a14c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99dc61c54ce73a8db8526b0f935a14c9">&#9670;&nbsp;</a></span>annotate_with_all_path_scores</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Surjector::annotate_with_all_path_scores = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace7092128b309c97f00fc688d3311c14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace7092128b309c97f00fc688d3311c14">&#9670;&nbsp;</a></span>dominated_path_chunk_diff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::dominated_path_chunk_diff = 10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f599519246cb13464ffe2bbde8bccbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f599519246cb13464ffe2bbde8bccbe">&#9670;&nbsp;</a></span>downsample_coverage</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::downsample_coverage = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>while downsampling, try to get down to this coverage on each base </p>

</div>
</div>
<a id="a118010284d37b604a7bcd7eb8dd13537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a118010284d37b604a7bcd7eb8dd13537">&#9670;&nbsp;</a></span>graph</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a>* vg::Surjector::graph = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>the graph we're surjecting onto </p>

</div>
</div>
<a id="a1df336db06fea7951c960f71265d513d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1df336db06fea7951c960f71265d513d">&#9670;&nbsp;</a></span>low_complexity_p_value</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::Surjector::low_complexity_p_value = .0075</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5a735901a421d305e6cbf13a016fdc9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a735901a421d305e6cbf13a016fdc9d">&#9670;&nbsp;</a></span>max_anchors</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::Surjector::max_anchors = std::numeric_limits&lt;size_t&gt;::max()</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>How many anchors (per path) will we use when surjecting using anchors? Excessive anchors will be pruned away. </p>

</div>
</div>
<a id="a0f304005022b214c309ff60a1f186b1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f304005022b214c309ff60a1f186b1f">&#9670;&nbsp;</a></span>max_low_complexity_anchor_prune</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::max_low_complexity_anchor_prune = 32</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77d7a865fffb0ebbc979ba8139f026c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77d7a865fffb0ebbc979ba8139f026c5">&#9670;&nbsp;</a></span>max_subgraph_bases</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::Surjector::max_subgraph_bases = 100 * 1024</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How big of a graph in bp should we ever try to align against for realigning surjection? </p>

</div>
</div>
<a id="a59034e11562bb0969c25defd215f166b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59034e11562bb0969c25defd215f166b">&#9670;&nbsp;</a></span>max_tail_anchor_prune</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::max_tail_anchor_prune = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a185cc3fad9b021b08f03880ae0119db6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a185cc3fad9b021b08f03880ae0119db6">&#9670;&nbsp;</a></span>max_tail_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::Surjector::max_tail_length = 10000</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the maximum length of a tail that we will try to align </p>

</div>
</div>
<a id="ac21d8c91876c3522c56c4c1c2b8f8f58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac21d8c91876c3522c56c4c1c2b8f8f58">&#9670;&nbsp;</a></span>min_fold_coverage_for_downsample</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::min_fold_coverage_for_downsample = 8</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>in spliced surject, downsample if the base-wise average coverage by chunks is this high </p>

</div>
</div>
<a id="a731d00674b2d71044a8e404be059c2cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a731d00674b2d71044a8e404be059c2cf">&#9670;&nbsp;</a></span>min_shift_for_prune</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::min_shift_for_prune = 32 * 1024</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9046bb2c7267f996a6636518e2747b89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9046bb2c7267f996a6636518e2747b89">&#9670;&nbsp;</a></span>min_splice_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::min_splice_length = 20</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the minimum length deletion that the spliced algorithm will interpret as a splice event </p>

</div>
</div>
<a id="ad5048905a75d047631f3552632f58cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5048905a75d047631f3552632f58cd3">&#9670;&nbsp;</a></span>min_splice_repair_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::min_splice_repair_length = 250</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>the minimum length apparent intron that we will try to repair </p>

</div>
</div>
<a id="a7231e0ecf35ed767417fc37184b0a806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7231e0ecf35ed767417fc37184b0a806">&#9670;&nbsp;</a></span>pad_suspicious_anchors_to_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::pad_suspicious_anchors_to_length = 10</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af01db9677cefc7952fee698f8ee2b672"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01db9677cefc7952fee698f8ee2b672">&#9670;&nbsp;</a></span>prune_suspicious_anchors</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Surjector::prune_suspicious_anchors = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3768ca4fe69ba4c58cdbfe81343c56bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3768ca4fe69ba4c58cdbfe81343c56bd">&#9670;&nbsp;</a></span>shift_prune_diff</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::Surjector::shift_prune_diff = 16 * 1024</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="affb3a5676516b7042d5c2d08734ea3c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb3a5676516b7042d5c2d08734ea3c8">&#9670;&nbsp;</a></span>warned_about_subgraph_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">atomic_flag vg::Surjector::warned_about_subgraph_size = ATOMIC_FLAG_INIT</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>And have we complained about hitting it? </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="surjector_8hpp.html">surjector.hpp</a></li>
<li>src/<a class="el" href="surjector_8cpp.html">surjector.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
