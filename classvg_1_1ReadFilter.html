<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::ReadFilter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1ReadFilter.html">ReadFilter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classvg_1_1ReadFilter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::ReadFilter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;readfilter.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ReadFilter_1_1Counts.html">Counts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a398d61417de9097c385315490b7034df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ReadFilter_1_1Counts.html">Counts</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a398d61417de9097c385315490b7034df">filter_alignment</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="separator:a398d61417de9097c385315490b7034df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe8cb61ed8a2f376b0404e934af8b91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a7fe8cb61ed8a2f376b0404e934af8b91">filter</a> (istream *alignment_stream)</td></tr>
<tr class="separator:a7fe8cb61ed8a2f376b0404e934af8b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31011cb29962d3510bb50b315409a025"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a31011cb29962d3510bb50b315409a025">trim_ambiguous_ends</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, int k)</td></tr>
<tr class="separator:a31011cb29962d3510bb50b315409a025"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7a22a82c55e23fca581060934d03935e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a7a22a82c55e23fca581060934d03935e">complement_filter</a> = false</td></tr>
<tr class="memdesc:a7a22a82c55e23fca581060934d03935e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actually take the complement of the filter.  <a href="#a7a22a82c55e23fca581060934d03935e">More...</a><br /></td></tr>
<tr class="separator:a7a22a82c55e23fca581060934d03935e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de9ae45579a188cfc673018e9dc8b0c"><td class="memItemLeft" align="right" valign="top">vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a1de9ae45579a188cfc673018e9dc8b0c">name_prefixes</a></td></tr>
<tr class="separator:a1de9ae45579a188cfc673018e9dc8b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b80df71a29a718b34af1becfe821026"><td class="memItemLeft" align="right" valign="top">vector&lt; regex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a3b80df71a29a718b34af1becfe821026">excluded_refpos_contigs</a></td></tr>
<tr class="memdesc:a3b80df71a29a718b34af1becfe821026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read must not have a refpos set with a contig name containing a match to any of these.  <a href="#a3b80df71a29a718b34af1becfe821026">More...</a><br /></td></tr>
<tr class="separator:a3b80df71a29a718b34af1becfe821026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacb1ca6d956c7cab4e2f6c93db0ceb2"><td class="memItemLeft" align="right" valign="top">unordered_set&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#acacb1ca6d956c7cab4e2f6c93db0ceb2">excluded_features</a></td></tr>
<tr class="separator:acacb1ca6d956c7cab4e2f6c93db0ceb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0ecf4f3140e483ba93592231929dbb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a8f0ecf4f3140e483ba93592231929dbb">min_secondary</a> = numeric_limits&lt;double&gt;::lowest()</td></tr>
<tr class="separator:a8f0ecf4f3140e483ba93592231929dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17dbd2182c6cf4816c1fe22ae60e2a01"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a17dbd2182c6cf4816c1fe22ae60e2a01">min_primary</a> = numeric_limits&lt;double&gt;::lowest()</td></tr>
<tr class="separator:a17dbd2182c6cf4816c1fe22ae60e2a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b47fbeff165aa3fb4fdff25d2cb6fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ab3b47fbeff165aa3fb4fdff25d2cb6fb">rescore</a> = false</td></tr>
<tr class="separator:ab3b47fbeff165aa3fb4fdff25d2cb6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39086ef40e89b6b3733e5e9c42482e1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a39086ef40e89b6b3733e5e9c42482e1e">frac_score</a> = false</td></tr>
<tr class="separator:a39086ef40e89b6b3733e5e9c42482e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c8a5914f93571e56eff63d3604596a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a96c8a5914f93571e56eff63d3604596a">sub_score</a> = false</td></tr>
<tr class="separator:a96c8a5914f93571e56eff63d3604596a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73972404a3db8d8f902d3d47896857d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ab73972404a3db8d8f902d3d47896857d">max_overhang</a> = numeric_limits&lt;int&gt;::max() / 2</td></tr>
<tr class="separator:ab73972404a3db8d8f902d3d47896857d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8848d4b66a515602fa38571b02667b51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a8848d4b66a515602fa38571b02667b51">min_end_matches</a> = numeric_limits&lt;int&gt;::min() / 2</td></tr>
<tr class="separator:a8848d4b66a515602fa38571b02667b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad1a1b72ee0b450fe79340451893cfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a2ad1a1b72ee0b450fe79340451893cfa">verbose</a> = false</td></tr>
<tr class="separator:a2ad1a1b72ee0b450fe79340451893cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d1564e0834e1236d104da7045a4894"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#aa1d1564e0834e1236d104da7045a4894">min_mapq</a> = numeric_limits&lt;double&gt;::lowest()</td></tr>
<tr class="separator:aa1d1564e0834e1236d104da7045a4894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1bcac75fda8d439384ba8c09c780cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a4d1bcac75fda8d439384ba8c09c780cf">repeat_size</a> = 0</td></tr>
<tr class="separator:a4d1bcac75fda8d439384ba8c09c780cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eba4b03f0f697ae6540a255dd7b0627"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a6eba4b03f0f697ae6540a255dd7b0627">drop_split</a> = false</td></tr>
<tr class="memdesc:a6eba4b03f0f697ae6540a255dd7b0627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should we drop split reads that follow edges not in the graph?  <a href="#a6eba4b03f0f697ae6540a255dd7b0627">More...</a><br /></td></tr>
<tr class="separator:a6eba4b03f0f697ae6540a255dd7b0627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11c0f9ba830e35a5b92a041b0a24ded"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#af11c0f9ba830e35a5b92a041b0a24ded">downsample_probability</a> = 1.0</td></tr>
<tr class="memdesc:af11c0f9ba830e35a5b92a041b0a24ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">We can also pseudorandomly drop reads. What's the probability that we keep a read?  <a href="#af11c0f9ba830e35a5b92a041b0a24ded">More...</a><br /></td></tr>
<tr class="separator:af11c0f9ba830e35a5b92a041b0a24ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad7bd40167b335fee96b0475a625aef"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#acad7bd40167b335fee96b0475a625aef">downsample_seed_mask</a> = 0</td></tr>
<tr class="separator:acad7bd40167b335fee96b0475a625aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d85ffe55c3074f0b5f9664465fec883"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a0d85ffe55c3074f0b5f9664465fec883">defray_length</a> = 0</td></tr>
<tr class="separator:a0d85ffe55c3074f0b5f9664465fec883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7397dca610aa815fd6a1abac7d67b5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ac7397dca610aa815fd6a1abac7d67b5c">defray_count</a> = 99999</td></tr>
<tr class="memdesc:ac7397dca610aa815fd6a1abac7d67b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limit defray recursion to visit this many nodes.  <a href="#ac7397dca610aa815fd6a1abac7d67b5c">More...</a><br /></td></tr>
<tr class="separator:ac7397dca610aa815fd6a1abac7d67b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e4ebb26cce954d20deb7b0d7a31641"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a22e4ebb26cce954d20deb7b0d7a31641">threads</a> = -1</td></tr>
<tr class="memdesc:a22e4ebb26cce954d20deb7b0d7a31641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of threads from omp.  <a href="#a22e4ebb26cce954d20deb7b0d7a31641">More...</a><br /></td></tr>
<tr class="separator:a22e4ebb26cce954d20deb7b0d7a31641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5aa58e55aa8546d0e555a90b7b1ac1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ad5aa58e55aa8546d0e555a90b7b1ac1a">buffer_size</a> = 512</td></tr>
<tr class="memdesc:ad5aa58e55aa8546d0e555a90b7b1ac1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAM output buffer size.  <a href="#ad5aa58e55aa8546d0e555a90b7b1ac1a">More...</a><br /></td></tr>
<tr class="separator:ad5aa58e55aa8546d0e555a90b7b1ac1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bab332dd50a2b84e4bb7798fabd349"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ad5bab332dd50a2b84e4bb7798fabd349">write_output</a> = true</td></tr>
<tr class="separator:ad5bab332dd50a2b84e4bb7798fabd349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc3a9a61f57bb5a8c9857fe43a032f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a7fc3a9a61f57bb5a8c9857fe43a032f5">graph</a> = nullptr</td></tr>
<tr class="memdesc:a7fc3a9a61f57bb5a8c9857fe43a032f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A HandleGraph is required for some filters (Note: <a class="el" href="classvg_1_1ReadFilter.html">ReadFilter</a> doesn't own/free this)  <a href="#a7fc3a9a61f57bb5a8c9857fe43a032f5">More...</a><br /></td></tr>
<tr class="separator:a7fc3a9a61f57bb5a8c9857fe43a032f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a2dea40e9afefb8e7e4e1827a5c109"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a30a2dea40e9afefb8e7e4e1827a5c109">interleaved</a> = false</td></tr>
<tr class="memdesc:a30a2dea40e9afefb8e7e4e1827a5c109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaved input.  <a href="#a30a2dea40e9afefb8e7e4e1827a5c109">More...</a><br /></td></tr>
<tr class="separator:a30a2dea40e9afefb8e7e4e1827a5c109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc075968b0c08ed7ad4f2cb0a837ef95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#acc075968b0c08ed7ad4f2cb0a837ef95">filter_on_all</a> = false</td></tr>
<tr class="separator:acc075968b0c08ed7ad4f2cb0a837ef95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c77d9ed319e6f7cf3e38582621fce1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a52c77d9ed319e6f7cf3e38582621fce1">min_base_quality</a> = numeric_limits&lt;int&gt;::min() / 2</td></tr>
<tr class="separator:a52c77d9ed319e6f7cf3e38582621fce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e494cd5be020669694244d1f3ffc4c6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a6e494cd5be020669694244d1f3ffc4c6">min_base_quality_fraction</a> = numeric_limits&lt;double&gt;::lowest()</td></tr>
<tr class="separator:a6e494cd5be020669694244d1f3ffc4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457e9fef8d1e19c78b4a72ff10d14260"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a457e9fef8d1e19c78b4a72ff10d14260">append_regions</a> = false</td></tr>
<tr class="separator:a457e9fef8d1e19c78b4a72ff10d14260"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac6a2619d7e6dff8fc81aed985a28e3f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ac6a2619d7e6dff8fc81aed985a28e3f2">has_repeat</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, int k)</td></tr>
<tr class="separator:ac6a2619d7e6dff8fc81aed985a28e3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f5b827c01ca762dbe3707034d42d25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a35f5b827c01ca762dbe3707034d42d25">trim_ambiguous_end</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, int k)</td></tr>
<tr class="separator:a35f5b827c01ca762dbe3707034d42d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07039862a8bee98803f764863b3ba0fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a07039862a8bee98803f764863b3ba0fa">is_split</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:a07039862a8bee98803f764863b3ba0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052c3d8dcfcf5b26d2180b37217159f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a052c3d8dcfcf5b26d2180b37217159f5">sample_read</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;read)</td></tr>
<tr class="separator:a052c3d8dcfcf5b26d2180b37217159f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7fe8cb61ed8a2f376b0404e934af8b91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe8cb61ed8a2f376b0404e934af8b91">&#9670;&nbsp;</a></span>filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::ReadFilter::filter </td>
          <td>(</td>
          <td class="paramtype">istream *&#160;</td>
          <td class="paramname"><em>alignment_stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classvg_1_1Filter.html">Filter</a> the alignments available from the given stream, placing them on standard output or in the appropriate file. Returns 0 on success, exit code to use on error. </p>

</div>
</div>
<a id="a398d61417de9097c385315490b7034df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a398d61417de9097c385315490b7034df">&#9670;&nbsp;</a></span>filter_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ReadFilter_1_1Counts.html">ReadFilter::Counts</a> vg::ReadFilter::filter_alignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run all the filters on an alignment. The alignment may get modified in-place by the defray filter </p>

</div>
</div>
<a id="ac6a2619d7e6dff8fc81aed985a28e3f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6a2619d7e6dff8fc81aed985a28e3f2">&#9670;&nbsp;</a></span>has_repeat()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::has_repeat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Â * quick and dirty filter to see if removing reads that can slip around and still map perfectly helps vg call. returns true if at either end of read sequence, at least k bases are repetitive, checking repeats of up to size 2k </p>

</div>
</div>
<a id="a07039862a8bee98803f764863b3ba0fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07039862a8bee98803f764863b3ba0fa">&#9670;&nbsp;</a></span>is_split()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::is_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return false if the read only follows edges in the graph, and true if the read is split (or just incorrect) and takes edges not in the index.</p>
<p>Throws an error if no graph is specified. </p>

</div>
</div>
<a id="a052c3d8dcfcf5b26d2180b37217159f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052c3d8dcfcf5b26d2180b37217159f5">&#9670;&nbsp;</a></span>sample_read()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::sample_read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Based on the read name and paired-ness, compute the SAM-style QNAME and use that and the configured sampling probability and seed in the Samtools read sampling algorithm, to determine if the read should be kept. Returns true if the read should stay, and false if it should be removed. Always accepts or rejects paired reads together. </p>

</div>
</div>
<a id="a35f5b827c01ca762dbe3707034d42d25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35f5b827c01ca762dbe3707034d42d25">&#9670;&nbsp;</a></span>trim_ambiguous_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::trim_ambiguous_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trim only the end of the given alignment, leaving the start alone. Two calls of this implement trim_ambiguous_ends above. </p>

</div>
</div>
<a id="a31011cb29962d3510bb50b315409a025"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31011cb29962d3510bb50b315409a025">&#9670;&nbsp;</a></span>trim_ambiguous_ends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::trim_ambiguous_ends </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look at either end of the given alignment, up to k bases in from the end. See if that tail of the alignment is mapped such that another embedding in the given graph can produce the same sequence as the sequence along the embedding that the read actually has, and if so trim back the read.</p>
<p>In the case of softclips, the aligned portion of the read is considered, and if trimmign is required, the softclips are hard-clipped off.</p>
<p>Returns true if the read had to be modified, and false otherwise.</p>
<p>MUST NOT be called with a null index. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a457e9fef8d1e19c78b4a72ff10d14260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a457e9fef8d1e19c78b4a72ff10d14260">&#9670;&nbsp;</a></span>append_regions</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::append_regions = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5aa58e55aa8546d0e555a90b7b1ac1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5aa58e55aa8546d0e555a90b7b1ac1a">&#9670;&nbsp;</a></span>buffer_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::ReadFilter::buffer_size = 512</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GAM output buffer size. </p>

</div>
</div>
<a id="a7a22a82c55e23fca581060934d03935e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a22a82c55e23fca581060934d03935e">&#9670;&nbsp;</a></span>complement_filter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::complement_filter = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actually take the complement of the filter. </p>

</div>
</div>
<a id="ac7397dca610aa815fd6a1abac7d67b5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7397dca610aa815fd6a1abac7d67b5c">&#9670;&nbsp;</a></span>defray_count</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::ReadFilter::defray_count = 99999</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Limit defray recursion to visit this many nodes. </p>

</div>
</div>
<a id="a0d85ffe55c3074f0b5f9664465fec883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d85ffe55c3074f0b5f9664465fec883">&#9670;&nbsp;</a></span>defray_length</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::ReadFilter::defray_length = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>How far in from the end should we look for ambiguous end alignment to clip off? </p>

</div>
</div>
<a id="af11c0f9ba830e35a5b92a041b0a24ded"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af11c0f9ba830e35a5b92a041b0a24ded">&#9670;&nbsp;</a></span>downsample_probability</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::ReadFilter::downsample_probability = 1.0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We can also pseudorandomly drop reads. What's the probability that we keep a read? </p>

</div>
</div>
<a id="acad7bd40167b335fee96b0475a625aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acad7bd40167b335fee96b0475a625aef">&#9670;&nbsp;</a></span>downsample_seed_mask</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vg::ReadFilter::downsample_seed_mask = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Samtools-compatible internal seed mask, for deciding which read pairs to keep. To be generated with rand() after srand() from the user-visible seed. </p>

</div>
</div>
<a id="a6eba4b03f0f697ae6540a255dd7b0627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eba4b03f0f697ae6540a255dd7b0627">&#9670;&nbsp;</a></span>drop_split</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::drop_split = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Should we drop split reads that follow edges not in the graph? </p>

</div>
</div>
<a id="acacb1ca6d956c7cab4e2f6c93db0ceb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acacb1ca6d956c7cab4e2f6c93db0ceb2">&#9670;&nbsp;</a></span>excluded_features</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_set&lt;string&gt; vg::ReadFilter::excluded_features</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If a read has one of the features in this set as annotations, the read is filtered out. </p>

</div>
</div>
<a id="a3b80df71a29a718b34af1becfe821026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b80df71a29a718b34af1becfe821026">&#9670;&nbsp;</a></span>excluded_refpos_contigs</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;regex&gt; vg::ReadFilter::excluded_refpos_contigs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read must not have a refpos set with a contig name containing a match to any of these. </p>

</div>
</div>
<a id="acc075968b0c08ed7ad4f2cb0a837ef95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc075968b0c08ed7ad4f2cb0a837ef95">&#9670;&nbsp;</a></span>filter_on_all</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::filter_on_all = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When outputting paired reads, fail the pair only if both (all) reads fail (true) instead of if either (any) read fails (false) </p>

</div>
</div>
<a id="a39086ef40e89b6b3733e5e9c42482e1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39086ef40e89b6b3733e5e9c42482e1e">&#9670;&nbsp;</a></span>frac_score</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::frac_score = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7fc3a9a61f57bb5a8c9857fe43a032f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fc3a9a61f57bb5a8c9857fe43a032f5">&#9670;&nbsp;</a></span>graph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a>* vg::ReadFilter::graph = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A HandleGraph is required for some filters (Note: <a class="el" href="classvg_1_1ReadFilter.html">ReadFilter</a> doesn't own/free this) </p>

</div>
</div>
<a id="a30a2dea40e9afefb8e7e4e1827a5c109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a2dea40e9afefb8e7e4e1827a5c109">&#9670;&nbsp;</a></span>interleaved</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::interleaved = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleaved input. </p>

</div>
</div>
<a id="ab73972404a3db8d8f902d3d47896857d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab73972404a3db8d8f902d3d47896857d">&#9670;&nbsp;</a></span>max_overhang</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::ReadFilter::max_overhang = numeric_limits&lt;int&gt;::max() / 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a52c77d9ed319e6f7cf3e38582621fce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c77d9ed319e6f7cf3e38582621fce1">&#9670;&nbsp;</a></span>min_base_quality</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::ReadFilter::min_base_quality = numeric_limits&lt;int&gt;::min() / 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e494cd5be020669694244d1f3ffc4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e494cd5be020669694244d1f3ffc4c6">&#9670;&nbsp;</a></span>min_base_quality_fraction</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::ReadFilter::min_base_quality_fraction = numeric_limits&lt;double&gt;::lowest()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8848d4b66a515602fa38571b02667b51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8848d4b66a515602fa38571b02667b51">&#9670;&nbsp;</a></span>min_end_matches</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::ReadFilter::min_end_matches = numeric_limits&lt;int&gt;::min() / 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1d1564e0834e1236d104da7045a4894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1d1564e0834e1236d104da7045a4894">&#9670;&nbsp;</a></span>min_mapq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::ReadFilter::min_mapq = numeric_limits&lt;double&gt;::lowest()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a17dbd2182c6cf4816c1fe22ae60e2a01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17dbd2182c6cf4816c1fe22ae60e2a01">&#9670;&nbsp;</a></span>min_primary</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::ReadFilter::min_primary = numeric_limits&lt;double&gt;::lowest()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f0ecf4f3140e483ba93592231929dbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0ecf4f3140e483ba93592231929dbb">&#9670;&nbsp;</a></span>min_secondary</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::ReadFilter::min_secondary = numeric_limits&lt;double&gt;::lowest()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1de9ae45579a188cfc673018e9dc8b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de9ae45579a188cfc673018e9dc8b0c">&#9670;&nbsp;</a></span>name_prefixes</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;string&gt; vg::ReadFilter::name_prefixes</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read name must have one of these prefixes, if any are present. TODO: This should be a trie but I don't have one handy. Must be sorted for vaguely efficient search. </p>

</div>
</div>
<a id="a4d1bcac75fda8d439384ba8c09c780cf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d1bcac75fda8d439384ba8c09c780cf">&#9670;&nbsp;</a></span>repeat_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::ReadFilter::repeat_size = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3b47fbeff165aa3fb4fdff25d2cb6fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3b47fbeff165aa3fb4fdff25d2cb6fb">&#9670;&nbsp;</a></span>rescore</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::rescore = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Should we rescore each alignment with default parameters and no e.g. haplotype info? </p>

</div>
</div>
<a id="a96c8a5914f93571e56eff63d3604596a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96c8a5914f93571e56eff63d3604596a">&#9670;&nbsp;</a></span>sub_score</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::sub_score = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a22e4ebb26cce954d20deb7b0d7a31641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22e4ebb26cce954d20deb7b0d7a31641">&#9670;&nbsp;</a></span>threads</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::ReadFilter::threads = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of threads from omp. </p>

</div>
</div>
<a id="a2ad1a1b72ee0b450fe79340451893cfa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ad1a1b72ee0b450fe79340451893cfa">&#9670;&nbsp;</a></span>verbose</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::verbose = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5bab332dd50a2b84e4bb7798fabd349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5bab332dd50a2b84e4bb7798fabd349">&#9670;&nbsp;</a></span>write_output</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::write_output = true</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sometimes we only want a report, and not a filtered gam. toggling off output speeds things up considerably. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="readfilter_8hpp.html">readfilter.hpp</a></li>
<li>src/<a class="el" href="readfilter_8cpp.html">readfilter.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
