<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::ReadFilter Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1ReadFilter.html">ReadFilter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classvg_1_1ReadFilter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::ReadFilter Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;readfilter.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ReadFilter_1_1Counts.html">Counts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a398d61417de9097c385315490b7034df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ReadFilter_1_1Counts.html">Counts</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a398d61417de9097c385315490b7034df">filter_alignment</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="separator:a398d61417de9097c385315490b7034df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe8cb61ed8a2f376b0404e934af8b91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a7fe8cb61ed8a2f376b0404e934af8b91">filter</a> (istream *alignment_stream)</td></tr>
<tr class="separator:a7fe8cb61ed8a2f376b0404e934af8b91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31011cb29962d3510bb50b315409a025"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a31011cb29962d3510bb50b315409a025">trim_ambiguous_ends</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, int k)</td></tr>
<tr class="separator:a31011cb29962d3510bb50b315409a025"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a7a22a82c55e23fca581060934d03935e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a7a22a82c55e23fca581060934d03935e">complement_filter</a> = false</td></tr>
<tr class="memdesc:a7a22a82c55e23fca581060934d03935e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actually take the complement of the filter.  <a href="#a7a22a82c55e23fca581060934d03935e">More...</a><br/></td></tr>
<tr class="separator:a7a22a82c55e23fca581060934d03935e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1de9ae45579a188cfc673018e9dc8b0c"><td class="memItemLeft" align="right" valign="top">vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a1de9ae45579a188cfc673018e9dc8b0c">name_prefixes</a></td></tr>
<tr class="separator:a1de9ae45579a188cfc673018e9dc8b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b80df71a29a718b34af1becfe821026"><td class="memItemLeft" align="right" valign="top">vector&lt; regex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a3b80df71a29a718b34af1becfe821026">excluded_refpos_contigs</a></td></tr>
<tr class="memdesc:a3b80df71a29a718b34af1becfe821026"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read must not have a refpos set with a contig name containing a match to any of these.  <a href="#a3b80df71a29a718b34af1becfe821026">More...</a><br/></td></tr>
<tr class="separator:a3b80df71a29a718b34af1becfe821026"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acacb1ca6d956c7cab4e2f6c93db0ceb2"><td class="memItemLeft" align="right" valign="top">unordered_set&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#acacb1ca6d956c7cab4e2f6c93db0ceb2">excluded_features</a></td></tr>
<tr class="separator:acacb1ca6d956c7cab4e2f6c93db0ceb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0ecf4f3140e483ba93592231929dbb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a8f0ecf4f3140e483ba93592231929dbb">min_secondary</a> = 0.</td></tr>
<tr class="separator:a8f0ecf4f3140e483ba93592231929dbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17dbd2182c6cf4816c1fe22ae60e2a01"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a17dbd2182c6cf4816c1fe22ae60e2a01">min_primary</a> = 0.</td></tr>
<tr class="separator:a17dbd2182c6cf4816c1fe22ae60e2a01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3b47fbeff165aa3fb4fdff25d2cb6fb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ab3b47fbeff165aa3fb4fdff25d2cb6fb">rescore</a> = false</td></tr>
<tr class="separator:ab3b47fbeff165aa3fb4fdff25d2cb6fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39086ef40e89b6b3733e5e9c42482e1e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a39086ef40e89b6b3733e5e9c42482e1e">frac_score</a> = false</td></tr>
<tr class="separator:a39086ef40e89b6b3733e5e9c42482e1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96c8a5914f93571e56eff63d3604596a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a96c8a5914f93571e56eff63d3604596a">sub_score</a> = false</td></tr>
<tr class="separator:a96c8a5914f93571e56eff63d3604596a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab73972404a3db8d8f902d3d47896857d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ab73972404a3db8d8f902d3d47896857d">max_overhang</a> = 99999</td></tr>
<tr class="separator:ab73972404a3db8d8f902d3d47896857d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8848d4b66a515602fa38571b02667b51"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a8848d4b66a515602fa38571b02667b51">min_end_matches</a> = 0</td></tr>
<tr class="separator:a8848d4b66a515602fa38571b02667b51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ad1a1b72ee0b450fe79340451893cfa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a2ad1a1b72ee0b450fe79340451893cfa">verbose</a> = false</td></tr>
<tr class="separator:a2ad1a1b72ee0b450fe79340451893cfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1d1564e0834e1236d104da7045a4894"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#aa1d1564e0834e1236d104da7045a4894">min_mapq</a> = 0.</td></tr>
<tr class="separator:aa1d1564e0834e1236d104da7045a4894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d1bcac75fda8d439384ba8c09c780cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a4d1bcac75fda8d439384ba8c09c780cf">repeat_size</a> = 0</td></tr>
<tr class="separator:a4d1bcac75fda8d439384ba8c09c780cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eba4b03f0f697ae6540a255dd7b0627"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a6eba4b03f0f697ae6540a255dd7b0627">drop_split</a> = false</td></tr>
<tr class="memdesc:a6eba4b03f0f697ae6540a255dd7b0627"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should we drop split reads that follow edges not in the graph?  <a href="#a6eba4b03f0f697ae6540a255dd7b0627">More...</a><br/></td></tr>
<tr class="separator:a6eba4b03f0f697ae6540a255dd7b0627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af11c0f9ba830e35a5b92a041b0a24ded"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#af11c0f9ba830e35a5b92a041b0a24ded">downsample_probability</a> = 1.0</td></tr>
<tr class="memdesc:af11c0f9ba830e35a5b92a041b0a24ded"><td class="mdescLeft">&#160;</td><td class="mdescRight">We can also pseudorandomly drop reads. What's the probability that we keep a read?  <a href="#af11c0f9ba830e35a5b92a041b0a24ded">More...</a><br/></td></tr>
<tr class="separator:af11c0f9ba830e35a5b92a041b0a24ded"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acad7bd40167b335fee96b0475a625aef"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#acad7bd40167b335fee96b0475a625aef">downsample_seed_mask</a> = 0</td></tr>
<tr class="separator:acad7bd40167b335fee96b0475a625aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d85ffe55c3074f0b5f9664465fec883"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a0d85ffe55c3074f0b5f9664465fec883">defray_length</a> = 0</td></tr>
<tr class="separator:a0d85ffe55c3074f0b5f9664465fec883"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7397dca610aa815fd6a1abac7d67b5c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ac7397dca610aa815fd6a1abac7d67b5c">defray_count</a> = 99999</td></tr>
<tr class="memdesc:ac7397dca610aa815fd6a1abac7d67b5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limit defray recursion to visit this many nodes.  <a href="#ac7397dca610aa815fd6a1abac7d67b5c">More...</a><br/></td></tr>
<tr class="separator:ac7397dca610aa815fd6a1abac7d67b5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22e4ebb26cce954d20deb7b0d7a31641"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a22e4ebb26cce954d20deb7b0d7a31641">threads</a> = -1</td></tr>
<tr class="memdesc:a22e4ebb26cce954d20deb7b0d7a31641"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of threads from omp.  <a href="#a22e4ebb26cce954d20deb7b0d7a31641">More...</a><br/></td></tr>
<tr class="separator:a22e4ebb26cce954d20deb7b0d7a31641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5aa58e55aa8546d0e555a90b7b1ac1a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ad5aa58e55aa8546d0e555a90b7b1ac1a">buffer_size</a> = 512</td></tr>
<tr class="memdesc:ad5aa58e55aa8546d0e555a90b7b1ac1a"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAM output buffer size.  <a href="#ad5aa58e55aa8546d0e555a90b7b1ac1a">More...</a><br/></td></tr>
<tr class="separator:ad5aa58e55aa8546d0e555a90b7b1ac1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5bab332dd50a2b84e4bb7798fabd349"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ad5bab332dd50a2b84e4bb7798fabd349">write_output</a> = true</td></tr>
<tr class="separator:ad5bab332dd50a2b84e4bb7798fabd349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fc3a9a61f57bb5a8c9857fe43a032f5"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a7fc3a9a61f57bb5a8c9857fe43a032f5">graph</a> = nullptr</td></tr>
<tr class="memdesc:a7fc3a9a61f57bb5a8c9857fe43a032f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">A HandleGraph is required for some filters (Note: <a class="el" href="classvg_1_1ReadFilter.html">ReadFilter</a> doesn't own/free this)  <a href="#a7fc3a9a61f57bb5a8c9857fe43a032f5">More...</a><br/></td></tr>
<tr class="separator:a7fc3a9a61f57bb5a8c9857fe43a032f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a2dea40e9afefb8e7e4e1827a5c109"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a30a2dea40e9afefb8e7e4e1827a5c109">interleaved</a> = false</td></tr>
<tr class="memdesc:a30a2dea40e9afefb8e7e4e1827a5c109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaved input.  <a href="#a30a2dea40e9afefb8e7e4e1827a5c109">More...</a><br/></td></tr>
<tr class="separator:a30a2dea40e9afefb8e7e4e1827a5c109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc075968b0c08ed7ad4f2cb0a837ef95"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#acc075968b0c08ed7ad4f2cb0a837ef95">filter_on_all</a> = false</td></tr>
<tr class="separator:acc075968b0c08ed7ad4f2cb0a837ef95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c77d9ed319e6f7cf3e38582621fce1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a52c77d9ed319e6f7cf3e38582621fce1">min_base_quality</a> = 0</td></tr>
<tr class="separator:a52c77d9ed319e6f7cf3e38582621fce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e494cd5be020669694244d1f3ffc4c6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a6e494cd5be020669694244d1f3ffc4c6">min_base_quality_fraction</a> = 0.0</td></tr>
<tr class="separator:a6e494cd5be020669694244d1f3ffc4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a457e9fef8d1e19c78b4a72ff10d14260"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a457e9fef8d1e19c78b4a72ff10d14260">append_regions</a> = false</td></tr>
<tr class="separator:a457e9fef8d1e19c78b4a72ff10d14260"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:ac6a2619d7e6dff8fc81aed985a28e3f2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ac6a2619d7e6dff8fc81aed985a28e3f2">has_repeat</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, int k)</td></tr>
<tr class="separator:ac6a2619d7e6dff8fc81aed985a28e3f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35f5b827c01ca762dbe3707034d42d25"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a35f5b827c01ca762dbe3707034d42d25">trim_ambiguous_end</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, int k)</td></tr>
<tr class="separator:a35f5b827c01ca762dbe3707034d42d25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07039862a8bee98803f764863b3ba0fa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a07039862a8bee98803f764863b3ba0fa">is_split</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:a07039862a8bee98803f764863b3ba0fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052c3d8dcfcf5b26d2180b37217159f5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a052c3d8dcfcf5b26d2180b37217159f5">sample_read</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;read)</td></tr>
<tr class="separator:a052c3d8dcfcf5b26d2180b37217159f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a7fe8cb61ed8a2f376b0404e934af8b91"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::ReadFilter::filter </td>
          <td>(</td>
          <td class="paramtype">istream *&#160;</td>
          <td class="paramname"><em>alignment_stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classvg_1_1Filter.html">Filter</a> the alignments available from the given stream, placing them on standard output or in the appropriate file. Returns 0 on success, exit code to use on error. </p>

</div>
</div>
<a class="anchor" id="a398d61417de9097c385315490b7034df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ReadFilter_1_1Counts.html">ReadFilter::Counts</a> vg::ReadFilter::filter_alignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run all the filters on an alignment. The alignment may get modified in-place by the defray filter </p>

</div>
</div>
<a class="anchor" id="ac6a2619d7e6dff8fc81aed985a28e3f2"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::has_repeat </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Â * quick and dirty filter to see if removing reads that can slip around and still map perfectly helps vg call. returns true if at either end of read sequence, at least k bases are repetitive, checking repeats of up to size 2k </p>

</div>
</div>
<a class="anchor" id="a07039862a8bee98803f764863b3ba0fa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::is_split </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return false if the read only follows edges in the xg index, and true if the read is split (or just incorrect) and takes edges not in the index.</p>
<p>Throws an error if no <a class="el" href="classvg_1_1XG.html">XG</a> index is specified. </p>

</div>
</div>
<a class="anchor" id="a052c3d8dcfcf5b26d2180b37217159f5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::sample_read </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Based on the read name and paired-ness, compute the SAM-style QNAME and use that and the configured sampling probability and seed in the Samtools read sampling algorithm, to determine if the read should be kept. Returns true if the read should stay, and false if it should be removed. Always accepts or rejects paired reads together. </p>

</div>
</div>
<a class="anchor" id="a35f5b827c01ca762dbe3707034d42d25"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::trim_ambiguous_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trim only the end of the given alignment, leaving the start alone. Two calls of this implement trim_ambiguous_ends above. </p>

</div>
</div>
<a class="anchor" id="a31011cb29962d3510bb50b315409a025"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::trim_ambiguous_ends </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look at either end of the given alignment, up to k bases in from the end. See if that tail of the alignment is mapped such that another embedding in the given graph can produce the same sequence as the sequence along the embedding that the read actually has, and if so trim back the read.</p>
<p>In the case of softclips, the aligned portion of the read is considered, and if trimmign is required, the softclips are hard-clipped off.</p>
<p>Returns true if the read had to be modified, and false otherwise.</p>
<p>MUST NOT be called with a null index. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a457e9fef8d1e19c78b4a72ff10d14260"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::append_regions = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad5aa58e55aa8546d0e555a90b7b1ac1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::ReadFilter::buffer_size = 512</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GAM output buffer size. </p>

</div>
</div>
<a class="anchor" id="a7a22a82c55e23fca581060934d03935e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::complement_filter = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actually take the complement of the filter. </p>

</div>
</div>
<a class="anchor" id="ac7397dca610aa815fd6a1abac7d67b5c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::ReadFilter::defray_count = 99999</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Limit defray recursion to visit this many nodes. </p>

</div>
</div>
<a class="anchor" id="a0d85ffe55c3074f0b5f9664465fec883"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::ReadFilter::defray_length = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>How far in from the end should we look for ambiguous end alignment to clip off? </p>

</div>
</div>
<a class="anchor" id="af11c0f9ba830e35a5b92a041b0a24ded"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::ReadFilter::downsample_probability = 1.0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We can also pseudorandomly drop reads. What's the probability that we keep a read? </p>

</div>
</div>
<a class="anchor" id="acad7bd40167b335fee96b0475a625aef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t vg::ReadFilter::downsample_seed_mask = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Samtools-compatible internal seed mask, for deciding which read pairs to keep. To be generated with rand() after srand() from the user-visible seed. </p>

</div>
</div>
<a class="anchor" id="a6eba4b03f0f697ae6540a255dd7b0627"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::drop_split = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Should we drop split reads that follow edges not in the graph? </p>

</div>
</div>
<a class="anchor" id="acacb1ca6d956c7cab4e2f6c93db0ceb2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_set&lt;string&gt; vg::ReadFilter::excluded_features</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If a read has one of the features in this set as annotations, the read is filtered out. </p>

</div>
</div>
<a class="anchor" id="a3b80df71a29a718b34af1becfe821026"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;regex&gt; vg::ReadFilter::excluded_refpos_contigs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read must not have a refpos set with a contig name containing a match to any of these. </p>

</div>
</div>
<a class="anchor" id="acc075968b0c08ed7ad4f2cb0a837ef95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::filter_on_all = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When outputting paired reads, fail the pair only if both (all) reads fail (true) instead of if either (any) read fails (false) </p>

</div>
</div>
<a class="anchor" id="a39086ef40e89b6b3733e5e9c42482e1e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::frac_score = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7fc3a9a61f57bb5a8c9857fe43a032f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a>* vg::ReadFilter::graph = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A HandleGraph is required for some filters (Note: <a class="el" href="classvg_1_1ReadFilter.html">ReadFilter</a> doesn't own/free this) </p>

</div>
</div>
<a class="anchor" id="a30a2dea40e9afefb8e7e4e1827a5c109"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::interleaved = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleaved input. </p>

</div>
</div>
<a class="anchor" id="ab73972404a3db8d8f902d3d47896857d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::ReadFilter::max_overhang = 99999</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a52c77d9ed319e6f7cf3e38582621fce1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::ReadFilter::min_base_quality = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6e494cd5be020669694244d1f3ffc4c6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::ReadFilter::min_base_quality_fraction = 0.0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8848d4b66a515602fa38571b02667b51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::ReadFilter::min_end_matches = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa1d1564e0834e1236d104da7045a4894"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::ReadFilter::min_mapq = 0.</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a17dbd2182c6cf4816c1fe22ae60e2a01"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::ReadFilter::min_primary = 0.</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8f0ecf4f3140e483ba93592231929dbb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::ReadFilter::min_secondary = 0.</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a1de9ae45579a188cfc673018e9dc8b0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;string&gt; vg::ReadFilter::name_prefixes</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read name must have one of these prefixes, if any are present. TODO: This should be a trie but I don't have one handy. Must be sorted for vaguely efficient search. </p>

</div>
</div>
<a class="anchor" id="a4d1bcac75fda8d439384ba8c09c780cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::ReadFilter::repeat_size = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab3b47fbeff165aa3fb4fdff25d2cb6fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::rescore = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Should we rescore each alignment with default parameters and no e.g. haplotype info? </p>

</div>
</div>
<a class="anchor" id="a96c8a5914f93571e56eff63d3604596a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::sub_score = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a22e4ebb26cce954d20deb7b0d7a31641"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::ReadFilter::threads = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of threads from omp. </p>

</div>
</div>
<a class="anchor" id="a2ad1a1b72ee0b450fe79340451893cfa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::verbose = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad5bab332dd50a2b84e4bb7798fabd349"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ReadFilter::write_output = true</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sometimes we only want a report, and not a filtered gam. toggling off output speeds things up considerably. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="readfilter_8hpp.html">readfilter.hpp</a></li>
<li>src/<a class="el" href="readfilter_8cpp.html">readfilter.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
