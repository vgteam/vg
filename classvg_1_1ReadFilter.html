<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::ReadFilter&lt; Read &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1ReadFilter.html">ReadFilter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1ReadFilter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::ReadFilter&lt; Read &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;readfilter.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a1398f727931b41bfff0d9e058f442ebc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Counts.html">Counts</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a1398f727931b41bfff0d9e058f442ebc">filter_alignment</a> (Read &amp;aln)</td></tr>
<tr class="separator:a1398f727931b41bfff0d9e058f442ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36c3ff48009706f3853bddd02a98de9c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a36c3ff48009706f3853bddd02a98de9c">filter</a> (istream *alignment_stream)</td></tr>
<tr class="separator:a36c3ff48009706f3853bddd02a98de9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a265a2c2d5e5af4924c406b97d764d9aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a265a2c2d5e5af4924c406b97d764d9aa">trim_ambiguous_ends</a> (Read &amp;read, int k) const</td></tr>
<tr class="separator:a265a2c2d5e5af4924c406b97d764d9aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb619abfe77d0b02cc7f8aa4ad47af5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a1fb619abfe77d0b02cc7f8aa4ad47af5">filter</a> (istream *alignment_stream)</td></tr>
<tr class="separator:a1fb619abfe77d0b02cc7f8aa4ad47af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab56d51dbf343ea44e78c31d54f1f317f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ab56d51dbf343ea44e78c31d54f1f317f">filter</a> (istream *alignment_stream)</td></tr>
<tr class="separator:ab56d51dbf343ea44e78c31d54f1f317f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49bf695fadbdaf8b41c972587493630"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ac49bf695fadbdaf8b41c972587493630">trim_ambiguous_ends</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, int k) const</td></tr>
<tr class="separator:ac49bf695fadbdaf8b41c972587493630"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a266b5aeeb2081d2bd5f29ae43fdc00f8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a266b5aeeb2081d2bd5f29ae43fdc00f8">trim_ambiguous_ends</a> (<a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;aln, int k) const</td></tr>
<tr class="separator:a266b5aeeb2081d2bd5f29ae43fdc00f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:ab7e72e4f3440fdc2a846de1e81fe2230"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ab7e72e4f3440fdc2a846de1e81fe2230">complement_filter</a> = false</td></tr>
<tr class="memdesc:ab7e72e4f3440fdc2a846de1e81fe2230"><td class="mdescLeft">&#160;</td><td class="mdescRight">Actually take the complement of the filter.  <a href="classvg_1_1ReadFilter.html#ab7e72e4f3440fdc2a846de1e81fe2230">More...</a><br /></td></tr>
<tr class="separator:ab7e72e4f3440fdc2a846de1e81fe2230"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59dd97c0eadf3aebd852ae3b0aabe31d"><td class="memItemLeft" align="right" valign="top">vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a59dd97c0eadf3aebd852ae3b0aabe31d">name_prefixes</a></td></tr>
<tr class="separator:a59dd97c0eadf3aebd852ae3b0aabe31d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3165602af2a80ad642c9f900f9bf723e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a3165602af2a80ad642c9f900f9bf723e">exact_name</a> = false</td></tr>
<tr class="memdesc:a3165602af2a80ad642c9f900f9bf723e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read name must not have anything in it besides the prefix.  <a href="classvg_1_1ReadFilter.html#a3165602af2a80ad642c9f900f9bf723e">More...</a><br /></td></tr>
<tr class="separator:a3165602af2a80ad642c9f900f9bf723e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a019f6eab0ba08ab063f2f9b1226a0cf0"><td class="memItemLeft" align="right" valign="top">vector&lt; regex &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a019f6eab0ba08ab063f2f9b1226a0cf0">excluded_refpos_contigs</a></td></tr>
<tr class="memdesc:a019f6eab0ba08ab063f2f9b1226a0cf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read must not have a refpos set with a contig name containing a match to any of these.  <a href="classvg_1_1ReadFilter.html#a019f6eab0ba08ab063f2f9b1226a0cf0">More...</a><br /></td></tr>
<tr class="separator:a019f6eab0ba08ab063f2f9b1226a0cf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98cd220c402ec88c512121825ed690df"><td class="memItemLeft" align="right" valign="top">vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a98cd220c402ec88c512121825ed690df">subsequences</a></td></tr>
<tr class="memdesc:a98cd220c402ec88c512121825ed690df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read must contain at least one of these strings as a subsequence.  <a href="classvg_1_1ReadFilter.html#a98cd220c402ec88c512121825ed690df">More...</a><br /></td></tr>
<tr class="separator:a98cd220c402ec88c512121825ed690df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621533fd4d338b7b5cee85df4a64c8ef"><td class="memItemLeft" align="right" valign="top">unordered_set&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a621533fd4d338b7b5cee85df4a64c8ef">excluded_features</a></td></tr>
<tr class="separator:a621533fd4d338b7b5cee85df4a64c8ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85c211a4a06a1fb750958002cefba0f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#af85c211a4a06a1fb750958002cefba0f">min_secondary</a> = numeric_limits&lt;double&gt;::lowest()</td></tr>
<tr class="separator:af85c211a4a06a1fb750958002cefba0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64132e9f5f27ce6930554ad3c197e694"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a64132e9f5f27ce6930554ad3c197e694">min_primary</a> = numeric_limits&lt;double&gt;::lowest()</td></tr>
<tr class="separator:a64132e9f5f27ce6930554ad3c197e694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2afae0acb031354f67f95f20dda1c4b8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a2afae0acb031354f67f95f20dda1c4b8">max_length</a> = std::numeric_limits&lt;size_t&gt;::max()</td></tr>
<tr class="separator:a2afae0acb031354f67f95f20dda1c4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7373ef70ee64562dd779628a234c1080"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a7373ef70ee64562dd779628a234c1080">rescore</a> = false</td></tr>
<tr class="separator:a7373ef70ee64562dd779628a234c1080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e3876fb7401ecf89e9cd75fee37d59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a28e3876fb7401ecf89e9cd75fee37d59">frac_score</a> = false</td></tr>
<tr class="separator:a28e3876fb7401ecf89e9cd75fee37d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529c0b978b3855bab3dc1074fd18a711"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a529c0b978b3855bab3dc1074fd18a711">sub_score</a> = false</td></tr>
<tr class="separator:a529c0b978b3855bab3dc1074fd18a711"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54c30818834f623c78a2cb0a0e9b4a91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a54c30818834f623c78a2cb0a0e9b4a91">max_overhang</a> = numeric_limits&lt;int&gt;::max() / 2</td></tr>
<tr class="separator:a54c30818834f623c78a2cb0a0e9b4a91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d07dd311e58f3fc04d510870ddf662"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a05d07dd311e58f3fc04d510870ddf662">min_end_matches</a> = numeric_limits&lt;int&gt;::min() / 2</td></tr>
<tr class="separator:a05d07dd311e58f3fc04d510870ddf662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa207b19d222c64919714bae506b726a6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#aa207b19d222c64919714bae506b726a6">verbose</a> = false</td></tr>
<tr class="separator:aa207b19d222c64919714bae506b726a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8da615d17aba7ed66be6174253ce64ce"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a8da615d17aba7ed66be6174253ce64ce">min_mapq</a> = numeric_limits&lt;double&gt;::lowest()</td></tr>
<tr class="separator:a8da615d17aba7ed66be6174253ce64ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95e0303086c9c6dc7a17d452b7d7f928"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a95e0303086c9c6dc7a17d452b7d7f928">repeat_size</a> = 0</td></tr>
<tr class="separator:a95e0303086c9c6dc7a17d452b7d7f928"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52316fdf4e8b2ee3741bfbc4a89727a7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a52316fdf4e8b2ee3741bfbc4a89727a7">drop_split</a> = false</td></tr>
<tr class="memdesc:a52316fdf4e8b2ee3741bfbc4a89727a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Should we drop split reads that follow edges not in the graph?  <a href="classvg_1_1ReadFilter.html#a52316fdf4e8b2ee3741bfbc4a89727a7">More...</a><br /></td></tr>
<tr class="separator:a52316fdf4e8b2ee3741bfbc4a89727a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44099974ab2ac2d374e4530b064e1908"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a44099974ab2ac2d374e4530b064e1908">downsample_probability</a> = 1.0</td></tr>
<tr class="memdesc:a44099974ab2ac2d374e4530b064e1908"><td class="mdescLeft">&#160;</td><td class="mdescRight">We can also pseudorandomly drop reads. What's the probability that we keep a read?  <a href="classvg_1_1ReadFilter.html#a44099974ab2ac2d374e4530b064e1908">More...</a><br /></td></tr>
<tr class="separator:a44099974ab2ac2d374e4530b064e1908"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a881165b11e7539bc03e331f16b1a5f0a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a881165b11e7539bc03e331f16b1a5f0a">downsample_seed_mask</a> = 0</td></tr>
<tr class="separator:a881165b11e7539bc03e331f16b1a5f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a4d052b3060e2b8a434310ce6dc14f5"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a1a4d052b3060e2b8a434310ce6dc14f5">max_reads</a> = numeric_limits&lt;size_t&gt;::max()</td></tr>
<tr class="memdesc:a1a4d052b3060e2b8a434310ce6dc14f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many reads should we take total? Note that this filter is nondeterministic.  <a href="classvg_1_1ReadFilter.html#a1a4d052b3060e2b8a434310ce6dc14f5">More...</a><br /></td></tr>
<tr class="separator:a1a4d052b3060e2b8a434310ce6dc14f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1a4ac583b2b783404b20e985c4a5f5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ab1a4ac583b2b783404b20e985c4a5f5e">defray_length</a> = 0</td></tr>
<tr class="separator:ab1a4ac583b2b783404b20e985c4a5f5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef4ec3c75ed003564641757d0d78b6ea"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#aef4ec3c75ed003564641757d0d78b6ea">defray_count</a> = 99999</td></tr>
<tr class="memdesc:aef4ec3c75ed003564641757d0d78b6ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Limit defray recursion to visit this many nodes.  <a href="classvg_1_1ReadFilter.html#aef4ec3c75ed003564641757d0d78b6ea">More...</a><br /></td></tr>
<tr class="separator:aef4ec3c75ed003564641757d0d78b6ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac41003be9ee710a1003288e2a6ba9c7d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ac41003be9ee710a1003288e2a6ba9c7d">only_proper_pairs</a> = true</td></tr>
<tr class="memdesc:ac41003be9ee710a1003288e2a6ba9c7d"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvg_1_1Filter.html">Filter</a> to proper pairs.  <a href="classvg_1_1ReadFilter.html#ac41003be9ee710a1003288e2a6ba9c7d">More...</a><br /></td></tr>
<tr class="separator:ac41003be9ee710a1003288e2a6ba9c7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab19be8fc638af431bb1a629aeff77f4f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ab19be8fc638af431bb1a629aeff77f4f">only_mapped</a> = true</td></tr>
<tr class="memdesc:ab19be8fc638af431bb1a629aeff77f4f"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvg_1_1Filter.html">Filter</a> to only mapped reads.  <a href="classvg_1_1ReadFilter.html#ab19be8fc638af431bb1a629aeff77f4f">More...</a><br /></td></tr>
<tr class="separator:ab19be8fc638af431bb1a629aeff77f4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41808c4d5db46d1405ac906a01bbf794"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a41808c4d5db46d1405ac906a01bbf794">threads</a> = -1</td></tr>
<tr class="memdesc:a41808c4d5db46d1405ac906a01bbf794"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of threads from omp.  <a href="classvg_1_1ReadFilter.html#a41808c4d5db46d1405ac906a01bbf794">More...</a><br /></td></tr>
<tr class="separator:a41808c4d5db46d1405ac906a01bbf794"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d00933de6bd943fed0a4ec48112f39e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a2d00933de6bd943fed0a4ec48112f39e">buffer_size</a> = 512</td></tr>
<tr class="memdesc:a2d00933de6bd943fed0a4ec48112f39e"><td class="mdescLeft">&#160;</td><td class="mdescRight">GAM output buffer size.  <a href="classvg_1_1ReadFilter.html#a2d00933de6bd943fed0a4ec48112f39e">More...</a><br /></td></tr>
<tr class="separator:a2d00933de6bd943fed0a4ec48112f39e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a249032f1613c12263e7c14d83b4e527e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a249032f1613c12263e7c14d83b4e527e">write_output</a> = true</td></tr>
<tr class="separator:a249032f1613c12263e7c14d83b4e527e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9979d9966e9ea82a9cd160dbf38d4b7c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a9979d9966e9ea82a9cd160dbf38d4b7c">write_tsv</a> = false</td></tr>
<tr class="memdesc:a9979d9966e9ea82a9cd160dbf38d4b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sometimes we want to pick out fields and write a tsv instead of a gam;.  <a href="classvg_1_1ReadFilter.html#a9979d9966e9ea82a9cd160dbf38d4b7c">More...</a><br /></td></tr>
<tr class="separator:a9979d9966e9ea82a9cd160dbf38d4b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade1a4a40379d72d2811fe0e32bece8f7"><td class="memItemLeft" align="right" valign="top">vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ade1a4a40379d72d2811fe0e32bece8f7">output_fields</a></td></tr>
<tr class="memdesc:ade1a4a40379d72d2811fe0e32bece8f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">What fields do we want to write to the tsv?  <a href="classvg_1_1ReadFilter.html#ade1a4a40379d72d2811fe0e32bece8f7">More...</a><br /></td></tr>
<tr class="separator:ade1a4a40379d72d2811fe0e32bece8f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73ca67996129403044a23de9544e88fd"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a73ca67996129403044a23de9544e88fd">graph</a> = nullptr</td></tr>
<tr class="memdesc:a73ca67996129403044a23de9544e88fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">A HandleGraph is required for some filters (Note: <a class="el" href="classvg_1_1ReadFilter.html">ReadFilter</a> doesn't own/free this)  <a href="classvg_1_1ReadFilter.html#a73ca67996129403044a23de9544e88fd">More...</a><br /></td></tr>
<tr class="separator:a73ca67996129403044a23de9544e88fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7c97fa34473eb5b1e3bce2dd64d6eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a3d7c97fa34473eb5b1e3bce2dd64d6eb">interleaved</a> = false</td></tr>
<tr class="memdesc:a3d7c97fa34473eb5b1e3bce2dd64d6eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Interleaved input.  <a href="classvg_1_1ReadFilter.html#a3d7c97fa34473eb5b1e3bce2dd64d6eb">More...</a><br /></td></tr>
<tr class="separator:a3d7c97fa34473eb5b1e3bce2dd64d6eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0789571cd8039786e8eb53e5e6f53cee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a0789571cd8039786e8eb53e5e6f53cee">filter_on_all</a> = false</td></tr>
<tr class="separator:a0789571cd8039786e8eb53e5e6f53cee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7fe13f943f153913f16aa594720d350a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a7fe13f943f153913f16aa594720d350a">min_base_quality</a> = numeric_limits&lt;int&gt;::min() / 2</td></tr>
<tr class="separator:a7fe13f943f153913f16aa594720d350a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8c6af52884a83d9538ea7ef42ac9eb4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ab8c6af52884a83d9538ea7ef42ac9eb4">min_base_quality_fraction</a> = numeric_limits&lt;double&gt;::lowest()</td></tr>
<tr class="separator:ab8c6af52884a83d9538ea7ef42ac9eb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89cd59970cfca5bf91f828f84035e39a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a89cd59970cfca5bf91f828f84035e39a">batch_size</a> = <a class="el" href="namespacevg_1_1io.html#aba1d6c41cb6ff7b47e64b6b584af0363">vg::io::DEFAULT_PARALLEL_BATCHSIZE</a></td></tr>
<tr class="memdesc:a89cd59970cfca5bf91f828f84035e39a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Process reads in batches of this size.  <a href="classvg_1_1ReadFilter.html#a89cd59970cfca5bf91f828f84035e39a">More...</a><br /></td></tr>
<tr class="separator:a89cd59970cfca5bf91f828f84035e39a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44b9ee21da92a8cd89af5b6538ac32a0"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a44b9ee21da92a8cd89af5b6538ac32a0">annotation_to_match</a> = &quot;&quot;</td></tr>
<tr class="separator:a44b9ee21da92a8cd89af5b6538ac32a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f19128ff55e1e2c1cad90adcfc0d6e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ab0f19128ff55e1e2c1cad90adcfc0d6e">only_correctly_mapped</a> = false</td></tr>
<tr class="memdesc:ab0f19128ff55e1e2c1cad90adcfc0d6e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvg_1_1Filter.html">Filter</a> to only correctly mapped reads.  <a href="classvg_1_1ReadFilter.html#ab0f19128ff55e1e2c1cad90adcfc0d6e">More...</a><br /></td></tr>
<tr class="separator:ab0f19128ff55e1e2c1cad90adcfc0d6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5747bfc6146fa25db9fd96f1f760f6f0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a5747bfc6146fa25db9fd96f1f760f6f0">only_first_alignment</a> = false</td></tr>
<tr class="memdesc:a5747bfc6146fa25db9fd96f1f760f6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="classvg_1_1Filter.html">Filter</a> to only keep the first alignment for each read.  <a href="classvg_1_1ReadFilter.html#a5747bfc6146fa25db9fd96f1f760f6f0">More...</a><br /></td></tr>
<tr class="separator:a5747bfc6146fa25db9fd96f1f760f6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a613b00bb83a119d89911ed4315e4e24a"><td class="memItemLeft" align="right" valign="top">unordered_set&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a613b00bb83a119d89911ed4315e4e24a">seen_read_names</a></td></tr>
<tr class="memdesc:a613b00bb83a119d89911ed4315e4e24a"><td class="mdescLeft">&#160;</td><td class="mdescRight">If we are picking only the first alignment for each read, keep track of what we've seen.  <a href="classvg_1_1ReadFilter.html#a613b00bb83a119d89911ed4315e4e24a">More...</a><br /></td></tr>
<tr class="separator:a613b00bb83a119d89911ed4315e4e24a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a9aecb91c19bb44bb9be32c4f30c44538"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a9aecb91c19bb44bb9be32c4f30c44538">has_repeat</a> (const Read &amp;read, int k) const</td></tr>
<tr class="separator:a9aecb91c19bb44bb9be32c4f30c44538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1acad05129d0a6146416f596903216a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a1acad05129d0a6146416f596903216a8">is_mapped</a> (const Read &amp;read) const</td></tr>
<tr class="separator:a1acad05129d0a6146416f596903216a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5d77581ac1d34661c62f446692217ab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ac5d77581ac1d34661c62f446692217ab">trim_ambiguous_end</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, int k) const</td></tr>
<tr class="separator:ac5d77581ac1d34661c62f446692217ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34d313741dcfe8c009dfcc380d1293ad"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a34d313741dcfe8c009dfcc380d1293ad">is_split</a> (const Read &amp;read) const</td></tr>
<tr class="separator:a34d313741dcfe8c009dfcc380d1293ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa592c88e758fc257fdf17418b0f189a8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#aa592c88e758fc257fdf17418b0f189a8">sample_read</a> (const Read &amp;read) const</td></tr>
<tr class="separator:aa592c88e758fc257fdf17418b0f189a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b0bf11e5636b41cf6dfc4a61441c4e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a21b0bf11e5636b41cf6dfc4a61441c4e">to_alignment</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;multipath_aln) const</td></tr>
<tr class="separator:a21b0bf11e5636b41cf6dfc4a61441c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e168659158cf4372fc11b8cda05883d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a3e168659158cf4372fc11b8cda05883d">get_score</a> (const Read &amp;read) const</td></tr>
<tr class="separator:a3e168659158cf4372fc11b8cda05883d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2ef22beb751d9415759fc1985da1946"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ae2ef22beb751d9415759fc1985da1946">get_length</a> (const Read &amp;read) const</td></tr>
<tr class="separator:ae2ef22beb751d9415759fc1985da1946"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab72c4fd96eedcb4bcd6aa565e97dfe4d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ab72c4fd96eedcb4bcd6aa565e97dfe4d">matches_name</a> (const Read &amp;read) const</td></tr>
<tr class="separator:ab72c4fd96eedcb4bcd6aa565e97dfe4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac772c0651477027191108e64ab7c53cb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ac772c0651477027191108e64ab7c53cb">has_excluded_refpos</a> (const Read &amp;read) const</td></tr>
<tr class="separator:ac772c0651477027191108e64ab7c53cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d30291c0c609d58670f40e2eb9661e4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a2d30291c0c609d58670f40e2eb9661e4">has_excuded_feature</a> (const Read &amp;read) const</td></tr>
<tr class="separator:a2d30291c0c609d58670f40e2eb9661e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947155b6ed467a8ea83ac80db6e11a63"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a947155b6ed467a8ea83ac80db6e11a63">is_secondary</a> (const Read &amp;read) const</td></tr>
<tr class="separator:a947155b6ed467a8ea83ac80db6e11a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bb794016b2f59d6495a98b9716e0b5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a71bb794016b2f59d6495a98b9716e0b5">get_overhang</a> (const Read &amp;read) const</td></tr>
<tr class="separator:a71bb794016b2f59d6495a98b9716e0b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab655011da419f60374d9238c0c21312b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ab655011da419f60374d9238c0c21312b">alignment_overhang</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln) const</td></tr>
<tr class="separator:ab655011da419f60374d9238c0c21312b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd3ee44928526e27e42e059b693ba76"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a3cd3ee44928526e27e42e059b693ba76">get_end_matches</a> (const Read &amp;read) const</td></tr>
<tr class="separator:a3cd3ee44928526e27e42e059b693ba76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5088cb81cac4ce8e26c6a921bf29b546"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a5088cb81cac4ce8e26c6a921bf29b546">alignment_end_matches</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln) const</td></tr>
<tr class="separator:a5088cb81cac4ce8e26c6a921bf29b546"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0550e932f7becd1fbccd46787b580216"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a0550e932f7becd1fbccd46787b580216">get_mapq</a> (const Read &amp;read) const</td></tr>
<tr class="separator:a0550e932f7becd1fbccd46787b580216"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2ca26c062585494f69520f9997d34eb"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ad2ca26c062585494f69520f9997d34eb">get_min_base_qual_fraction</a> (const Read &amp;read) const</td></tr>
<tr class="separator:ad2ca26c062585494f69520f9997d34eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b78c03c1379b1ed5576db5c6772adb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a8b78c03c1379b1ed5576db5c6772adb3">get_is_paired</a> (const Read &amp;read) const</td></tr>
<tr class="separator:a8b78c03c1379b1ed5576db5c6772adb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ebb80a71eaf7c765f33b306ab230d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ad5ebb80a71eaf7c765f33b306ab230d8">is_proper_pair</a> (const Read &amp;read) const</td></tr>
<tr class="separator:ad5ebb80a71eaf7c765f33b306ab230d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553af1f5f52e24334fb2dd22928ac86a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a553af1f5f52e24334fb2dd22928ac86a">contains_subsequence</a> (const Read &amp;read) const</td></tr>
<tr class="separator:a553af1f5f52e24334fb2dd22928ac86a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d1165f7c3901772a70ba863d1fc983"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a95d1165f7c3901772a70ba863d1fc983">matches_annotation</a> (const Read &amp;read) const</td></tr>
<tr class="separator:a95d1165f7c3901772a70ba863d1fc983"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5da32515034e6669d9e14de3c748122"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ac5da32515034e6669d9e14de3c748122">is_correctly_mapped</a> (const Read &amp;read) const</td></tr>
<tr class="separator:ac5da32515034e6669d9e14de3c748122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50fce1e4c1159834e6371156040c6cbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a50fce1e4c1159834e6371156040c6cbe">emit</a> (Read &amp;read)</td></tr>
<tr class="separator:a50fce1e4c1159834e6371156040c6cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5beda5e781b3a4b1b6ec139b280785d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a5beda5e781b3a4b1b6ec139b280785d9">emit</a> (Read &amp;read1, Read &amp;read2)</td></tr>
<tr class="separator:a5beda5e781b3a4b1b6ec139b280785d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02ed848e6d5395a8b966f883bd318a8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a02ed848e6d5395a8b966f883bd318a8e">emit_tsv</a> (Read &amp;read, std::ostream &amp;out)</td></tr>
<tr class="separator:a02ed848e6d5395a8b966f883bd318a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3220ffe3aa6042a1423c6251c95a2b05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a3220ffe3aa6042a1423c6251c95a2b05">filter_internal</a> (istream *in)</td></tr>
<tr class="memdesc:a3220ffe3aa6042a1423c6251c95a2b05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function for filter.  <a href="classvg_1_1ReadFilter.html#a3220ffe3aa6042a1423c6251c95a2b05">More...</a><br /></td></tr>
<tr class="separator:a3220ffe3aa6042a1423c6251c95a2b05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf05b0ded409cd19894c24b6fe9412bf"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#acf05b0ded409cd19894c24b6fe9412bf">is_mapped</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment) const</td></tr>
<tr class="separator:acf05b0ded409cd19894c24b6fe9412bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1fe573ba370f839adb1cd28350cac81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ad1fe573ba370f839adb1cd28350cac81">is_mapped</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;mp_alignment) const</td></tr>
<tr class="separator:ad1fe573ba370f839adb1cd28350cac81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab76d4dc77becdaf866f724d5b88dcdb5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ab76d4dc77becdaf866f724d5b88dcdb5">is_correctly_mapped</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment) const</td></tr>
<tr class="separator:ab76d4dc77becdaf866f724d5b88dcdb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a053397b20bc378d11f11b365e6d68032"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a053397b20bc378d11f11b365e6d68032">is_correctly_mapped</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;alignment) const</td></tr>
<tr class="separator:a053397b20bc378d11f11b365e6d68032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4436cd59a7d2ed18c4a315ef157239ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a4436cd59a7d2ed18c4a315ef157239ed">emit</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="separator:a4436cd59a7d2ed18c4a315ef157239ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae811413740325799e12d313149f2b15a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ae811413740325799e12d313149f2b15a">emit</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln1, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln2)</td></tr>
<tr class="separator:ae811413740325799e12d313149f2b15a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95b5ca4213c6da0a174e53c2f91fb36b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a95b5ca4213c6da0a174e53c2f91fb36b">emit</a> (<a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;mp_aln)</td></tr>
<tr class="separator:a95b5ca4213c6da0a174e53c2f91fb36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3864d427682af9b6e0a67a157fddcfa2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a3864d427682af9b6e0a67a157fddcfa2">emit</a> (<a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;mp_aln1, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;mp_aln2)</td></tr>
<tr class="separator:a3864d427682af9b6e0a67a157fddcfa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2144e5b768ebd71768d37265c07deda2"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a2144e5b768ebd71768d37265c07deda2">get_score</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln) const</td></tr>
<tr class="separator:a2144e5b768ebd71768d37265c07deda2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af800d67aa469136b6318c02e282c5a30"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#af800d67aa469136b6318c02e282c5a30">get_score</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;read) const</td></tr>
<tr class="separator:af800d67aa469136b6318c02e282c5a30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab609cc20f1e49dc1001e71fe82c5ead4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ab609cc20f1e49dc1001e71fe82c5ead4">has_excluded_refpos</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;read) const</td></tr>
<tr class="separator:ab609cc20f1e49dc1001e71fe82c5ead4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca79c3eda85a8f4fafcd25a243b7efd4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#aca79c3eda85a8f4fafcd25a243b7efd4">has_excluded_refpos</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln) const</td></tr>
<tr class="separator:aca79c3eda85a8f4fafcd25a243b7efd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44451e4c12ff1a923221d019c31c610c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a44451e4c12ff1a923221d019c31c610c">is_secondary</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;mp_aln) const</td></tr>
<tr class="separator:a44451e4c12ff1a923221d019c31c610c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4ae201744c8abc543d60afb24b294eb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ab4ae201744c8abc543d60afb24b294eb">is_secondary</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln) const</td></tr>
<tr class="separator:ab4ae201744c8abc543d60afb24b294eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50797c8911ec77ac3a392370a1c91cbe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a50797c8911ec77ac3a392370a1c91cbe">get_overhang</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln) const</td></tr>
<tr class="separator:a50797c8911ec77ac3a392370a1c91cbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3bff405c9a8994993ea71e0c03b8772"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#ab3bff405c9a8994993ea71e0c03b8772">get_overhang</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;mp_aln) const</td></tr>
<tr class="separator:ab3bff405c9a8994993ea71e0c03b8772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e40faa7aa74f7b17390b06da6ad32e4"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a1e40faa7aa74f7b17390b06da6ad32e4">get_end_matches</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;read) const</td></tr>
<tr class="separator:a1e40faa7aa74f7b17390b06da6ad32e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45116be7bd52bfd9fb40e30f08aee97f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a45116be7bd52bfd9fb40e30f08aee97f">get_end_matches</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;read) const</td></tr>
<tr class="separator:a45116be7bd52bfd9fb40e30f08aee97f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a956bc9e366bb25f9544dbb3d8573b5b5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a956bc9e366bb25f9544dbb3d8573b5b5">is_split</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment) const</td></tr>
<tr class="separator:a956bc9e366bb25f9544dbb3d8573b5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fcb1771035304240c7a0401d84ef60b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a3fcb1771035304240c7a0401d84ef60b">is_split</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;mp_aln) const</td></tr>
<tr class="separator:a3fcb1771035304240c7a0401d84ef60b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6db93c73e3030a098aa54a21416cd7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#aaf6db93c73e3030a098aa54a21416cd7">get_is_paired</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln) const</td></tr>
<tr class="separator:aaf6db93c73e3030a098aa54a21416cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa38e8c41e26d7932caa918cfcfe76e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a1aa38e8c41e26d7932caa918cfcfe76e">get_is_paired</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;mp_aln) const</td></tr>
<tr class="separator:a1aa38e8c41e26d7932caa918cfcfe76e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ee0191017a8bf8b6c09ea5ef01e9517"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a8ee0191017a8bf8b6c09ea5ef01e9517">emit_tsv</a> (<a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;read, std::ostream &amp;out)</td></tr>
<tr class="separator:a8ee0191017a8bf8b6c09ea5ef01e9517"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ce4a34cb9883643cfc277ac0c213f64"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a7ce4a34cb9883643cfc277ac0c213f64">emit_tsv</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;read, std::ostream &amp;out)</td></tr>
<tr class="separator:a7ce4a34cb9883643cfc277ac0c213f64"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:a06835480f40ef09dd073cc14a469f760"><td class="memItemLeft" align="right" valign="top">std::atomic&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a06835480f40ef09dd073cc14a469f760">max_reads_used</a> {}</td></tr>
<tr class="separator:a06835480f40ef09dd073cc14a469f760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd41aa98c633f881001c8924b212b23"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; <a class="el" href="classvg_1_1io_1_1AlignmentEmitter.html">AlignmentEmitter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a0dd41aa98c633f881001c8924b212b23">aln_emitter</a></td></tr>
<tr class="memdesc:a0dd41aa98c633f881001c8924b212b23"><td class="mdescLeft">&#160;</td><td class="mdescRight">The two specializations have different writing infrastructure.  <a href="classvg_1_1ReadFilter.html#a0dd41aa98c633f881001c8924b212b23">More...</a><br /></td></tr>
<tr class="separator:a0dd41aa98c633f881001c8924b212b23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7baa666446be017dea5507fe5771de57"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; <a class="el" href="classvg_1_1MultipathAlignmentEmitter.html">MultipathAlignmentEmitter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html#a7baa666446be017dea5507fe5771de57">mp_aln_emitter</a></td></tr>
<tr class="separator:a7baa666446be017dea5507fe5771de57"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a5088cb81cac4ce8e26c6a921bf29b546"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5088cb81cac4ce8e26c6a921bf29b546">&#9670;&nbsp;</a></span>alignment_end_matches()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::alignment_end_matches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>internal helper for get_end_matches </p>

</div>
</div>
<a id="ab655011da419f60374d9238c0c21312b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab655011da419f60374d9238c0c21312b">&#9670;&nbsp;</a></span>alignment_overhang()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::alignment_overhang </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Internal helper for get_overhang </p>

</div>
</div>
<a id="a553af1f5f52e24334fb2dd22928ac86a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553af1f5f52e24334fb2dd22928ac86a">&#9670;&nbsp;</a></span>contains_subsequence()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::contains_subsequence </td>
          <td>(</td>
          <td class="paramtype">const Read &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does the read contain at least one of the indicated sequences </p>

</div>
</div>
<a id="a4436cd59a7d2ed18c4a315ef157239ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4436cd59a7d2ed18c4a315ef157239ed">&#9670;&nbsp;</a></span>emit() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;::emit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae811413740325799e12d313149f2b15a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae811413740325799e12d313149f2b15a">&#9670;&nbsp;</a></span>emit() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;::emit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a95b5ca4213c6da0a174e53c2f91fb36b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95b5ca4213c6da0a174e53c2f91fb36b">&#9670;&nbsp;</a></span>emit() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;::emit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>mp_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3864d427682af9b6e0a67a157fddcfa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3864d427682af9b6e0a67a157fddcfa2">&#9670;&nbsp;</a></span>emit() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;::emit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>mp_aln1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>mp_aln2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a50fce1e4c1159834e6371156040c6cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50fce1e4c1159834e6371156040c6cbe">&#9670;&nbsp;</a></span>emit() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::emit </td>
          <td>(</td>
          <td class="paramtype">Read &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write the read to stdout </p>

</div>
</div>
<a id="a5beda5e781b3a4b1b6ec139b280785d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5beda5e781b3a4b1b6ec139b280785d9">&#9670;&nbsp;</a></span>emit() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::emit </td>
          <td>(</td>
          <td class="paramtype">Read &amp;&#160;</td>
          <td class="paramname"><em>read1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Read &amp;&#160;</td>
          <td class="paramname"><em>read2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a read pair to stdout </p>

</div>
</div>
<a id="a7ce4a34cb9883643cfc277ac0c213f64"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ce4a34cb9883643cfc277ac0c213f64">&#9670;&nbsp;</a></span>emit_tsv() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;::emit_tsv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ee0191017a8bf8b6c09ea5ef01e9517"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ee0191017a8bf8b6c09ea5ef01e9517">&#9670;&nbsp;</a></span>emit_tsv() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;::emit_tsv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a02ed848e6d5395a8b966f883bd318a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02ed848e6d5395a8b966f883bd318a8e">&#9670;&nbsp;</a></span>emit_tsv() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::emit_tsv </td>
          <td>(</td>
          <td class="paramtype">Read &amp;&#160;</td>
          <td class="paramname"><em>read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Write a tsv line for a read to the given stream </p>

</div>
</div>
<a id="a36c3ff48009706f3853bddd02a98de9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36c3ff48009706f3853bddd02a98de9c">&#9670;&nbsp;</a></span>filter() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">istream *&#160;</td>
          <td class="paramname"><em>alignment_stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classvg_1_1Filter.html">Filter</a> the alignments available from the given stream, placing them on standard output or in the appropriate file. Returns 0 on success, exit code to use on error. </p>

</div>
</div>
<a id="a1fb619abfe77d0b02cc7f8aa4ad47af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb619abfe77d0b02cc7f8aa4ad47af5">&#9670;&nbsp;</a></span>filter() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">istream *&#160;</td>
          <td class="paramname"><em>alignment_stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab56d51dbf343ea44e78c31d54f1f317f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab56d51dbf343ea44e78c31d54f1f317f">&#9670;&nbsp;</a></span>filter() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;::filter </td>
          <td>(</td>
          <td class="paramtype">istream *&#160;</td>
          <td class="paramname"><em>alignment_stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1398f727931b41bfff0d9e058f442ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1398f727931b41bfff0d9e058f442ebc">&#9670;&nbsp;</a></span>filter_alignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Counts.html">Counts</a> <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::filter_alignment </td>
          <td>(</td>
          <td class="paramtype">Read &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run all the filters on an alignment. The alignment may get modified in-place by the defray filter </p>

</div>
</div>
<a id="a3220ffe3aa6042a1423c6251c95a2b05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3220ffe3aa6042a1423c6251c95a2b05">&#9670;&nbsp;</a></span>filter_internal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::filter_internal </td>
          <td>(</td>
          <td class="paramtype">istream *&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function for filter. </p>
<p>Template implementations </p>

</div>
</div>
<a id="a45116be7bd52bfd9fb40e30f08aee97f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45116be7bd52bfd9fb40e30f08aee97f">&#9670;&nbsp;</a></span>get_end_matches() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;::get_end_matches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e40faa7aa74f7b17390b06da6ad32e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e40faa7aa74f7b17390b06da6ad32e4">&#9670;&nbsp;</a></span>get_end_matches() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;::get_end_matches </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3cd3ee44928526e27e42e059b693ba76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cd3ee44928526e27e42e059b693ba76">&#9670;&nbsp;</a></span>get_end_matches() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::get_end_matches </td>
          <td>(</td>
          <td class="paramtype">const Read &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>What is the shortest run of end matches on either end? </p>

</div>
</div>
<a id="aaf6db93c73e3030a098aa54a21416cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6db93c73e3030a098aa54a21416cd7">&#9670;&nbsp;</a></span>get_is_paired() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;::get_is_paired </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1aa38e8c41e26d7932caa918cfcfe76e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa38e8c41e26d7932caa918cfcfe76e">&#9670;&nbsp;</a></span>get_is_paired() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;::get_is_paired </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>mp_aln</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b78c03c1379b1ed5576db5c6772adb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b78c03c1379b1ed5576db5c6772adb3">&#9670;&nbsp;</a></span>get_is_paired() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::get_is_paired </td>
          <td>(</td>
          <td class="paramtype">const Read &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is the read paired? </p>

</div>
</div>
<a id="ae2ef22beb751d9415759fc1985da1946"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2ef22beb751d9415759fc1985da1946">&#9670;&nbsp;</a></span>get_length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::get_length </td>
          <td>(</td>
          <td class="paramtype">const Read &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>What is the read's length? </p>

</div>
</div>
<a id="a0550e932f7becd1fbccd46787b580216"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0550e932f7becd1fbccd46787b580216">&#9670;&nbsp;</a></span>get_mapq()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::get_mapq </td>
          <td>(</td>
          <td class="paramtype">const Read &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>What is the read's mapping quality </p>

</div>
</div>
<a id="ad2ca26c062585494f69520f9997d34eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2ca26c062585494f69520f9997d34eb">&#9670;&nbsp;</a></span>get_min_base_qual_fraction()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::get_min_base_qual_fraction </td>
          <td>(</td>
          <td class="paramtype">const Read &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>What fraction of the base qualities are at least as large as the min base quality </p>

</div>
</div>
<a id="a50797c8911ec77ac3a392370a1c91cbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50797c8911ec77ac3a392370a1c91cbe">&#9670;&nbsp;</a></span>get_overhang() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;::get_overhang </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3bff405c9a8994993ea71e0c03b8772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3bff405c9a8994993ea71e0c03b8772">&#9670;&nbsp;</a></span>get_overhang() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;::get_overhang </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>mp_aln</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71bb794016b2f59d6495a98b9716e0b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71bb794016b2f59d6495a98b9716e0b5">&#9670;&nbsp;</a></span>get_overhang() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::get_overhang </td>
          <td>(</td>
          <td class="paramtype">const Read &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>How long are the read overhangs? </p>

</div>
</div>
<a id="a2144e5b768ebd71768d37265c07deda2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2144e5b768ebd71768d37265c07deda2">&#9670;&nbsp;</a></span>get_score() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;::get_score </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af800d67aa469136b6318c02e282c5a30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af800d67aa469136b6318c02e282c5a30">&#9670;&nbsp;</a></span>get_score() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;::get_score </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e168659158cf4372fc11b8cda05883d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e168659158cf4372fc11b8cda05883d">&#9670;&nbsp;</a></span>get_score() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::get_score </td>
          <td>(</td>
          <td class="paramtype">const Read &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the score indicated by the params </p>

</div>
</div>
<a id="aca79c3eda85a8f4fafcd25a243b7efd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca79c3eda85a8f4fafcd25a243b7efd4">&#9670;&nbsp;</a></span>has_excluded_refpos() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;::has_excluded_refpos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab609cc20f1e49dc1001e71fe82c5ead4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab609cc20f1e49dc1001e71fe82c5ead4">&#9670;&nbsp;</a></span>has_excluded_refpos() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;::has_excluded_refpos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac772c0651477027191108e64ab7c53cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac772c0651477027191108e64ab7c53cb">&#9670;&nbsp;</a></span>has_excluded_refpos() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::has_excluded_refpos </td>
          <td>(</td>
          <td class="paramtype">const Read &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does the read match one of the excluded refpos contigs? </p>

</div>
</div>
<a id="a2d30291c0c609d58670f40e2eb9661e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d30291c0c609d58670f40e2eb9661e4">&#9670;&nbsp;</a></span>has_excuded_feature()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::has_excuded_feature </td>
          <td>(</td>
          <td class="paramtype">const Read &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is the read annotated with any of the excluded features </p>

</div>
</div>
<a id="a9aecb91c19bb44bb9be32c4f30c44538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9aecb91c19bb44bb9be32c4f30c44538">&#9670;&nbsp;</a></span>has_repeat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::has_repeat </td>
          <td>(</td>
          <td class="paramtype">const Read &amp;&#160;</td>
          <td class="paramname"><em>read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>quick and dirty filter to see if removing reads that can slip around and still map perfectly helps vg call. returns true if at either end of read sequence, at least k bases are repetitive, checking repeats of up to size 2k </p>

</div>
</div>
<a id="ab76d4dc77becdaf866f724d5b88dcdb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab76d4dc77becdaf866f724d5b88dcdb5">&#9670;&nbsp;</a></span>is_correctly_mapped() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;::is_correctly_mapped </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a053397b20bc378d11f11b365e6d68032"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a053397b20bc378d11f11b365e6d68032">&#9670;&nbsp;</a></span>is_correctly_mapped() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;::is_correctly_mapped </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac5da32515034e6669d9e14de3c748122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5da32515034e6669d9e14de3c748122">&#9670;&nbsp;</a></span>is_correctly_mapped() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::is_correctly_mapped </td>
          <td>(</td>
          <td class="paramtype">const Read &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the alignment is marked as being correctly mapped </p>

</div>
</div>
<a id="acf05b0ded409cd19894c24b6fe9412bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf05b0ded409cd19894c24b6fe9412bf">&#9670;&nbsp;</a></span>is_mapped() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;::is_mapped </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1fe573ba370f839adb1cd28350cac81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1fe573ba370f839adb1cd28350cac81">&#9670;&nbsp;</a></span>is_mapped() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;::is_mapped </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>mp_alignment</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1acad05129d0a6146416f596903216a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1acad05129d0a6146416f596903216a8">&#9670;&nbsp;</a></span>is_mapped() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::is_mapped </td>
          <td>(</td>
          <td class="paramtype">const Read &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Check if the alignment includes any aligned bases </p>

</div>
</div>
<a id="ad5ebb80a71eaf7c765f33b306ab230d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ebb80a71eaf7c765f33b306ab230d8">&#9670;&nbsp;</a></span>is_proper_pair()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::is_proper_pair </td>
          <td>(</td>
          <td class="paramtype">const Read &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is the read in a proper-mapped pair? </p>

</div>
</div>
<a id="ab4ae201744c8abc543d60afb24b294eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4ae201744c8abc543d60afb24b294eb">&#9670;&nbsp;</a></span>is_secondary() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;::is_secondary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a44451e4c12ff1a923221d019c31c610c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44451e4c12ff1a923221d019c31c610c">&#9670;&nbsp;</a></span>is_secondary() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;::is_secondary </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>mp_aln</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a947155b6ed467a8ea83ac80db6e11a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947155b6ed467a8ea83ac80db6e11a63">&#9670;&nbsp;</a></span>is_secondary() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::is_secondary </td>
          <td>(</td>
          <td class="paramtype">const Read &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Is the read a secondary alignments? </p>

</div>
</div>
<a id="a956bc9e366bb25f9544dbb3d8573b5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a956bc9e366bb25f9544dbb3d8573b5b5">&#9670;&nbsp;</a></span>is_split() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;::is_split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3fcb1771035304240c7a0401d84ef60b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fcb1771035304240c7a0401d84ef60b">&#9670;&nbsp;</a></span>is_split() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;::is_split </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>mp_aln</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a34d313741dcfe8c009dfcc380d1293ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34d313741dcfe8c009dfcc380d1293ad">&#9670;&nbsp;</a></span>is_split() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::is_split </td>
          <td>(</td>
          <td class="paramtype">const Read &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return false if the read only follows edges in the graph, and true if the read is split (or just incorrect) and takes edges not in the index.</p>
<p>Throws an error if no graph is specified. </p>

</div>
</div>
<a id="a95d1165f7c3901772a70ba863d1fc983"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d1165f7c3901772a70ba863d1fc983">&#9670;&nbsp;</a></span>matches_annotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::matches_annotation </td>
          <td>(</td>
          <td class="paramtype">const Read &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does has the given annotation and does it match </p>

</div>
</div>
<a id="ab72c4fd96eedcb4bcd6aa565e97dfe4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab72c4fd96eedcb4bcd6aa565e97dfe4d">&#9670;&nbsp;</a></span>matches_name()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::matches_name </td>
          <td>(</td>
          <td class="paramtype">const Read &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Does the read name have one of the indicated prefixes? If exact_name is set, only finds complete matches of a "prefix" to the whole read name. </p>

</div>
</div>
<a id="aa592c88e758fc257fdf17418b0f189a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa592c88e758fc257fdf17418b0f189a8">&#9670;&nbsp;</a></span>sample_read()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::sample_read </td>
          <td>(</td>
          <td class="paramtype">const Read &amp;&#160;</td>
          <td class="paramname"><em>read</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Based on the read name and paired-ness, compute the SAM-style QNAME and use that and the configured sampling probability and seed in the Samtools read sampling algorithm, to determine if the read should be kept. Returns true if the read should stay, and false if it should be removed. Always accepts or rejects paired reads together. </p>

</div>
</div>
<a id="a21b0bf11e5636b41cf6dfc4a61441c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b0bf11e5636b41cf6dfc4a61441c4e">&#9670;&nbsp;</a></span>to_alignment()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::to_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a multipath alignment to a single path </p>

</div>
</div>
<a id="ac5d77581ac1d34661c62f446692217ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5d77581ac1d34661c62f446692217ab">&#9670;&nbsp;</a></span>trim_ambiguous_end()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::trim_ambiguous_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trim only the end of the given alignment, leaving the start alone. Two calls of this implement trim_ambiguous_ends above. </p>

</div>
</div>
<a id="ac49bf695fadbdaf8b41c972587493630"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49bf695fadbdaf8b41c972587493630">&#9670;&nbsp;</a></span>trim_ambiguous_ends() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;::trim_ambiguous_ends </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a266b5aeeb2081d2bd5f29ae43fdc00f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a266b5aeeb2081d2bd5f29ae43fdc00f8">&#9670;&nbsp;</a></span>trim_ambiguous_ends() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &gt;::trim_ambiguous_ends </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a265a2c2d5e5af4924c406b97d764d9aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a265a2c2d5e5af4924c406b97d764d9aa">&#9670;&nbsp;</a></span>trim_ambiguous_ends() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::trim_ambiguous_ends </td>
          <td>(</td>
          <td class="paramtype">Read &amp;&#160;</td>
          <td class="paramname"><em>read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Look at either end of the given alignment, up to k bases in from the end. See if that tail of the alignment is mapped such that another embedding in the given graph can produce the same sequence as the sequence along the embedding that the read actually has, and if so trim back the read.</p>
<p>In the case of softclips, the aligned portion of the read is considered, and if trimmign is required, the softclips are hard-clipped off.</p>
<p>Returns true if the read had to be modified, and false otherwise.</p>
<p>MUST NOT be called with a null index. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0dd41aa98c633f881001c8924b212b23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd41aa98c633f881001c8924b212b23">&#9670;&nbsp;</a></span>aln_emitter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;<a class="el" href="classvg_1_1io_1_1AlignmentEmitter.html">AlignmentEmitter</a>&gt; <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::aln_emitter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The two specializations have different writing infrastructure. </p>

</div>
</div>
<a id="a44b9ee21da92a8cd89af5b6538ac32a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44b9ee21da92a8cd89af5b6538ac32a0">&#9670;&nbsp;</a></span>annotation_to_match</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::annotation_to_match = &quot;&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A string formatted "annotation[.subfield]*:value" Value is optional if the key is a flag Used like jq select </p>

</div>
</div>
<a id="a89cd59970cfca5bf91f828f84035e39a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89cd59970cfca5bf91f828f84035e39a">&#9670;&nbsp;</a></span>batch_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::batch_size = <a class="el" href="namespacevg_1_1io.html#aba1d6c41cb6ff7b47e64b6b584af0363">vg::io::DEFAULT_PARALLEL_BATCHSIZE</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Process reads in batches of this size. </p>

</div>
</div>
<a id="a2d00933de6bd943fed0a4ec48112f39e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d00933de6bd943fed0a4ec48112f39e">&#9670;&nbsp;</a></span>buffer_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::buffer_size = 512</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>GAM output buffer size. </p>

</div>
</div>
<a id="ab7e72e4f3440fdc2a846de1e81fe2230"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7e72e4f3440fdc2a846de1e81fe2230">&#9670;&nbsp;</a></span>complement_filter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::complement_filter = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Actually take the complement of the filter. </p>

</div>
</div>
<a id="aef4ec3c75ed003564641757d0d78b6ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef4ec3c75ed003564641757d0d78b6ea">&#9670;&nbsp;</a></span>defray_count</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::defray_count = 99999</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Limit defray recursion to visit this many nodes. </p>

</div>
</div>
<a id="ab1a4ac583b2b783404b20e985c4a5f5e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1a4ac583b2b783404b20e985c4a5f5e">&#9670;&nbsp;</a></span>defray_length</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::defray_length = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>How far in from the end should we look for ambiguous end alignment to clip off? </p>

</div>
</div>
<a id="a44099974ab2ac2d374e4530b064e1908"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44099974ab2ac2d374e4530b064e1908">&#9670;&nbsp;</a></span>downsample_probability</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::downsample_probability = 1.0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We can also pseudorandomly drop reads. What's the probability that we keep a read? </p>

</div>
</div>
<a id="a881165b11e7539bc03e331f16b1a5f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a881165b11e7539bc03e331f16b1a5f0a">&#9670;&nbsp;</a></span>downsample_seed_mask</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::downsample_seed_mask = 0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Samtools-compatible internal seed mask, for deciding which read pairs to keep. To be generated with rand() after srand() from the user-visible seed. </p>

</div>
</div>
<a id="a52316fdf4e8b2ee3741bfbc4a89727a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52316fdf4e8b2ee3741bfbc4a89727a7">&#9670;&nbsp;</a></span>drop_split</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::drop_split = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Should we drop split reads that follow edges not in the graph? </p>

</div>
</div>
<a id="a3165602af2a80ad642c9f900f9bf723e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3165602af2a80ad642c9f900f9bf723e">&#9670;&nbsp;</a></span>exact_name</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::exact_name = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read name must not have anything in it besides the prefix. </p>

</div>
</div>
<a id="a621533fd4d338b7b5cee85df4a64c8ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621533fd4d338b7b5cee85df4a64c8ef">&#9670;&nbsp;</a></span>excluded_features</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unordered_set&lt;string&gt; <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::excluded_features</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If a read has one of the features in this set as annotations, the read is filtered out. </p>

</div>
</div>
<a id="a019f6eab0ba08ab063f2f9b1226a0cf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a019f6eab0ba08ab063f2f9b1226a0cf0">&#9670;&nbsp;</a></span>excluded_refpos_contigs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;regex&gt; <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::excluded_refpos_contigs</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read must not have a refpos set with a contig name containing a match to any of these. </p>

</div>
</div>
<a id="a0789571cd8039786e8eb53e5e6f53cee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0789571cd8039786e8eb53e5e6f53cee">&#9670;&nbsp;</a></span>filter_on_all</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::filter_on_all = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>When outputting paired reads, fail the pair only if both (all) reads fail (true) instead of if either (any) read fails (false) </p>

</div>
</div>
<a id="a28e3876fb7401ecf89e9cd75fee37d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e3876fb7401ecf89e9cd75fee37d59">&#9670;&nbsp;</a></span>frac_score</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::frac_score = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a73ca67996129403044a23de9544e88fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73ca67996129403044a23de9544e88fd">&#9670;&nbsp;</a></span>graph</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a>* <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::graph = nullptr</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A HandleGraph is required for some filters (Note: <a class="el" href="classvg_1_1ReadFilter.html">ReadFilter</a> doesn't own/free this) </p>

</div>
</div>
<a id="a3d7c97fa34473eb5b1e3bce2dd64d6eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7c97fa34473eb5b1e3bce2dd64d6eb">&#9670;&nbsp;</a></span>interleaved</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::interleaved = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Interleaved input. </p>

</div>
</div>
<a id="a2afae0acb031354f67f95f20dda1c4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2afae0acb031354f67f95f20dda1c4b8">&#9670;&nbsp;</a></span>max_length</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::max_length = std::numeric_limits&lt;size_t&gt;::max()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54c30818834f623c78a2cb0a0e9b4a91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54c30818834f623c78a2cb0a0e9b4a91">&#9670;&nbsp;</a></span>max_overhang</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::max_overhang = numeric_limits&lt;int&gt;::max() / 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a4d052b3060e2b8a434310ce6dc14f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a4d052b3060e2b8a434310ce6dc14f5">&#9670;&nbsp;</a></span>max_reads</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::max_reads = numeric_limits&lt;size_t&gt;::max()</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>How many reads should we take total? Note that this filter is nondeterministic. </p>

</div>
</div>
<a id="a06835480f40ef09dd073cc14a469f760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06835480f40ef09dd073cc14a469f760">&#9670;&nbsp;</a></span>max_reads_used</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::atomic&lt;size_t&gt; <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::max_reads_used {}</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7fe13f943f153913f16aa594720d350a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7fe13f943f153913f16aa594720d350a">&#9670;&nbsp;</a></span>min_base_quality</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::min_base_quality = numeric_limits&lt;int&gt;::min() / 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8c6af52884a83d9538ea7ef42ac9eb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8c6af52884a83d9538ea7ef42ac9eb4">&#9670;&nbsp;</a></span>min_base_quality_fraction</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::min_base_quality_fraction = numeric_limits&lt;double&gt;::lowest()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05d07dd311e58f3fc04d510870ddf662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d07dd311e58f3fc04d510870ddf662">&#9670;&nbsp;</a></span>min_end_matches</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::min_end_matches = numeric_limits&lt;int&gt;::min() / 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8da615d17aba7ed66be6174253ce64ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8da615d17aba7ed66be6174253ce64ce">&#9670;&nbsp;</a></span>min_mapq</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::min_mapq = numeric_limits&lt;double&gt;::lowest()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a64132e9f5f27ce6930554ad3c197e694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64132e9f5f27ce6930554ad3c197e694">&#9670;&nbsp;</a></span>min_primary</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::min_primary = numeric_limits&lt;double&gt;::lowest()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af85c211a4a06a1fb750958002cefba0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85c211a4a06a1fb750958002cefba0f">&#9670;&nbsp;</a></span>min_secondary</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::min_secondary = numeric_limits&lt;double&gt;::lowest()</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7baa666446be017dea5507fe5771de57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7baa666446be017dea5507fe5771de57">&#9670;&nbsp;</a></span>mp_aln_emitter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt;<a class="el" href="classvg_1_1MultipathAlignmentEmitter.html">MultipathAlignmentEmitter</a>&gt; <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::mp_aln_emitter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a59dd97c0eadf3aebd852ae3b0aabe31d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59dd97c0eadf3aebd852ae3b0aabe31d">&#9670;&nbsp;</a></span>name_prefixes</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;string&gt; <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::name_prefixes</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read name must have one of these prefixes, if any are present. TODO: This should be a trie but I don't have one handy. Must be sorted for vaguely efficient search. </p>

</div>
</div>
<a id="ab0f19128ff55e1e2c1cad90adcfc0d6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f19128ff55e1e2c1cad90adcfc0d6e">&#9670;&nbsp;</a></span>only_correctly_mapped</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::only_correctly_mapped = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classvg_1_1Filter.html">Filter</a> to only correctly mapped reads. </p>

</div>
</div>
<a id="a5747bfc6146fa25db9fd96f1f760f6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5747bfc6146fa25db9fd96f1f760f6f0">&#9670;&nbsp;</a></span>only_first_alignment</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::only_first_alignment = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classvg_1_1Filter.html">Filter</a> to only keep the first alignment for each read. </p>

</div>
</div>
<a id="ab19be8fc638af431bb1a629aeff77f4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab19be8fc638af431bb1a629aeff77f4f">&#9670;&nbsp;</a></span>only_mapped</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::only_mapped = true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classvg_1_1Filter.html">Filter</a> to only mapped reads. </p>

</div>
</div>
<a id="ac41003be9ee710a1003288e2a6ba9c7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac41003be9ee710a1003288e2a6ba9c7d">&#9670;&nbsp;</a></span>only_proper_pairs</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::only_proper_pairs = true</td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="classvg_1_1Filter.html">Filter</a> to proper pairs. </p>

</div>
</div>
<a id="ade1a4a40379d72d2811fe0e32bece8f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade1a4a40379d72d2811fe0e32bece8f7">&#9670;&nbsp;</a></span>output_fields</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;string&gt; <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::output_fields</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>What fields do we want to write to the tsv? </p>

</div>
</div>
<a id="a95e0303086c9c6dc7a17d452b7d7f928"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95e0303086c9c6dc7a17d452b7d7f928">&#9670;&nbsp;</a></span>repeat_size</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::repeat_size = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7373ef70ee64562dd779628a234c1080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7373ef70ee64562dd779628a234c1080">&#9670;&nbsp;</a></span>rescore</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::rescore = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Should we rescore each alignment with default parameters and no e.g. haplotype info? </p>

</div>
</div>
<a id="a613b00bb83a119d89911ed4315e4e24a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a613b00bb83a119d89911ed4315e4e24a">&#9670;&nbsp;</a></span>seen_read_names</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">unordered_set&lt;string&gt; <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::seen_read_names</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>If we are picking only the first alignment for each read, keep track of what we've seen. </p>

</div>
</div>
<a id="a529c0b978b3855bab3dc1074fd18a711"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529c0b978b3855bab3dc1074fd18a711">&#9670;&nbsp;</a></span>sub_score</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::sub_score = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98cd220c402ec88c512121825ed690df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98cd220c402ec88c512121825ed690df">&#9670;&nbsp;</a></span>subsequences</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;string&gt; <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::subsequences</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read must contain at least one of these strings as a subsequence. </p>

</div>
</div>
<a id="a41808c4d5db46d1405ac906a01bbf794"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41808c4d5db46d1405ac906a01bbf794">&#9670;&nbsp;</a></span>threads</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::threads = -1</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Number of threads from omp. </p>

</div>
</div>
<a id="aa207b19d222c64919714bae506b726a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa207b19d222c64919714bae506b726a6">&#9670;&nbsp;</a></span>verbose</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::verbose = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a249032f1613c12263e7c14d83b4e527e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a249032f1613c12263e7c14d83b4e527e">&#9670;&nbsp;</a></span>write_output</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::write_output = true</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sometimes we only want a report, and not a filtered gam. toggling off output speeds things up considerably. </p>

</div>
</div>
<a id="a9979d9966e9ea82a9cd160dbf38d4b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9979d9966e9ea82a9cd160dbf38d4b7c">&#9670;&nbsp;</a></span>write_tsv</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Read &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="classvg_1_1ReadFilter.html">vg::ReadFilter</a>&lt; Read &gt;::write_tsv = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sometimes we want to pick out fields and write a tsv instead of a gam;. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>src/<a class="el" href="readfilter_8hpp.html">readfilter.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
