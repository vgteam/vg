<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::Funnel Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1Funnel.html">Funnel</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-types">Protected Types</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classvg_1_1Funnel-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::Funnel Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;funnel.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Funnel_1_1FilterPerformance.html">FilterPerformance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Funnel_1_1Item.html">Item</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an <a class="el" href="structvg_1_1Funnel_1_1Item.html" title="Represents an Item whose provenance we track.">Item</a> whose provenance we track.  <a href="structvg_1_1Funnel_1_1Item.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Funnel_1_1PaintableSpace.html">PaintableSpace</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Funnel_1_1Stage.html">Stage</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents a <a class="el" href="structvg_1_1Funnel_1_1Stage.html" title="Represents a Stage which is a series of Items, which track their own provenance.">Stage</a> which is a series of Items, which track their own provenance.  <a href="structvg_1_1Funnel_1_1Stage.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a23e7fd0c49df53dd8a9e25934fe06c85"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a23e7fd0c49df53dd8a9e25934fe06c85">State</a> { <a class="el" href="classvg_1_1Funnel.html#a23e7fd0c49df53dd8a9e25934fe06c85ab50339a10e1de285ac99d4c3990b8693">State::NONE</a> = 0, 
<a class="el" href="classvg_1_1Funnel.html#a23e7fd0c49df53dd8a9e25934fe06c85a0a4373ca716769f93112e16e251bb8a1">State::PLACED</a> = 1, 
<a class="el" href="classvg_1_1Funnel.html#a23e7fd0c49df53dd8a9e25934fe06c85a0d536515ce0fb6e96a5510b6556f30f2">State::CORRECT</a> = 2
 }</td></tr>
<tr class="memdesc:a23e7fd0c49df53dd8a9e25934fe06c85"><td class="mdescLeft">&#160;</td><td class="mdescRight">We can tag items as having one of these states.  <a href="classvg_1_1Funnel.html#a23e7fd0c49df53dd8a9e25934fe06c85">More...</a><br /></td></tr>
<tr class="separator:a23e7fd0c49df53dd8a9e25934fe06c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4ba2b8db1575820b05d069cd6c802e31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a4ba2b8db1575820b05d069cd6c802e31">start</a> (const string &amp;name)</td></tr>
<tr class="separator:a4ba2b8db1575820b05d069cd6c802e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe0233346c63f1693fa865eca0083b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#adbe0233346c63f1693fa865eca0083b2">stop</a> ()</td></tr>
<tr class="separator:adbe0233346c63f1693fa865eca0083b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21b5f8762aa446a64b5ddb3809e5c8e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a21b5f8762aa446a64b5ddb3809e5c8e2">stage</a> (const string &amp;name)</td></tr>
<tr class="separator:a21b5f8762aa446a64b5ddb3809e5c8e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87e1b8deccb4438d7f71267ee5f12ced"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a87e1b8deccb4438d7f71267ee5f12ced">stage_stop</a> ()</td></tr>
<tr class="memdesc:a87e1b8deccb4438d7f71267ee5f12ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the current stage.  <a href="classvg_1_1Funnel.html#a87e1b8deccb4438d7f71267ee5f12ced">More...</a><br /></td></tr>
<tr class="separator:a87e1b8deccb4438d7f71267ee5f12ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0520d00fd1dcd9fa4af18d715580c900"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a0520d00fd1dcd9fa4af18d715580c900">substage</a> (const string &amp;name)</td></tr>
<tr class="separator:a0520d00fd1dcd9fa4af18d715580c900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5934891f37d57dc9309e5b0e9f80d9e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#ab5934891f37d57dc9309e5b0e9f80d9e">substage_stop</a> ()</td></tr>
<tr class="memdesc:ab5934891f37d57dc9309e5b0e9f80d9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop the current substage.  <a href="classvg_1_1Funnel.html#ab5934891f37d57dc9309e5b0e9f80d9e">More...</a><br /></td></tr>
<tr class="separator:ab5934891f37d57dc9309e5b0e9f80d9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c21502db704cde878d989f3cc75e91c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a3c21502db704cde878d989f3cc75e91c">processing_input</a> (size_t prev_stage_item)</td></tr>
<tr class="memdesc:a3c21502db704cde878d989f3cc75e91c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start processing the given item coming from the previous stage.  <a href="classvg_1_1Funnel.html#a3c21502db704cde878d989f3cc75e91c">More...</a><br /></td></tr>
<tr class="separator:a3c21502db704cde878d989f3cc75e91c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94e07fb24eee3bb9284a1ba8945b010a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a94e07fb24eee3bb9284a1ba8945b010a">processed_input</a> ()</td></tr>
<tr class="memdesc:a94e07fb24eee3bb9284a1ba8945b010a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop processing an item from the previous stage.  <a href="classvg_1_1Funnel.html#a94e07fb24eee3bb9284a1ba8945b010a">More...</a><br /></td></tr>
<tr class="separator:a94e07fb24eee3bb9284a1ba8945b010a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a919aae2ef8cf780bcaba00b1ea1603b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a919aae2ef8cf780bcaba00b1ea1603b8">producing_output</a> (size_t item)</td></tr>
<tr class="memdesc:a919aae2ef8cf780bcaba00b1ea1603b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start producing the given output item, whether it has been projected yet or not.  <a href="classvg_1_1Funnel.html#a919aae2ef8cf780bcaba00b1ea1603b8">More...</a><br /></td></tr>
<tr class="separator:a919aae2ef8cf780bcaba00b1ea1603b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9dec7f539cf37d822328a71e376783a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#ae9dec7f539cf37d822328a71e376783a">produced_output</a> ()</td></tr>
<tr class="memdesc:ae9dec7f539cf37d822328a71e376783a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop producing an output item.  <a href="classvg_1_1Funnel.html#ae9dec7f539cf37d822328a71e376783a">More...</a><br /></td></tr>
<tr class="separator:ae9dec7f539cf37d822328a71e376783a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfe8a13519ae236c400f3ad68980e16c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#adfe8a13519ae236c400f3ad68980e16c">introduce</a> (size_t count=1)</td></tr>
<tr class="memdesc:adfe8a13519ae236c400f3ad68980e16c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Introduce the given number of new items, starting their own lines of provenance (default 1).  <a href="classvg_1_1Funnel.html#adfe8a13519ae236c400f3ad68980e16c">More...</a><br /></td></tr>
<tr class="separator:adfe8a13519ae236c400f3ad68980e16c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9440c3268e8c60b664a37283d9fc5cff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a9440c3268e8c60b664a37283d9fc5cff">expand</a> (size_t prev_stage_item, size_t count)</td></tr>
<tr class="memdesc:a9440c3268e8c60b664a37283d9fc5cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Expand the given item from the previous stage into the given number of new items at this stage.  <a href="classvg_1_1Funnel.html#a9440c3268e8c60b664a37283d9fc5cff">More...</a><br /></td></tr>
<tr class="separator:a9440c3268e8c60b664a37283d9fc5cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585c5484ef877a1ede56ed4467e32312"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a585c5484ef877a1ede56ed4467e32312"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a585c5484ef877a1ede56ed4467e32312">merge_group</a> (Iterator prev_stage_items_begin, Iterator prev_stage_items_end)</td></tr>
<tr class="separator:a585c5484ef877a1ede56ed4467e32312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44fcff7c06cb79e43cc1aa2fc73a8da6"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a44fcff7c06cb79e43cc1aa2fc73a8da6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a44fcff7c06cb79e43cc1aa2fc73a8da6">merge_groups</a> (Iterator prev_stage_items_begin, Iterator prev_stage_items_end)</td></tr>
<tr class="separator:a44fcff7c06cb79e43cc1aa2fc73a8da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae75f133fdc545176a27f0121a61a98e4"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ae75f133fdc545176a27f0121a61a98e4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#ae75f133fdc545176a27f0121a61a98e4">merge</a> (Iterator prev_stage_items_begin, Iterator prev_stage_items_end)</td></tr>
<tr class="separator:ae75f133fdc545176a27f0121a61a98e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc00e34c78f024874b44ebf90443cc4e"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:abc00e34c78f024874b44ebf90443cc4e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#abc00e34c78f024874b44ebf90443cc4e">also_merge_group</a> (Iterator prev_stage_items_begin, Iterator prev_stage_items_end)</td></tr>
<tr class="separator:abc00e34c78f024874b44ebf90443cc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68135544a4504edde8de7df48557d4ba"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:a68135544a4504edde8de7df48557d4ba"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a68135544a4504edde8de7df48557d4ba">also_merge_group</a> (size_t earlier_stage_lookback, Iterator earlier_stage_items_begin, Iterator earlier_stage_items_end)</td></tr>
<tr class="separator:a68135544a4504edde8de7df48557d4ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0642f2a1faae54dc12e98df452d4be65"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a0642f2a1faae54dc12e98df452d4be65">also_relevant</a> (size_t earlier_stage_lookback, size_t earlier_stage_item)</td></tr>
<tr class="separator:a0642f2a1faae54dc12e98df452d4be65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9e7695a998b23314c25f7fe3de4701"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a2b9e7695a998b23314c25f7fe3de4701">project</a> (size_t prev_stage_item)</td></tr>
<tr class="memdesc:a2b9e7695a998b23314c25f7fe3de4701"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project a single item from the previous stage to a single non-group item at this stage.  <a href="classvg_1_1Funnel.html#a2b9e7695a998b23314c25f7fe3de4701">More...</a><br /></td></tr>
<tr class="separator:a2b9e7695a998b23314c25f7fe3de4701"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a321b1e593102927ff8677214abce5592"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a321b1e593102927ff8677214abce5592">project_group</a> (size_t prev_stage_item, size_t group_size)</td></tr>
<tr class="memdesc:a321b1e593102927ff8677214abce5592"><td class="mdescLeft">&#160;</td><td class="mdescRight">Project a single item from the previous stage to a new group item at the current stage, with the given size.  <a href="classvg_1_1Funnel.html#a321b1e593102927ff8677214abce5592">More...</a><br /></td></tr>
<tr class="separator:a321b1e593102927ff8677214abce5592"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e1d7d328fe8ea456c2631abffaebb4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a38e1d7d328fe8ea456c2631abffaebb4">fail</a> (const char *filter, size_t prev_stage_item, double statistic=nan(&quot;&quot;))</td></tr>
<tr class="separator:a38e1d7d328fe8ea456c2631abffaebb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec19daea826d5951ecf1477769722d9a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#aec19daea826d5951ecf1477769722d9a">pass</a> (const char *filter, size_t prev_stage_item, double statistic=nan(&quot;&quot;))</td></tr>
<tr class="separator:aec19daea826d5951ecf1477769722d9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cdacae4561ece776ba90e293299f930"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a9cdacae4561ece776ba90e293299f930">score</a> (size_t item, double score)</td></tr>
<tr class="memdesc:a9cdacae4561ece776ba90e293299f930"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assign the given score to the given item at the current stage.  <a href="classvg_1_1Funnel.html#a9cdacae4561ece776ba90e293299f930">More...</a><br /></td></tr>
<tr class="separator:a9cdacae4561ece776ba90e293299f930"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd3cf8783612cccf4faf96f25fc4f17c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#abd3cf8783612cccf4faf96f25fc4f17c">tag</a> (size_t item, <a class="el" href="classvg_1_1Funnel.html#a23e7fd0c49df53dd8a9e25934fe06c85">State</a> state, size_t tag_start=0, size_t tag_length=std::numeric_limits&lt; size_t &gt;::max())</td></tr>
<tr class="separator:abd3cf8783612cccf4faf96f25fc4f17c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa725f066e32a967c8d482f50c1606f08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#aa725f066e32a967c8d482f50c1606f08">tag_correct</a> (size_t item, size_t tag_start=0, size_t tag_length=std::numeric_limits&lt; size_t &gt;::max())</td></tr>
<tr class="separator:aa725f066e32a967c8d482f50c1606f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4296184811926cf97a42d52aaf3fc6f6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a4296184811926cf97a42d52aaf3fc6f6">is_correct</a> (size_t item) const</td></tr>
<tr class="separator:a4296184811926cf97a42d52aaf3fc6f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac71f37530afee1b7e49770aff8cc53b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#aac71f37530afee1b7e49770aff8cc53b">was_correct</a> (size_t prev_stage_item) const</td></tr>
<tr class="separator:aac71f37530afee1b7e49770aff8cc53b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f0037505a9df13b92e381f5ff108d72"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a5f0037505a9df13b92e381f5ff108d72">was_correct</a> (size_t prev_stage_index, const string &amp;prev_stage_name, size_t prev_stage_item) const</td></tr>
<tr class="separator:a5f0037505a9df13b92e381f5ff108d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a996005ebe76091bbba404bf4a2a9a405"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a996005ebe76091bbba404bf4a2a9a405">last_correct_stage</a> (size_t tag_start=0, size_t tag_length=std::numeric_limits&lt; size_t &gt;::max()) const</td></tr>
<tr class="separator:a996005ebe76091bbba404bf4a2a9a405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab53e816bd740407417b0bd8d14d5237c"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#ab53e816bd740407417b0bd8d14d5237c">last_tagged_stage</a> (<a class="el" href="classvg_1_1Funnel.html#a23e7fd0c49df53dd8a9e25934fe06c85">State</a> <a class="el" href="classvg_1_1Funnel.html#abd3cf8783612cccf4faf96f25fc4f17c">tag</a>, size_t tag_start=0, size_t tag_length=std::numeric_limits&lt; size_t &gt;::max()) const</td></tr>
<tr class="separator:ab53e816bd740407417b0bd8d14d5237c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a933c8a296c5a680aa96b0b913c465250"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a933c8a296c5a680aa96b0b913c465250">latest</a> () const</td></tr>
<tr class="memdesc:a933c8a296c5a680aa96b0b913c465250"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index of the most recent item created in the current stage.  <a href="classvg_1_1Funnel.html#a933c8a296c5a680aa96b0b913c465250">More...</a><br /></td></tr>
<tr class="separator:a933c8a296c5a680aa96b0b913c465250"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe28658059032edb97960675bd8806ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#afe28658059032edb97960675bd8806ab">for_each_stage</a> (const function&lt; void(const string &amp;, const vector&lt; size_t &gt; &amp;, const double &amp;)&gt; &amp;callback) const</td></tr>
<tr class="separator:afe28658059032edb97960675bd8806ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc114c16e43a80739d292e03b65fa8ab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#afc114c16e43a80739d292e03b65fa8ab">for_each_filter</a> (const function&lt; void(const string &amp;, const string &amp;, const <a class="el" href="structvg_1_1Funnel_1_1FilterPerformance.html">FilterPerformance</a> &amp;, const <a class="el" href="structvg_1_1Funnel_1_1FilterPerformance.html">FilterPerformance</a> &amp;, const vector&lt; double &gt; &amp;, const vector&lt; double &gt; &amp;)&gt; &amp;callback) const</td></tr>
<tr class="separator:afc114c16e43a80739d292e03b65fa8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4a9374a423b2b87a15355ffac7a1935"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#ad4a9374a423b2b87a15355ffac7a1935">to_dot</a> (ostream &amp;out) const</td></tr>
<tr class="separator:ad4a9374a423b2b87a15355ffac7a1935"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc044b59bc97ac7e6536068fa9bdb5d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#adc044b59bc97ac7e6536068fa9bdb5d2">annotate_mapped_alignment</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, bool annotate_correctness) const</td></tr>
<tr class="separator:adc044b59bc97ac7e6536068fa9bdb5d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-types"></a>
Protected Types</h2></td></tr>
<tr class="memitem:a8173e5288d688fbf38e324eeb1308978"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a8173e5288d688fbf38e324eeb1308978">clock</a> = std::chrono::high_resolution_clock</td></tr>
<tr class="memdesc:a8173e5288d688fbf38e324eeb1308978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pick a clock to use for measuring stage duration.  <a href="classvg_1_1Funnel.html#a8173e5288d688fbf38e324eeb1308978">More...</a><br /></td></tr>
<tr class="separator:a8173e5288d688fbf38e324eeb1308978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a573543e4560aee58697f78cc266f22c7"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a573543e4560aee58697f78cc266f22c7">time_point</a> = clock::time_point</td></tr>
<tr class="memdesc:a573543e4560aee58697f78cc266f22c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">And a type to represent stage transition times.  <a href="classvg_1_1Funnel.html#a573543e4560aee58697f78cc266f22c7">More...</a><br /></td></tr>
<tr class="separator:a573543e4560aee58697f78cc266f22c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a5f8f988df65fc91adc7da9dd8d4446ef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Funnel_1_1Item.html">Item</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a5f8f988df65fc91adc7da9dd8d4446ef">get_item</a> (size_t index)</td></tr>
<tr class="separator:a5f8f988df65fc91adc7da9dd8d4446ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d28d3fee3f8658d59a63c52338644e2"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a9d28d3fee3f8658d59a63c52338644e2">create_item</a> ()</td></tr>
<tr class="separator:a9d28d3fee3f8658d59a63c52338644e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:aae00e188df16e84d5ecdb12e6ce5d51e"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#aae00e188df16e84d5ecdb12e6ce5d51e">funnel_name</a></td></tr>
<tr class="memdesc:aae00e188df16e84d5ecdb12e6ce5d51e"><td class="mdescLeft">&#160;</td><td class="mdescRight">What's the name of the funnel we <a class="el" href="classvg_1_1Funnel.html#a4ba2b8db1575820b05d069cd6c802e31">start()</a>-ed. Will be empty if nothing is running.  <a href="classvg_1_1Funnel.html#aae00e188df16e84d5ecdb12e6ce5d51e">More...</a><br /></td></tr>
<tr class="separator:aae00e188df16e84d5ecdb12e6ce5d51e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72a0ecffb7bd38fcd89ee3c71dd638b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Funnel.html#a573543e4560aee58697f78cc266f22c7">time_point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#af72a0ecffb7bd38fcd89ee3c71dd638b">start_time</a></td></tr>
<tr class="memdesc:af72a0ecffb7bd38fcd89ee3c71dd638b"><td class="mdescLeft">&#160;</td><td class="mdescRight">At what time did we <a class="el" href="classvg_1_1Funnel.html#a4ba2b8db1575820b05d069cd6c802e31">start()</a>  <a href="classvg_1_1Funnel.html#af72a0ecffb7bd38fcd89ee3c71dd638b">More...</a><br /></td></tr>
<tr class="separator:af72a0ecffb7bd38fcd89ee3c71dd638b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b3ea467d461a57b8801c8845b0bdb3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Funnel.html#a573543e4560aee58697f78cc266f22c7">time_point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a59b3ea467d461a57b8801c8845b0bdb3">stop_time</a></td></tr>
<tr class="memdesc:a59b3ea467d461a57b8801c8845b0bdb3"><td class="mdescLeft">&#160;</td><td class="mdescRight">At what time did we <a class="el" href="classvg_1_1Funnel.html#adbe0233346c63f1693fa865eca0083b2">stop()</a>  <a href="classvg_1_1Funnel.html#a59b3ea467d461a57b8801c8845b0bdb3">More...</a><br /></td></tr>
<tr class="separator:a59b3ea467d461a57b8801c8845b0bdb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832c7d0be58aa6fa1e8dd8e7780e6850"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a832c7d0be58aa6fa1e8dd8e7780e6850">stage_name</a></td></tr>
<tr class="memdesc:a832c7d0be58aa6fa1e8dd8e7780e6850"><td class="mdescLeft">&#160;</td><td class="mdescRight">What's the name of the current stage? Will be empty if no stage is running.  <a href="classvg_1_1Funnel.html#a832c7d0be58aa6fa1e8dd8e7780e6850">More...</a><br /></td></tr>
<tr class="separator:a832c7d0be58aa6fa1e8dd8e7780e6850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74a7f57094e7e1a8040ed9df34932aee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Funnel.html#a573543e4560aee58697f78cc266f22c7">time_point</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a74a7f57094e7e1a8040ed9df34932aee">stage_start_time</a></td></tr>
<tr class="memdesc:a74a7f57094e7e1a8040ed9df34932aee"><td class="mdescLeft">&#160;</td><td class="mdescRight">At what time did the stage start?  <a href="classvg_1_1Funnel.html#a74a7f57094e7e1a8040ed9df34932aee">More...</a><br /></td></tr>
<tr class="separator:a74a7f57094e7e1a8040ed9df34932aee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cfa61145fcd97f5710c3d609e72a997"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a4cfa61145fcd97f5710c3d609e72a997">substage_name</a></td></tr>
<tr class="memdesc:a4cfa61145fcd97f5710c3d609e72a997"><td class="mdescLeft">&#160;</td><td class="mdescRight">What's the name of the current substage? Will be empty if no substage is running.  <a href="classvg_1_1Funnel.html#a4cfa61145fcd97f5710c3d609e72a997">More...</a><br /></td></tr>
<tr class="separator:a4cfa61145fcd97f5710c3d609e72a997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a755941e4c7988487e539256c16b507bb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a755941e4c7988487e539256c16b507bb">input_in_progress</a> = numeric_limits&lt;size_t&gt;::max()</td></tr>
<tr class="separator:a755941e4c7988487e539256c16b507bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae946f8189275c0f4b77f29433406a24b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#ae946f8189275c0f4b77f29433406a24b">output_in_progress</a> = numeric_limits&lt;size_t&gt;::max()</td></tr>
<tr class="separator:ae946f8189275c0f4b77f29433406a24b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48bdc3457d5f66a3f454bcde8d42883e"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Funnel_1_1Stage.html">Stage</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html#a48bdc3457d5f66a3f454bcde8d42883e">stages</a></td></tr>
<tr class="separator:a48bdc3457d5f66a3f454bcde8d42883e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Represents a record of an invocation of a pipeline for an input.</p>
<p>Tracks the history of "lines" of data "item" provenance through a series of "stages", containing a series of "filters".</p>
<p>Lines are "introduced", and "project" from earlier stages to later stages, possibly "expanding" or "merging", until they "fail" a filter or reach the final stage. At each stage, items occur in a linear order and are identified by index.</p>
<p>An item may be a "group", with a certain size.</p>
<p>We also can assign "scores" or correctness/placed-ness "tags" to items at a stage. Tags can cover a region of a linear read space. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a8173e5288d688fbf38e324eeb1308978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8173e5288d688fbf38e324eeb1308978">&#9670;&nbsp;</a></span>clock</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1Funnel.html#a8173e5288d688fbf38e324eeb1308978">vg::Funnel::clock</a> =  std::chrono::high_resolution_clock</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pick a clock to use for measuring stage duration. </p>

</div>
</div>
<a id="a573543e4560aee58697f78cc266f22c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a573543e4560aee58697f78cc266f22c7">&#9670;&nbsp;</a></span>time_point</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1Funnel.html#a573543e4560aee58697f78cc266f22c7">vg::Funnel::time_point</a> =  clock::time_point</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>And a type to represent stage transition times. </p>

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a23e7fd0c49df53dd8a9e25934fe06c85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23e7fd0c49df53dd8a9e25934fe06c85">&#9670;&nbsp;</a></span>State</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classvg_1_1Funnel.html#a23e7fd0c49df53dd8a9e25934fe06c85">vg::Funnel::State</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We can tag items as having one of these states. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a23e7fd0c49df53dd8a9e25934fe06c85ab50339a10e1de285ac99d4c3990b8693"></a>NONE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a23e7fd0c49df53dd8a9e25934fe06c85a0a4373ca716769f93112e16e251bb8a1"></a>PLACED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a23e7fd0c49df53dd8a9e25934fe06c85a0d536515ce0fb6e96a5510b6556f30f2"></a>CORRECT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="abc00e34c78f024874b44ebf90443cc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc00e34c78f024874b44ebf90443cc4e">&#9670;&nbsp;</a></span>also_merge_group() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::also_merge_group </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>prev_stage_items_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>prev_stage_items_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Record extra provenance relationships where the latest current-stage item came from the given previous-stage items. Increases the current-stage item group size by the number of previous-stage items added.</p>
<p>Propagates tagging. </p>

</div>
</div>
<a id="a68135544a4504edde8de7df48557d4ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68135544a4504edde8de7df48557d4ba">&#9670;&nbsp;</a></span>also_merge_group() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::also_merge_group </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>earlier_stage_lookback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>earlier_stage_items_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>earlier_stage_items_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Record extra provenance relationships where the latest current-stage item came from the given earlier-stage items. Increases the current-stage item group size by the number of previous-stage items added.</p>
<p>Propagates tagging.</p>
<p>earlier_stage_lookback determines how many stages to look back and must be 1 or more. </p>

</div>
</div>
<a id="a0642f2a1faae54dc12e98df452d4be65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0642f2a1faae54dc12e98df452d4be65">&#9670;&nbsp;</a></span>also_relevant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::also_relevant </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>earlier_stage_lookback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>earlier_stage_item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Record an extra provenance relationship where the latest current-stage item came from the given previous-stage item, the given number of stages ago (min 1).</p>
<p>Does not adjust group size or propagate tagging. </p>

</div>
</div>
<a id="adc044b59bc97ac7e6536068fa9bdb5d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc044b59bc97ac7e6536068fa9bdb5d2">&#9670;&nbsp;</a></span>annotate_mapped_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::annotate_mapped_alignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>annotate_correctness</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set an alignments annotations with the number of results at each stage if annotate_correctness is true, also annotate the alignment with the number of correct results at each stage. This assumes that we've been tracking correctness all along </p>

</div>
</div>
<a id="a9d28d3fee3f8658d59a63c52338644e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d28d3fee3f8658d59a63c52338644e2">&#9670;&nbsp;</a></span>create_item()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::Funnel::create_item </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create a new item in the current stage and get its index. Advances the projected count counter. </p>

</div>
</div>
<a id="a9440c3268e8c60b664a37283d9fc5cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9440c3268e8c60b664a37283d9fc5cff">&#9670;&nbsp;</a></span>expand()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::expand </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prev_stage_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Expand the given item from the previous stage into the given number of new items at this stage. </p>

</div>
</div>
<a id="a38e1d7d328fe8ea456c2631abffaebb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e1d7d328fe8ea456c2631abffaebb4">&#9670;&nbsp;</a></span>fail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::fail </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prev_stage_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>statistic</em> = <code>nan(&quot;&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fail the given item from the previous stage on the given filter and do not project it through to this stage. Items which do not fail a filter must pass the filter and be projected to something. The filter name must survive the funnel, because a pointer to it will be stored. Allows a statistic for the filtered-on value for the failing item to be recorded. </p>

</div>
</div>
<a id="afc114c16e43a80739d292e03b65fa8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc114c16e43a80739d292e03b65fa8ab">&#9670;&nbsp;</a></span>for_each_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::for_each_filter </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(const string &amp;, const string &amp;, const <a class="el" href="structvg_1_1Funnel_1_1FilterPerformance.html">FilterPerformance</a> &amp;, const <a class="el" href="structvg_1_1Funnel_1_1FilterPerformance.html">FilterPerformance</a> &amp;, const vector&lt; double &gt; &amp;, const vector&lt; double &gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the given callback with stage name, filter name, performance report for items, performance report for total size of items, values for correct items for the filter statistic, and values for incorrect (or merely not known-correct) items for the filter statistic. Runs the callback for each stage and filter, in order. Only includes filters that were actually passed or failed by any items. </p>

</div>
</div>
<a id="afe28658059032edb97960675bd8806ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe28658059032edb97960675bd8806ab">&#9670;&nbsp;</a></span>for_each_stage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::for_each_stage </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(const string &amp;, const vector&lt; size_t &gt; &amp;, const double &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>callback</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Call the given callback with stage name, and vector of result item sizes at that stage, and a duration in seconds, for each stage. </p>

</div>
</div>
<a id="a5f8f988df65fc91adc7da9dd8d4446ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f8f988df65fc91adc7da9dd8d4446ef">&#9670;&nbsp;</a></span>get_item()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Funnel_1_1Item.html">Funnel::Item</a> &amp; vg::Funnel::get_item </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ensure an item with the given index exists in the current stage and return a reference to it. We need to do it this way because we might save a production duration before an item is really projected. The items of the current stage should only be modified through this. Note that you do <em>not</em> need to create an item in order to get it. </p>

</div>
</div>
<a id="adfe8a13519ae236c400f3ad68980e16c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfe8a13519ae236c400f3ad68980e16c">&#9670;&nbsp;</a></span>introduce()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::introduce </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em> = <code>1</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Introduce the given number of new items, starting their own lines of provenance (default 1). </p>

</div>
</div>
<a id="a4296184811926cf97a42d52aaf3fc6f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4296184811926cf97a42d52aaf3fc6f6">&#9670;&nbsp;</a></span>is_correct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Funnel::is_correct </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the given item at this stage is tagged correct, or descends from an item that was tagged correct. </p>

</div>
</div>
<a id="a996005ebe76091bbba404bf4a2a9a405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a996005ebe76091bbba404bf4a2a9a405">&#9670;&nbsp;</a></span>last_correct_stage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::Funnel::last_correct_stage </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tag_start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tag_length</em> = <code>std::numeric_limits&lt;size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of the most recent stage that had a correct-tagged item survive into it, or "none" if no items were ever tagged correct. Optionally allows specifying a read space interval to intersect with items, so the query returns the last stage that had a correct item intersecting that range. </p>

</div>
</div>
<a id="ab53e816bd740407417b0bd8d14d5237c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab53e816bd740407417b0bd8d14d5237c">&#9670;&nbsp;</a></span>last_tagged_stage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::Funnel::last_tagged_stage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1Funnel.html#a23e7fd0c49df53dd8a9e25934fe06c85">State</a>&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tag_start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tag_length</em> = <code>std::numeric_limits&lt;size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the name of the most recent stage that had a n item tagged with the given tag or better survive into it, or "none" if no items were ever tagged that good. Optionally allows specifying a read space interval to intersect with items, so the query returns the last stage that had an item intersecting that range and also an item witht hat tag or better.</p>
<p>TODO: Make worse tag ranges not match queries for better tags! </p>

</div>
</div>
<a id="a933c8a296c5a680aa96b0b913c465250"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a933c8a296c5a680aa96b0b913c465250">&#9670;&nbsp;</a></span>latest()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::Funnel::latest </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index of the most recent item created in the current stage. </p>

</div>
</div>
<a id="ae75f133fdc545176a27f0121a61a98e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae75f133fdc545176a27f0121a61a98e4">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::merge </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>prev_stage_items_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>prev_stage_items_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge all the given item indexes from the previous stage into a new item at this stage. The new item will be a single item. </p>

</div>
</div>
<a id="a585c5484ef877a1ede56ed4467e32312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585c5484ef877a1ede56ed4467e32312">&#9670;&nbsp;</a></span>merge_group()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::merge_group </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>prev_stage_items_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>prev_stage_items_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge all the given item indexes from the previous stage into a new item at this stage. The new item will be a group, sized according to the number of previous items merged. </p>

</div>
</div>
<a id="a44fcff7c06cb79e43cc1aa2fc73a8da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44fcff7c06cb79e43cc1aa2fc73a8da6">&#9670;&nbsp;</a></span>merge_groups()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::merge_groups </td>
          <td>(</td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>prev_stage_items_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iterator&#160;</td>
          <td class="paramname"><em>prev_stage_items_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge all the given item indexes from the previous stage into a new item at this stage. The new item will be a group, sized according to the total size of previous groups, with non-groups counting as size 1. </p>

</div>
</div>
<a id="aec19daea826d5951ecf1477769722d9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec19daea826d5951ecf1477769722d9a">&#9670;&nbsp;</a></span>pass()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::pass </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filter</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prev_stage_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>statistic</em> = <code>nan(&quot;&quot;)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Pass the given item from the previous stage through the given filter at this stage. Items which do not pass a filter must fail it. All items which pass filters must do so in the same order. The filter name must survive the funnel, because a pointer to it will be stored. Allows a statistic for the filtered-on value for the passing item to be recorded. </p>

</div>
</div>
<a id="a94e07fb24eee3bb9284a1ba8945b010a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94e07fb24eee3bb9284a1ba8945b010a">&#9670;&nbsp;</a></span>processed_input()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::processed_input </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop processing an item from the previous stage. </p>

</div>
</div>
<a id="a3c21502db704cde878d989f3cc75e91c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c21502db704cde878d989f3cc75e91c">&#9670;&nbsp;</a></span>processing_input()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::processing_input </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prev_stage_item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start processing the given item coming from the previous stage. </p>

</div>
</div>
<a id="ae9dec7f539cf37d822328a71e376783a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9dec7f539cf37d822328a71e376783a">&#9670;&nbsp;</a></span>produced_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::produced_output </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop producing an output item. </p>

</div>
</div>
<a id="a919aae2ef8cf780bcaba00b1ea1603b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a919aae2ef8cf780bcaba00b1ea1603b8">&#9670;&nbsp;</a></span>producing_output()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::producing_output </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start producing the given output item, whether it has been projected yet or not. </p>

</div>
</div>
<a id="a2b9e7695a998b23314c25f7fe3de4701"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9e7695a998b23314c25f7fe3de4701">&#9670;&nbsp;</a></span>project()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::project </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prev_stage_item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project a single item from the previous stage to a single non-group item at this stage. </p>

</div>
</div>
<a id="a321b1e593102927ff8677214abce5592"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a321b1e593102927ff8677214abce5592">&#9670;&nbsp;</a></span>project_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::project_group </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prev_stage_item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>group_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Project a single item from the previous stage to a new group item at the current stage, with the given size. </p>

</div>
</div>
<a id="a9cdacae4561ece776ba90e293299f930"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cdacae4561ece776ba90e293299f930">&#9670;&nbsp;</a></span>score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::score </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>score</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assign the given score to the given item at the current stage. </p>

</div>
</div>
<a id="a21b5f8762aa446a64b5ddb3809e5c8e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21b5f8762aa446a64b5ddb3809e5c8e2">&#9670;&nbsp;</a></span>stage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::stage </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start the given stage, and end all previous stages and substages. Name must not be empty. Multiple stages with the same name will be coalesced. </p>

</div>
</div>
<a id="a87e1b8deccb4438d7f71267ee5f12ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87e1b8deccb4438d7f71267ee5f12ced">&#9670;&nbsp;</a></span>stage_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::stage_stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the current stage. </p>

</div>
</div>
<a id="a4ba2b8db1575820b05d069cd6c802e31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ba2b8db1575820b05d069cd6c802e31">&#9670;&nbsp;</a></span>start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::start </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start processing the given named input. Name must not be empty. No stage or substage will be active. </p>

</div>
</div>
<a id="adbe0233346c63f1693fa865eca0083b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe0233346c63f1693fa865eca0083b2">&#9670;&nbsp;</a></span>stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop processing the given named input. All stages and substages are stopped. </p>

</div>
</div>
<a id="a0520d00fd1dcd9fa4af18d715580c900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0520d00fd1dcd9fa4af18d715580c900">&#9670;&nbsp;</a></span>substage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::substage </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start the given substage, nested insude the current stage. End all previous substages. Substages within a stage may repeat and are coalesced. Name must not be empty. </p>

</div>
</div>
<a id="ab5934891f37d57dc9309e5b0e9f80d9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5934891f37d57dc9309e5b0e9f80d9e">&#9670;&nbsp;</a></span>substage_stop()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::substage_stop </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop the current substage. </p>

</div>
</div>
<a id="abd3cf8783612cccf4faf96f25fc4f17c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd3cf8783612cccf4faf96f25fc4f17c">&#9670;&nbsp;</a></span>tag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::tag </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1Funnel.html#a23e7fd0c49df53dd8a9e25934fe06c85">State</a>&#160;</td>
          <td class="paramname"><em>state</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tag_start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tag_length</em> = <code>std::numeric_limits&lt;size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tag the given item as being in the given state at the current stage. Future items that derive from it will inherit these tags. Optionally allows specifying that the state extends over a range in read space. </p>

</div>
</div>
<a id="aa725f066e32a967c8d482f50c1606f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa725f066e32a967c8d482f50c1606f08">&#9670;&nbsp;</a></span>tag_correct()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::tag_correct </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>item</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tag_start</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tag_length</em> = <code>std::numeric_limits&lt;size_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tag the given item as "correct" at the current stage. Future items that derive from it will also be tagged as correct. Optionally allows specifying that the correctness extends over a range in read space, so correctness can be tracked as a property of regions of the read, rather than the whole read. If called multiple times, with different bounds, the correct region will enclose all the correct regions provided in the different calls. </p>

</div>
</div>
<a id="ad4a9374a423b2b87a15355ffac7a1935"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4a9374a423b2b87a15355ffac7a1935">&#9670;&nbsp;</a></span>to_dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Funnel::to_dot </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump information from the <a class="el" href="classvg_1_1Funnel.html">Funnel</a> as a dot-format Graphviz graph to the given stream. Illustrates stages and provenance. </p>

</div>
</div>
<a id="a5f0037505a9df13b92e381f5ff108d72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f0037505a9df13b92e381f5ff108d72">&#9670;&nbsp;</a></span>was_correct() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Funnel::was_correct </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prev_stage_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>prev_stage_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prev_stage_item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the given item at the given named previous stage is tagged correct, or descends from an item that was tagged correct. Needs a hint about what number the stage was in the order, to make lookup fast. </p>

</div>
</div>
<a id="aac71f37530afee1b7e49770aff8cc53b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac71f37530afee1b7e49770aff8cc53b">&#9670;&nbsp;</a></span>was_correct() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Funnel::was_correct </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prev_stage_item</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the given item at the previous stage is tagged correct, or descends from an item that was tagged correct. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aae00e188df16e84d5ecdb12e6ce5d51e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae00e188df16e84d5ecdb12e6ce5d51e">&#9670;&nbsp;</a></span>funnel_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::Funnel::funnel_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What's the name of the funnel we <a class="el" href="classvg_1_1Funnel.html#a4ba2b8db1575820b05d069cd6c802e31">start()</a>-ed. Will be empty if nothing is running. </p>

</div>
</div>
<a id="a755941e4c7988487e539256c16b507bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755941e4c7988487e539256c16b507bb">&#9670;&nbsp;</a></span>input_in_progress</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::Funnel::input_in_progress = numeric_limits&lt;size_t&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>What's the current prev-stage input we are processing? Will be <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">numeric_limits&lt;size_t&gt;::max()</a> if none. </p>

</div>
</div>
<a id="ae946f8189275c0f4b77f29433406a24b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae946f8189275c0f4b77f29433406a24b">&#9670;&nbsp;</a></span>output_in_progress</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::Funnel::output_in_progress = numeric_limits&lt;size_t&gt;::max()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>what's the current current-stage output we are generating? Will be <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">numeric_limits&lt;size_t&gt;::max()</a> if none. </p>

</div>
</div>
<a id="a832c7d0be58aa6fa1e8dd8e7780e6850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a832c7d0be58aa6fa1e8dd8e7780e6850">&#9670;&nbsp;</a></span>stage_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::Funnel::stage_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What's the name of the current stage? Will be empty if no stage is running. </p>

</div>
</div>
<a id="a74a7f57094e7e1a8040ed9df34932aee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74a7f57094e7e1a8040ed9df34932aee">&#9670;&nbsp;</a></span>stage_start_time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Funnel.html#a573543e4560aee58697f78cc266f22c7">time_point</a> vg::Funnel::stage_start_time</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>At what time did the stage start? </p>

</div>
</div>
<a id="a48bdc3457d5f66a3f454bcde8d42883e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48bdc3457d5f66a3f454bcde8d42883e">&#9670;&nbsp;</a></span>stages</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="structvg_1_1Funnel_1_1Stage.html">Stage</a>&gt; vg::Funnel::stages</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Rercord all the stages, including their names and item provenance. Handles repeated stages. </p>

</div>
</div>
<a id="af72a0ecffb7bd38fcd89ee3c71dd638b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af72a0ecffb7bd38fcd89ee3c71dd638b">&#9670;&nbsp;</a></span>start_time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Funnel.html#a573543e4560aee58697f78cc266f22c7">time_point</a> vg::Funnel::start_time</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>At what time did we <a class="el" href="classvg_1_1Funnel.html#a4ba2b8db1575820b05d069cd6c802e31">start()</a> </p>

</div>
</div>
<a id="a59b3ea467d461a57b8801c8845b0bdb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b3ea467d461a57b8801c8845b0bdb3">&#9670;&nbsp;</a></span>stop_time</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Funnel.html#a573543e4560aee58697f78cc266f22c7">time_point</a> vg::Funnel::stop_time</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>At what time did we <a class="el" href="classvg_1_1Funnel.html#adbe0233346c63f1693fa865eca0083b2">stop()</a> </p>

</div>
</div>
<a id="a4cfa61145fcd97f5710c3d609e72a997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cfa61145fcd97f5710c3d609e72a997">&#9670;&nbsp;</a></span>substage_name</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::Funnel::substage_name</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What's the name of the current substage? Will be empty if no substage is running. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="funnel_8hpp.html">funnel.hpp</a></li>
<li>src/<a class="el" href="funnel_8cpp.html">funnel.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
