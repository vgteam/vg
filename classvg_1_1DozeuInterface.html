<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::DozeuInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1DozeuInterface.html">DozeuInterface</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="classvg_1_1DozeuInterface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::DozeuInterface Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;dozeu_interface.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::DozeuInterface:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1DozeuInterface.png" usemap="#vg::DozeuInterface_map" alt=""/>
  <map id="vg::DozeuInterface_map" name="vg::DozeuInterface_map">
<area href="classvg_1_1QualAdjXdropAligner.html" alt="vg::QualAdjXdropAligner" shape="rect" coords="0,56,154,80"/>
<area href="classvg_1_1XdropAligner.html" alt="vg::XdropAligner" shape="rect" coords="164,56,318,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1DozeuInterface_1_1graph__pos__s.html">graph_pos_s</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1DozeuInterface_1_1OrderedGraph.html">OrderedGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0ac4d30c781e2a2278986ecbb84a34a6"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html#a0ac4d30c781e2a2278986ecbb84a34a6">~DozeuInterface</a> ()=default</td></tr>
<tr class="separator:a0ac4d30c781e2a2278986ecbb84a34a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b2d827b7cf43451065a2e2369895aff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html#a3b2d827b7cf43451065a2e2369895aff">align</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, bool reverse_complemented, int8_t full_length_bonus, uint16_t max_gap_length=default_xdrop_max_gap_length)</td></tr>
<tr class="separator:a3b2d827b7cf43451065a2e2369895aff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa901ac96f18c5f60cbe114087aada362"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html#aa901ac96f18c5f60cbe114087aada362">align</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;order, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, bool reverse_complemented, int8_t full_length_bonus, uint16_t max_gap_length=default_xdrop_max_gap_length)</td></tr>
<tr class="separator:aa901ac96f18c5f60cbe114087aada362"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f8736e97ee778271e35b2d212c8603d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html#a7f8736e97ee778271e35b2d212c8603d">align_pinned</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;g, bool pin_left, int8_t full_length_bonus, uint16_t max_gap_length=default_xdrop_max_gap_length)</td></tr>
<tr class="separator:a7f8736e97ee778271e35b2d212c8603d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7f00debc965248ba99fc5450ed35e24d"><td class="memItemLeft" align="right" valign="top">static constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html#a7f00debc965248ba99fc5450ed35e24d">THREAD_MAX_RETAINED_BYTES</a> = 2ULL * 1024 * 1024 * 1024</td></tr>
<tr class="separator:a7f00debc965248ba99fc5450ed35e24d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:acd17348d5d2dd0ec4c10af98748fe67a"><td class="memItemLeft" align="right" valign="top">virtual dz_query_s *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html#acd17348d5d2dd0ec4c10af98748fe67a">pack_query_forward</a> (const char *seq, const uint8_t *qual, int8_t full_length_bonus, size_t len)=0</td></tr>
<tr class="separator:acd17348d5d2dd0ec4c10af98748fe67a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa15876efde0e6d8f963d37ae245c8ead"><td class="memItemLeft" align="right" valign="top">virtual dz_query_s *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html#aa15876efde0e6d8f963d37ae245c8ead">pack_query_reverse</a> (const char *seq, const uint8_t *qual, int8_t full_length_bonus, size_t len)=0</td></tr>
<tr class="separator:aa15876efde0e6d8f963d37ae245c8ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73d9afd8c6b52ff715ae0606bbae4b63"><td class="memItemLeft" align="right" valign="top">virtual const dz_forefront_s *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html#a73d9afd8c6b52ff715ae0606bbae4b63">scan</a> (const dz_query_s *query, const dz_forefront_s **forefronts, size_t n_forefronts, const char *ref, int32_t rlen, uint32_t rid, uint16_t xt)=0</td></tr>
<tr class="separator:a73d9afd8c6b52ff715ae0606bbae4b63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8102472215beaaa523c33e34be6c849"><td class="memItemLeft" align="right" valign="top">virtual const dz_forefront_s *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html#ab8102472215beaaa523c33e34be6c849">extend</a> (const dz_query_s *query, const dz_forefront_s **forefronts, size_t n_forefronts, const char *ref, int32_t rlen, uint32_t rid, uint16_t xt)=0</td></tr>
<tr class="separator:ab8102472215beaaa523c33e34be6c849"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82634289dc80707e1ba8bb1a94503027"><td class="memItemLeft" align="right" valign="top">virtual dz_alignment_s *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html#a82634289dc80707e1ba8bb1a94503027">trace</a> (const dz_forefront_s *forefront)=0</td></tr>
<tr class="separator:a82634289dc80707e1ba8bb1a94503027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51a02b103eb50f4f458c0f756152302"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html#ac51a02b103eb50f4f458c0f756152302">flush</a> ()=0</td></tr>
<tr class="separator:ac51a02b103eb50f4f458c0f756152302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a397c817ed543794a609d32fb21063790"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1DozeuInterface_1_1graph__pos__s.html">graph_pos_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html#a397c817ed543794a609d32fb21063790">calculate_seed_position</a> (const <a class="el" href="structvg_1_1DozeuInterface_1_1OrderedGraph.html">OrderedGraph</a> &amp;graph, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, size_t query_length, bool direction) const</td></tr>
<tr class="separator:a397c817ed543794a609d32fb21063790"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa863b61f59ea128a5e17e97538405d9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1DozeuInterface_1_1graph__pos__s.html">graph_pos_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html#aa863b61f59ea128a5e17e97538405d9b">calculate_max_position</a> (const <a class="el" href="structvg_1_1DozeuInterface_1_1OrderedGraph.html">OrderedGraph</a> &amp;graph, const <a class="el" href="structvg_1_1DozeuInterface_1_1graph__pos__s.html">graph_pos_s</a> &amp;seed_pos, size_t max_node_index, bool direction, const vector&lt; const dz_forefront_s * &gt; &amp;forefronts)</td></tr>
<tr class="separator:aa863b61f59ea128a5e17e97538405d9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472afdc993f32bfa38518a9cfbd14dcb"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structvg_1_1DozeuInterface_1_1graph__pos__s.html">graph_pos_s</a>, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html#a472afdc993f32bfa38518a9cfbd14dcb">scan_seed_position</a> (const <a class="el" href="structvg_1_1DozeuInterface_1_1OrderedGraph.html">OrderedGraph</a> &amp;graph, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, bool direction, vector&lt; const dz_forefront_s * &gt; &amp;forefronts, int8_t full_length_bonus, uint16_t max_gap_length)</td></tr>
<tr class="separator:a472afdc993f32bfa38518a9cfbd14dcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc84e0c73002c23f8249ea17efff6848"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html#acc84e0c73002c23f8249ea17efff6848">push_edit</a> (<a class="el" href="structvg_1_1Mapping.html">Mapping</a> *mapping, uint8_t op, const char *alt, size_t len) const</td></tr>
<tr class="separator:acc84e0c73002c23f8249ea17efff6848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f8194b77acf4e94604b5b0759231c62"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html#a4f8194b77acf4e94604b5b0759231c62">do_poa</a> (const <a class="el" href="structvg_1_1DozeuInterface_1_1OrderedGraph.html">OrderedGraph</a> &amp;graph, const dz_query_s *packed_query, const vector&lt; <a class="el" href="structvg_1_1DozeuInterface_1_1graph__pos__s.html">graph_pos_s</a> &gt; &amp;seed_positions, bool right_to_left, vector&lt; const dz_forefront_s * &gt; &amp;forefronts, uint16_t)</td></tr>
<tr class="separator:a4f8194b77acf4e94604b5b0759231c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa8e98b63ac97d3d4c60ca93708973302"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html#aa8e98b63ac97d3d4c60ca93708973302">calculate_and_save_alignment</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="structvg_1_1DozeuInterface_1_1OrderedGraph.html">OrderedGraph</a> &amp;graph, const vector&lt; <a class="el" href="structvg_1_1DozeuInterface_1_1graph__pos__s.html">graph_pos_s</a> &gt; &amp;head_positions, size_t tail_node_index, bool left_to_right, const vector&lt; const dz_forefront_s * &gt; &amp;forefronts)</td></tr>
<tr class="separator:aa8e98b63ac97d3d4c60ca93708973302"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a907ed564c2ed19ecaf7ee880b8a1a13c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html#a907ed564c2ed19ecaf7ee880b8a1a13c">align_downward</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="structvg_1_1DozeuInterface_1_1OrderedGraph.html">OrderedGraph</a> &amp;graph, const vector&lt; <a class="el" href="structvg_1_1DozeuInterface_1_1graph__pos__s.html">graph_pos_s</a> &gt; &amp;head_positions, bool left_to_right, vector&lt; const dz_forefront_s * &gt; &amp;forefronts, int8_t full_length_bonus, uint16_t max_gap_length)</td></tr>
<tr class="separator:a907ed564c2ed19ecaf7ee880b8a1a13c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a7df127f3d122bd29a38453a08c5c22b8"><td class="memItemLeft" align="right" valign="top">dz_s *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html#a7df127f3d122bd29a38453a08c5c22b8">dz</a> = nullptr</td></tr>
<tr class="memdesc:a7df127f3d122bd29a38453a08c5c22b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The core dozeu class, which does the alignments.  <a href="classvg_1_1DozeuInterface.html#a7df127f3d122bd29a38453a08c5c22b8">More...</a><br /></td></tr>
<tr class="separator:a7df127f3d122bd29a38453a08c5c22b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Align to a graph using the xdrop algorithm, as implemented in dozeu.</p>
<p>The underlying Dozeu library is fundamentally based around semi-global alignment: extending an alignment from a known matching position (what in other parts of vg we call "pinned" alignment).</p>
<p>To simulate non-pinned alignment, we align in two passes in different directions. One from a guess of a pinning position, to get a more accurate "head" pinning position for the other end, and once back from where the previous pass ended up, to get an overall hopefully-optimal alignment.</p>
<p>If the input graph is not reverse-complemented, direction = false (reverse, right to left) on the first pass, and direction = true (forward, left to right) on the second. If it is reverse complemented, we flip them.</p>
<p>This won't actually work in theory to get the optimal local alignment in all cases, but it works well in practice.</p>
<p>This class maintains an internal dz_s, which is <em>NOT THREADSAFE</em>, and non-const during alignments. However, it may be reused for subsequent alignments. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0ac4d30c781e2a2278986ecbb84a34a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ac4d30c781e2a2278986ecbb84a34a6">&#9670;&nbsp;</a></span>~DozeuInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual vg::DozeuInterface::~DozeuInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="aa901ac96f18c5f60cbe114087aada362"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa901ac96f18c5f60cbe114087aada362">&#9670;&nbsp;</a></span>align() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DozeuInterface::align </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse_complemented</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>full_length_bonus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_gap_length</em> = <code>default_xdrop_max_gap_length</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above except using a precomputed topological order, which need not include all handles in the graph, and which may contain both orientations of a handle. </p>

</div>
</div>
<a id="a3b2d827b7cf43451065a2e2369895aff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b2d827b7cf43451065a2e2369895aff">&#9670;&nbsp;</a></span>align() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DozeuInterface::align </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reverse_complemented</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>full_length_bonus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_gap_length</em> = <code>default_xdrop_max_gap_length</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>align query: forward-backward banded alignment</p>
<p>Compute an alignment of the given <a class="el" href="structvg_1_1Alignment.html">Alignment</a>'s sequence against the given DAG, using (one of) the given MEMs to seed the alignment.</p>
<p>reverse_complemented is true if the topologically sorted graph we have was reverse-complemented when extracted from a larger containing graph, and false if it is in the same orientation as it exists in the larger containing graph. The MEMs and the <a class="el" href="structvg_1_1Alignment.html">Alignment</a> are interpreted as being against the forward strand of the passed subgraph no matter the value of this setting.</p>
<p>reverse_complemented true means we will compute the alignment forward in the topologically-sorted order of the given graph (anchoring to the first node if no MEMs are provided) and false if we want to compute the alignment backward in the topological order (anchoring to the last node).</p>
<p>First the head (the most upstream) seed in MEMs is selected and extended downward to detect the downstream breakpoint. Next the alignment path is generated by second upward extension from the downstream breakpoint.</p>
<p>The MEM list may be empty. If MEMs are provided, uses only the begin, end, and nodes fields of the <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> objects. It uses the first occurrence of the last MEM if reverse_complemented is true, and the last occurrence of the first MEM otherwise. </p>

</div>
</div>
<a id="a907ed564c2ed19ecaf7ee880b8a1a13c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a907ed564c2ed19ecaf7ee880b8a1a13c">&#9670;&nbsp;</a></span>align_downward()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DozeuInterface::align_downward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1DozeuInterface_1_1OrderedGraph.html">OrderedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1DozeuInterface_1_1graph__pos__s.html">graph_pos_s</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>head_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left_to_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; const dz_forefront_s * &gt; &amp;&#160;</td>
          <td class="paramname"><em>forefronts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>full_length_bonus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_gap_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After doing the upward pass and finding head_pos to anchor from, do the downward alignment pass and traceback. If left_to_right is set, goes left to right and traces back the other way. If it is unset, goes right to left and traces back the other way. </p>

</div>
</div>
<a id="a7f8736e97ee778271e35b2d212c8603d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f8736e97ee778271e35b2d212c8603d">&#9670;&nbsp;</a></span>align_pinned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void DozeuInterface::align_pinned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>pin_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>full_length_bonus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_gap_length</em> = <code>default_xdrop_max_gap_length</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a pinned alignment, where the start (pin_left=true) or end (pin_left=false) end of the <a class="el" href="structvg_1_1Alignment.html">Alignment</a> sequence is pinned to the start of the first (pin_left=true) or end of the last (pin_left=false) node in the graph's topological order.</p>
<p>Does not account for multiple sources/sinks in the topological order; whichever comes first/last ends up being used for the pin. </p>

</div>
</div>
<a id="aa8e98b63ac97d3d4c60ca93708973302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa8e98b63ac97d3d4c60ca93708973302">&#9670;&nbsp;</a></span>calculate_and_save_alignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void DozeuInterface::calculate_and_save_alignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1DozeuInterface_1_1OrderedGraph.html">OrderedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1DozeuInterface_1_1graph__pos__s.html">graph_pos_s</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>head_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tail_node_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left_to_right</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; const dz_forefront_s * &gt; &amp;&#160;</td>
          <td class="paramname"><em>forefronts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>After all the alignment work has been done, do the traceback and save into the given <a class="el" href="structvg_1_1Alignment.html">Alignment</a> object.</p>
<p>If left_to_right is true, the nodes were filled left to right, and the internal traceback will come out in left to right order, so we can emit it as is. If it is false, the nodes were filled right to left, and the internal traceback comes out in right to left order, so we need to flip it.</p>
<p>All Mappings in the <a class="el" href="structvg_1_1Alignment.html">Alignment</a> other than the first will have a zero offset in their Positions. </p>

</div>
</div>
<a id="aa863b61f59ea128a5e17e97538405d9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa863b61f59ea128a5e17e97538405d9b">&#9670;&nbsp;</a></span>calculate_max_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1DozeuInterface_1_1graph__pos__s.html">DozeuInterface::graph_pos_s</a> DozeuInterface::calculate_max_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1DozeuInterface_1_1OrderedGraph.html">OrderedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1DozeuInterface_1_1graph__pos__s.html">graph_pos_s</a> &amp;&#160;</td>
          <td class="paramname"><em>seed_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_node_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; const dz_forefront_s * &gt; &amp;&#160;</td>
          <td class="paramname"><em>forefronts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the index of the node at which the winning score occurs, find the position in the node and read sequence at which the winning match is found. </p>

</div>
</div>
<a id="a397c817ed543794a609d32fb21063790"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a397c817ed543794a609d32fb21063790">&#9670;&nbsp;</a></span>calculate_seed_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1DozeuInterface_1_1graph__pos__s.html">DozeuInterface::graph_pos_s</a> DozeuInterface::calculate_seed_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1DozeuInterface_1_1OrderedGraph.html">OrderedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>query_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>direction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the subgraph we are aligning to, the MEM hist against it, the length of the query, and the direction we are aligning the query in (true = forward), select a single anchoring match between the graph and the query to align out from.</p>
<p>This replaces scan_seed_position for the case where we have MEMs. </p>

</div>
</div>
<a id="a4f8194b77acf4e94604b5b0759231c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f8194b77acf4e94604b5b0759231c62">&#9670;&nbsp;</a></span>do_poa()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t DozeuInterface::do_poa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1DozeuInterface_1_1OrderedGraph.html">OrderedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dz_query_s *&#160;</td>
          <td class="paramname"><em>packed_query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1DozeuInterface_1_1graph__pos__s.html">graph_pos_s</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seed_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>right_to_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; const dz_forefront_s * &gt; &amp;&#160;</td>
          <td class="paramname"><em>forefronts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_gap_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Do alignment. Takes the graph, the sorted packed edges in ascending order for a forward pass or descending order for a reverse pass, the packed query sequence, the index of the seed node in the graph, the offset (TODO: in the read?) of the seed position, and the direction to traverse the graph topological order.</p>
<p>Note that we take our direction as right_to_left, whole many other functions take it as left_to_right.</p>
<p>If a MEM seed is provided, this is run in two passes. The first is left to right (right_to_left = false) if align did not have reverse_complement set and the second is right to left (right_to_left = true).</p>
<p>If we have no MEM seed, we only run one pass (the second one).</p>
<p>Returns the index in the topological order of the node with the highest scoring alignment.</p>
<p>Note that if no non-empty local alignment is found, it may not be safe to call dz_calc_max_qpos on the associated forefront! </p>

</div>
</div>
<a id="ab8102472215beaaa523c33e34be6c849"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8102472215beaaa523c33e34be6c849">&#9670;&nbsp;</a></span>extend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const dz_forefront_s* vg::DozeuInterface::extend </td>
          <td>(</td>
          <td class="paramtype">const dz_query_s *&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dz_forefront_s **&#160;</td>
          <td class="paramname"><em>forefronts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_forefronts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>xt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classvg_1_1QualAdjXdropAligner.html#a3f2fec934929a0dacc2f2870755e117f">vg::QualAdjXdropAligner</a>, and <a class="el" href="classvg_1_1XdropAligner.html#a9c65c36083d9f587665bf1fbcf4ba208">vg::XdropAligner</a>.</p>

</div>
</div>
<a id="ac51a02b103eb50f4f458c0f756152302"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51a02b103eb50f4f458c0f756152302">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void vg::DozeuInterface::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classvg_1_1QualAdjXdropAligner.html#a9e0a9d6587bcc78fc8453a2d5a6c00ae">vg::QualAdjXdropAligner</a>, and <a class="el" href="classvg_1_1XdropAligner.html#a06cf48f7dd057db6268218733cc9c991">vg::XdropAligner</a>.</p>

</div>
</div>
<a id="acd17348d5d2dd0ec4c10af98748fe67a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd17348d5d2dd0ec4c10af98748fe67a">&#9670;&nbsp;</a></span>pack_query_forward()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual dz_query_s* vg::DozeuInterface::pack_query_forward </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>qual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>full_length_bonus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classvg_1_1QualAdjXdropAligner.html#a0e1140ad3ee66b2583869ccd2267841b">vg::QualAdjXdropAligner</a>, and <a class="el" href="classvg_1_1XdropAligner.html#a9179d91b00ed33fbc3e9e6a4bd6b9321">vg::XdropAligner</a>.</p>

</div>
</div>
<a id="aa15876efde0e6d8f963d37ae245c8ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa15876efde0e6d8f963d37ae245c8ead">&#9670;&nbsp;</a></span>pack_query_reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual dz_query_s* vg::DozeuInterface::pack_query_reverse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>qual</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>full_length_bonus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classvg_1_1QualAdjXdropAligner.html#a0d6b25927dccfe18f03eab6457486ac7">vg::QualAdjXdropAligner</a>, and <a class="el" href="classvg_1_1XdropAligner.html#a3c3832ae9935773f0dd0b97ed031c70e">vg::XdropAligner</a>.</p>

</div>
</div>
<a id="acc84e0c73002c23f8249ea17efff6848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc84e0c73002c23f8249ea17efff6848">&#9670;&nbsp;</a></span>push_edit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t DozeuInterface::push_edit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> *&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>op</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>alt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Append an edit at the end of the current mapping array. Returns the length passed in. </p>

</div>
</div>
<a id="a73d9afd8c6b52ff715ae0606bbae4b63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73d9afd8c6b52ff715ae0606bbae4b63">&#9670;&nbsp;</a></span>scan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const dz_forefront_s* vg::DozeuInterface::scan </td>
          <td>(</td>
          <td class="paramtype">const dz_query_s *&#160;</td>
          <td class="paramname"><em>query</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const dz_forefront_s **&#160;</td>
          <td class="paramname"><em>forefronts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n_forefronts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>rlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>rid</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>xt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classvg_1_1QualAdjXdropAligner.html#a2e8adea58e74731765b5c7d0eb54386f">vg::QualAdjXdropAligner</a>, and <a class="el" href="classvg_1_1XdropAligner.html#a3bf50d433186476abc2f732525bf1377">vg::XdropAligner</a>.</p>

</div>
</div>
<a id="a472afdc993f32bfa38518a9cfbd14dcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472afdc993f32bfa38518a9cfbd14dcb">&#9670;&nbsp;</a></span>scan_seed_position()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structvg_1_1DozeuInterface_1_1graph__pos__s.html">DozeuInterface::graph_pos_s</a>, bool &gt; DozeuInterface::scan_seed_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1DozeuInterface_1_1OrderedGraph.html">OrderedGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>direction</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; const dz_forefront_s * &gt; &amp;&#160;</td>
          <td class="paramname"><em>forefronts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>full_length_bonus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>max_gap_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If no seeds are provided as alignment input, we need to compute our own starting anchor position. This function does that. Takes the topologically-sorted graph, the query sequence, and the direction. If direction is false, finds a seed hit on the first node of the graph. If it is true, finds a hit on the last node.</p>
<p>This replaces calculate_seed_position for the case where we have no MEMs.</p>
<p>The bool return with the position indicates whether the scan succeeded or failed. If the scan failed, then the alignment should not be attempted. </p>

</div>
</div>
<a id="a82634289dc80707e1ba8bb1a94503027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82634289dc80707e1ba8bb1a94503027">&#9670;&nbsp;</a></span>trace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual dz_alignment_s* vg::DozeuInterface::trace </td>
          <td>(</td>
          <td class="paramtype">const dz_forefront_s *&#160;</td>
          <td class="paramname"><em>forefront</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classvg_1_1QualAdjXdropAligner.html#a8a382e7378bfeb43954a9436cf9d3b09">vg::QualAdjXdropAligner</a>, and <a class="el" href="classvg_1_1XdropAligner.html#adb3c7fa9b6b7c272ab687e0693a1dc47">vg::XdropAligner</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a7df127f3d122bd29a38453a08c5c22b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7df127f3d122bd29a38453a08c5c22b8">&#9670;&nbsp;</a></span>dz</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">dz_s* vg::DozeuInterface::dz = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The core dozeu class, which does the alignments. </p>

</div>
</div>
<a id="a7f00debc965248ba99fc5450ed35e24d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f00debc965248ba99fc5450ed35e24d">&#9670;&nbsp;</a></span>THREAD_MAX_RETAINED_BYTES</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t vg::DozeuInterface::THREAD_MAX_RETAINED_BYTES = 2ULL * 1024 * 1024 * 1024</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maximum number of bytes of Dozeu scratch space to retain permanently for each thread. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="dozeu__interface_8hpp.html">dozeu_interface.hpp</a></li>
<li>src/<a class="el" href="dozeu__interface_8cpp.html">dozeu_interface.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
