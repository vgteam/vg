<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::SnarlDistanceIndexClusterer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html">SnarlDistanceIndexClusterer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1SnarlDistanceIndexClusterer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::SnarlDistanceIndexClusterer Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;snarl_seed_clusterer.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Cluster.html">Cluster</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Cluster.html" title="Cluster information used in Giraffe.">Cluster</a> information used in Giraffe.  <a href="structvg_1_1SnarlDistanceIndexClusterer_1_1Cluster.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusterHead.html">ClusterHead</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html">Seed</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html" title="Seed information used in Giraffe.">Seed</a> information used in Giraffe.  <a href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SeedCache.html">SeedCache</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html" title="Seed information used in Giraffe.">Seed</a> information used for clustering.  <a href="structvg_1_1SnarlDistanceIndexClusterer_1_1SeedCache.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0333d80b03665df71c7d448b7cfb0b06"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#a0333d80b03665df71c7d448b7cfb0b06">SnarlDistanceIndexClusterer</a> (const SnarlDistanceIndex &amp;<a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#aa3ee07e1c0cbacde2d5d524d65a03204">distance_index</a>, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *<a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#a49cfcfdb9e2c378e973dd8a883e154df">graph</a>)</td></tr>
<tr class="separator:a0333d80b03665df71c7d448b7cfb0b06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66a56a78a0500f79258057cd3d688966"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#a66a56a78a0500f79258057cd3d688966">SnarlDistanceIndexClusterer</a> (const SnarlDistanceIndex *<a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#aa3ee07e1c0cbacde2d5d524d65a03204">distance_index</a>, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *<a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#a49cfcfdb9e2c378e973dd8a883e154df">graph</a>)</td></tr>
<tr class="separator:a66a56a78a0500f79258057cd3d688966"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2275f78a71459c60e56929b106d4ed46"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#a2275f78a71459c60e56929b106d4ed46">SnarlDistanceIndexClusterer</a> (const SnarlDistanceIndex &amp;<a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#aa3ee07e1c0cbacde2d5d524d65a03204">distance_index</a>)</td></tr>
<tr class="separator:a2275f78a71459c60e56929b106d4ed46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d9080f0e9ddf775de34ae3aaab7019"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#ae2d9080f0e9ddf775de34ae3aaab7019">SnarlDistanceIndexClusterer</a> (const SnarlDistanceIndex *<a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#aa3ee07e1c0cbacde2d5d524d65a03204">distance_index</a>)</td></tr>
<tr class="separator:ae2d9080f0e9ddf775de34ae3aaab7019"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a210ee5c625ead0e415f2276d1d20bb05"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Cluster.html">Cluster</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#a210ee5c625ead0e415f2276d1d20bb05">cluster_seeds</a> (const vector&lt; <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html">Seed</a> &gt; &amp;seeds, size_t read_distance_limit) const</td></tr>
<tr class="separator:a210ee5c625ead0e415f2276d1d20bb05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37e825d3d82904c3bda0598ac1093326"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Cluster.html">Cluster</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#a37e825d3d82904c3bda0598ac1093326">cluster_seeds</a> (const vector&lt; vector&lt; <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html">Seed</a> &gt;&gt; &amp;all_seeds, size_t read_distance_limit, size_t fragment_distance_limit=0) const</td></tr>
<tr class="separator:a37e825d3d82904c3bda0598ac1093326"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17649672360f10442f4476d31de7e02c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#a17649672360f10442f4476d31de7e02c">distance_between_seeds</a> (const <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html">Seed</a> &amp;seed1, const <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html">Seed</a> &amp;seed2, bool stop_at_lowest_common_ancestor) const</td></tr>
<tr class="separator:a17649672360f10442f4476d31de7e02c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a1c7c1aee0a7019289ca94234fe604075"><td class="memItemLeft" align="right" valign="top">tuple&lt; vector&lt; structures::UnionFind &gt;, structures::UnionFind &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#a1c7c1aee0a7019289ca94234fe604075">cluster_seeds_internal</a> (vector&lt; vector&lt; <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SeedCache.html">SeedCache</a> &gt; * &gt; &amp;all_seeds, size_t read_distance_limit, size_t fragment_distance_limit=0) const</td></tr>
<tr class="separator:a1c7c1aee0a7019289ca94234fe604075"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a932649a134317ad387ee70adc03d4474"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#a932649a134317ad387ee70adc03d4474">get_nodes</a> (<a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;clustering_problem, vector&lt; vector&lt; <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &gt;&gt; &amp;chains_by_level) const</td></tr>
<tr class="separator:a932649a134317ad387ee70adc03d4474"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac823b12963123338ac75a24f930dd93e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#ac823b12963123338ac75a24f930dd93e">cluster_snarl_level</a> (<a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;clustering_problem) const</td></tr>
<tr class="separator:ac823b12963123338ac75a24f930dd93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92faf3de4024dcb284ae3b0487f6b1f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#a92faf3de4024dcb284ae3b0487f6b1f2">cluster_chain_level</a> (<a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;clustering_problem, size_t depth) const</td></tr>
<tr class="separator:a92faf3de4024dcb284ae3b0487f6b1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3707a4eac66610e37faaf4f6ff9eff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#a1b3707a4eac66610e37faaf4f6ff9eff">cluster_one_node</a> (<a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;clustering_problem, <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *node_problem) const</td></tr>
<tr class="separator:a1b3707a4eac66610e37faaf4f6ff9eff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f1a2986c932dfe614d11707cef49bd8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#a0f1a2986c932dfe614d11707cef49bd8">cluster_one_snarl</a> (<a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;clustering_problem, <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *snarl_problem) const</td></tr>
<tr class="separator:a0f1a2986c932dfe614d11707cef49bd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5f6b8a6201ce57b88b2d7bf772e1da6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#ad5f6b8a6201ce57b88b2d7bf772e1da6">cluster_one_chain</a> (<a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;clustering_problem, <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *chain_problem, bool is_top_level_chain) const</td></tr>
<tr class="separator:ad5f6b8a6201ce57b88b2d7bf772e1da6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a95c48ea0d0de320803712285aaf6f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#a9a95c48ea0d0de320803712285aaf6f0">add_seed_to_chain_problem</a> (<a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;clustering_problem, <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *chain_problem, <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem_1_1SnarlTreeChild.html">SnarlTreeNodeProblem::SnarlTreeChild</a> &amp;last_child, size_t &amp;last_prefix_sum, size_t &amp;last_length, size_t &amp;last_chain_component_end, vector&lt; <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusterHead.html">ClusterHead</a> &gt; &amp;cluster_heads_to_add_again, bool &amp;found_first_node, pair&lt; bool, bool &gt; &amp;found_first_node_by_read, const <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem_1_1SnarlTreeChild.html">SnarlTreeNodeProblem::SnarlTreeChild</a> &amp;current_child, bool is_first_child, bool is_last_child, bool skip_distances_to_ends) const</td></tr>
<tr class="separator:a9a95c48ea0d0de320803712285aaf6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac22dd38425e040559e64b1e11ad1d704"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#ac22dd38425e040559e64b1e11ad1d704">add_snarl_to_chain_problem</a> (<a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;clustering_problem, <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *chain_problem, <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem_1_1SnarlTreeChild.html">SnarlTreeNodeProblem::SnarlTreeChild</a> &amp;last_child, size_t &amp;last_prefix_sum, size_t &amp;last_length, size_t &amp;last_chain_component_end, vector&lt; <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusterHead.html">ClusterHead</a> &gt; &amp;cluster_heads_to_add_again, bool &amp;found_first_node, pair&lt; bool, bool &gt; &amp;found_first_node_by_read, const <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem_1_1SnarlTreeChild.html">SnarlTreeNodeProblem::SnarlTreeChild</a> &amp;current_child, bool is_first_child, bool is_last_child, bool skip_distances_to_ends) const</td></tr>
<tr class="separator:ac22dd38425e040559e64b1e11ad1d704"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afed897fb0affc471c0800137a5ff9872"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#afed897fb0affc471c0800137a5ff9872">cluster_root</a> (<a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;clustering_problem) const</td></tr>
<tr class="separator:afed897fb0affc471c0800137a5ff9872"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31a2fd3cf7ce67590b86c45bb4f2b91e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#a31a2fd3cf7ce67590b86c45bb4f2b91e">cluster_seeds_on_linear_structure</a> (<a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;clustering_problem, <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *problem, size_t structure_length, bool include_prefix_sum, bool skip_distances_to_ends) const</td></tr>
<tr class="separator:a31a2fd3cf7ce67590b86c45bb4f2b91e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d03992071ee1f20ad833992e145b305"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#a0d03992071ee1f20ad833992e145b305">compare_and_combine_cluster_on_child_structures</a> (<a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;clustering_problem, <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *child_problem1, <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *child_problem2, <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *parent_problem, const vector&lt; pair&lt; size_t, size_t &gt;&gt; &amp;child_distances, bool is_root, bool first_child) const</td></tr>
<tr class="separator:a0d03992071ee1f20ad833992e145b305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98757d1cd5e82dd67e9056890cc1077d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#a98757d1cd5e82dd67e9056890cc1077d">compare_and_combine_cluster_on_one_child</a> (<a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;clustering_problem, <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *child_problem) const</td></tr>
<tr class="separator:a98757d1cd5e82dd67e9056890cc1077d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa3ee07e1c0cbacde2d5d524d65a03204"><td class="memItemLeft" align="right" valign="top">const SnarlDistanceIndex &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#aa3ee07e1c0cbacde2d5d524d65a03204">distance_index</a></td></tr>
<tr class="separator:aa3ee07e1c0cbacde2d5d524d65a03204"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49cfcfdb9e2c378e973dd8a883e154df"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html#a49cfcfdb9e2c378e973dd8a883e154df">graph</a></td></tr>
<tr class="separator:a49cfcfdb9e2c378e973dd8a883e154df"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html">SnarlDistanceIndexClusterer</a> is used for clustering seeds (positions on the graph) A "cluster" is a partition of seeds that is based on the minimum distance between them in the graph Consider a graph where each seed is a node and two seeds are connected if the minimum distance between them is smaller than a given distance limit. Each connected component of this graph is a cluster</p>
<p>The clustering algorithm is based on the snarl tree Clusters are formed on nodes of the snarl tree, which represent nodes/snarls/chains Each node/snarl/chain represents a subgraph of the variation graph A clustered snarl tree node contains all seeds that occur on its subgraph, and the seeds have been partitioned into clusters Each cluster knows the shortest distance from any seed it contains to both ends of the snarl tree node containing it Clustering is done progressively by walking up the snarl tree and forming clusters on each snarl tree node (only visiting nodes that have seeds on them) At each snarl tree node, assume that its children have already been clustered. The clusters of the children are compared to each other, and any pair that are close enough are combined to produce clusters on the parent The distances from each cluster to the ends of the parent are updated</p>
<p>The algorithm starts by assigning each seed to its node on the snarl tree Since nodes are all on chains, this fills in all the children of chains that are nodes It then walks up the snarl tree, level by level, and clusters each snarl tree node that contains seeds At a given level, first cluster each chain in the level. After clustering a chain, assign it to its parent snarl. Then, go through each of the snarls that have just been given children, and cluster the snarls. Each snarl then gets assigned to its parent chain This completes one level of the snarl tree. Each chain in the next level has just been populated by the snarls from this level, and already knew about its nodes from the first step, so it is ready to be clustered</p>
<p>Every time the clusterer is run, a <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> is made to store information about the state of the clusterer The <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> keeps track of which level of the snarl tree is currently being clustered, and keeps track of the children of the current and next level of the snarl tree. Each snarl tree node that contains seeds is represented by a <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a>. The <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> represents the problem of clustering one snarl tree node. It knows the identities of its children and keeps track of its cluster heads </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0333d80b03665df71c7d448b7cfb0b06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0333d80b03665df71c7d448b7cfb0b06">&#9670;&nbsp;</a></span>SnarlDistanceIndexClusterer() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::SnarlDistanceIndexClusterer::SnarlDistanceIndexClusterer </td>
          <td>(</td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66a56a78a0500f79258057cd3d688966"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66a56a78a0500f79258057cd3d688966">&#9670;&nbsp;</a></span>SnarlDistanceIndexClusterer() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::SnarlDistanceIndexClusterer::SnarlDistanceIndexClusterer </td>
          <td>(</td>
          <td class="paramtype">const SnarlDistanceIndex *&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2275f78a71459c60e56929b106d4ed46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2275f78a71459c60e56929b106d4ed46">&#9670;&nbsp;</a></span>SnarlDistanceIndexClusterer() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::SnarlDistanceIndexClusterer::SnarlDistanceIndexClusterer </td>
          <td>(</td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2d9080f0e9ddf775de34ae3aaab7019"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d9080f0e9ddf775de34ae3aaab7019">&#9670;&nbsp;</a></span>SnarlDistanceIndexClusterer() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::SnarlDistanceIndexClusterer::SnarlDistanceIndexClusterer </td>
          <td>(</td>
          <td class="paramtype">const SnarlDistanceIndex *&#160;</td>
          <td class="paramname"><em>distance_index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a9a95c48ea0d0de320803712285aaf6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a95c48ea0d0de320803712285aaf6f0">&#9670;&nbsp;</a></span>add_seed_to_chain_problem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlDistanceIndexClusterer::add_seed_to_chain_problem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>clustering_problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *&#160;</td>
          <td class="paramname"><em>chain_problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem_1_1SnarlTreeChild.html">SnarlTreeNodeProblem::SnarlTreeChild</a> &amp;&#160;</td>
          <td class="paramname"><em>last_child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>last_prefix_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>last_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>last_chain_component_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusterHead.html">ClusterHead</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_heads_to_add_again</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>found_first_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pair&lt; bool, bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>found_first_node_by_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem_1_1SnarlTreeChild.html">SnarlTreeNodeProblem::SnarlTreeChild</a> &amp;&#160;</td>
          <td class="paramname"><em>current_child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_first_child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_last_child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_distances_to_ends</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Go through the clusters on the chain up to this point and see if anything can be combined with the clusters on the child Also update the distances of the chain clusters to reach the end of this node</p>

</div>
</div>
<a id="ac22dd38425e040559e64b1e11ad1d704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac22dd38425e040559e64b1e11ad1d704">&#9670;&nbsp;</a></span>add_snarl_to_chain_problem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlDistanceIndexClusterer::add_snarl_to_chain_problem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>clustering_problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *&#160;</td>
          <td class="paramname"><em>chain_problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem_1_1SnarlTreeChild.html">SnarlTreeNodeProblem::SnarlTreeChild</a> &amp;&#160;</td>
          <td class="paramname"><em>last_child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>last_prefix_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>last_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>last_chain_component_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusterHead.html">ClusterHead</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster_heads_to_add_again</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>found_first_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pair&lt; bool, bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>found_first_node_by_read</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem_1_1SnarlTreeChild.html">SnarlTreeNodeProblem::SnarlTreeChild</a> &amp;&#160;</td>
          <td class="paramname"><em>current_child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_first_child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_last_child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_distances_to_ends</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>First, go through the clusters of the current child and see what can be combined</p>
<p>Next, go through the clusters on the chain up to this point and see if anything can be combined with the clusters on the child</p>

</div>
</div>
<a id="a92faf3de4024dcb284ae3b0487f6b1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92faf3de4024dcb284ae3b0487f6b1f2">&#9670;&nbsp;</a></span>cluster_chain_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlDistanceIndexClusterer::cluster_chain_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>clustering_problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5f6b8a6201ce57b88b2d7bf772e1da6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5f6b8a6201ce57b88b2d7bf772e1da6">&#9670;&nbsp;</a></span>cluster_one_chain()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlDistanceIndexClusterer::cluster_one_chain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>clustering_problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *&#160;</td>
          <td class="paramname"><em>chain_problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_top_level_chain</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b3707a4eac66610e37faaf4f6ff9eff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3707a4eac66610e37faaf4f6ff9eff">&#9670;&nbsp;</a></span>cluster_one_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlDistanceIndexClusterer::cluster_one_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>clustering_problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *&#160;</td>
          <td class="paramname"><em>node_problem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0f1a2986c932dfe614d11707cef49bd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f1a2986c932dfe614d11707cef49bd8">&#9670;&nbsp;</a></span>cluster_one_snarl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlDistanceIndexClusterer::cluster_one_snarl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>clustering_problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *&#160;</td>
          <td class="paramname"><em>snarl_problem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afed897fb0affc471c0800137a5ff9872"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afed897fb0affc471c0800137a5ff9872">&#9670;&nbsp;</a></span>cluster_root()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlDistanceIndexClusterer::cluster_root </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>clustering_problem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a210ee5c625ead0e415f2276d1d20bb05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a210ee5c625ead0e415f2276d1d20bb05">&#9670;&nbsp;</a></span>cluster_seeds() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Cluster.html">SnarlDistanceIndexClusterer::Cluster</a> &gt; vg::SnarlDistanceIndexClusterer::cluster_seeds </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html">Seed</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>read_distance_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a37e825d3d82904c3bda0598ac1093326"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37e825d3d82904c3bda0598ac1093326">&#9670;&nbsp;</a></span>cluster_seeds() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Cluster.html">SnarlDistanceIndexClusterer::Cluster</a> &gt; &gt; vg::SnarlDistanceIndexClusterer::cluster_seeds </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html">Seed</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>read_distance_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fragment_distance_limit</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c7c1aee0a7019289ca94234fe604075"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c7c1aee0a7019289ca94234fe604075">&#9670;&nbsp;</a></span>cluster_seeds_internal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">tuple&lt; vector&lt; structures::UnionFind &gt;, structures::UnionFind &gt; vg::SnarlDistanceIndexClusterer::cluster_seeds_internal </td>
          <td>(</td>
          <td class="paramtype">vector&lt; vector&lt; <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SeedCache.html">SeedCache</a> &gt; * &gt; &amp;&#160;</td>
          <td class="paramname"><em>all_seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>read_distance_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>fragment_distance_limit</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a31a2fd3cf7ce67590b86c45bb4f2b91e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31a2fd3cf7ce67590b86c45bb4f2b91e">&#9670;&nbsp;</a></span>cluster_seeds_on_linear_structure()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlDistanceIndexClusterer::cluster_seeds_on_linear_structure </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>clustering_problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *&#160;</td>
          <td class="paramname"><em>problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>structure_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_prefix_sum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skip_distances_to_ends</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac823b12963123338ac75a24f930dd93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac823b12963123338ac75a24f930dd93e">&#9670;&nbsp;</a></span>cluster_snarl_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlDistanceIndexClusterer::cluster_snarl_level </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>clustering_problem</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d03992071ee1f20ad833992e145b305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d03992071ee1f20ad833992e145b305">&#9670;&nbsp;</a></span>compare_and_combine_cluster_on_child_structures()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlDistanceIndexClusterer::compare_and_combine_cluster_on_child_structures </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>clustering_problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *&#160;</td>
          <td class="paramname"><em>child_problem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *&#160;</td>
          <td class="paramname"><em>child_problem2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *&#160;</td>
          <td class="paramname"><em>parent_problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; size_t, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>child_distances</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>first_child</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a98757d1cd5e82dd67e9056890cc1077d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98757d1cd5e82dd67e9056890cc1077d">&#9670;&nbsp;</a></span>compare_and_combine_cluster_on_one_child()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlDistanceIndexClusterer::compare_and_combine_cluster_on_one_child </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>clustering_problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1SnarlTreeNodeProblem.html">SnarlTreeNodeProblem</a> *&#160;</td>
          <td class="paramname"><em>child_problem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a17649672360f10442f4476d31de7e02c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17649672360f10442f4476d31de7e02c">&#9670;&nbsp;</a></span>distance_between_seeds()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::SnarlDistanceIndexClusterer::distance_between_seeds </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html">Seed</a> &amp;&#160;</td>
          <td class="paramname"><em>seed1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html">Seed</a> &amp;&#160;</td>
          <td class="paramname"><em>seed2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>stop_at_lowest_common_ancestor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the minimum distance between two seeds. This will use the minimizer payload when possible </p>

</div>
</div>
<a id="a932649a134317ad387ee70adc03d4474"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a932649a134317ad387ee70adc03d4474">&#9670;&nbsp;</a></span>get_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::SnarlDistanceIndexClusterer::get_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1ClusteringProblem.html">ClusteringProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>clustering_problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>chains_by_level</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="aa3ee07e1c0cbacde2d5d524d65a03204"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa3ee07e1c0cbacde2d5d524d65a03204">&#9670;&nbsp;</a></span>distance_index</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const SnarlDistanceIndex&amp; vg::SnarlDistanceIndexClusterer::distance_index</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a49cfcfdb9e2c378e973dd8a883e154df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49cfcfdb9e2c378e973dd8a883e154df">&#9670;&nbsp;</a></span>graph</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a>* vg::SnarlDistanceIndexClusterer::graph</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="snarl__seed__clusterer_8hpp.html">snarl_seed_clusterer.hpp</a></li>
<li>src/<a class="el" href="snarl__seed__clusterer_8cpp.html">snarl_seed_clusterer.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
