<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::algorithms Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="namespacevg_1_1algorithms.html">algorithms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">vg::algorithms Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1algorithms_1_1Edge.html">Edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1algorithms_1_1GFADuplicatePathError.html">GFADuplicatePathError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1algorithms_1_1GFAFormatError.html">GFAFormatError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception will be thrown if the GFA data is not acceptable.  <a href="structvg_1_1algorithms_1_1GFAFormatError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1algorithms_1_1GFAIDMapInfo.html">GFAIDMapInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1algorithms_1_1GFAParser.html">GFAParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1algorithms_1_1kmer__t.html">kmer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a kmer in the context of a graph.  <a href="structvg_1_1algorithms_1_1kmer__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1algorithms_1_1Node.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1algorithms_1_1walk__t.html">walk_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record a &lt;=k-length walk in the context of a graph.  <a href="structvg_1_1algorithms_1_1walk__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:acf8cb40a8f834b42f1ec89af0ef140b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#acf8cb40a8f834b42f1ec89af0ef140b9">BinnedDepthIndex</a> = unordered_map&lt; string, map&lt; size_t, map&lt; size_t, pair&lt; float, float &gt; &gt;&gt; &gt;</td></tr>
<tr class="separator:acf8cb40a8f834b42f1ec89af0ef140b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6474017f8ab54b0c6e20095206a880a8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a> = unordered_map&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, vector&lt; pair&lt; size_t, bool &gt; &gt;&gt;</td></tr>
<tr class="separator:a6474017f8ab54b0c6e20095206a880a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5af5b6f1083925669832ae59d0e549e7"><td class="memTemplParams" colspan="2">template&lt;class DistHeuristic &gt; </td></tr>
<tr class="memitem:a5af5b6f1083925669832ae59d0e549e7"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a5af5b6f1083925669832ae59d0e549e7">a_star</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;pos_1, const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;pos_2, const DistHeuristic &amp;dist_heuristic, bool find_min=true, int64_t extremal_distance=numeric_limits&lt; int64_t &gt;::max(), bool monotonic_heuristic=true)</td></tr>
<tr class="separator:a5af5b6f1083925669832ae59d0e549e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9941053149e9b62a3987e6910aab8f6"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ad9941053149e9b62a3987e6910aab8f6">alignment_path_offsets</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;graph, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, bool just_min, bool nearby, size_t search_limit, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *path_filter)</td></tr>
<tr class="separator:ad9941053149e9b62a3987e6910aab8f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cecedaa8dd475e634b513af5be028b"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ad0cecedaa8dd475e634b513af5be028b">multipath_alignment_path_offsets</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;graph, const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;mp_aln, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *path_filter)</td></tr>
<tr class="separator:ad0cecedaa8dd475e634b513af5be028b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47438272f0eac991e9d3edce30cf9123"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a47438272f0eac991e9d3edce30cf9123">annotate_with_initial_path_positions</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;graph, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, size_t search_limit, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *path_filter)</td></tr>
<tr class="separator:a47438272f0eac991e9d3edce30cf9123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae92f9ba72b27512a1a744e60fc164844"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ae92f9ba72b27512a1a744e60fc164844">annotate_with_node_path_positions</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;graph, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, size_t search_limit, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *path_filter)</td></tr>
<tr class="separator:ae92f9ba72b27512a1a744e60fc164844"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a001d349e7ad0fa290437ca9846decced"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a001d349e7ad0fa290437ca9846decced">annotate_with_path_positions</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;graph, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, bool just_min, size_t search_limit, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *path_filter)</td></tr>
<tr class="separator:a001d349e7ad0fa290437ca9846decced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cf2e0df2e99d24d22fbfac537120cc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a8cf2e0df2e99d24d22fbfac537120cc8">annotate_with_initial_path_positions</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;graph, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alns, size_t search_limit, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *path_filter)</td></tr>
<tr class="separator:a8cf2e0df2e99d24d22fbfac537120cc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18b50d29d9accb763b44d6e065dac58"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ae18b50d29d9accb763b44d6e065dac58">min_approx_path_distance</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph, const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;pos1, const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;pos2, uint64_t max_search)</td></tr>
<tr class="memdesc:ae18b50d29d9accb763b44d6e065dac58"><td class="mdescLeft">&#160;</td><td class="mdescRight">use the embedded paths to get an estimated minimum distance between the positions  <a href="namespacevg_1_1algorithms.html#ae18b50d29d9accb763b44d6e065dac58">More...</a><br /></td></tr>
<tr class="separator:ae18b50d29d9accb763b44d6e065dac58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0e29a34fb2e1f712751a8a8fda6f03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a0d0e29a34fb2e1f712751a8a8fda6f03">back_translate_in_place</a> (const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> *translation, <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:a0d0e29a34fb2e1f712751a8a8fda6f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb0b1f6ca5892b532032ecddd8fde19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a0fb0b1f6ca5892b532032ecddd8fde19">back_translate_in_place</a> (const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> *translation, <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;snarl)</td></tr>
<tr class="separator:a0fb0b1f6ca5892b532032ecddd8fde19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efe72c9db6dd4c1828dae311795e9b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a0efe72c9db6dd4c1828dae311795e9b0">back_translate_in_place</a> (const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> *translation, <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;traversal)</td></tr>
<tr class="separator:a0efe72c9db6dd4c1828dae311795e9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e04f69397f1d7e1f33b99f0ff145af5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a0e04f69397f1d7e1f33b99f0ff145af5">back_translate_in_place</a> (const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> *translation, <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit)</td></tr>
<tr class="separator:a0e04f69397f1d7e1f33b99f0ff145af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbc78daa41b0c018cd39b7cccbaf53a"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aafbc78daa41b0c018cd39b7cccbaf53a">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;anchor)</td></tr>
<tr class="memdesc:aafbc78daa41b0c018cd39b7cccbaf53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explain an <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> to the given stream.  <a href="namespacevg_1_1algorithms.html#aafbc78daa41b0c018cd39b7cccbaf53a">More...</a><br /></td></tr>
<tr class="separator:aafbc78daa41b0c018cd39b7cccbaf53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503ad2215490c5c599530d7331a70120"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a503ad2215490c5c599530d7331a70120">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a> &amp;value)</td></tr>
<tr class="memdesc:a503ad2215490c5c599530d7331a70120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print operator.  <a href="namespacevg_1_1algorithms.html#a503ad2215490c5c599530d7331a70120">More...</a><br /></td></tr>
<tr class="separator:a503ad2215490c5c599530d7331a70120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7e7cecbe08dfe8b3316a90204c2ab43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ac7e7cecbe08dfe8b3316a90204c2ab43">sort_and_shadow</a> (const std::vector&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;items, std::vector&lt; size_t &gt; &amp;indexes)</td></tr>
<tr class="separator:ac7e7cecbe08dfe8b3316a90204c2ab43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0c2a9008815cae2b118a30b7c2fc75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#afb0c2a9008815cae2b118a30b7c2fc75">sort_and_shadow</a> (std::vector&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;items)</td></tr>
<tr class="separator:afb0c2a9008815cae2b118a30b7c2fc75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05bafa99c51765b72bf17b91538fcff5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a05bafa99c51765b72bf17b91538fcff5">chain_items_dp</a> (vector&lt; <a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a> &gt; &amp;best_chain_score, const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;to_chain, const SnarlDistanceIndex &amp;distance_index, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, int gap_open, int gap_extension, size_t max_lookback_bases, size_t min_lookback_items, size_t lookback_item_hard_cap, size_t initial_lookback_threshold, double lookback_scale_factor, double min_good_transition_score_per_base, int item_bonus, size_t max_indel_bases)</td></tr>
<tr class="separator:a05bafa99c51765b72bf17b91538fcff5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0147b2932e3f053cc2f2b0912390978"><td class="memItemLeft" align="right" valign="top">vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ab0147b2932e3f053cc2f2b0912390978">chain_items_traceback</a> (const vector&lt; <a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a> &gt; &amp;best_chain_score, const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;to_chain, const <a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a> &amp;best_past_ending_score_ever)</td></tr>
<tr class="separator:ab0147b2932e3f053cc2f2b0912390978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d0662e21c846f8d7e836a67439c208f"><td class="memItemLeft" align="right" valign="top">pair&lt; int, vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a5d0662e21c846f8d7e836a67439c208f">find_best_chain</a> (const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;to_chain, const SnarlDistanceIndex &amp;distance_index, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, int gap_open, int gap_extension, size_t max_lookback_bases, size_t min_lookback_items, size_t lookback_item_hard_cap, size_t initial_lookback_threshold, double lookback_scale_factor, double min_good_transition_score_per_base, int item_bonus, size_t max_indel_bases)</td></tr>
<tr class="separator:a5d0662e21c846f8d7e836a67439c208f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91b7ceb67d3923a4c5cace56a5c4f6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ad91b7ceb67d3923a4c5cace56a5c4f6e">score_best_chain</a> (const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;to_chain, const SnarlDistanceIndex &amp;distance_index, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, int gap_open, int gap_extension)</td></tr>
<tr class="separator:ad91b7ceb67d3923a4c5cace56a5c4f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbd2aaa2256eb33182306586f40187c6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#afbd2aaa2256eb33182306586f40187c6">get_graph_distance</a> (const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;from, const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;to, const SnarlDistanceIndex &amp;distance_index, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:afbd2aaa2256eb33182306586f40187c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get distance in the graph, or <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">std::numeric_limits&lt;size_t&gt;::max()</a> if unreachable.  <a href="namespacevg_1_1algorithms.html#afbd2aaa2256eb33182306586f40187c6">More...</a><br /></td></tr>
<tr class="separator:afbd2aaa2256eb33182306586f40187c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8762b533e64039ce1a917b047097d8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a5d8762b533e64039ce1a917b047097d8">get_read_distance</a> (const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;from, const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;to)</td></tr>
<tr class="memdesc:a5d8762b533e64039ce1a917b047097d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get distance in the read, or <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">std::numeric_limits&lt;size_t&gt;::max()</a> if unreachable.  <a href="namespacevg_1_1algorithms.html#a5d8762b533e64039ce1a917b047097d8">More...</a><br /></td></tr>
<tr class="separator:a5d8762b533e64039ce1a917b047097d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6341683f1b89495d2ac1558ed2875343"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a6341683f1b89495d2ac1558ed2875343">traverse_components</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, function&lt; void(void)&gt; &amp;on_new_comp, function&lt; void(<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>)&gt; &amp;on_node)</td></tr>
<tr class="separator:a6341683f1b89495d2ac1558ed2875343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84bd9740e748431857b5fd8a0397183"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aa84bd9740e748431857b5fd8a0397183">num_components</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph)</td></tr>
<tr class="separator:aa84bd9740e748431857b5fd8a0397183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5fdb03a21f88395e1d69f53821ae59"><td class="memItemLeft" align="right" valign="top">vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a8e5fdb03a21f88395e1d69f53821ae59">component_sizes</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph)</td></tr>
<tr class="separator:a8e5fdb03a21f88395e1d69f53821ae59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f810108840ab4014eb58b2bfe19ac1"><td class="memItemLeft" align="right" valign="top">vector&lt; unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a51f810108840ab4014eb58b2bfe19ac1">component_paths</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;graph)</td></tr>
<tr class="separator:a51f810108840ab4014eb58b2bfe19ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd891e00c4846e53f760d504434ead12"><td class="memTemplParams" colspan="2">template&lt;typename Int1 , typename Int2 &gt; </td></tr>
<tr class="memitem:acd891e00c4846e53f760d504434ead12"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#acd891e00c4846e53f760d504434ead12">reallocate_atomic_int_vector</a> (vector&lt; atomic&lt; Int1 &gt;&gt; *&amp;vec1, vector&lt; atomic&lt; Int2 &gt;&gt; *&amp;vec2)</td></tr>
<tr class="separator:acd891e00c4846e53f760d504434ead12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b07f6f41f8dd36c5d3b1ff9a03ce93"><td class="memItemLeft" align="right" valign="top">vector&lt; unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a10b07f6f41f8dd36c5d3b1ff9a03ce93">component_paths_parallel</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;graph)</td></tr>
<tr class="separator:a10b07f6f41f8dd36c5d3b1ff9a03ce93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b477c1e232c9d4f1e689a95dd55861d"><td class="memTemplParams" colspan="2">template&lt;typename Collection &gt; </td></tr>
<tr class="memitem:a2b477c1e232c9d4f1e689a95dd55861d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a2b477c1e232c9d4f1e689a95dd55861d">count_covered</a> (Collection &amp;segments)</td></tr>
<tr class="separator:a2b477c1e232c9d4f1e689a95dd55861d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd431ebd9786d796f708a7046e643e2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#abd431ebd9786d796f708a7046e643e2e">packed_depths</a> (const <a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;packer, const string &amp;path_name, size_t min_coverage, ostream &amp;out_stream)</td></tr>
<tr class="separator:abd431ebd9786d796f708a7046e643e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ebbcbfe1250940eb8ebf0a2dcbc19a"><td class="memItemLeft" align="right" valign="top">pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a62ebbcbfe1250940eb8ebf0a2dcbc19a">packed_depth_of_bin</a> (const <a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;packer, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> start_step, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> end_plus_one_step, size_t min_coverage, bool include_deletions)</td></tr>
<tr class="separator:a62ebbcbfe1250940eb8ebf0a2dcbc19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb3df22b1d7955546bbcc8c438f6efc"><td class="memItemLeft" align="right" valign="top">vector&lt; tuple&lt; size_t, size_t, double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a8fb3df22b1d7955546bbcc8c438f6efc">binned_packed_depth</a> (const <a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;packer, const string &amp;path_name, size_t bin_size, size_t min_coverage, bool include_deletions)</td></tr>
<tr class="separator:a8fb3df22b1d7955546bbcc8c438f6efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05e00ad1e6a7b34cde8c37aa9dbbdbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg_1_1algorithms.html#acf8cb40a8f834b42f1ec89af0ef140b9">BinnedDepthIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#af05e00ad1e6a7b34cde8c37aa9dbbdbc">binned_packed_depth_index</a> (const <a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;packer, const vector&lt; string &gt; &amp;path_names, size_t min_bin_size, size_t max_bin_size, double exp_growth_factor, size_t min_coverage, bool include_deletions, bool std_err)</td></tr>
<tr class="separator:af05e00ad1e6a7b34cde8c37aa9dbbdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4152fa019243d9fd4c41c73fafce2241"><td class="memItemLeft" align="right" valign="top">pair&lt; float, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a4152fa019243d9fd4c41c73fafce2241">get_depth_from_index</a> (const <a class="el" href="namespacevg_1_1algorithms.html#acf8cb40a8f834b42f1ec89af0ef140b9">BinnedDepthIndex</a> &amp;depth_index, const string &amp;path_name, size_t start_offset, size_t end_offset)</td></tr>
<tr class="memdesc:a4152fa019243d9fd4c41c73fafce2241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query index created above.  <a href="namespacevg_1_1algorithms.html#a4152fa019243d9fd4c41c73fafce2241">More...</a><br /></td></tr>
<tr class="separator:a4152fa019243d9fd4c41c73fafce2241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bd0de261a829b2d81ec48eed9d6482"><td class="memItemLeft" align="right" valign="top">pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a16bd0de261a829b2d81ec48eed9d6482">sample_mapping_depth</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const string &amp;input_filename, size_t max_nodes, size_t random_seed, size_t min_coverage, size_t min_mapq, const string &amp;format)</td></tr>
<tr class="separator:a16bd0de261a829b2d81ec48eed9d6482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80703607cfe21f1f593f7b2f03c08b40"><td class="memItemLeft" align="right" valign="top">pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a80703607cfe21f1f593f7b2f03c08b40">sample_gam_depth</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alignments, size_t max_nodes, size_t random_seed, size_t min_coverage, size_t min_mapq)</td></tr>
<tr class="separator:a80703607cfe21f1f593f7b2f03c08b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85250c33b7d32346be371ab7e4404471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a85250c33b7d32346be371ab7e4404471">path_depths</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;graph, const string &amp;path_name, size_t min_coverage, bool count_cycles, ostream &amp;out_stream)</td></tr>
<tr class="separator:a85250c33b7d32346be371ab7e4404471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c66507d55ed6e10e9d77e1281d4bcfc"><td class="memItemLeft" align="right" valign="top">pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a8c66507d55ed6e10e9d77e1281d4bcfc">path_depth_of_bin</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;graph, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> start_step, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> end_plus_one_step, size_t min_coverage, bool count_cycles)</td></tr>
<tr class="memdesc:a8c66507d55ed6e10e9d77e1281d4bcfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">like packed_depth_of_bin (above), but use paths (as in path_depths) for measuring coverage  <a href="namespacevg_1_1algorithms.html#a8c66507d55ed6e10e9d77e1281d4bcfc">More...</a><br /></td></tr>
<tr class="separator:a8c66507d55ed6e10e9d77e1281d4bcfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d48562b230a318ee15820aa508867fc"><td class="memItemLeft" align="right" valign="top">vector&lt; tuple&lt; size_t, size_t, double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a1d48562b230a318ee15820aa508867fc">binned_path_depth</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;graph, const string &amp;path_name, size_t bin_size, size_t min_coverage, bool count_cycles)</td></tr>
<tr class="separator:a1d48562b230a318ee15820aa508867fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244822514c71473756cfd5ad87f79e08"><td class="memItemLeft" align="right" valign="top">pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a244822514c71473756cfd5ad87f79e08">sample_mapping_depth</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alignments, size_t max_nodes, size_t random_seed, size_t min_coverage, size_t min_mapq)</td></tr>
<tr class="memdesc:a244822514c71473756cfd5ad87f79e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above, but read a vector instead of a stream.  <a href="namespacevg_1_1algorithms.html#a244822514c71473756cfd5ad87f79e08">More...</a><br /></td></tr>
<tr class="separator:a244822514c71473756cfd5ad87f79e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2ca7e29cbf4769c5f6432499a45e23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a2a2ca7e29cbf4769c5f6432499a45e23">dfs</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;handle_begin_fn, const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;handle_end_fn, const function&lt; bool(void)&gt; &amp;break_fn, const function&lt; void(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; &amp;edge_fn, const function&lt; void(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; &amp;tree_fn, const function&lt; void(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; &amp;edge_curr_fn, const function&lt; void(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; &amp;edge_cross_fn, const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;sources, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;sinks)</td></tr>
<tr class="separator:a2a2ca7e29cbf4769c5f6432499a45e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade95900b3f3715ae3ecf9b3aee79961f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ade95900b3f3715ae3ecf9b3aee79961f">dfs</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;handle_begin_fn, const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;handle_end_fn, const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;sources, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;sinks)</td></tr>
<tr class="separator:ade95900b3f3715ae3ecf9b3aee79961f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89d8d2356483ef348082609dc310b80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ac89d8d2356483ef348082609dc310b80">dfs</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;handle_begin_fn, const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;handle_end_fn, const function&lt; bool(void)&gt; &amp;break_fn)</td></tr>
<tr class="separator:ac89d8d2356483ef348082609dc310b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ba5a6719f9f5496130c72a047ad890"><td class="memItemLeft" align="right" valign="top">list&lt; bdsg::HashGraph &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a38ba5a6719f9f5496130c72a047ad890">disjoint_components</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph)</td></tr>
<tr class="separator:a38ba5a6719f9f5496130c72a047ad890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cb6665721af1f7c749ca8f73472d6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aa4cb6665721af1f7c749ca8f73472d6c">is_head_node</a> (<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> h, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *g)</td></tr>
<tr class="separator:aa4cb6665721af1f7c749ca8f73472d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187fd628ac942c540a1a5fde0e27b0ef"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a187fd628ac942c540a1a5fde0e27b0ef">distance_to_head</a> (<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> h, int32_t limit, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="separator:a187fd628ac942c540a1a5fde0e27b0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33aca5bac60aa4d0a4c402ed607b06a3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a33aca5bac60aa4d0a4c402ed607b06a3">distance_to_head</a> (<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> h, int32_t limit, int32_t dist, unordered_set&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;seen, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="separator:a33aca5bac60aa4d0a4c402ed607b06a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e4eb795d14d441c4b2944c070a1d78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ac8e4eb795d14d441c4b2944c070a1d78">is_tail_node</a> (<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> h, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *g)</td></tr>
<tr class="separator:ac8e4eb795d14d441c4b2944c070a1d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458c768a87a1182eae38b362aa7b5ad7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a458c768a87a1182eae38b362aa7b5ad7">distance_to_tail</a> (<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> h, int32_t limit, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="separator:a458c768a87a1182eae38b362aa7b5ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fb0ce9a4ccbb1505e661a1caa266f8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ac8fb0ce9a4ccbb1505e661a1caa266f8">distance_to_tail</a> (<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> h, int32_t limit, int32_t dist, unordered_set&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;seen, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="separator:ac8fb0ce9a4ccbb1505e661a1caa266f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354ea4a2a6aed208945fc0994ec50d9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a354ea4a2a6aed208945fc0994ec50d9d">expand_context_by_steps</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *subgraph, int64_t dist, bool expand_forward, bool expand_backward)</td></tr>
<tr class="separator:a354ea4a2a6aed208945fc0994ec50d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238775e0e0ecf0b7576f7c2265dfd5e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a238775e0e0ecf0b7576f7c2265dfd5e0">expand_context_by_length</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *subgraph, int64_t dist, bool expand_forward, bool expand_backward)</td></tr>
<tr class="separator:a238775e0e0ecf0b7576f7c2265dfd5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7fcd701af4fdcbb87e83f0ea5b420a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aec7fcd701af4fdcbb87e83f0ea5b420a">expand_context</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *subgraph, int64_t dist, bool use_steps, bool expand_forward, bool expand_backward)</td></tr>
<tr class="separator:aec7fcd701af4fdcbb87e83f0ea5b420a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0c0c6d333cb438f96e5df6faec3621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a8a0c0c6d333cb438f96e5df6faec3621">expand_context_with_paths</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> *source, <a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *subgraph, int64_t dist, bool use_steps, bool expand_forward, bool expand_backward)</td></tr>
<tr class="separator:a8a0c0c6d333cb438f96e5df6faec3621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d0446bde00e10bd77816c968ae97b0"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ac0d0446bde00e10bd77816c968ae97b0">extract_connecting_graph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *source, <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> *into, int64_t max_len, <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> pos_1, <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> pos_2, bool strict_max_len)</td></tr>
<tr class="separator:ac0d0446bde00e10bd77816c968ae97b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4270da794ad0185dacef1874a1e4d3c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a4270da794ad0185dacef1874a1e4d3c2">extract_containing_graph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *into, const vector&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &gt; &amp;positions, const vector&lt; size_t &gt; &amp;forward_search_lengths, const vector&lt; size_t &gt; &amp;backward_search_lengths, size_t reversing_walk_length)</td></tr>
<tr class="separator:a4270da794ad0185dacef1874a1e4d3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecd79b7d4b622b583a8e08df594e45c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a0ecd79b7d4b622b583a8e08df594e45c">extract_containing_graph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *into, const vector&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &gt; &amp;positions, size_t max_dist, size_t reversing_walk_length)</td></tr>
<tr class="separator:a0ecd79b7d4b622b583a8e08df594e45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31b1b707c93f96d6f013e579c4d8783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ab31b1b707c93f96d6f013e579c4d8783">extract_containing_graph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *into, const vector&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &gt; &amp;positions, const vector&lt; size_t &gt; &amp;position_max_dist, size_t reversing_walk_length)</td></tr>
<tr class="separator:ab31b1b707c93f96d6f013e579c4d8783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f600eb589d48607c2616bed69ff2e27"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a1f600eb589d48607c2616bed69ff2e27">extract_extending_graph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *source, <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> *into, int64_t max_dist, <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> pos, bool backward, bool preserve_cycles_on_src_node)</td></tr>
<tr class="separator:a1f600eb589d48607c2616bed69ff2e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92780d34d13ab2a6be9fe477543179ce"><td class="memItemLeft" align="right" valign="top">const gbwt::GBWT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a92780d34d13ab2a6be9fe477543179ce">find_gbwt</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="separator:a92780d34d13ab2a6be9fe477543179ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5783b30c1ad6ea3ff4bc4576f447b615"><td class="memItemLeft" align="right" valign="top">const gbwt::GBWT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a5783b30c1ad6ea3ff4bc4576f447b615">find_gbwt</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, std::unique_ptr&lt; gbwt::GBWT &gt; &amp;holder, const std::string &amp;filename)</td></tr>
<tr class="separator:a5783b30c1ad6ea3ff4bc4576f447b615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8867ea22636dc22aa53bd8fe1d0aaa"><td class="memItemLeft" align="right" valign="top">const gbwtgraph::GBWTGraph *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a1e8867ea22636dc22aa53bd8fe1d0aaa">find_gbwtgraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="separator:a1e8867ea22636dc22aa53bd8fe1d0aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38c05b9c1e56c79faccfbbf6b3ade95"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#af38c05b9c1e56c79faccfbbf6b3ade95">find_translation</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="separator:af38c05b9c1e56c79faccfbbf6b3ade95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfca626dc003dc3fee77c6bbfcde297"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aedfca626dc003dc3fee77c6bbfcde297">gfa_to_handle_graph</a> (const string &amp;filename, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *graph, <a class="el" href="structvg_1_1algorithms_1_1GFAIDMapInfo.html">GFAIDMapInfo</a> *translation)</td></tr>
<tr class="separator:aedfca626dc003dc3fee77c6bbfcde297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca14b7dcba0bb21f3fdb0c98d867c72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#adca14b7dcba0bb21f3fdb0c98d867c72">gfa_to_handle_graph</a> (const string &amp;filename, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *graph, const string &amp;translation_filename)</td></tr>
<tr class="memdesc:adca14b7dcba0bb21f3fdb0c98d867c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload which serializes its translation to a file internally.  <a href="namespacevg_1_1algorithms.html#adca14b7dcba0bb21f3fdb0c98d867c72">More...</a><br /></td></tr>
<tr class="separator:adca14b7dcba0bb21f3fdb0c98d867c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031cb6d0db20a6aaee020c5a6909ba80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a031cb6d0db20a6aaee020c5a6909ba80">gfa_to_handle_graph</a> (istream &amp;in, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *graph, <a class="el" href="structvg_1_1algorithms_1_1GFAIDMapInfo.html">GFAIDMapInfo</a> *translation=nullptr)</td></tr>
<tr class="memdesc:a031cb6d0db20a6aaee020c5a6909ba80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a GFA from a stream (assumed not to be seekable or reopenable) into a HandleGraph.  <a href="namespacevg_1_1algorithms.html#a031cb6d0db20a6aaee020c5a6909ba80">More...</a><br /></td></tr>
<tr class="separator:a031cb6d0db20a6aaee020c5a6909ba80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5c41c06269c778d2c97f39cbc79de8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a9f5c41c06269c778d2c97f39cbc79de8">gfa_to_path_handle_graph</a> (const string &amp;filename, <a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *graph, <a class="el" href="structvg_1_1algorithms_1_1GFAIDMapInfo.html">GFAIDMapInfo</a> *translation=nullptr, int64_t max_rgfa_rank=numeric_limits&lt; int64_t &gt;::max(), unordered_set&lt; <a class="el" href="namespacehandlegraph.html#ab3d3683c53bb48b8af63a6d94497271c">PathSense</a> &gt; *ignore_sense=nullptr)</td></tr>
<tr class="memdesc:a9f5c41c06269c778d2c97f39cbc79de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as gfa_to_handle_graph but also adds path elements from the GFA to the graph.  <a href="namespacevg_1_1algorithms.html#a9f5c41c06269c778d2c97f39cbc79de8">More...</a><br /></td></tr>
<tr class="separator:a9f5c41c06269c778d2c97f39cbc79de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f2c7006c531ad5dd319ea30ec0087f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a61f2c7006c531ad5dd319ea30ec0087f">gfa_to_path_handle_graph</a> (const string &amp;filename, <a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *graph, int64_t max_rgfa_rank, const string &amp;translation_filename, unordered_set&lt; <a class="el" href="namespacehandlegraph.html#ab3d3683c53bb48b8af63a6d94497271c">PathSense</a> &gt; *ignore_sense=nullptr)</td></tr>
<tr class="memdesc:a61f2c7006c531ad5dd319ea30ec0087f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload which serializes its translation to a file internally.  <a href="namespacevg_1_1algorithms.html#a61f2c7006c531ad5dd319ea30ec0087f">More...</a><br /></td></tr>
<tr class="separator:a61f2c7006c531ad5dd319ea30ec0087f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8baa82611439357dc02996ba17ce6aa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a8baa82611439357dc02996ba17ce6aa9">gfa_to_path_handle_graph</a> (istream &amp;in, <a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *graph, <a class="el" href="structvg_1_1algorithms_1_1GFAIDMapInfo.html">GFAIDMapInfo</a> *translation=nullptr, int64_t max_rgfa_rank=numeric_limits&lt; int64_t &gt;::max(), unordered_set&lt; <a class="el" href="namespacehandlegraph.html#ab3d3683c53bb48b8af63a6d94497271c">PathSense</a> &gt; *ignore_sense=nullptr)</td></tr>
<tr class="memdesc:a8baa82611439357dc02996ba17ce6aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a GFA from a stream (assumed not to be seekable or reopenable) into a PathHandleGraph.  <a href="namespacevg_1_1algorithms.html#a8baa82611439357dc02996ba17ce6aa9">More...</a><br /></td></tr>
<tr class="separator:a8baa82611439357dc02996ba17ce6aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54730e9452c2609633da201ba85a8bca"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a54730e9452c2609633da201ba85a8bca">id_order</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *g)</td></tr>
<tr class="separator:a54730e9452c2609633da201ba85a8bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce4dabb6661657c7d72593afc3f41df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a9ce4dabb6661657c7d72593afc3f41df">intersect_path_offsets</a> (const <a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a> &amp;a_offsets, const <a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a> &amp;b_offsets, size_t <a class="el" href="namespacevg.html#a004ed92d4db665ce8ec4e527f150a7c4">maximum_distance</a>)</td></tr>
<tr class="separator:a9ce4dabb6661657c7d72593afc3f41df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e5913b682c7c14f119543eca7e7548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ad8e5913b682c7c14f119543eca7e7548">sort_path_offsets</a> (<a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a> &amp;offsets)</td></tr>
<tr class="separator:ad8e5913b682c7c14f119543eca7e7548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633a1600c6a7e447c040fefb1432e508"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a633a1600c6a7e447c040fefb1432e508">jump_along_closest_path</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph, const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;pos, int64_t jump_dist, size_t max_search_dist)</td></tr>
<tr class="separator:a633a1600c6a7e447c040fefb1432e508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c6d85f2dc09c22c5d14ed81808769e"><td class="memItemLeft" align="right" valign="top">pair&lt; double, vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a08c6d85f2dc09c22c5d14ed81808769e">widest_dijkstra</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *g, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> source, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> sink, function&lt; double(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; node_weight_callback, function&lt; double(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; edge_weight_callback, function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; is_node_ignored_callback, function&lt; bool(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; is_edge_ignored_callback, bool greedy_avg)</td></tr>
<tr class="separator:a08c6d85f2dc09c22c5d14ed81808769e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a715606bdd30499dc9db88583c6573"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; double, vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ad9a715606bdd30499dc9db88583c6573">yens_k_widest_paths</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *g, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> source, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> sink, size_t K, function&lt; double(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; node_weight_callback, function&lt; double(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; edge_weight_callback, bool greedy_avg, size_t max_path_length)</td></tr>
<tr class="separator:ad9a715606bdd30499dc9db88583c6573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b8fd7a0d56e1827faa3aa56c8828f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a30b8fd7a0d56e1827faa3aa56c8828f0">for_each_kmer</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, size_t k, size_t edge_max, const std::function&lt; void(const <a class="el" href="structvg_1_1algorithms_1_1kmer__t.html">kmer_t</a> &amp;)&gt; &amp;lambda)</td></tr>
<tr class="memdesc:a30b8fd7a0d56e1827faa3aa56c8828f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all the kmers in the graph, running lambda on each.  <a href="namespacevg_1_1algorithms.html#a30b8fd7a0d56e1827faa3aa56c8828f0">More...</a><br /></td></tr>
<tr class="separator:a30b8fd7a0d56e1827faa3aa56c8828f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3961418e3f3af94c4275118e4693a2fe"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a3961418e3f3af94c4275118e4693a2fe">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structvg_1_1algorithms_1_1kmer__t.html">kmer_t</a> &amp;kmer)</td></tr>
<tr class="memdesc:a3961418e3f3af94c4275118e4693a2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a <a class="el" href="structvg_1_1algorithms_1_1kmer__t.html" title="Stores a kmer in the context of a graph.">kmer_t</a> to a stream.  <a href="namespacevg_1_1algorithms.html#a3961418e3f3af94c4275118e4693a2fe">More...</a><br /></td></tr>
<tr class="separator:a3961418e3f3af94c4275118e4693a2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa015cfde6842fff0d0dcd81f7130c659"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aa015cfde6842fff0d0dcd81f7130c659">locally_expand_graph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;parent, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;subgraph, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> from, int64_t max_dist)</td></tr>
<tr class="separator:aa015cfde6842fff0d0dcd81f7130c659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a6bbd822f6380421a973f75036c3d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a91a6bbd822f6380421a973f75036c3d3">merge</a> (<a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html">handlegraph::MutablePathDeletableHandleGraph</a> *graph, const vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, size_t &gt;&gt; &amp;start, size_t length)</td></tr>
<tr class="separator:a91a6bbd822f6380421a973f75036c3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0820d23864c46dc1bc71ec68aee4e55e"><td class="memItemLeft" align="right" valign="top">pair&lt; vector&lt; unordered_set&lt; size_t &gt; &gt;, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a0820d23864c46dc1bc71ec68aee4e55e">kargers_min_cut</a> (<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> graph, const int seed)</td></tr>
<tr class="separator:a0820d23864c46dc1bc71ec68aee4e55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae1eba2313c3ce068851c85b8d019e2"><td class="memItemLeft" align="right" valign="top">pair&lt; vector&lt; unordered_set&lt; size_t &gt; &gt;, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a7ae1eba2313c3ce068851c85b8d019e2">compute_min_cut</a> (<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> graph, const int seed)</td></tr>
<tr class="separator:a7ae1eba2313c3ce068851c85b8d019e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd4d23b1a702613134895c2d5618154"><td class="memItemLeft" align="right" valign="top">vector&lt; unordered_set&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a5cd4d23b1a702613134895c2d5618154">min_cut_decomposition</a> (<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> graph, const int seed)</td></tr>
<tr class="separator:a5cd4d23b1a702613134895c2d5618154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477330d3ab29cbd3c48e4830d51b3e0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a477330d3ab29cbd3c48e4830d51b3e0f">nearest_offsets_in_paths</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph, const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;pos, int64_t max_search, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *path_filter)</td></tr>
<tr class="separator:a477330d3ab29cbd3c48e4830d51b3e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef24fa77dadb09d5920ec94b88af2128"><td class="memItemLeft" align="right" valign="top">map&lt; string, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aef24fa77dadb09d5920ec94b88af2128">offsets_in_paths</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph, const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;pos)</td></tr>
<tr class="separator:aef24fa77dadb09d5920ec94b88af2128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddb73ef3cf5a8891aa82001f272c3c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a9ddb73ef3cf5a8891aa82001f272c3c4">simple_offsets_in_paths</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph, <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> pos)</td></tr>
<tr class="memdesc:a9ddb73ef3cf5a8891aa82001f272c3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "simple" model for path position getting for debugging.  <a href="namespacevg_1_1algorithms.html#a9ddb73ef3cf5a8891aa82001f272c3c4">More...</a><br /></td></tr>
<tr class="separator:a9ddb73ef3cf5a8891aa82001f272c3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d03c4f50c51d0d537811ba88895688"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a>, char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a22d03c4f50c51d0d537811ba88895688">next_pos_chars</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;graph, <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> pos)</td></tr>
<tr class="separator:a22d03c4f50c51d0d537811ba88895688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6a93eb17739d744908d61ca6650f4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#afb6a93eb17739d744908d61ca6650f4c">normalize</a> (<a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html">handlegraph::MutablePathDeletableHandleGraph</a> *graph, int max_iter, bool debug, function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; can_merge)</td></tr>
<tr class="separator:afb6a93eb17739d744908d61ca6650f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ff6fdbf4ef393faf59f22365c46bbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ae5ff6fdbf4ef393faf59f22365c46bbb">append_mapping_sequence</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m, const string &amp;node_seq, string &amp;seq)</td></tr>
<tr class="memdesc:ae5ff6fdbf4ef393faf59f22365c46bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">use the given oriented node sequence and the mapping to reconstruct the sequence represented by the mapping  <a href="namespacevg_1_1algorithms.html#ae5ff6fdbf4ef393faf59f22365c46bbb">More...</a><br /></td></tr>
<tr class="separator:ae5ff6fdbf4ef393faf59f22365c46bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acc0acf3d99939a0943ca9e0b86e48a"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a7acc0acf3d99939a0943ca9e0b86e48a">path_string</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="memdesc:a7acc0acf3d99939a0943ca9e0b86e48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">use the given graph and the path to determine our path string  <a href="namespacevg_1_1algorithms.html#a7acc0acf3d99939a0943ca9e0b86e48a">More...</a><br /></td></tr>
<tr class="separator:a7acc0acf3d99939a0943ca9e0b86e48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8529f1718d5f0330dbb301d1148f12e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1pair__hash__set.html">pair_hash_set</a>&lt; <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a8529f1718d5f0330dbb301d1148f12e1">find_edges_to_prune</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, size_t k, size_t edge_max)</td></tr>
<tr class="separator:a8529f1718d5f0330dbb301d1148f12e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b6e838b2991d13e272ddcb41aacfbc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a09b6e838b2991d13e272ddcb41aacfbc">prune_complex</a> (<a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;graph, int path_length, int edge_max)</td></tr>
<tr class="separator:a09b6e838b2991d13e272ddcb41aacfbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784ee29876a24431a865541426f42dee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a784ee29876a24431a865541426f42dee">prune_complex_with_head_tail</a> (<a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;graph, int path_length, int edge_max)</td></tr>
<tr class="separator:a784ee29876a24431a865541426f42dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e87cf3f8a5ca4362776cf1a3050242"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a83e87cf3f8a5ca4362776cf1a3050242">prune_short_subgraphs</a> (<a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;graph, int min_size)</td></tr>
<tr class="separator:a83e87cf3f8a5ca4362776cf1a3050242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96020f05a81255adfca3821f538c02b9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a96020f05a81255adfca3821f538c02b9">remove_high_degree_nodes</a> (<a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;g, int max_degree)</td></tr>
<tr class="separator:a96020f05a81255adfca3821f538c02b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d74c519ccaa204e7735d5bd26c5095a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a3d74c519ccaa204e7735d5bd26c5095a">prune_to_connecting_graph</a> (<a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;graph, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;from, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;to)</td></tr>
<tr class="memdesc:a3d74c519ccaa204e7735d5bd26c5095a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all parts of the graph that are not on some path between the two handles.  <a href="namespacevg_1_1algorithms.html#a3d74c519ccaa204e7735d5bd26c5095a">More...</a><br /></td></tr>
<tr class="separator:a3d74c519ccaa204e7735d5bd26c5095a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e4dc632e98b58b67a99af6749d9e05"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aa5e4dc632e98b58b67a99af6749d9e05">ref_path_distance</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph, const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;pos_1, const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;pos_2, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;ref_paths, int64_t max_search_dist)</td></tr>
<tr class="separator:aa5e4dc632e98b58b67a99af6749d9e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51e5eafc2c18f33dd6a120c753247a3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#af51e5eafc2c18f33dd6a120c753247a3">bellman_ford_shortest_cycle_length</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;source, const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;layout, const unordered_map&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, size_t &gt; &amp;handle_index, const vector&lt; pair&lt; size_t, size_t &gt;&gt; &amp;feedback_edges)</td></tr>
<tr class="separator:af51e5eafc2c18f33dd6a120c753247a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d6162a9f0dba28306c836d07d7d6e3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a40d6162a9f0dba28306c836d07d7d6e3">dijkstra_shortest_cycle_length</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;source)</td></tr>
<tr class="memdesc:a40d6162a9f0dba28306c836d07d7d6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple Dijkstra implementation that computes shortest cycle.  <a href="namespacevg_1_1algorithms.html#a40d6162a9f0dba28306c836d07d7d6e3">More...</a><br /></td></tr>
<tr class="separator:a40d6162a9f0dba28306c836d07d7d6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87ca8c58307fdb47d448deb2ec43389"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aa87ca8c58307fdb47d448deb2ec43389">shortest_cycle_length_internal</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;source, const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;layout, const unordered_map&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, size_t &gt; &amp;handle_index, const vector&lt; pair&lt; size_t, size_t &gt;&gt; &amp;feedback_edges)</td></tr>
<tr class="separator:aa87ca8c58307fdb47d448deb2ec43389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe6f985e8bedbad1b33861c62379772"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#acfe6f985e8bedbad1b33861c62379772">shortest_cycle_length</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;source)</td></tr>
<tr class="separator:acfe6f985e8bedbad1b33861c62379772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012fced2754c445ec404ff5420018982"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a012fced2754c445ec404ff5420018982">shortest_cycle_length</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="separator:a012fced2754c445ec404ff5420018982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4cebdfc1e901db4588c4612653df96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a9e4cebdfc1e901db4588c4612653df96">simplify_siblings</a> (<a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html">handlegraph::MutablePathDeletableHandleGraph</a> *graph, function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; can_merge)</td></tr>
<tr class="separator:a9e4cebdfc1e901db4588c4612653df96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bd6b3ff0d2e22bf752e29e3522a98d"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a64bd6b3ff0d2e22bf752e29e3522a98d">sorted_id_ranges</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="memdesc:a64bd6b3ff0d2e22bf752e29e3522a98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a sorted list of inclusive ranges of IDs used in the given HandleGraph.  <a href="namespacevg_1_1algorithms.html#a64bd6b3ff0d2e22bf752e29e3522a98d">More...</a><br /></td></tr>
<tr class="separator:a64bd6b3ff0d2e22bf752e29e3522a98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ff68675a6735fbd34ce736e67a9d52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ac8ff68675a6735fbd34ce736e67a9d52">expand_subgraph_by_steps</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;subgraph, const uint64_t &amp;steps, bool forward_only=false)</td></tr>
<tr class="memdesc:ac8ff68675a6735fbd34ce736e67a9d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">expand the subgraph iteratively for this many steps  <a href="namespacevg_1_1algorithms.html#ac8ff68675a6735fbd34ce736e67a9d52">More...</a><br /></td></tr>
<tr class="separator:ac8ff68675a6735fbd34ce736e67a9d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1998da7905d222d25839ca3b9b6c52c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ae1998da7905d222d25839ca3b9b6c52c">expand_subgraph_to_node_count</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;subgraph, const uint64_t &amp;node_count, bool forward_only=false)</td></tr>
<tr class="memdesc:ae1998da7905d222d25839ca3b9b6c52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">expand the subgraph iteratively until its node count is at least node_count  <a href="namespacevg_1_1algorithms.html#ae1998da7905d222d25839ca3b9b6c52c">More...</a><br /></td></tr>
<tr class="separator:ae1998da7905d222d25839ca3b9b6c52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b57bed3b0fc8427419ccddc077fe20c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a5b57bed3b0fc8427419ccddc077fe20c">expand_subgraph_by_length</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;subgraph, const uint64_t &amp;length, bool forward_only=false)</td></tr>
<tr class="memdesc:a5b57bed3b0fc8427419ccddc077fe20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">expand the subgraph iteratively to include at least length new sequence  <a href="namespacevg_1_1algorithms.html#a5b57bed3b0fc8427419ccddc077fe20c">More...</a><br /></td></tr>
<tr class="separator:a5b57bed3b0fc8427419ccddc077fe20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93f6a90a43d95f7340318a0d9ac4fe6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aa93f6a90a43d95f7340318a0d9ac4fe6">expand_subgraph_to_length</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;subgraph, const uint64_t &amp;length, bool forward_only=false)</td></tr>
<tr class="memdesc:aa93f6a90a43d95f7340318a0d9ac4fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">expand the subgraph iterativel until its total sequence length is greater than length  <a href="namespacevg_1_1algorithms.html#aa93f6a90a43d95f7340318a0d9ac4fe6">More...</a><br /></td></tr>
<tr class="separator:aa93f6a90a43d95f7340318a0d9ac4fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ea20ebc7800702ec0cdb96920c6184"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a38ea20ebc7800702ec0cdb96920c6184">extract_context</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;subgraph, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const uint64_t &amp;<a class="el" href="namespacevg.html#ad48a54a3ddd5e6ffd8e3e6296fb9c037">offset</a>, const uint64_t &amp;length, bool fwd, bool rev)</td></tr>
<tr class="memdesc:a38ea20ebc7800702ec0cdb96920c6184"><td class="mdescLeft">&#160;</td><td class="mdescRight">expand the context around a single handle position  <a href="namespacevg_1_1algorithms.html#a38ea20ebc7800702ec0cdb96920c6184">More...</a><br /></td></tr>
<tr class="separator:a38ea20ebc7800702ec0cdb96920c6184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53dd7f2ff1b53bec309f368a79db951"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ac53dd7f2ff1b53bec309f368a79db951">extract_id_range</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;source, const <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">nid_t</a> &amp;id1, const <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">nid_t</a> &amp;id2, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;subgraph)</td></tr>
<tr class="memdesc:ac53dd7f2ff1b53bec309f368a79db951"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract the node id range  <a href="namespacevg_1_1algorithms.html#ac53dd7f2ff1b53bec309f368a79db951">More...</a><br /></td></tr>
<tr class="separator:ac53dd7f2ff1b53bec309f368a79db951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da60961fae57a5568354ef5b541bcf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a6da60961fae57a5568354ef5b541bcf7">extract_path_range</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;source, <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> path_handle, int64_t start, int64_t end, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;subgraph)</td></tr>
<tr class="separator:a6da60961fae57a5568354ef5b541bcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad37fc704de99f02f0bf767d6ab41fe4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ad37fc704de99f02f0bf767d6ab41fe4e">add_subpaths_to_subgraph</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;source, <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html">MutablePathHandleGraph</a> &amp;subgraph, bool subpath_naming)</td></tr>
<tr class="separator:ad37fc704de99f02f0bf767d6ab41fe4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6347e00229560b4adb7cc7cb6332b21a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a6347e00229560b4adb7cc7cb6332b21a">add_connecting_edges_to_subgraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;subgraph)</td></tr>
<tr class="separator:a6347e00229560b4adb7cc7cb6332b21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4b7c6814fb1f53a83c2e8355d72efa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a4d4b7c6814fb1f53a83c2e8355d72efa">three_edge_connected_component_merges_dense</a> (size_t node_count, size_t first_root, const function&lt; void(size_t, const function&lt; void(size_t)&gt; &amp;)&gt; &amp;for_each_connected_node, const function&lt; void(size_t, size_t)&gt; &amp;same_component)</td></tr>
<tr class="separator:a4d4b7c6814fb1f53a83c2e8355d72efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c4a74208a88c0f956e697d5e183f5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a34c4a74208a88c0f956e697d5e183f5c">three_edge_connected_components_dense</a> (size_t node_count, size_t first_root, const function&lt; void(size_t, const function&lt; void(size_t)&gt; &amp;)&gt; &amp;for_each_connected_node, const function&lt; void(const function&lt; void(const function&lt; void(size_t)&gt; &amp;)&gt; &amp;)&gt; &amp;component_callback)</td></tr>
<tr class="separator:a34c4a74208a88c0f956e697d5e183f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57de725b70b138394479863428f9d2eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a57de725b70b138394479863428f9d2eb">three_edge_connected_components_dense_cactus</a> (size_t node_count, const function&lt; void(size_t, const function&lt; void(size_t)&gt; &amp;)&gt; &amp;for_each_connected_node, const function&lt; void(const function&lt; void(const function&lt; void(size_t)&gt; &amp;)&gt; &amp;)&gt; &amp;component_callback)</td></tr>
<tr class="separator:a57de725b70b138394479863428f9d2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4677e69f0b8ceb8580bc019cc8fbea8"><td class="memTemplParams" colspan="2">template&lt;typename TECCNode &gt; </td></tr>
<tr class="memitem:ae4677e69f0b8ceb8580bc019cc8fbea8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ae4677e69f0b8ceb8580bc019cc8fbea8">three_edge_connected_components</a> (const function&lt; void(const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;for_each_node, const function&lt; void(TECCNode, const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;for_each_connected_node, const function&lt; void(const function&lt; void(const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;)&gt; &amp;component_callback)</td></tr>
<tr class="separator:ae4677e69f0b8ceb8580bc019cc8fbea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7215192f2cc6536b6b3aadef4e95c64a"><td class="memTemplParams" colspan="2">template&lt;typename TECCNode &gt; </td></tr>
<tr class="memitem:a7215192f2cc6536b6b3aadef4e95c64a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a7215192f2cc6536b6b3aadef4e95c64a">three_edge_connected_component_merges</a> (const function&lt; void(const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;for_each_node, const function&lt; void(TECCNode, const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;for_each_connected_node, const function&lt; void(TECCNode, TECCNode)&gt; &amp;same_component)</td></tr>
<tr class="separator:a7215192f2cc6536b6b3aadef4e95c64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1ad4f4eccc7041eb1e700463492540"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ace1ad4f4eccc7041eb1e700463492540">for_each_walk</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, size_t k, size_t edge_max, const std::function&lt; void(const <a class="el" href="structvg_1_1algorithms_1_1walk__t.html">walk_t</a> &amp;)&gt; &amp;lambda)</td></tr>
<tr class="memdesc:ace1ad4f4eccc7041eb1e700463492540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all the walks in the graph, running lambda on each.  <a href="namespacevg_1_1algorithms.html#ace1ad4f4eccc7041eb1e700463492540">More...</a><br /></td></tr>
<tr class="separator:ace1ad4f4eccc7041eb1e700463492540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ec8c8d09fde1a6e83194ec7126ed4e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a58ec8c8d09fde1a6e83194ec7126ed4e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structvg_1_1algorithms_1_1walk__t.html">walk_t</a> &amp;walk)</td></tr>
<tr class="memdesc:a58ec8c8d09fde1a6e83194ec7126ed4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a <a class="el" href="structvg_1_1algorithms_1_1walk__t.html" title="Record a &lt;=k-length walk in the context of a graph.">walk_t</a> to a stream.  <a href="namespacevg_1_1algorithms.html#a58ec8c8d09fde1a6e83194ec7126ed4e">More...</a><br /></td></tr>
<tr class="separator:a58ec8c8d09fde1a6e83194ec7126ed4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af5e9c480c0dc7d0843cf981cd52c32"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a4af5e9c480c0dc7d0843cf981cd52c32">walk_haplotype_frequency</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const gbwt::GBWT &amp;haplotypes, const <a class="el" href="structvg_1_1algorithms_1_1walk__t.html">walk_t</a> &amp;walk)</td></tr>
<tr class="separator:a4af5e9c480c0dc7d0843cf981cd52c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9cb62b2ae1c6eb08b10f172980788d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#abe9cb62b2ae1c6eb08b10f172980788d">walk_haplotype_names</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const gbwt::GBWT &amp;haplotypes, const <a class="el" href="structvg_1_1algorithms_1_1walk__t.html">walk_t</a> &amp;walk)</td></tr>
<tr class="separator:abe9cb62b2ae1c6eb08b10f172980788d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a64f4abe5d8279f14a52b56ffb47fff34"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a64f4abe5d8279f14a52b56ffb47fff34">PRUNE_THREAD_BUFFER_SIZE</a> = 1024 * 1024</td></tr>
<tr class="separator:a64f4abe5d8279f14a52b56ffb47fff34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="acf8cb40a8f834b42f1ec89af0ef140b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8cb40a8f834b42f1ec89af0ef140b9">&#9670;&nbsp;</a></span>BinnedDepthIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg_1_1algorithms.html#acf8cb40a8f834b42f1ec89af0ef140b9">vg::algorithms::BinnedDepthIndex</a> = typedef unordered_map&lt;string, map&lt;size_t, map&lt;size_t, pair&lt;float, float&gt; &gt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the above function to retrieve the binned depths of a list of paths, and store them indexed by start coordinate. If std_err is true, store &lt;mean, stderr&gt; instead of &lt;mean, variance&gt; For each path, a series of indexes is computed, for bin sizes from min_bin_size, min_bin_size^(exp_growth_factor), etc. </p>

</div>
</div>
<a id="a6474017f8ab54b0c6e20095206a880a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6474017f8ab54b0c6e20095206a880a8">&#9670;&nbsp;</a></span>path_offset_collection_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">vg::algorithms::path_offset_collection_t</a> = typedef unordered_map&lt;<a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, vector&lt;pair&lt;size_t, bool&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents a set of positions and orientations, along a collection of paths. Positions and orientations may or may not be stored sorted. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5af5b6f1083925669832ae59d0e549e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af5b6f1083925669832ae59d0e549e7">&#9670;&nbsp;</a></span>a_star()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DistHeuristic &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; vg::algorithms::a_star </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DistHeuristic &amp;&#160;</td>
          <td class="paramname"><em>dist_heuristic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>find_min</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>extremal_distance</em> = <code>numeric_limits&lt;int64_t&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>monotonic_heuristic</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implements the A* heuristic-guided search algorithm. Returns the path from pos_1 to pos_2 that is either minimal or maximal length, according to the parameters. Allows an extremal distance beyond which the algorithm will cease looking for paths (this should be a large value when looking for minimal paths and a small value when looking for maximum paths). If there is no path between the positions, or none within the extremal length, an empty vector will be returned. </p>

</div>
</div>
<a id="a6347e00229560b4adb7cc7cb6332b21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6347e00229560b4adb7cc7cb6332b21a">&#9670;&nbsp;</a></span>add_connecting_edges_to_subgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::add_connecting_edges_to_subgraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We can accumulate a subgraph without accumulating all the edges between its nodes this helper ensures that we get the full set </p>

</div>
</div>
<a id="ad37fc704de99f02f0bf767d6ab41fe4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad37fc704de99f02f0bf767d6ab41fe4e">&#9670;&nbsp;</a></span>add_subpaths_to_subgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::add_subpaths_to_subgraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html">MutablePathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subpath_naming</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>add subpaths to the subgraph, providing a concatenation of subpaths that are discontiguous over the subgraph based on their order in the path position index provided by the source graph will clear any path found in both graphs before writing the new steps into it if subpath_naming is true, a suffix will be added to each path in the subgraph denoting its offset in the source graph (unless the subpath was not cut up at all) </p>

</div>
</div>
<a id="ad9941053149e9b62a3987e6910aab8f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9941053149e9b62a3987e6910aab8f6">&#9670;&nbsp;</a></span>alignment_path_offsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; vg::algorithms::alignment_path_offsets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>just_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nearby</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>search_limit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *&#160;</td>
          <td class="paramname"><em>path_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the path positions of the alignment. If just_min is set, gives the minimum position on each path. Else, gives all <a class="el" href="structvg_1_1Mapping.html">Mapping</a> start positions on each path. If nearby is set, will search for a nearby path. Will recurse with nearby set if it is not set on initial call and no positions are found. Respects search_limit in bp in that case. If search_limit is 0, read length is used.</p>
<p>If path_filter is set, and it returns false for a path, that path is not used to annotate the read. </p>

</div>
</div>
<a id="a47438272f0eac991e9d3edce30cf9123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47438272f0eac991e9d3edce30cf9123">&#9670;&nbsp;</a></span>annotate_with_initial_path_positions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::annotate_with_initial_path_positions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>search_limit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *&#160;</td>
          <td class="paramname"><em>path_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the graph to annotate an <a class="el" href="structvg_1_1Alignment.html">Alignment</a> with the first position it touches on each reference path. Thread safe.</p>
<p>search_limit gives the maximum distance to search for a path if the alignment does not actually touch any paths. If 0, the alignment's sequence length is used.</p>
<p>If path_filter is set, and it returns false for a path, that path is not used to annotate the read. </p>

</div>
</div>
<a id="a8cf2e0df2e99d24d22fbfac537120cc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cf2e0df2e99d24d22fbfac537120cc8">&#9670;&nbsp;</a></span>annotate_with_initial_path_positions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::annotate_with_initial_path_positions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>search_limit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *&#160;</td>
          <td class="paramname"><em>path_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the graph annotate Alignments with the first position they touch on each reference path. Thread safe.</p>
<p>search_limit gives the maximum distance to search for a path if the alignment does not actually touch any paths. If 0, the alignment's sequence length is used.</p>
<p>If path_filter is set, and it returns false for a path, that path is not used to annotate the read. </p>

</div>
</div>
<a id="ae92f9ba72b27512a1a744e60fc164844"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae92f9ba72b27512a1a744e60fc164844">&#9670;&nbsp;</a></span>annotate_with_node_path_positions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::annotate_with_node_path_positions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>search_limit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *&#160;</td>
          <td class="paramname"><em>path_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the graph to annotate an <a class="el" href="structvg_1_1Alignment.html">Alignment</a> with the first position it touches on each node it visits in each reference path. Thread safe. If no nodes on any path are visited, searches for a nearby path position to use.</p>
<p>search_limit gives the maximum distance to search for a path if the alignment does not actually touch any paths. If 0, the alignment's sequence length is used.</p>
<p>If path_filter is set, and it returns false for a path, that path is not used to annotate the read. </p>

</div>
</div>
<a id="a001d349e7ad0fa290437ca9846decced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a001d349e7ad0fa290437ca9846decced">&#9670;&nbsp;</a></span>annotate_with_path_positions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::annotate_with_path_positions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>just_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>search_limit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *&#160;</td>
          <td class="paramname"><em>path_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the graph to annotate an <a class="el" href="structvg_1_1Alignment.html">Alignment</a> with positions on each reference path. Thread safe.</p>
<p>If just_min is set, gives the minimum position on each path. Else, gives all <a class="el" href="structvg_1_1Mapping.html">Mapping</a> start positions on each path. If no positions on the path are found, looks for nearby path positions in graph space. Respects search_limit in bp in that case. If search_limit is 0, read length is used.</p>
<p>If path_filter is set, and it returns false for a path, that path is not used to annotate the read. </p>

</div>
</div>
<a id="ae5ff6fdbf4ef393faf59f22365c46bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ff6fdbf4ef393faf59f22365c46bbb">&#9670;&nbsp;</a></span>append_mapping_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::append_mapping_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>node_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>use the given oriented node sequence and the mapping to reconstruct the sequence represented by the mapping </p>

</div>
</div>
<a id="a0d0e29a34fb2e1f712751a8a8fda6f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0e29a34fb2e1f712751a8a8fda6f03">&#9670;&nbsp;</a></span>back_translate_in_place() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::back_translate_in_place </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> *&#160;</td>
          <td class="paramname"><em>translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translate the given <a class="el" href="structvg_1_1Path.html">Path</a> in place from node ID space to named segment space. </p>

</div>
</div>
<a id="a0fb0b1f6ca5892b532032ecddd8fde19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb0b1f6ca5892b532032ecddd8fde19">&#9670;&nbsp;</a></span>back_translate_in_place() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::back_translate_in_place </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> *&#160;</td>
          <td class="paramname"><em>translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translate the given <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes.">Snarl</a> in place from node ID space to named segment space. </p>

</div>
</div>
<a id="a0efe72c9db6dd4c1828dae311795e9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efe72c9db6dd4c1828dae311795e9b0">&#9670;&nbsp;</a></span>back_translate_in_place() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::back_translate_in_place </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> *&#160;</td>
          <td class="paramname"><em>translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>traversal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translate the given <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> in place from node ID space to named segment space. Visits that end up being to snarls where both boundaries are from the same orientation of the same segment will be removed. Multiple visits in a row to the same orientation of the same segment will be elided.</p>
<p>TODO: Work out a way to preserve traversals around cycles while not repeating ourselves for visits to diffrent pieces of the same chopped segment. </p>

</div>
</div>
<a id="a0e04f69397f1d7e1f33b99f0ff145af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e04f69397f1d7e1f33b99f0ff145af5">&#9670;&nbsp;</a></span>back_translate_in_place() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::back_translate_in_place </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> *&#160;</td>
          <td class="paramname"><em>translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>visit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translate the given <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> in place from node ID space to named segment space. </p>

</div>
</div>
<a id="af51e5eafc2c18f33dd6a120c753247a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51e5eafc2c18f33dd6a120c753247a3">&#9670;&nbsp;</a></span>bellman_ford_shortest_cycle_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::bellman_ford_shortest_cycle_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; size_t, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>feedback_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An implementation of Bellman-Ford with Yen's ordering improvement applied to a layout ideally has a small feedback arc set </p>

</div>
</div>
<a id="a8fb3df22b1d7955546bbcc8c438f6efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb3df22b1d7955546bbcc8c438f6efc">&#9670;&nbsp;</a></span>binned_packed_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; tuple&lt; size_t, size_t, double, double &gt; &gt; vg::algorithms::binned_packed_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;&#160;</td>
          <td class="paramname"><em>packer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bin_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_deletions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use all available threads to estimate the binned packed coverage of a path using above fucntion Each element is a bin's 0-based open-ended interval in the path, and its coverage mean,variance. <br  />
 </p>

</div>
</div>
<a id="af05e00ad1e6a7b34cde8c37aa9dbbdbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05e00ad1e6a7b34cde8c37aa9dbbdbc">&#9670;&nbsp;</a></span>binned_packed_depth_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg_1_1algorithms.html#acf8cb40a8f834b42f1ec89af0ef140b9">BinnedDepthIndex</a> vg::algorithms::binned_packed_depth_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;&#160;</td>
          <td class="paramname"><em>packer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_bin_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_bin_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>exp_growth_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_deletions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>std_err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d48562b230a318ee15820aa508867fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d48562b230a318ee15820aa508867fc">&#9670;&nbsp;</a></span>binned_path_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; tuple&lt; size_t, size_t, double, double &gt; &gt; vg::algorithms::binned_path_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bin_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>count_cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05bafa99c51765b72bf17b91538fcff5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05bafa99c51765b72bf17b91538fcff5">&#9670;&nbsp;</a></span>chain_items_dp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a> vg::algorithms::chain_items_dp </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>best_chain_score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>to_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gap_open</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gap_extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_lookback_bases</em> = <code>150</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_lookback_items</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lookback_item_hard_cap</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>initial_lookback_threshold</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lookback_scale_factor</em> = <code>2.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_good_transition_score_per_base</em> = <code>-0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>item_bonus</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_indel_bases</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill in the given DP table for the best chain score ending with each item. Returns the best observed score overall from that table, with provenance to its location in the table, if tracked in the type. Assumes some items exist.</p>
<p>Input items must be sorted by start position in the read.</p>
<p>Takes the given per-item bonus for each item collected.</p>
<p>Uses a finite lookback in items and in read bases when checking where we can come from to reach an item. Also, once a given number of good-looking predecessor items have been found, stop looking back.</p>
<p>Limits transitions to those involving indels of the given size or less, to avoid very bad transitions. </p>

</div>
</div>
<a id="ab0147b2932e3f053cc2f2b0912390978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0147b2932e3f053cc2f2b0912390978">&#9670;&nbsp;</a></span>chain_items_traceback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; size_t &gt; vg::algorithms::chain_items_traceback </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>best_chain_score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>to_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a> &amp;&#160;</td>
          <td class="paramname"><em>best_past_ending_score_ever</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trace back through in the given DP table from the best chain score. </p>

</div>
</div>
<a id="a51f810108840ab4014eb58b2bfe19ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f810108840ab4014eb58b2bfe19ac1">&#9670;&nbsp;</a></span>component_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &gt; vg::algorithms::component_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10b07f6f41f8dd36c5d3b1ff9a03ce93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b07f6f41f8dd36c5d3b1ff9a03ce93">&#9670;&nbsp;</a></span>component_paths_parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &gt; vg::algorithms::component_paths_parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e5fdb03a21f88395e1d69f53821ae59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5fdb03a21f88395e1d69f53821ae59">&#9670;&nbsp;</a></span>component_sizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; size_t &gt; vg::algorithms::component_sizes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ae1eba2313c3ce068851c85b8d019e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae1eba2313c3ce068851c85b8d019e2">&#9670;&nbsp;</a></span>compute_min_cut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; vector&lt; unordered_set&lt; size_t &gt; &gt;, size_t &gt; vg::algorithms::compute_min_cut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a>&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b477c1e232c9d4f1e689a95dd55861d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b477c1e232c9d4f1e689a95dd55861d">&#9670;&nbsp;</a></span>count_covered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::count_covered </td>
          <td>(</td>
          <td class="paramtype">Collection &amp;&#160;</td>
          <td class="paramname"><em>segments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count, from begin to end, the number of positions covered by ranges in the given collection. The collection will be sorted in place.</p>
<p>The collection must be a have a begin(), end(), and random [] access (like a vector).</p>
<p>No boundaries are needed because no positions can be covered without segments representing them. </p>

</div>
</div>
<a id="ac89d8d2356483ef348082609dc310b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89d8d2356483ef348082609dc310b80">&#9670;&nbsp;</a></span>dfs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::dfs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_begin_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_end_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>break_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a2ca7e29cbf4769c5f6432499a45e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2ca7e29cbf4769c5f6432499a45e23">&#9670;&nbsp;</a></span>dfs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::dfs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_begin_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_end_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>break_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>tree_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_curr_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_cross_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sinks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade95900b3f3715ae3ecf9b3aee79961f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade95900b3f3715ae3ecf9b3aee79961f">&#9670;&nbsp;</a></span>dfs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::dfs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_begin_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_end_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sinks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a40d6162a9f0dba28306c836d07d7d6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d6162a9f0dba28306c836d07d7d6e3">&#9670;&nbsp;</a></span>dijkstra_shortest_cycle_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::dijkstra_shortest_cycle_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple Dijkstra implementation that computes shortest cycle. </p>

</div>
</div>
<a id="a38ba5a6719f9f5496130c72a047ad890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ba5a6719f9f5496130c72a047ad890">&#9670;&nbsp;</a></span>disjoint_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list&lt; bdsg::HashGraph &gt; vg::algorithms::disjoint_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a list of graphs, one for each connected component in the original graph. <a class="el" href="structvg_1_1algorithms_1_1Node.html">Node</a> IDs are preserved from the original graph. </p>

</div>
</div>
<a id="a187fd628ac942c540a1a5fde0e27b0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187fd628ac942c540a1a5fde0e27b0ef">&#9670;&nbsp;</a></span>distance_to_head() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::algorithms::distance_to_head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33aca5bac60aa4d0a4c402ed607b06a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33aca5bac60aa4d0a4c402ed607b06a3">&#9670;&nbsp;</a></span>distance_to_head() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::algorithms::distance_to_head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_set&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the distance in bases from start of node to start of closest head node of graph, or -1 if that distance exceeds the limit. dist increases by the number of bases of each previous node until you reach the head node seen is a set that holds the nodes that you have already gotten the distance of, but starts off empty </p>

</div>
</div>
<a id="a458c768a87a1182eae38b362aa7b5ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458c768a87a1182eae38b362aa7b5ad7">&#9670;&nbsp;</a></span>distance_to_tail() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::algorithms::distance_to_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8fb0ce9a4ccbb1505e661a1caa266f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8fb0ce9a4ccbb1505e661a1caa266f8">&#9670;&nbsp;</a></span>distance_to_tail() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::algorithms::distance_to_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_set&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the distance in bases from end of node to end of closest tail node of graph, or -1 if that distance exceeds the limit. dist increases by the number of bases of each previous node until you reach the head node seen is a set that holds the nodes that you have already gotten the distance of, but starts off empty </p>

</div>
</div>
<a id="aec7fcd701af4fdcbb87e83f0ea5b420a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7fcd701af4fdcbb87e83f0ea5b420a">&#9670;&nbsp;</a></span>expand_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::expand_context </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_forward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_backward</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a238775e0e0ecf0b7576f7c2265dfd5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238775e0e0ecf0b7576f7c2265dfd5e0">&#9670;&nbsp;</a></span>expand_context_by_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::expand_context_by_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_forward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_backward</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a354ea4a2a6aed208945fc0994ec50d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354ea4a2a6aed208945fc0994ec50d9d">&#9670;&nbsp;</a></span>expand_context_by_steps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::expand_context_by_steps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_forward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_backward</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a0c0c6d333cb438f96e5df6faec3621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0c0c6d333cb438f96e5df6faec3621">&#9670;&nbsp;</a></span>expand_context_with_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::expand_context_with_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_forward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_backward</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b57bed3b0fc8427419ccddc077fe20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b57bed3b0fc8427419ccddc077fe20c">&#9670;&nbsp;</a></span>expand_subgraph_by_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::expand_subgraph_by_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forward_only</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>expand the subgraph iteratively to include at least length new sequence </p>

</div>
</div>
<a id="ac8ff68675a6735fbd34ce736e67a9d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ff68675a6735fbd34ce736e67a9d52">&#9670;&nbsp;</a></span>expand_subgraph_by_steps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::expand_subgraph_by_steps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forward_only</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>expand the subgraph iteratively for this many steps </p>

</div>
</div>
<a id="aa93f6a90a43d95f7340318a0d9ac4fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93f6a90a43d95f7340318a0d9ac4fe6">&#9670;&nbsp;</a></span>expand_subgraph_to_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::expand_subgraph_to_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forward_only</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>expand the subgraph iterativel until its total sequence length is greater than length </p>

</div>
</div>
<a id="ae1998da7905d222d25839ca3b9b6c52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1998da7905d222d25839ca3b9b6c52c">&#9670;&nbsp;</a></span>expand_subgraph_to_node_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::expand_subgraph_to_node_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forward_only</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>expand the subgraph iteratively until its node count is at least node_count </p>

</div>
</div>
<a id="ac0d0446bde00e10bd77816c968ae97b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d0446bde00e10bd77816c968ae97b0">&#9670;&nbsp;</a></span>extract_connecting_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; vg::algorithms::extract_connecting_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict_max_len</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills a DeletableHandleGraph with the subgraph of a HandleGraph that connects two positions. The nodes that contain the two positions will be 'cut' at the position and will be tips in the returned graph. The algorithm guarantees that 'into' contains all walks between pos_1 and pos_2 under the maximum length except walks that include a cycle involving either position. If no walk between the two positions under the maximum length exists, 'into' will be left empty. An error is thrown if 'into' is not empty when passed to function.</p>
<p>Args: source graph to extract subgraph from into graph to extract into max_len guarantee finding walks along which pos_1 and pos_2 are this distance apart pos_1 start position, subgraph walks begin from here in same orientation pos_2 end position, subgraph walks end here in the same orientation strict_max_len only extract nodes and edges if they fall on some walk between pos_1 and pos_2 that is under the maximum length (implies only_walks = true)</p>
<p>Returns: a map from node ids in the extracted graph to the node ids in the original graph </p>

</div>
</div>
<a id="a4270da794ad0185dacef1874a1e4d3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4270da794ad0185dacef1874a1e4d3c2">&#9670;&nbsp;</a></span>extract_containing_graph() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::extract_containing_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>position_forward_max_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>position_backward_max_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>reversing_walk_length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same semantics as previous except that there is a separate maximum distance for different positions in the graph and for each search direction. Each distance is associated with the position with the same index. The forward distance is in the same orientation as the position, and the backward distance is in the reverse orientation of the position. Throws an error if the position and distance vectors are not the same length. </p>

</div>
</div>
<a id="ab31b1b707c93f96d6f013e579c4d8783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31b1b707c93f96d6f013e579c4d8783">&#9670;&nbsp;</a></span>extract_containing_graph() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::extract_containing_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>position_max_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>reversing_walk_length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same semantics as previous except that there is a separate maximum distance for different positions in the graph. Each distance is associated with the position with the same index. Throws an error if the position and distance vectors are not the same length. </p>

</div>
</div>
<a id="a0ecd79b7d4b622b583a8e08df594e45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecd79b7d4b622b583a8e08df594e45c">&#9670;&nbsp;</a></span>extract_containing_graph() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::extract_containing_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>reversing_walk_length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills graph 'into' with the subgraph of the handle graph 'source' that contains all of the positions in the positions vector and all other nodes and edges that can be reached within a maximum distance from any of these positions. Optionally also finds nodes and edges that can be reached within some distance from the previously mentioned nodes, except along non- proper bidirected walks. <a class="el" href="structvg_1_1algorithms_1_1Node.html">Node</a> IDs in the subgraph are retained from the source graph.</p>
<p>Args: source graph to extract subgraph from into graph to extract into positions search outward from these positions max_dist include all nodes and edges that can be reached in at most this distance reversing_walk_length also find graph material that can be reached </p>

</div>
</div>
<a id="a38ea20ebc7800702ec0cdb96920c6184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ea20ebc7800702ec0cdb96920c6184">&#9670;&nbsp;</a></span>extract_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::extract_context </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>expand the context around a single handle position </p>

</div>
</div>
<a id="a1f600eb589d48607c2616bed69ff2e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f600eb589d48607c2616bed69ff2e27">&#9670;&nbsp;</a></span>extract_extending_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; vg::algorithms::extract_extending_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>backward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_cycles_on_src_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills graph 'into' with the subgraph of the handle graph 'source' that extends in one direction from a given position, up to a maximum distance. The node containing the position will be "cut" so that only the portion that is forward in the search direction remains. <a class="el" href="structvg_1_1algorithms_1_1Node.html">Node</a> IDs may be changed in the extracted graph, but they can be translated back to node IDs in the original graph with the returned map, although that translation procedure MUST handle the node that pos is on specially, as it may be cut. translate_node_ids from <a class="el" href="path_8hpp.html">path.hpp</a> can do this as long as you pass along what part of the node was removed. The node containing the source position may optionally be duplicated to preserve cycles on it after its cut, but no other nodes will will duplicated.</p>
<p>Args: source graph to extract subgraph from into graph to extract into max_dist include all nodes and edges that can be reached in at most this distance pos extend from this position backward extend in this direction preserve_cycles_on_src if necessary, duplicate starting node to preserve cycles after cutting it </p>

</div>
</div>
<a id="ac53dd7f2ff1b53bec309f368a79db951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53dd7f2ff1b53bec309f368a79db951">&#9670;&nbsp;</a></span>extract_id_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::extract_id_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">nid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">nid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extract the node id range </p>

</div>
</div>
<a id="a6da60961fae57a5568354ef5b541bcf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da60961fae57a5568354ef5b541bcf7">&#9670;&nbsp;</a></span>extract_path_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::extract_path_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td>
          <td class="paramname"><em>path_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>extract the path range nodes aren't cut, so the returned graph may start before start and/or end after end if end &lt; 0, then it will walk to the end of the path </p>

</div>
</div>
<a id="a5d0662e21c846f8d7e836a67439c208f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d0662e21c846f8d7e836a67439c208f">&#9670;&nbsp;</a></span>find_best_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; int, vector&lt; size_t &gt; &gt; vg::algorithms::find_best_chain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>to_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gap_open</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gap_extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_lookback_bases</em> = <code>150</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_lookback_items</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lookback_item_hard_cap</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>initial_lookback_threshold</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lookback_scale_factor</em> = <code>2.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_good_transition_score_per_base</em> = <code>-0.1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>item_bonus</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_indel_bases</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Chain up the given group of items. Determines the best score and traceback that can be obtained by chaining items together.</p>
<p>Input items must be sorted by start position in the read.</p>
<p>Returns the score and the list of indexes of items visited to achieve that score, in order. </p>

</div>
</div>
<a id="a8529f1718d5f0330dbb301d1148f12e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8529f1718d5f0330dbb301d1148f12e1">&#9670;&nbsp;</a></span>find_edges_to_prune()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1pair__hash__set.html">pair_hash_set</a>&lt;<a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a>&gt; vg::algorithms::find_edges_to_prune </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edge_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92780d34d13ab2a6be9fe477543179ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92780d34d13ab2a6be9fe477543179ce">&#9670;&nbsp;</a></span>find_gbwt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const gbwt::GBWT * vg::algorithms::find_gbwt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the GBWT that is part of the given handle graph, if any exists. Works on GBWTGraphs and GBZGraphs. Returns null if no such GBWT exists. </p>

</div>
</div>
<a id="a5783b30c1ad6ea3ff4bc4576f447b615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5783b30c1ad6ea3ff4bc4576f447b615">&#9670;&nbsp;</a></span>find_gbwt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const gbwt::GBWT * vg::algorithms::find_gbwt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; gbwt::GBWT &gt; &amp;&#160;</td>
          <td class="paramname"><em>holder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a GBWT either by getting it from the given graph or loading it from the given filename into the given unique_ptr. </p>

</div>
</div>
<a id="a1e8867ea22636dc22aa53bd8fe1d0aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8867ea22636dc22aa53bd8fe1d0aaa">&#9670;&nbsp;</a></span>find_gbwtgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const gbwtgraph::GBWTGraph * vg::algorithms::find_gbwtgraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the GBWTGraph that is part of the given handle graph, if any exists. Works on GBWTGraphs and GBZGraphs. Returns null if no such GBWTGraph exists. </p>

</div>
</div>
<a id="af38c05b9c1e56c79faccfbbf6b3ade95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38c05b9c1e56c79faccfbbf6b3ade95">&#9670;&nbsp;</a></span>find_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> * vg::algorithms::find_translation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the NamedNodeBackTranslation defining e.g. GFA segment space for the given handle graph, if any exists. Works on GFAs that have been loaded and finds their path space information. </p>

</div>
</div>
<a id="a30b8fd7a0d56e1827faa3aa56c8828f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b8fd7a0d56e1827faa3aa56c8828f0">&#9670;&nbsp;</a></span>for_each_kmer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::for_each_kmer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edge_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="structvg_1_1algorithms_1_1kmer__t.html">kmer_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over all the kmers in the graph, running lambda on each. </p>

</div>
</div>
<a id="ace1ad4f4eccc7041eb1e700463492540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1ad4f4eccc7041eb1e700463492540">&#9670;&nbsp;</a></span>for_each_walk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::for_each_walk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edge_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="structvg_1_1algorithms_1_1walk__t.html">walk_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over all the walks in the graph, running lambda on each. </p>

</div>
</div>
<a id="a4152fa019243d9fd4c41c73fafce2241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4152fa019243d9fd4c41c73fafce2241">&#9670;&nbsp;</a></span>get_depth_from_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; float, float &gt; vg::algorithms::get_depth_from_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg_1_1algorithms.html#acf8cb40a8f834b42f1ec89af0ef140b9">BinnedDepthIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>depth_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query index created above. </p>

</div>
</div>
<a id="afbd2aaa2256eb33182306586f40187c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbd2aaa2256eb33182306586f40187c6">&#9670;&nbsp;</a></span>get_graph_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::get_graph_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get distance in the graph, or <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">std::numeric_limits&lt;size_t&gt;::max()</a> if unreachable. </p>

</div>
</div>
<a id="a5d8762b533e64039ce1a917b047097d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8762b533e64039ce1a917b047097d8">&#9670;&nbsp;</a></span>get_read_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::get_read_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get distance in the read, or <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">std::numeric_limits&lt;size_t&gt;::max()</a> if unreachable. </p>

</div>
</div>
<a id="adca14b7dcba0bb21f3fdb0c98d867c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca14b7dcba0bb21f3fdb0c98d867c72">&#9670;&nbsp;</a></span>gfa_to_handle_graph() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::gfa_to_handle_graph </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>translation_filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload which serializes its translation to a file internally. </p>

</div>
</div>
<a id="aedfca626dc003dc3fee77c6bbfcde297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfca626dc003dc3fee77c6bbfcde297">&#9670;&nbsp;</a></span>gfa_to_handle_graph() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::gfa_to_handle_graph </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1GFAIDMapInfo.html">GFAIDMapInfo</a> *&#160;</td>
          <td class="paramname"><em>translation</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a GFA file for a blunt-ended graph into a HandleGraph. Give "-" as a filename for stdin.</p>
<p>Throws <a class="el" href="structvg_1_1algorithms_1_1GFAFormatError.html" title="This exception will be thrown if the GFA data is not acceptable.">GFAFormatError</a> if the GFA file is not acceptable, and std::ios_base::failure if an IO operation fails. Throws invalid_argument if otherwise misused. Does not give max ID hints, and so might be very slow when loading into an ODGI graph. </p>

</div>
</div>
<a id="a031cb6d0db20a6aaee020c5a6909ba80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031cb6d0db20a6aaee020c5a6909ba80">&#9670;&nbsp;</a></span>gfa_to_handle_graph() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::gfa_to_handle_graph </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1GFAIDMapInfo.html">GFAIDMapInfo</a> *&#160;</td>
          <td class="paramname"><em>translation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a GFA from a stream (assumed not to be seekable or reopenable) into a HandleGraph. </p>

</div>
</div>
<a id="a9f5c41c06269c778d2c97f39cbc79de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5c41c06269c778d2c97f39cbc79de8">&#9670;&nbsp;</a></span>gfa_to_path_handle_graph() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::gfa_to_path_handle_graph </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1GFAIDMapInfo.html">GFAIDMapInfo</a> *&#160;</td>
          <td class="paramname"><em>translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_rgfa_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_set&lt; <a class="el" href="namespacehandlegraph.html#ab3d3683c53bb48b8af63a6d94497271c">PathSense</a> &gt; *&#160;</td>
          <td class="paramname"><em>ignore_sense</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as gfa_to_handle_graph but also adds path elements from the GFA to the graph. </p>

</div>
</div>
<a id="a61f2c7006c531ad5dd319ea30ec0087f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f2c7006c531ad5dd319ea30ec0087f">&#9670;&nbsp;</a></span>gfa_to_path_handle_graph() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::gfa_to_path_handle_graph </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_rgfa_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>translation_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_set&lt; <a class="el" href="namespacehandlegraph.html#ab3d3683c53bb48b8af63a6d94497271c">PathSense</a> &gt; *&#160;</td>
          <td class="paramname"><em>ignore_sense</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload which serializes its translation to a file internally. </p>

</div>
</div>
<a id="a8baa82611439357dc02996ba17ce6aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8baa82611439357dc02996ba17ce6aa9">&#9670;&nbsp;</a></span>gfa_to_path_handle_graph() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::gfa_to_path_handle_graph </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1GFAIDMapInfo.html">GFAIDMapInfo</a> *&#160;</td>
          <td class="paramname"><em>translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_rgfa_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_set&lt; <a class="el" href="namespacehandlegraph.html#ab3d3683c53bb48b8af63a6d94497271c">PathSense</a> &gt; *&#160;</td>
          <td class="paramname"><em>ignore_sense</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a GFA from a stream (assumed not to be seekable or reopenable) into a PathHandleGraph. </p>

</div>
</div>
<a id="a54730e9452c2609633da201ba85a8bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54730e9452c2609633da201ba85a8bca">&#9670;&nbsp;</a></span>id_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; vg::algorithms::id_order </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Order all the handles in the graph in ID order. All orientations are forward. </p>

</div>
</div>
<a id="a9ce4dabb6661657c7d72593afc3f41df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce4dabb6661657c7d72593afc3f41df">&#9670;&nbsp;</a></span>intersect_path_offsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::algorithms::intersect_path_offsets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a> &amp;&#160;</td>
          <td class="paramname"><em>a_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a> &amp;&#160;</td>
          <td class="paramname"><em>b_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maximum_distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given two maps from path handle to (position, orientation) pair vectors, determine if any positions in the two sets are on the same path, within the given maximum distance.</p>
<p>The set expected to have more visits should be passed first.</p>
<p>Orientation is ignored.</p>
<p>The first set must be sorted, for binary search. We run binary search for each item in the second set, so the first set should be the larger one.</p>
<p>We run in b log a time. </p>

</div>
</div>
<a id="aa4cb6665721af1f7c749ca8f73472d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4cb6665721af1f7c749ca8f73472d6c">&#9670;&nbsp;</a></span>is_head_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::algorithms::is_head_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8e4eb795d14d441c4b2944c070a1d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e4eb795d14d441c4b2944c070a1d78">&#9670;&nbsp;</a></span>is_tail_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::algorithms::is_tail_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a633a1600c6a7e447c040fefb1432e508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633a1600c6a7e447c040fefb1432e508">&#9670;&nbsp;</a></span>jump_along_closest_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &gt; vg::algorithms::jump_along_closest_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>jump_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_search_dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns a vector of positions that are found by jumping a fixed oriented distance along path(s) from the given position. if the position is not on a path, searches from the position to a path and adds/subtracts the search distance to the jump depending on the search direction. returns an empty vector if there is no path within the max search distance or if the jump distance goes past the end of the path </p>

</div>
</div>
<a id="a0820d23864c46dc1bc71ec68aee4e55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0820d23864c46dc1bc71ec68aee4e55e">&#9670;&nbsp;</a></span>kargers_min_cut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; vector&lt; unordered_set&lt; size_t &gt; &gt;, size_t &gt; vg::algorithms::kargers_min_cut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a>&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa015cfde6842fff0d0dcd81f7130c659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa015cfde6842fff0d0dcd81f7130c659">&#9670;&nbsp;</a></span>locally_expand_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::locally_expand_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add to a subgraph (with same node ID space as parent) by walking forward from a given node and adding all walks up to a maximum distance away. The handle provided graph should be from the subgraph, not the parent graph. </p>

</div>
</div>
<a id="a91a6bbd822f6380421a973f75036c3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a6bbd822f6380421a973f75036c3d3">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html">handlegraph::MutablePathDeletableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge the given ranges of bases on the given handles together, rewriting paths. Sequences must match. Handles to a single node may occur no more than once. </p>

</div>
</div>
<a id="ae18b50d29d9accb763b44d6e065dac58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18b50d29d9accb763b44d6e065dac58">&#9670;&nbsp;</a></span>min_approx_path_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::min_approx_path_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max_search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>use the embedded paths to get an estimated minimum distance between the positions </p>

</div>
</div>
<a id="a5cd4d23b1a702613134895c2d5618154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd4d23b1a702613134895c2d5618154">&#9670;&nbsp;</a></span>min_cut_decomposition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; unordered_set&lt; size_t &gt; &gt; vg::algorithms::min_cut_decomposition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a>&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0cecedaa8dd475e634b513af5be028b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0cecedaa8dd475e634b513af5be028b">&#9670;&nbsp;</a></span>multipath_alignment_path_offsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; vg::algorithms::multipath_alignment_path_offsets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mp_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *&#160;</td>
          <td class="paramname"><em>path_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the position of a multipath alignment on paths. Returns the lowest offset position on a path for each contiguous stretch of the multipath alignment, but multiple positions on the same path may be returned if the multipath alignment is disconnected or fans out toward the sources or sinks.</p>
<p>If path_filter is set, and it returns false for a path, that path is not used to annotate the read. </p>

</div>
</div>
<a id="a477330d3ab29cbd3c48e4830d51b3e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477330d3ab29cbd3c48e4830d51b3e0f">&#9670;&nbsp;</a></span>nearest_offsets_in_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a> vg::algorithms::nearest_offsets_in_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *&#160;</td>
          <td class="paramname"><em>path_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return, for the nearest position in a path to the given position, subject to the given max search distance, a mapping from path name to all positions on each path where that pos_t occurs. Stops search when path(s) are ancountered.</p>
<p>If path_filter is set, ignores paths for which it returns false. </p>

</div>
</div>
<a id="a22d03c4f50c51d0d537811ba88895688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d03c4f50c51d0d537811ba88895688">&#9670;&nbsp;</a></span>next_pos_chars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a>, char &gt; vg::algorithms::next_pos_chars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb6a93eb17739d744908d61ca6650f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6a93eb17739d744908d61ca6650f4c">&#9670;&nbsp;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html">handlegraph::MutablePathDeletableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>can_merge</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Normalize a graph, performing up to the given number of iterations. Simplifies siblings and unchops runs of nodes, in a loop.</p>
<p>if "can_merge" specified, it must return true in order for a pair of nodes to get merged </p>

</div>
</div>
<a id="aa84bd9740e748431857b5fd8a0397183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84bd9740e748431857b5fd8a0397183">&#9670;&nbsp;</a></span>num_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::num_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef24fa77dadb09d5920ec94b88af2128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef24fa77dadb09d5920ec94b88af2128">&#9670;&nbsp;</a></span>offsets_in_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; vg::algorithms::offsets_in_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper for the above to support some earlier code. Only looks for paths that directly touch the position, and returns the paths by name. </p>

</div>
</div>
<a id="aafbc78daa41b0c018cd39b7cccbaf53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafbc78daa41b0c018cd39b7cccbaf53a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::algorithms::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;&#160;</td>
          <td class="paramname"><em>anchor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explain an <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> to the given stream. </p>

</div>
</div>
<a id="a503ad2215490c5c599530d7331a70120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503ad2215490c5c599530d7331a70120">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::algorithms::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print operator. </p>

</div>
</div>
<a id="a3961418e3f3af94c4275118e4693a2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3961418e3f3af94c4275118e4693a2fe">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; vg::algorithms::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1algorithms_1_1kmer__t.html">kmer_t</a> &amp;&#160;</td>
          <td class="paramname"><em>kmer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a <a class="el" href="structvg_1_1algorithms_1_1kmer__t.html" title="Stores a kmer in the context of a graph.">kmer_t</a> to a stream. </p>

</div>
</div>
<a id="a58ec8c8d09fde1a6e83194ec7126ed4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ec8c8d09fde1a6e83194ec7126ed4e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; vg::algorithms::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1algorithms_1_1walk__t.html">walk_t</a> &amp;&#160;</td>
          <td class="paramname"><em>walk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a <a class="el" href="structvg_1_1algorithms_1_1walk__t.html" title="Record a &lt;=k-length walk in the context of a graph.">walk_t</a> to a stream. </p>

</div>
</div>
<a id="a62ebbcbfe1250940eb8ebf0a2dcbc19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ebbcbfe1250940eb8ebf0a2dcbc19a">&#9670;&nbsp;</a></span>packed_depth_of_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; double, double &gt; vg::algorithms::packed_depth_of_bin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;&#160;</td>
          <td class="paramname"><em>packer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td>
          <td class="paramname"><em>start_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td>
          <td class="paramname"><em>end_plus_one_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_deletions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimate the coverage along a given reference path interval [start_step, end_plus_one_step) Coverage is obtained only from positions along the path, and variation is not counted Except if "include_deletions" is true, then reference path positions covered by a deletion edge (which is contained in the bin) will get the deletion edge's coverage counted. Other types of events (such as SNPs) can throw off coverage in similar ways but deletions tend to be bigger (and easier to find), so we hope that counting them is enough. If one wants to infer deletions from the coverage, obviously this should be false, but if looking for a background coverage for genotyping, then setting it to true may be helpful </p>

</div>
</div>
<a id="abd431ebd9786d796f708a7046e643e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd431ebd9786d796f708a7046e643e2e">&#9670;&nbsp;</a></span>packed_depths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::packed_depths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;&#160;</td>
          <td class="paramname"><em>packer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out_stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>print path-name offset base-coverage for every base on a path (just like samtools depth) ignoring things below min_coverage. offsets are 1-based in output stream </p>

</div>
</div>
<a id="a8c66507d55ed6e10e9d77e1281d4bcfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c66507d55ed6e10e9d77e1281d4bcfc">&#9670;&nbsp;</a></span>path_depth_of_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; double, double &gt; vg::algorithms::path_depth_of_bin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td>
          <td class="paramname"><em>start_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td>
          <td class="paramname"><em>end_plus_one_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>count_cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>like packed_depth_of_bin (above), but use paths (as in path_depths) for measuring coverage </p>

</div>
</div>
<a id="a85250c33b7d32346be371ab7e4404471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85250c33b7d32346be371ab7e4404471">&#9670;&nbsp;</a></span>path_depths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::path_depths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>count_cycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out_stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>print path-name offset base-coverage for every base on a path (just like samtools depth) ignoring things below min_coverage. offsets are 1-based in output stream coverage here is the number of steps from (unique) other paths </p>

</div>
</div>
<a id="a7acc0acf3d99939a0943ca9e0b86e48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acc0acf3d99939a0943ca9e0b86e48a">&#9670;&nbsp;</a></span>path_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vg::algorithms::path_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>use the given graph and the path to determine our path string </p>

</div>
</div>
<a id="a09b6e838b2991d13e272ddcb41aacfbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b6e838b2991d13e272ddcb41aacfbc">&#9670;&nbsp;</a></span>prune_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::prune_complex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>path_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take all nodes that would introduce paths of &gt; edge_max edge crossings, remove them, and link their neighbors to head_node or tail_node depending on which direction the path extension was stopped. For pruning graph prior to indexing with gcsa2. Returns the number of edges removed. </p>

</div>
</div>
<a id="a784ee29876a24431a865541426f42dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784ee29876a24431a865541426f42dee">&#9670;&nbsp;</a></span>prune_complex_with_head_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::prune_complex_with_head_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>path_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrap the graph with heads and tails (for GCSA2 indexing) and then prune as with prune_complex. Returns the number of edges removed. </p>

</div>
</div>
<a id="a83e87cf3f8a5ca4362776cf1a3050242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e87cf3f8a5ca4362776cf1a3050242">&#9670;&nbsp;</a></span>prune_short_subgraphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::prune_short_subgraphs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove any weakly connected components that have total sequence length under the minimum size. Returns the number of nodes removed. </p>

</div>
</div>
<a id="a3d74c519ccaa204e7735d5bd26c5095a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d74c519ccaa204e7735d5bd26c5095a">&#9670;&nbsp;</a></span>prune_to_connecting_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::prune_to_connecting_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all parts of the graph that are not on some path between the two handles. </p>

</div>
</div>
<a id="acd891e00c4846e53f760d504434ead12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd891e00c4846e53f760d504434ead12">&#9670;&nbsp;</a></span>reallocate_atomic_int_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int1 , typename Int2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::reallocate_atomic_int_vector </td>
          <td>(</td>
          <td class="paramtype">vector&lt; atomic&lt; Int1 &gt;&gt; *&amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; atomic&lt; Int2 &gt;&gt; *&amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5e4dc632e98b58b67a99af6749d9e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e4dc632e98b58b67a99af6749d9e05">&#9670;&nbsp;</a></span>ref_path_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::algorithms::ref_path_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_search_dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search the local region around two positions and return the longest distance between them along any paths found during this search. Returns <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">numeric_limits&lt;int64_t&gt;::max()</a> if no shared path is found. </p>

</div>
</div>
<a id="a96020f05a81255adfca3821f538c02b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96020f05a81255adfca3821f538c02b9">&#9670;&nbsp;</a></span>remove_high_degree_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::remove_high_degree_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove nodes with &gt;= max_degree total edges on each side. Note that end-to-start self loops count twice. Returns the number of nodes removed. </p>

</div>
</div>
<a id="a80703607cfe21f1f593f7b2f03c08b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80703607cfe21f1f593f7b2f03c08b40">&#9670;&nbsp;</a></span>sample_gam_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;double, double&gt; vg::algorithms::sample_gam_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>random_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_mapq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16bd0de261a829b2d81ec48eed9d6482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bd0de261a829b2d81ec48eed9d6482">&#9670;&nbsp;</a></span>sample_mapping_depth() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; double, double &gt; vg::algorithms::sample_mapping_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>input_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>random_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_mapq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;GAM&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the mean and variance of coverage of randomly sampled nodes from a mappings file Nodes with less than min_coverage are ignored The input_filename can be - for stdin The stream is scanned in parallel with all threads max_nodes is used to keep memory down valid formats are "GAM" and "GAF" </p>

</div>
</div>
<a id="a244822514c71473756cfd5ad87f79e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244822514c71473756cfd5ad87f79e08">&#9670;&nbsp;</a></span>sample_mapping_depth() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;double, double&gt; vg::algorithms::sample_mapping_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>random_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_mapq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As above, but read a vector instead of a stream. </p>

</div>
</div>
<a id="ad91b7ceb67d3923a4c5cace56a5c4f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91b7ceb67d3923a4c5cace56a5c4f6e">&#9670;&nbsp;</a></span>score_best_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::algorithms::score_best_chain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>to_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gap_open</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gap_extension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Score the given group of items. Determines the best score that can be obtained by chaining items together.</p>
<p>Input items must be sorted by start position in the read. </p>

</div>
</div>
<a id="a012fced2754c445ec404ff5420018982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012fced2754c445ec404ff5420018982">&#9670;&nbsp;</a></span>shortest_cycle_length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::shortest_cycle_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of the shortest cycle in the entire graph, or <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">numeric_limits&lt;size_t&gt;::max()</a> if no cycle exists. </p>

</div>
</div>
<a id="acfe6f985e8bedbad1b33861c62379772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe6f985e8bedbad1b33861c62379772">&#9670;&nbsp;</a></span>shortest_cycle_length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::shortest_cycle_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of the shortest cycle containing the source node, or <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">numeric_limits&lt;size_t&gt;::max()</a> if no cycle exists. </p>

</div>
</div>
<a id="aa87ca8c58307fdb47d448deb2ec43389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87ca8c58307fdb47d448deb2ec43389">&#9670;&nbsp;</a></span>shortest_cycle_length_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::shortest_cycle_length_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; size_t, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>feedback_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ddb73ef3cf5a8891aa82001f272c3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddb73ef3cf5a8891aa82001f272c3c4">&#9670;&nbsp;</a></span>simple_offsets_in_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a> vg::algorithms::simple_offsets_in_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A "simple" model for path position getting for debugging. </p>

</div>
</div>
<a id="a9e4cebdfc1e901db4588c4612653df96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4cebdfc1e901db4588c4612653df96">&#9670;&nbsp;</a></span>simplify_siblings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::algorithms::simplify_siblings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html">handlegraph::MutablePathDeletableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>can_merge</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simplify siblings in the given graph.</p>
<p>When one base has two successors with the same base value, and those successors have the same set of predecessors, the successors will be merged.</p>
<p>Performs only a subset of the possible merges. Can only merge in from one side of a given node in a single invocation. Returns true if it made progress and there may be more merging to do.</p>
<p>Preserves paths.</p>
<p>Optional can_merge callback will only let nodes get merged together if this pairwise check returns true. </p>

</div>
</div>
<a id="ac7e7cecbe08dfe8b3316a90204c2ab43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7e7cecbe08dfe8b3316a90204c2ab43">&#9670;&nbsp;</a></span>sort_and_shadow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::sort_and_shadow </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get rid of items that are shadowed or contained by (or are identical to) others.</p>
<p>Erases items that didn't survive from indexes, and sorts them by read start position. </p>

</div>
</div>
<a id="afb0c2a9008815cae2b118a30b7c2fc75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0c2a9008815cae2b118a30b7c2fc75">&#9670;&nbsp;</a></span>sort_and_shadow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::sort_and_shadow </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>items</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get rid of items that are shadowed or contained by (or are identical to) others.</p>
<p>Erases items that didn't survive from items, and sorts them by read start position. </p>

</div>
</div>
<a id="ad8e5913b682c7c14f119543eca7e7548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e5913b682c7c14f119543eca7e7548">&#9670;&nbsp;</a></span>sort_path_offsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::sort_path_offsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a> &amp;&#160;</td>
          <td class="paramname"><em>offsets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort path offsets, so <a class="el" href="namespacevg_1_1algorithms.html#a9ce4dabb6661657c7d72593afc3f41df">intersect_path_offsets()</a> can use them as a target. </p>

</div>
</div>
<a id="a64bd6b3ff0d2e22bf752e29e3522a98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bd6b3ff0d2e22bf752e29e3522a98d">&#9670;&nbsp;</a></span>sorted_id_ranges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &gt; vg::algorithms::sorted_id_ranges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a sorted list of inclusive ranges of IDs used in the given HandleGraph. </p>

</div>
</div>
<a id="a7215192f2cc6536b6b3aadef4e95c64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7215192f2cc6536b6b3aadef4e95c64a">&#9670;&nbsp;</a></span>three_edge_connected_component_merges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TECCNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::three_edge_connected_component_merges </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>for_each_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(TECCNode, const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>for_each_connected_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(TECCNode, TECCNode)&gt; &amp;&#160;</td>
          <td class="paramname"><em>same_component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the three-edge-connected components of an arbitrary graph (not necessarily a handle graph). Only recognizes one kind of edge and one kind of node. Nodes are arbitrary value types (which may need to be hashable).</p>
<p>Takes a function that loops an iteratee over all nodes, and a function that, given a node, loops an iteratee over all nodes connected to it.</p>
<p>Calls same_component with pairs of nodes in (at least) a spanning tree of the set of nodes in each component (not restricted to the input graph). Doing merge operations on a union-find can get you the set of components. The callback MUST NOT modify the graph!</p>
<p>If you have a graph where you can easily rank the nodes, don't use this. Use <a class="el" href="namespacevg_1_1algorithms.html#a34c4a74208a88c0f956e697d5e183f5c">three_edge_connected_components_dense()</a> instead. The first thing this function does is asign nodes a dense, 0-based rank space. <br  />
 </p>

</div>
</div>
<a id="a4d4b7c6814fb1f53a83c2e8355d72efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4b7c6814fb1f53a83c2e8355d72efa">&#9670;&nbsp;</a></span>three_edge_connected_component_merges_dense()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::three_edge_connected_component_merges_dense </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(size_t, const function&lt; void(size_t)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>for_each_connected_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(size_t, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>same_component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the three-edge-connected components of an arbitrary graph (not necessarily a handle graph). Only recognizes one kind of edge and one kind of node. Nodes are dense positive integers starting with 0.</p>
<p>Takes a total node count, a suggested root (or 0), and a function that, given a node, loops an iteratee over all nodes connected to it.</p>
<p>Calls same_component with pairs of nodes in (at least) a spanning tree of the set of nodes in each component (not restricted to the input graph). Doing merge operations on a union-find can get you the set of components. The callback MUST NOT modify the graph! </p>
<p>This defines the data we track for each node in the graph</p>
<p>When in the DFS were we first visited?</p>
<p>When in the DFS were we last visited? Needed for finding replacement neighbors to implement path range absorption in part 1.3, when we're asked for a range to a neighbor that got eaten.</p>
<p>What is our "low point" in the search. This is the earliest dfs_counter for a node that this node or any node in its DFS subtree has a back-edge to.</p>
<p>What is the effective degree of this node in the graph with all the absorb-eject modifications applied?</p>
<p>What node has the continuation of this node's path? If equal to <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">numeric_limits&lt;number_t&gt;::max()</a>, the path ends after here. The node's path is the path from this node, into its DFS subtree, to (one of) the nodes in the subtree that has the back-edge that caused this node's low point to be so low. Basically a low point traceback.</p>
<p>Is this node actually on its own path? Nodes can be removed from their paths if those nodes don't matter any more (i.e. got absorbed) but their paths still need to be tails for other paths.</p>
<p>Has the node been visited yet? Must be 0. TODO: Move to its own vector to make zeroing them all free-ish with page table shenanigans.</p>
<p>Track the node that this stack frame represents</p>
<p>Track all the neighbors left to visit. When we visit a neighbor we pop it off the back.</p>
<p>When we look at the neighbors, we need to be able to tell the tree edge to the parent from further back edges to the parent. So we have a flag for whether we have seen the parent tree edge already, and the first neighbors entry that is our parent will get called the tree edge.</p>
<p>Track whether we made a recursive DFS call into the last neighbor or not. If we did, we need to do some work when we come out of it and return to this frame.</p>

</div>
</div>
<a id="ae4677e69f0b8ceb8580bc019cc8fbea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4677e69f0b8ceb8580bc019cc8fbea8">&#9670;&nbsp;</a></span>three_edge_connected_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TECCNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::three_edge_connected_components </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>for_each_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(TECCNode, const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>for_each_connected_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const function&lt; void(const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>component_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the three-edge-connected components of an arbitrary graph (not necessarily a handle graph). Only recognizes one kind of edge and one kind of node. Nodes are arbitrary value types (which may need to be hashable).</p>
<p>Takes a function that loops an iteratee over all nodes, and a function that, given a node, loops an iteratee over all nodes connected to it.</p>
<p>For each component identified, calls the given callback with a function that iterates over all nodes in the component.</p>
<p>If you have a graph where you can easily rank the nodes, don't use this. Use <a class="el" href="namespacevg_1_1algorithms.html#a34c4a74208a88c0f956e697d5e183f5c">three_edge_connected_components_dense()</a> instead. The first thing this function does is asign nodes a dense, 0-based rank space. <br  />
 </p>

</div>
</div>
<a id="a34c4a74208a88c0f956e697d5e183f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c4a74208a88c0f956e697d5e183f5c">&#9670;&nbsp;</a></span>three_edge_connected_components_dense()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::three_edge_connected_components_dense </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(size_t, const function&lt; void(size_t)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>for_each_connected_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const function&lt; void(const function&lt; void(size_t)&gt; &amp;)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>component_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the three-edge-connected components of an arbitrary graph (not necessarily a handle graph). Only recognizes one kind of edge and one kind of node. Nodes are dense positive integers starting with 0.</p>
<p>Takes a total node count, a suggested root (or 0), and a function that, given a node, loops an iteratee over all nodes connected to it.</p>
<p>For each component identified, calls the given callback with a function that iterates over all nodes in the component. </p>

</div>
</div>
<a id="a57de725b70b138394479863428f9d2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57de725b70b138394479863428f9d2eb">&#9670;&nbsp;</a></span>three_edge_connected_components_dense_cactus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::three_edge_connected_components_dense_cactus </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(size_t, const function&lt; void(size_t)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>for_each_connected_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const function&lt; void(const function&lt; void(size_t)&gt; &amp;)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>component_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the three-edge-connected components of an arbitrary graph (not necessarily a handle graph). Only recognizes one kind of edge and one kind of node. Nodes are dense positive integers starting with 0.</p>
<p>Wraps the known good the 3 edge connected components algorithm from the pinchesAndCacti library.</p>
<p>Takes a total node count, and a function that, given a node, loops an iteratee over all nodes connected to it.</p>
<p>For each component identified, calls the given callback with a function that iterates over all nodes in the component. </p>

</div>
</div>
<a id="a6341683f1b89495d2ac1558ed2875343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6341683f1b89495d2ac1558ed2875343">&#9670;&nbsp;</a></span>traverse_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::traverse_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>on_new_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>on_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4af5e9c480c0dc7d0843cf981cd52c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af5e9c480c0dc7d0843cf981cd52c32">&#9670;&nbsp;</a></span>walk_haplotype_frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::algorithms::walk_haplotype_frequency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>haplotypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1algorithms_1_1walk__t.html">walk_t</a> &amp;&#160;</td>
          <td class="paramname"><em>walk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe9cb62b2ae1c6eb08b10f172980788d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9cb62b2ae1c6eb08b10f172980788d">&#9670;&nbsp;</a></span>walk_haplotype_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; vg::algorithms::walk_haplotype_names </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>haplotypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1algorithms_1_1walk__t.html">walk_t</a> &amp;&#160;</td>
          <td class="paramname"><em>walk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08c6d85f2dc09c22c5d14ed81808769e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c6d85f2dc09c22c5d14ed81808769e">&#9670;&nbsp;</a></span>widest_dijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; double, vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &gt; vg::algorithms::widest_dijkstra </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; double(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>node_weight_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; double(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>edge_weight_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>is_node_ignored_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; bool(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>is_edge_ignored_callbback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>greedy_avg</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This Dijkstra is the same underlying algorithm as the one in dijkstra.hpp but the interface is different enough that I opted to make it a seprate thing rather than add loads of optional arguments. The key differences are these generalizations: &ndash; looks for the "widest" path (maximum minimum weight) instead of shortest &ndash; counts node and edge weights (via callbakcs) &ndash; returns the path as well as the score &ndash; option for ignoring certain nodes and edges in search (required by Yen's algorithm) &ndash; greedy_avg option switches the algorithm to a heuristic (no optimal guarantee) search using the running averages support instead of min-flow support as objective function. </p>

</div>
</div>
<a id="ad9a715606bdd30499dc9db88583c6573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a715606bdd30499dc9db88583c6573">&#9670;&nbsp;</a></span>yens_k_widest_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; double, vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &gt; &gt; vg::algorithms::yens_k_widest_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; double(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>node_weight_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; double(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>edge_weight_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>greedy_avg</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_path_length</em> = <code>numeric_limits&lt;&#160;size_t&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the k widest paths Search is aborted (and current list returned) if a path longer than max_path_length is added to the results </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="a64f4abe5d8279f14a52b56ffb47fff34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f4abe5d8279f14a52b56ffb47fff34">&#9670;&nbsp;</a></span>PRUNE_THREAD_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t vg::algorithms::PRUNE_THREAD_BUFFER_SIZE = 1024 * 1024</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
