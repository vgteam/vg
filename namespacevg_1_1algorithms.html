<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::algorithms Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="namespacevg_1_1algorithms.html">algorithms</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">vg::algorithms Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1algorithms_1_1Edge.html">Edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1algorithms_1_1GFADuplicatePathError.html">GFADuplicatePathError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1algorithms_1_1GFAFormatError.html">GFAFormatError</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This exception will be thrown if the GFA data is not acceptable.  <a href="structvg_1_1algorithms_1_1GFAFormatError.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1algorithms_1_1GFAIDMapInfo.html">GFAIDMapInfo</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1algorithms_1_1GFAParser.html">GFAParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1algorithms_1_1kmer__t.html">kmer_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stores a kmer in the context of a graph.  <a href="structvg_1_1algorithms_1_1kmer__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1algorithms_1_1Node.html">Node</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1algorithms_1_1walk__t.html">walk_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Record a &lt;=k-length walk in the context of a graph.  <a href="structvg_1_1algorithms_1_1walk__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad64245b7dca5a8144ae8720a92b65685"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ad64245b7dca5a8144ae8720a92b65685">transition_iteratee</a> = std::function&lt; void(size_t from_anchor, size_t to_anchor, size_t read_distance, size_t graph_distance)&gt;</td></tr>
<tr class="separator:ad64245b7dca5a8144ae8720a92b65685"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79c214c1e7f1d7cc5fe322b8c9fb260c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a79c214c1e7f1d7cc5fe322b8c9fb260c">transition_iterator</a> = std::function&lt; void(const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;to_chain, const SnarlDistanceIndex &amp;distance_index, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, size_t max_indel_bases, const <a class="el" href="namespacevg_1_1algorithms.html#ad64245b7dca5a8144ae8720a92b65685">transition_iteratee</a> &amp;callback)&gt;</td></tr>
<tr class="separator:a79c214c1e7f1d7cc5fe322b8c9fb260c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf8cb40a8f834b42f1ec89af0ef140b9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#acf8cb40a8f834b42f1ec89af0ef140b9">BinnedDepthIndex</a> = unordered_map&lt; string, map&lt; size_t, map&lt; size_t, pair&lt; float, float &gt; &gt;&gt; &gt;</td></tr>
<tr class="separator:acf8cb40a8f834b42f1ec89af0ef140b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6474017f8ab54b0c6e20095206a880a8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a> = unordered_map&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, vector&lt; pair&lt; size_t, bool &gt; &gt;&gt;</td></tr>
<tr class="separator:a6474017f8ab54b0c6e20095206a880a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5af5b6f1083925669832ae59d0e549e7"><td class="memTemplParams" colspan="2">template&lt;class DistHeuristic &gt; </td></tr>
<tr class="memitem:a5af5b6f1083925669832ae59d0e549e7"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a5af5b6f1083925669832ae59d0e549e7">a_star</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;pos_1, const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;pos_2, const DistHeuristic &amp;dist_heuristic, bool find_min=true, int64_t extremal_distance=numeric_limits&lt; int64_t &gt;::max(), bool monotonic_heuristic=true)</td></tr>
<tr class="separator:a5af5b6f1083925669832ae59d0e549e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aead0aa069554bbc1a3fcce05ca4d1127"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aead0aa069554bbc1a3fcce05ca4d1127">alignment_path_offsets</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;graph, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, bool just_min, bool nearby, int64_t search_limit, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *path_filter)</td></tr>
<tr class="separator:aead0aa069554bbc1a3fcce05ca4d1127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0cecedaa8dd475e634b513af5be028b"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ad0cecedaa8dd475e634b513af5be028b">multipath_alignment_path_offsets</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;graph, const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;mp_aln, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *path_filter)</td></tr>
<tr class="separator:ad0cecedaa8dd475e634b513af5be028b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c1bbf062eb429066c7b46da24704cdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a3c1bbf062eb429066c7b46da24704cdf">annotate_with_initial_path_positions</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;graph, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, int64_t search_limit, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *path_filter)</td></tr>
<tr class="separator:a3c1bbf062eb429066c7b46da24704cdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2151b93596855953805b98d78ac83c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ad2151b93596855953805b98d78ac83c6">annotate_with_node_path_positions</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;graph, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, int64_t search_limit, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *path_filter)</td></tr>
<tr class="separator:ad2151b93596855953805b98d78ac83c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e67738fef35591e953849387e94d58"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a66e67738fef35591e953849387e94d58">annotate_with_path_positions</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;graph, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, bool just_min, int64_t search_limit, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *path_filter)</td></tr>
<tr class="separator:a66e67738fef35591e953849387e94d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29c8bb498d4cab7c964783dbf98dae28"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a29c8bb498d4cab7c964783dbf98dae28">annotate_with_initial_path_positions</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;graph, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alns, int64_t search_limit, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *path_filter)</td></tr>
<tr class="separator:a29c8bb498d4cab7c964783dbf98dae28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae18b50d29d9accb763b44d6e065dac58"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ae18b50d29d9accb763b44d6e065dac58">min_approx_path_distance</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph, const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;pos1, const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;pos2, uint64_t max_search)</td></tr>
<tr class="memdesc:ae18b50d29d9accb763b44d6e065dac58"><td class="mdescLeft">&#160;</td><td class="mdescRight">use the embedded paths to get an estimated minimum distance between the positions  <a href="namespacevg_1_1algorithms.html#ae18b50d29d9accb763b44d6e065dac58">More...</a><br /></td></tr>
<tr class="separator:ae18b50d29d9accb763b44d6e065dac58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0e29a34fb2e1f712751a8a8fda6f03"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a0d0e29a34fb2e1f712751a8a8fda6f03">back_translate_in_place</a> (const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> *translation, <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:a0d0e29a34fb2e1f712751a8a8fda6f03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fb0b1f6ca5892b532032ecddd8fde19"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a0fb0b1f6ca5892b532032ecddd8fde19">back_translate_in_place</a> (const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> *translation, <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;snarl)</td></tr>
<tr class="separator:a0fb0b1f6ca5892b532032ecddd8fde19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0efe72c9db6dd4c1828dae311795e9b0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a0efe72c9db6dd4c1828dae311795e9b0">back_translate_in_place</a> (const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> *translation, <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;traversal)</td></tr>
<tr class="separator:a0efe72c9db6dd4c1828dae311795e9b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e04f69397f1d7e1f33b99f0ff145af5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a0e04f69397f1d7e1f33b99f0ff145af5">back_translate_in_place</a> (const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> *translation, <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit)</td></tr>
<tr class="separator:a0e04f69397f1d7e1f33b99f0ff145af5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafbc78daa41b0c018cd39b7cccbaf53a"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aafbc78daa41b0c018cd39b7cccbaf53a">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;anchor)</td></tr>
<tr class="memdesc:aafbc78daa41b0c018cd39b7cccbaf53a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Explain an <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> to the given stream.  <a href="namespacevg_1_1algorithms.html#aafbc78daa41b0c018cd39b7cccbaf53a">More...</a><br /></td></tr>
<tr class="separator:aafbc78daa41b0c018cd39b7cccbaf53a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503ad2215490c5c599530d7331a70120"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a503ad2215490c5c599530d7331a70120">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a> &amp;value)</td></tr>
<tr class="memdesc:a503ad2215490c5c599530d7331a70120"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print operator.  <a href="namespacevg_1_1algorithms.html#a503ad2215490c5c599530d7331a70120">More...</a><br /></td></tr>
<tr class="separator:a503ad2215490c5c599530d7331a70120"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeeaa766337fc50f0a9b4d3214271923"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aaeeaa766337fc50f0a9b4d3214271923">sort_anchor_indexes</a> (const std::vector&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;items, std::vector&lt; size_t &gt; &amp;indexes)</td></tr>
<tr class="separator:aaeeaa766337fc50f0a9b4d3214271923"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e2917f0a06c55852e4ef044548f2bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg_1_1algorithms.html#a79c214c1e7f1d7cc5fe322b8c9fb260c">transition_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ac8e2917f0a06c55852e4ef044548f2bb">lookback_transition_iterator</a> (size_t max_lookback_bases, size_t min_lookback_items, size_t lookback_item_hard_cap)</td></tr>
<tr class="separator:ac8e2917f0a06c55852e4ef044548f2bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa186cef438679cb79232d24f64be1f89"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg_1_1algorithms.html#a79c214c1e7f1d7cc5fe322b8c9fb260c">transition_iterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aa186cef438679cb79232d24f64be1f89">zip_tree_transition_iterator</a> (const std::vector&lt; <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html">SnarlDistanceIndexClusterer::Seed</a> &gt; &amp;seeds, const <a class="el" href="classvg_1_1ZipCodeTree.html">ZipCodeTree</a> &amp;zip_code_tree, size_t max_graph_lookback_bases, size_t max_read_lookback_bases)</td></tr>
<tr class="separator:aa186cef438679cb79232d24f64be1f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc2933db32d78a14a8e439f7e9643ab"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#abdc2933db32d78a14a8e439f7e9643ab">score_chain_gap</a> (size_t distance_difference, size_t base_seed_length)</td></tr>
<tr class="separator:abdc2933db32d78a14a8e439f7e9643ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fda86d465d26d7f101e00f3431564e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a2fda86d465d26d7f101e00f3431564e8">chain_items_dp</a> (vector&lt; <a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a> &gt; &amp;chain_scores, const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;to_chain, const SnarlDistanceIndex &amp;distance_index, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, int gap_open, int gap_extension, const <a class="el" href="namespacevg_1_1algorithms.html#a79c214c1e7f1d7cc5fe322b8c9fb260c">transition_iterator</a> &amp;for_each_transition, int item_bonus, double item_scale, double gap_scale, double points_per_possible_match, size_t max_indel_bases, bool show_work)</td></tr>
<tr class="separator:a2fda86d465d26d7f101e00f3431564e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a9239fd23ed6838263f4dd05828d18c"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; vector&lt; size_t &gt;, int &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a7a9239fd23ed6838263f4dd05828d18c">chain_items_traceback</a> (const vector&lt; <a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a> &gt; &amp;chain_scores, const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;to_chain, const <a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a> &amp;best_past_ending_score_ever, int item_bonus, double item_scale, size_t max_tracebacks)</td></tr>
<tr class="separator:a7a9239fd23ed6838263f4dd05828d18c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67dc5da4c5935ba307303798c521c1c8"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; int, vector&lt; size_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a67dc5da4c5935ba307303798c521c1c8">find_best_chains</a> (const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;to_chain, const SnarlDistanceIndex &amp;distance_index, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, int gap_open, int gap_extension, size_t max_chains, const <a class="el" href="namespacevg_1_1algorithms.html#a79c214c1e7f1d7cc5fe322b8c9fb260c">transition_iterator</a> &amp;for_each_transition, int item_bonus, double item_scale, double gap_scale, double points_per_possible_match, size_t max_indel_bases, bool show_work)</td></tr>
<tr class="separator:a67dc5da4c5935ba307303798c521c1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f3eeb71fb9bd08889b08aa20fe9605"><td class="memItemLeft" align="right" valign="top">pair&lt; int, vector&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ac3f3eeb71fb9bd08889b08aa20fe9605">find_best_chain</a> (const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;to_chain, const SnarlDistanceIndex &amp;distance_index, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, int gap_open, int gap_extension, const <a class="el" href="namespacevg_1_1algorithms.html#a79c214c1e7f1d7cc5fe322b8c9fb260c">transition_iterator</a> &amp;for_each_transition, int item_bonus, double item_scale, double gap_scale, double points_per_possible_match, size_t max_indel_bases)</td></tr>
<tr class="separator:ac3f3eeb71fb9bd08889b08aa20fe9605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91b7ceb67d3923a4c5cace56a5c4f6e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ad91b7ceb67d3923a4c5cace56a5c4f6e">score_best_chain</a> (const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;to_chain, const SnarlDistanceIndex &amp;distance_index, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, int gap_open, int gap_extension)</td></tr>
<tr class="separator:ad91b7ceb67d3923a4c5cace56a5c4f6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b788763f4e6747ba55e5340de9da855"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a0b788763f4e6747ba55e5340de9da855">get_graph_distance</a> (const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;from, const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;to, const SnarlDistanceIndex &amp;distance_index, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, size_t distance_limit=std::numeric_limits&lt; size_t &gt;::max())</td></tr>
<tr class="memdesc:a0b788763f4e6747ba55e5340de9da855"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get distance in the graph, or <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">std::numeric_limits&lt;size_t&gt;::max()</a> if unreachable or beyond the limit.  <a href="namespacevg_1_1algorithms.html#a0b788763f4e6747ba55e5340de9da855">More...</a><br /></td></tr>
<tr class="separator:a0b788763f4e6747ba55e5340de9da855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8762b533e64039ce1a917b047097d8"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a5d8762b533e64039ce1a917b047097d8">get_read_distance</a> (const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;from, const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;to)</td></tr>
<tr class="memdesc:a5d8762b533e64039ce1a917b047097d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get distance in the read, or <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">std::numeric_limits&lt;size_t&gt;::max()</a> if unreachable.  <a href="namespacevg_1_1algorithms.html#a5d8762b533e64039ce1a917b047097d8">More...</a><br /></td></tr>
<tr class="separator:a5d8762b533e64039ce1a917b047097d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6341683f1b89495d2ac1558ed2875343"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a6341683f1b89495d2ac1558ed2875343">traverse_components</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, function&lt; void(void)&gt; &amp;on_new_comp, function&lt; void(<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>)&gt; &amp;on_node)</td></tr>
<tr class="separator:a6341683f1b89495d2ac1558ed2875343"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84bd9740e748431857b5fd8a0397183"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aa84bd9740e748431857b5fd8a0397183">num_components</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph)</td></tr>
<tr class="separator:aa84bd9740e748431857b5fd8a0397183"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5fdb03a21f88395e1d69f53821ae59"><td class="memItemLeft" align="right" valign="top">vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a8e5fdb03a21f88395e1d69f53821ae59">component_sizes</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph)</td></tr>
<tr class="separator:a8e5fdb03a21f88395e1d69f53821ae59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51f810108840ab4014eb58b2bfe19ac1"><td class="memItemLeft" align="right" valign="top">vector&lt; unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a51f810108840ab4014eb58b2bfe19ac1">component_paths</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;graph)</td></tr>
<tr class="separator:a51f810108840ab4014eb58b2bfe19ac1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd891e00c4846e53f760d504434ead12"><td class="memTemplParams" colspan="2">template&lt;typename Int1 , typename Int2 &gt; </td></tr>
<tr class="memitem:acd891e00c4846e53f760d504434ead12"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#acd891e00c4846e53f760d504434ead12">reallocate_atomic_int_vector</a> (vector&lt; atomic&lt; Int1 &gt;&gt; *&amp;vec1, vector&lt; atomic&lt; Int2 &gt;&gt; *&amp;vec2)</td></tr>
<tr class="separator:acd891e00c4846e53f760d504434ead12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10b07f6f41f8dd36c5d3b1ff9a03ce93"><td class="memItemLeft" align="right" valign="top">vector&lt; unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a10b07f6f41f8dd36c5d3b1ff9a03ce93">component_paths_parallel</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;graph)</td></tr>
<tr class="separator:a10b07f6f41f8dd36c5d3b1ff9a03ce93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b477c1e232c9d4f1e689a95dd55861d"><td class="memTemplParams" colspan="2">template&lt;typename Collection &gt; </td></tr>
<tr class="memitem:a2b477c1e232c9d4f1e689a95dd55861d"><td class="memTemplItemLeft" align="right" valign="top">size_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a2b477c1e232c9d4f1e689a95dd55861d">count_covered</a> (Collection &amp;segments)</td></tr>
<tr class="separator:a2b477c1e232c9d4f1e689a95dd55861d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd431ebd9786d796f708a7046e643e2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#abd431ebd9786d796f708a7046e643e2e">packed_depths</a> (const <a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;packer, const string &amp;path_name, size_t min_coverage, ostream &amp;out_stream)</td></tr>
<tr class="separator:abd431ebd9786d796f708a7046e643e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62ebbcbfe1250940eb8ebf0a2dcbc19a"><td class="memItemLeft" align="right" valign="top">pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a62ebbcbfe1250940eb8ebf0a2dcbc19a">packed_depth_of_bin</a> (const <a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;packer, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> start_step, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> end_plus_one_step, size_t min_coverage, bool include_deletions)</td></tr>
<tr class="separator:a62ebbcbfe1250940eb8ebf0a2dcbc19a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fb3df22b1d7955546bbcc8c438f6efc"><td class="memItemLeft" align="right" valign="top">vector&lt; tuple&lt; size_t, size_t, double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a8fb3df22b1d7955546bbcc8c438f6efc">binned_packed_depth</a> (const <a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;packer, const string &amp;path_name, size_t bin_size, size_t min_coverage, bool include_deletions)</td></tr>
<tr class="separator:a8fb3df22b1d7955546bbcc8c438f6efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05e00ad1e6a7b34cde8c37aa9dbbdbc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg_1_1algorithms.html#acf8cb40a8f834b42f1ec89af0ef140b9">BinnedDepthIndex</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#af05e00ad1e6a7b34cde8c37aa9dbbdbc">binned_packed_depth_index</a> (const <a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;packer, const vector&lt; string &gt; &amp;path_names, size_t min_bin_size, size_t max_bin_size, double exp_growth_factor, size_t min_coverage, bool include_deletions, bool std_err)</td></tr>
<tr class="separator:af05e00ad1e6a7b34cde8c37aa9dbbdbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4152fa019243d9fd4c41c73fafce2241"><td class="memItemLeft" align="right" valign="top">pair&lt; float, float &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a4152fa019243d9fd4c41c73fafce2241">get_depth_from_index</a> (const <a class="el" href="namespacevg_1_1algorithms.html#acf8cb40a8f834b42f1ec89af0ef140b9">BinnedDepthIndex</a> &amp;depth_index, const string &amp;path_name, size_t start_offset, size_t end_offset)</td></tr>
<tr class="memdesc:a4152fa019243d9fd4c41c73fafce2241"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query index created above.  <a href="namespacevg_1_1algorithms.html#a4152fa019243d9fd4c41c73fafce2241">More...</a><br /></td></tr>
<tr class="separator:a4152fa019243d9fd4c41c73fafce2241"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16bd0de261a829b2d81ec48eed9d6482"><td class="memItemLeft" align="right" valign="top">pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a16bd0de261a829b2d81ec48eed9d6482">sample_mapping_depth</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const string &amp;input_filename, size_t max_nodes, size_t random_seed, size_t min_coverage, size_t min_mapq, const string &amp;format)</td></tr>
<tr class="separator:a16bd0de261a829b2d81ec48eed9d6482"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80703607cfe21f1f593f7b2f03c08b40"><td class="memItemLeft" align="right" valign="top">pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a80703607cfe21f1f593f7b2f03c08b40">sample_gam_depth</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alignments, size_t max_nodes, size_t random_seed, size_t min_coverage, size_t min_mapq)</td></tr>
<tr class="separator:a80703607cfe21f1f593f7b2f03c08b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85250c33b7d32346be371ab7e4404471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a85250c33b7d32346be371ab7e4404471">path_depths</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;graph, const string &amp;path_name, size_t min_coverage, bool count_cycles, ostream &amp;out_stream)</td></tr>
<tr class="separator:a85250c33b7d32346be371ab7e4404471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c66507d55ed6e10e9d77e1281d4bcfc"><td class="memItemLeft" align="right" valign="top">pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a8c66507d55ed6e10e9d77e1281d4bcfc">path_depth_of_bin</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;graph, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> start_step, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a> end_plus_one_step, size_t min_coverage, bool count_cycles)</td></tr>
<tr class="memdesc:a8c66507d55ed6e10e9d77e1281d4bcfc"><td class="mdescLeft">&#160;</td><td class="mdescRight">like packed_depth_of_bin (above), but use paths (as in path_depths) for measuring coverage  <a href="namespacevg_1_1algorithms.html#a8c66507d55ed6e10e9d77e1281d4bcfc">More...</a><br /></td></tr>
<tr class="separator:a8c66507d55ed6e10e9d77e1281d4bcfc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d48562b230a318ee15820aa508867fc"><td class="memItemLeft" align="right" valign="top">vector&lt; tuple&lt; size_t, size_t, double, double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a1d48562b230a318ee15820aa508867fc">binned_path_depth</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;graph, const string &amp;path_name, size_t bin_size, size_t min_coverage, bool count_cycles)</td></tr>
<tr class="separator:a1d48562b230a318ee15820aa508867fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a244822514c71473756cfd5ad87f79e08"><td class="memItemLeft" align="right" valign="top">pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a244822514c71473756cfd5ad87f79e08">sample_mapping_depth</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alignments, size_t max_nodes, size_t random_seed, size_t min_coverage, size_t min_mapq)</td></tr>
<tr class="memdesc:a244822514c71473756cfd5ad87f79e08"><td class="mdescLeft">&#160;</td><td class="mdescRight">As above, but read a vector instead of a stream.  <a href="namespacevg_1_1algorithms.html#a244822514c71473756cfd5ad87f79e08">More...</a><br /></td></tr>
<tr class="separator:a244822514c71473756cfd5ad87f79e08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2ca7e29cbf4769c5f6432499a45e23"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a2a2ca7e29cbf4769c5f6432499a45e23">dfs</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;handle_begin_fn, const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;handle_end_fn, const function&lt; bool(void)&gt; &amp;break_fn, const function&lt; void(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; &amp;edge_fn, const function&lt; void(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; &amp;tree_fn, const function&lt; void(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; &amp;edge_curr_fn, const function&lt; void(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; &amp;edge_cross_fn, const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;sources, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;sinks)</td></tr>
<tr class="separator:a2a2ca7e29cbf4769c5f6432499a45e23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade95900b3f3715ae3ecf9b3aee79961f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ade95900b3f3715ae3ecf9b3aee79961f">dfs</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;handle_begin_fn, const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;handle_end_fn, const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;sources, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;sinks)</td></tr>
<tr class="separator:ade95900b3f3715ae3ecf9b3aee79961f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac89d8d2356483ef348082609dc310b80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ac89d8d2356483ef348082609dc310b80">dfs</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;handle_begin_fn, const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;handle_end_fn, const function&lt; bool(void)&gt; &amp;break_fn)</td></tr>
<tr class="separator:ac89d8d2356483ef348082609dc310b80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ba5a6719f9f5496130c72a047ad890"><td class="memItemLeft" align="right" valign="top">list&lt; bdsg::HashGraph &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a38ba5a6719f9f5496130c72a047ad890">disjoint_components</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph)</td></tr>
<tr class="separator:a38ba5a6719f9f5496130c72a047ad890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4cb6665721af1f7c749ca8f73472d6c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aa4cb6665721af1f7c749ca8f73472d6c">is_head_node</a> (<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> h, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *g)</td></tr>
<tr class="separator:aa4cb6665721af1f7c749ca8f73472d6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a187fd628ac942c540a1a5fde0e27b0ef"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a187fd628ac942c540a1a5fde0e27b0ef">distance_to_head</a> (<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> h, int32_t limit, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="separator:a187fd628ac942c540a1a5fde0e27b0ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33aca5bac60aa4d0a4c402ed607b06a3"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a33aca5bac60aa4d0a4c402ed607b06a3">distance_to_head</a> (<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> h, int32_t limit, int32_t dist, unordered_set&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;seen, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="separator:a33aca5bac60aa4d0a4c402ed607b06a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8e4eb795d14d441c4b2944c070a1d78"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ac8e4eb795d14d441c4b2944c070a1d78">is_tail_node</a> (<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> h, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *g)</td></tr>
<tr class="separator:ac8e4eb795d14d441c4b2944c070a1d78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a458c768a87a1182eae38b362aa7b5ad7"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a458c768a87a1182eae38b362aa7b5ad7">distance_to_tail</a> (<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> h, int32_t limit, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="separator:a458c768a87a1182eae38b362aa7b5ad7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8fb0ce9a4ccbb1505e661a1caa266f8"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ac8fb0ce9a4ccbb1505e661a1caa266f8">distance_to_tail</a> (<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> h, int32_t limit, int32_t dist, unordered_set&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;seen, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="separator:ac8fb0ce9a4ccbb1505e661a1caa266f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a354ea4a2a6aed208945fc0994ec50d9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a354ea4a2a6aed208945fc0994ec50d9d">expand_context_by_steps</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *subgraph, int64_t dist, bool expand_forward, bool expand_backward)</td></tr>
<tr class="separator:a354ea4a2a6aed208945fc0994ec50d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a238775e0e0ecf0b7576f7c2265dfd5e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a238775e0e0ecf0b7576f7c2265dfd5e0">expand_context_by_length</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *subgraph, int64_t dist, bool expand_forward, bool expand_backward)</td></tr>
<tr class="separator:a238775e0e0ecf0b7576f7c2265dfd5e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec7fcd701af4fdcbb87e83f0ea5b420a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aec7fcd701af4fdcbb87e83f0ea5b420a">expand_context</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *subgraph, int64_t dist, bool use_steps, bool expand_forward, bool expand_backward)</td></tr>
<tr class="separator:aec7fcd701af4fdcbb87e83f0ea5b420a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a0c0c6d333cb438f96e5df6faec3621"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a8a0c0c6d333cb438f96e5df6faec3621">expand_context_with_paths</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> *source, <a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *subgraph, int64_t dist, bool use_steps, bool expand_forward, bool expand_backward)</td></tr>
<tr class="separator:a8a0c0c6d333cb438f96e5df6faec3621"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0d0446bde00e10bd77816c968ae97b0"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ac0d0446bde00e10bd77816c968ae97b0">extract_connecting_graph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *source, <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> *into, int64_t max_len, <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> pos_1, <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> pos_2, bool strict_max_len)</td></tr>
<tr class="separator:ac0d0446bde00e10bd77816c968ae97b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4270da794ad0185dacef1874a1e4d3c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a4270da794ad0185dacef1874a1e4d3c2">extract_containing_graph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *into, const vector&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &gt; &amp;positions, const vector&lt; size_t &gt; &amp;forward_search_lengths, const vector&lt; size_t &gt; &amp;backward_search_lengths, size_t reversing_walk_length)</td></tr>
<tr class="separator:a4270da794ad0185dacef1874a1e4d3c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ecd79b7d4b622b583a8e08df594e45c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a0ecd79b7d4b622b583a8e08df594e45c">extract_containing_graph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *into, const vector&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &gt; &amp;positions, size_t max_dist, size_t reversing_walk_length)</td></tr>
<tr class="separator:a0ecd79b7d4b622b583a8e08df594e45c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31b1b707c93f96d6f013e579c4d8783"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ab31b1b707c93f96d6f013e579c4d8783">extract_containing_graph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *into, const vector&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &gt; &amp;positions, const vector&lt; size_t &gt; &amp;position_max_dist, size_t reversing_walk_length)</td></tr>
<tr class="separator:ab31b1b707c93f96d6f013e579c4d8783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f600eb589d48607c2616bed69ff2e27"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a1f600eb589d48607c2616bed69ff2e27">extract_extending_graph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *source, <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> *into, int64_t max_dist, <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> pos, bool backward, bool preserve_cycles_on_src_node)</td></tr>
<tr class="separator:a1f600eb589d48607c2616bed69ff2e27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92780d34d13ab2a6be9fe477543179ce"><td class="memItemLeft" align="right" valign="top">const gbwt::GBWT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a92780d34d13ab2a6be9fe477543179ce">find_gbwt</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="separator:a92780d34d13ab2a6be9fe477543179ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5783b30c1ad6ea3ff4bc4576f447b615"><td class="memItemLeft" align="right" valign="top">const gbwt::GBWT *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a5783b30c1ad6ea3ff4bc4576f447b615">find_gbwt</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, std::unique_ptr&lt; gbwt::GBWT &gt; &amp;holder, const std::string &amp;filename)</td></tr>
<tr class="separator:a5783b30c1ad6ea3ff4bc4576f447b615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8867ea22636dc22aa53bd8fe1d0aaa"><td class="memItemLeft" align="right" valign="top">const gbwtgraph::GBWTGraph *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a1e8867ea22636dc22aa53bd8fe1d0aaa">find_gbwtgraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="separator:a1e8867ea22636dc22aa53bd8fe1d0aaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af38c05b9c1e56c79faccfbbf6b3ade95"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#af38c05b9c1e56c79faccfbbf6b3ade95">find_translation</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="separator:af38c05b9c1e56c79faccfbbf6b3ade95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedfca626dc003dc3fee77c6bbfcde297"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aedfca626dc003dc3fee77c6bbfcde297">gfa_to_handle_graph</a> (const string &amp;filename, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *graph, <a class="el" href="structvg_1_1algorithms_1_1GFAIDMapInfo.html">GFAIDMapInfo</a> *translation)</td></tr>
<tr class="separator:aedfca626dc003dc3fee77c6bbfcde297"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adca14b7dcba0bb21f3fdb0c98d867c72"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#adca14b7dcba0bb21f3fdb0c98d867c72">gfa_to_handle_graph</a> (const string &amp;filename, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *graph, const string &amp;translation_filename)</td></tr>
<tr class="memdesc:adca14b7dcba0bb21f3fdb0c98d867c72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload which serializes its translation to a file internally.  <a href="namespacevg_1_1algorithms.html#adca14b7dcba0bb21f3fdb0c98d867c72">More...</a><br /></td></tr>
<tr class="separator:adca14b7dcba0bb21f3fdb0c98d867c72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a031cb6d0db20a6aaee020c5a6909ba80"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a031cb6d0db20a6aaee020c5a6909ba80">gfa_to_handle_graph</a> (istream &amp;in, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *graph, <a class="el" href="structvg_1_1algorithms_1_1GFAIDMapInfo.html">GFAIDMapInfo</a> *translation=nullptr)</td></tr>
<tr class="memdesc:a031cb6d0db20a6aaee020c5a6909ba80"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a GFA from a stream (assumed not to be seekable or reopenable) into a HandleGraph.  <a href="namespacevg_1_1algorithms.html#a031cb6d0db20a6aaee020c5a6909ba80">More...</a><br /></td></tr>
<tr class="separator:a031cb6d0db20a6aaee020c5a6909ba80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f5c41c06269c778d2c97f39cbc79de8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a9f5c41c06269c778d2c97f39cbc79de8">gfa_to_path_handle_graph</a> (const string &amp;filename, <a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *graph, <a class="el" href="structvg_1_1algorithms_1_1GFAIDMapInfo.html">GFAIDMapInfo</a> *translation=nullptr, int64_t max_rgfa_rank=numeric_limits&lt; int64_t &gt;::max(), unordered_set&lt; <a class="el" href="namespacehandlegraph.html#ab3d3683c53bb48b8af63a6d94497271c">PathSense</a> &gt; *ignore_sense=nullptr)</td></tr>
<tr class="memdesc:a9f5c41c06269c778d2c97f39cbc79de8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as gfa_to_handle_graph but also adds path elements from the GFA to the graph.  <a href="namespacevg_1_1algorithms.html#a9f5c41c06269c778d2c97f39cbc79de8">More...</a><br /></td></tr>
<tr class="separator:a9f5c41c06269c778d2c97f39cbc79de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61f2c7006c531ad5dd319ea30ec0087f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a61f2c7006c531ad5dd319ea30ec0087f">gfa_to_path_handle_graph</a> (const string &amp;filename, <a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *graph, int64_t max_rgfa_rank, const string &amp;translation_filename, unordered_set&lt; <a class="el" href="namespacehandlegraph.html#ab3d3683c53bb48b8af63a6d94497271c">PathSense</a> &gt; *ignore_sense=nullptr)</td></tr>
<tr class="memdesc:a61f2c7006c531ad5dd319ea30ec0087f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Overload which serializes its translation to a file internally.  <a href="namespacevg_1_1algorithms.html#a61f2c7006c531ad5dd319ea30ec0087f">More...</a><br /></td></tr>
<tr class="separator:a61f2c7006c531ad5dd319ea30ec0087f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8baa82611439357dc02996ba17ce6aa9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a8baa82611439357dc02996ba17ce6aa9">gfa_to_path_handle_graph</a> (istream &amp;in, <a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *graph, <a class="el" href="structvg_1_1algorithms_1_1GFAIDMapInfo.html">GFAIDMapInfo</a> *translation=nullptr, int64_t max_rgfa_rank=numeric_limits&lt; int64_t &gt;::max(), unordered_set&lt; <a class="el" href="namespacehandlegraph.html#ab3d3683c53bb48b8af63a6d94497271c">PathSense</a> &gt; *ignore_sense=nullptr)</td></tr>
<tr class="memdesc:a8baa82611439357dc02996ba17ce6aa9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a GFA from a stream (assumed not to be seekable or reopenable) into a PathHandleGraph.  <a href="namespacevg_1_1algorithms.html#a8baa82611439357dc02996ba17ce6aa9">More...</a><br /></td></tr>
<tr class="separator:a8baa82611439357dc02996ba17ce6aa9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54730e9452c2609633da201ba85a8bca"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a54730e9452c2609633da201ba85a8bca">id_order</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *g)</td></tr>
<tr class="separator:a54730e9452c2609633da201ba85a8bca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ce4dabb6661657c7d72593afc3f41df"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a9ce4dabb6661657c7d72593afc3f41df">intersect_path_offsets</a> (const <a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a> &amp;a_offsets, const <a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a> &amp;b_offsets, size_t <a class="el" href="namespacevg.html#a004ed92d4db665ce8ec4e527f150a7c4">maximum_distance</a>)</td></tr>
<tr class="separator:a9ce4dabb6661657c7d72593afc3f41df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8e5913b682c7c14f119543eca7e7548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ad8e5913b682c7c14f119543eca7e7548">sort_path_offsets</a> (<a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a> &amp;offsets)</td></tr>
<tr class="separator:ad8e5913b682c7c14f119543eca7e7548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a633a1600c6a7e447c040fefb1432e508"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a633a1600c6a7e447c040fefb1432e508">jump_along_closest_path</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph, const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;pos, int64_t jump_dist, size_t max_search_dist)</td></tr>
<tr class="separator:a633a1600c6a7e447c040fefb1432e508"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08c6d85f2dc09c22c5d14ed81808769e"><td class="memItemLeft" align="right" valign="top">pair&lt; double, vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a08c6d85f2dc09c22c5d14ed81808769e">widest_dijkstra</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *g, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> source, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> sink, function&lt; double(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; node_weight_callback, function&lt; double(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; edge_weight_callback, function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; is_node_ignored_callback, function&lt; bool(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; is_edge_ignored_callback, bool greedy_avg)</td></tr>
<tr class="separator:a08c6d85f2dc09c22c5d14ed81808769e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9a715606bdd30499dc9db88583c6573"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; double, vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ad9a715606bdd30499dc9db88583c6573">yens_k_widest_paths</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *g, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> source, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> sink, size_t K, function&lt; double(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; node_weight_callback, function&lt; double(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; edge_weight_callback, bool greedy_avg, size_t max_path_length)</td></tr>
<tr class="separator:ad9a715606bdd30499dc9db88583c6573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30b8fd7a0d56e1827faa3aa56c8828f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a30b8fd7a0d56e1827faa3aa56c8828f0">for_each_kmer</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, size_t k, size_t edge_max, const std::function&lt; void(const <a class="el" href="structvg_1_1algorithms_1_1kmer__t.html">kmer_t</a> &amp;)&gt; &amp;lambda)</td></tr>
<tr class="memdesc:a30b8fd7a0d56e1827faa3aa56c8828f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all the kmers in the graph, running lambda on each.  <a href="namespacevg_1_1algorithms.html#a30b8fd7a0d56e1827faa3aa56c8828f0">More...</a><br /></td></tr>
<tr class="separator:a30b8fd7a0d56e1827faa3aa56c8828f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3961418e3f3af94c4275118e4693a2fe"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a3961418e3f3af94c4275118e4693a2fe">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structvg_1_1algorithms_1_1kmer__t.html">kmer_t</a> &amp;kmer)</td></tr>
<tr class="memdesc:a3961418e3f3af94c4275118e4693a2fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a <a class="el" href="structvg_1_1algorithms_1_1kmer__t.html" title="Stores a kmer in the context of a graph.">kmer_t</a> to a stream.  <a href="namespacevg_1_1algorithms.html#a3961418e3f3af94c4275118e4693a2fe">More...</a><br /></td></tr>
<tr class="separator:a3961418e3f3af94c4275118e4693a2fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa015cfde6842fff0d0dcd81f7130c659"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aa015cfde6842fff0d0dcd81f7130c659">locally_expand_graph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;parent, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;subgraph, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> from, int64_t max_dist)</td></tr>
<tr class="separator:aa015cfde6842fff0d0dcd81f7130c659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91a6bbd822f6380421a973f75036c3d3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a91a6bbd822f6380421a973f75036c3d3">merge</a> (<a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html">handlegraph::MutablePathDeletableHandleGraph</a> *graph, const vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, size_t &gt;&gt; &amp;start, size_t length)</td></tr>
<tr class="separator:a91a6bbd822f6380421a973f75036c3d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0820d23864c46dc1bc71ec68aee4e55e"><td class="memItemLeft" align="right" valign="top">pair&lt; vector&lt; unordered_set&lt; size_t &gt; &gt;, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a0820d23864c46dc1bc71ec68aee4e55e">kargers_min_cut</a> (<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> graph, const int seed)</td></tr>
<tr class="separator:a0820d23864c46dc1bc71ec68aee4e55e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae1eba2313c3ce068851c85b8d019e2"><td class="memItemLeft" align="right" valign="top">pair&lt; vector&lt; unordered_set&lt; size_t &gt; &gt;, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a7ae1eba2313c3ce068851c85b8d019e2">compute_min_cut</a> (<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> graph, const int seed)</td></tr>
<tr class="separator:a7ae1eba2313c3ce068851c85b8d019e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cd4d23b1a702613134895c2d5618154"><td class="memItemLeft" align="right" valign="top">vector&lt; unordered_set&lt; size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a5cd4d23b1a702613134895c2d5618154">min_cut_decomposition</a> (<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> graph, const int seed)</td></tr>
<tr class="separator:a5cd4d23b1a702613134895c2d5618154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a477330d3ab29cbd3c48e4830d51b3e0f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a477330d3ab29cbd3c48e4830d51b3e0f">nearest_offsets_in_paths</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph, const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;pos, int64_t max_search, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *path_filter)</td></tr>
<tr class="separator:a477330d3ab29cbd3c48e4830d51b3e0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef24fa77dadb09d5920ec94b88af2128"><td class="memItemLeft" align="right" valign="top">map&lt; string, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aef24fa77dadb09d5920ec94b88af2128">offsets_in_paths</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph, const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;pos)</td></tr>
<tr class="separator:aef24fa77dadb09d5920ec94b88af2128"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ddb73ef3cf5a8891aa82001f272c3c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a9ddb73ef3cf5a8891aa82001f272c3c4">simple_offsets_in_paths</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph, <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> pos)</td></tr>
<tr class="memdesc:a9ddb73ef3cf5a8891aa82001f272c3c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">A "simple" model for path position getting for debugging.  <a href="namespacevg_1_1algorithms.html#a9ddb73ef3cf5a8891aa82001f272c3c4">More...</a><br /></td></tr>
<tr class="separator:a9ddb73ef3cf5a8891aa82001f272c3c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22d03c4f50c51d0d537811ba88895688"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a>, char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a22d03c4f50c51d0d537811ba88895688">next_pos_chars</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;graph, <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> pos)</td></tr>
<tr class="separator:a22d03c4f50c51d0d537811ba88895688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb6a93eb17739d744908d61ca6650f4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#afb6a93eb17739d744908d61ca6650f4c">normalize</a> (<a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html">handlegraph::MutablePathDeletableHandleGraph</a> *graph, int max_iter, bool <a class="el" href="minimizer__mapper__from__chains_8cpp.html#a322565ccf348d13e4d3de13af771e5fc">debug</a>, function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; can_merge)</td></tr>
<tr class="separator:afb6a93eb17739d744908d61ca6650f4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9957e925ee25c57698383d4e1df21f0d"><td class="memItemLeft" align="right" valign="top">std::function&lt; size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a9957e925ee25c57698383d4e1df21f0d">pad_band_random_walk_internal</a> (double band_padding_multiplier, size_t band_padding_memo_size, size_t max_padding, const std::function&lt; size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;)&gt; size_function)</td></tr>
<tr class="separator:a9957e925ee25c57698383d4e1df21f0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1294ed71274673b7e4cc1d40e9472666"><td class="memItemLeft" align="right" valign="top">std::function&lt; size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a1294ed71274673b7e4cc1d40e9472666">pad_band_random_walk</a> (double band_padding_multiplier, size_t band_padding_memo_size, size_t max_padding)</td></tr>
<tr class="separator:a1294ed71274673b7e4cc1d40e9472666"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a25a37b51facd101b8a29b1a57661f74f"><td class="memItemLeft" align="right" valign="top">std::function&lt; size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a25a37b51facd101b8a29b1a57661f74f">pad_band_min_random_walk</a> (double band_padding_multiplier, size_t band_padding_memo_size, size_t max_padding)</td></tr>
<tr class="separator:a25a37b51facd101b8a29b1a57661f74f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab5b2261edb66897af9d1158e7758d8"><td class="memItemLeft" align="right" valign="top">std::function&lt; size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aaab5b2261edb66897af9d1158e7758d8">pad_band_constant</a> (size_t band_padding)</td></tr>
<tr class="separator:aaab5b2261edb66897af9d1158e7758d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5ff6fdbf4ef393faf59f22365c46bbb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ae5ff6fdbf4ef393faf59f22365c46bbb">append_mapping_sequence</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m, const string &amp;node_seq, string &amp;seq)</td></tr>
<tr class="memdesc:ae5ff6fdbf4ef393faf59f22365c46bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">use the given oriented node sequence and the mapping to reconstruct the sequence represented by the mapping  <a href="namespacevg_1_1algorithms.html#ae5ff6fdbf4ef393faf59f22365c46bbb">More...</a><br /></td></tr>
<tr class="separator:ae5ff6fdbf4ef393faf59f22365c46bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acc0acf3d99939a0943ca9e0b86e48a"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a7acc0acf3d99939a0943ca9e0b86e48a">path_string</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="memdesc:a7acc0acf3d99939a0943ca9e0b86e48a"><td class="mdescLeft">&#160;</td><td class="mdescRight">use the given graph and the path to determine our path string  <a href="namespacevg_1_1algorithms.html#a7acc0acf3d99939a0943ca9e0b86e48a">More...</a><br /></td></tr>
<tr class="separator:a7acc0acf3d99939a0943ca9e0b86e48a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8529f1718d5f0330dbb301d1148f12e1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1pair__hash__set.html">pair_hash_set</a>&lt; <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a8529f1718d5f0330dbb301d1148f12e1">find_edges_to_prune</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, size_t k, size_t edge_max)</td></tr>
<tr class="separator:a8529f1718d5f0330dbb301d1148f12e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09b6e838b2991d13e272ddcb41aacfbc"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a09b6e838b2991d13e272ddcb41aacfbc">prune_complex</a> (<a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;graph, int path_length, int edge_max)</td></tr>
<tr class="separator:a09b6e838b2991d13e272ddcb41aacfbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a784ee29876a24431a865541426f42dee"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a784ee29876a24431a865541426f42dee">prune_complex_with_head_tail</a> (<a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;graph, int path_length, int edge_max)</td></tr>
<tr class="separator:a784ee29876a24431a865541426f42dee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83e87cf3f8a5ca4362776cf1a3050242"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a83e87cf3f8a5ca4362776cf1a3050242">prune_short_subgraphs</a> (<a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;graph, int min_size)</td></tr>
<tr class="separator:a83e87cf3f8a5ca4362776cf1a3050242"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96020f05a81255adfca3821f538c02b9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a96020f05a81255adfca3821f538c02b9">remove_high_degree_nodes</a> (<a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;g, int max_degree)</td></tr>
<tr class="separator:a96020f05a81255adfca3821f538c02b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d74c519ccaa204e7735d5bd26c5095a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a3d74c519ccaa204e7735d5bd26c5095a">prune_to_connecting_graph</a> (<a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;graph, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;from, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;to)</td></tr>
<tr class="memdesc:a3d74c519ccaa204e7735d5bd26c5095a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove all parts of the graph that are not on some path between the two handles.  <a href="namespacevg_1_1algorithms.html#a3d74c519ccaa204e7735d5bd26c5095a">More...</a><br /></td></tr>
<tr class="separator:a3d74c519ccaa204e7735d5bd26c5095a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5e4dc632e98b58b67a99af6749d9e05"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aa5e4dc632e98b58b67a99af6749d9e05">ref_path_distance</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph, const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;pos_1, const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;pos_2, const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;ref_paths, int64_t max_search_dist)</td></tr>
<tr class="separator:aa5e4dc632e98b58b67a99af6749d9e05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a175ee345e226732cb1c37da13a2f045e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a175ee345e226732cb1c37da13a2f045e">sample_minimal</a> (size_t count, size_t element_length, size_t window_size, size_t sequence_length, const std::function&lt; size_t(size_t)&gt; &amp;get_start, const std::function&lt; bool(size_t, size_t)&gt; &amp;should_beat, const std::function&lt; void(size_t)&gt; &amp;sample)</td></tr>
<tr class="separator:a175ee345e226732cb1c37da13a2f045e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af51e5eafc2c18f33dd6a120c753247a3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#af51e5eafc2c18f33dd6a120c753247a3">bellman_ford_shortest_cycle_length</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;source, const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;layout, const unordered_map&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, size_t &gt; &amp;handle_index, const vector&lt; pair&lt; size_t, size_t &gt;&gt; &amp;feedback_edges)</td></tr>
<tr class="separator:af51e5eafc2c18f33dd6a120c753247a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40d6162a9f0dba28306c836d07d7d6e3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a40d6162a9f0dba28306c836d07d7d6e3">dijkstra_shortest_cycle_length</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;source)</td></tr>
<tr class="memdesc:a40d6162a9f0dba28306c836d07d7d6e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple Dijkstra implementation that computes shortest cycle.  <a href="namespacevg_1_1algorithms.html#a40d6162a9f0dba28306c836d07d7d6e3">More...</a><br /></td></tr>
<tr class="separator:a40d6162a9f0dba28306c836d07d7d6e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa87ca8c58307fdb47d448deb2ec43389"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aa87ca8c58307fdb47d448deb2ec43389">shortest_cycle_length_internal</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;source, const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;layout, const unordered_map&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, size_t &gt; &amp;handle_index, const vector&lt; pair&lt; size_t, size_t &gt;&gt; &amp;feedback_edges)</td></tr>
<tr class="separator:aa87ca8c58307fdb47d448deb2ec43389"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe6f985e8bedbad1b33861c62379772"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#acfe6f985e8bedbad1b33861c62379772">shortest_cycle_length</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;source)</td></tr>
<tr class="separator:acfe6f985e8bedbad1b33861c62379772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a012fced2754c445ec404ff5420018982"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a012fced2754c445ec404ff5420018982">shortest_cycle_length</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="separator:a012fced2754c445ec404ff5420018982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e4cebdfc1e901db4588c4612653df96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a9e4cebdfc1e901db4588c4612653df96">simplify_siblings</a> (<a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html">handlegraph::MutablePathDeletableHandleGraph</a> *graph, function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; can_merge)</td></tr>
<tr class="separator:a9e4cebdfc1e901db4588c4612653df96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64bd6b3ff0d2e22bf752e29e3522a98d"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a64bd6b3ff0d2e22bf752e29e3522a98d">sorted_id_ranges</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="memdesc:a64bd6b3ff0d2e22bf752e29e3522a98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a sorted list of inclusive ranges of IDs used in the given HandleGraph.  <a href="namespacevg_1_1algorithms.html#a64bd6b3ff0d2e22bf752e29e3522a98d">More...</a><br /></td></tr>
<tr class="separator:a64bd6b3ff0d2e22bf752e29e3522a98d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8ff68675a6735fbd34ce736e67a9d52"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ac8ff68675a6735fbd34ce736e67a9d52">expand_subgraph_by_steps</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;subgraph, const uint64_t &amp;steps, bool forward_only=false)</td></tr>
<tr class="memdesc:ac8ff68675a6735fbd34ce736e67a9d52"><td class="mdescLeft">&#160;</td><td class="mdescRight">expand the subgraph iteratively for this many steps  <a href="namespacevg_1_1algorithms.html#ac8ff68675a6735fbd34ce736e67a9d52">More...</a><br /></td></tr>
<tr class="separator:ac8ff68675a6735fbd34ce736e67a9d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1998da7905d222d25839ca3b9b6c52c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ae1998da7905d222d25839ca3b9b6c52c">expand_subgraph_to_node_count</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;subgraph, const uint64_t &amp;node_count, bool forward_only=false)</td></tr>
<tr class="memdesc:ae1998da7905d222d25839ca3b9b6c52c"><td class="mdescLeft">&#160;</td><td class="mdescRight">expand the subgraph iteratively until its node count is at least node_count  <a href="namespacevg_1_1algorithms.html#ae1998da7905d222d25839ca3b9b6c52c">More...</a><br /></td></tr>
<tr class="separator:ae1998da7905d222d25839ca3b9b6c52c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b57bed3b0fc8427419ccddc077fe20c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a5b57bed3b0fc8427419ccddc077fe20c">expand_subgraph_by_length</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;subgraph, const uint64_t &amp;length, bool forward_only=false)</td></tr>
<tr class="memdesc:a5b57bed3b0fc8427419ccddc077fe20c"><td class="mdescLeft">&#160;</td><td class="mdescRight">expand the subgraph iteratively to include at least length new sequence  <a href="namespacevg_1_1algorithms.html#a5b57bed3b0fc8427419ccddc077fe20c">More...</a><br /></td></tr>
<tr class="separator:a5b57bed3b0fc8427419ccddc077fe20c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa93f6a90a43d95f7340318a0d9ac4fe6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#aa93f6a90a43d95f7340318a0d9ac4fe6">expand_subgraph_to_length</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;subgraph, const uint64_t &amp;length, bool forward_only=false)</td></tr>
<tr class="memdesc:aa93f6a90a43d95f7340318a0d9ac4fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">expand the subgraph iterativel until its total sequence length is greater than length  <a href="namespacevg_1_1algorithms.html#aa93f6a90a43d95f7340318a0d9ac4fe6">More...</a><br /></td></tr>
<tr class="separator:aa93f6a90a43d95f7340318a0d9ac4fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38ea20ebc7800702ec0cdb96920c6184"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a38ea20ebc7800702ec0cdb96920c6184">extract_context</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;subgraph, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, const uint64_t &amp;<a class="el" href="namespacevg.html#ad48a54a3ddd5e6ffd8e3e6296fb9c037">offset</a>, const uint64_t &amp;length, bool fwd, bool rev)</td></tr>
<tr class="memdesc:a38ea20ebc7800702ec0cdb96920c6184"><td class="mdescLeft">&#160;</td><td class="mdescRight">expand the context around a single handle position  <a href="namespacevg_1_1algorithms.html#a38ea20ebc7800702ec0cdb96920c6184">More...</a><br /></td></tr>
<tr class="separator:a38ea20ebc7800702ec0cdb96920c6184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac53dd7f2ff1b53bec309f368a79db951"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ac53dd7f2ff1b53bec309f368a79db951">extract_id_range</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;source, const <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">nid_t</a> &amp;id1, const <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">nid_t</a> &amp;id2, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;subgraph)</td></tr>
<tr class="memdesc:ac53dd7f2ff1b53bec309f368a79db951"><td class="mdescLeft">&#160;</td><td class="mdescRight">extract the node id range  <a href="namespacevg_1_1algorithms.html#ac53dd7f2ff1b53bec309f368a79db951">More...</a><br /></td></tr>
<tr class="separator:ac53dd7f2ff1b53bec309f368a79db951"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6da60961fae57a5568354ef5b541bcf7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a6da60961fae57a5568354ef5b541bcf7">extract_path_range</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;source, <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> path_handle, int64_t start, int64_t end, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;subgraph)</td></tr>
<tr class="separator:a6da60961fae57a5568354ef5b541bcf7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90946d442f4b518bb61154cde44d109c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a90946d442f4b518bb61154cde44d109c">add_subpaths_to_subgraph</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;source, <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html">MutablePathHandleGraph</a> &amp;subgraph)</td></tr>
<tr class="separator:a90946d442f4b518bb61154cde44d109c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6347e00229560b4adb7cc7cb6332b21a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a6347e00229560b4adb7cc7cb6332b21a">add_connecting_edges_to_subgraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;source, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;subgraph)</td></tr>
<tr class="separator:a6347e00229560b4adb7cc7cb6332b21a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d4b7c6814fb1f53a83c2e8355d72efa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a4d4b7c6814fb1f53a83c2e8355d72efa">three_edge_connected_component_merges_dense</a> (size_t node_count, size_t first_root, const function&lt; void(size_t, const function&lt; void(size_t)&gt; &amp;)&gt; &amp;for_each_connected_node, const function&lt; void(size_t, size_t)&gt; &amp;same_component)</td></tr>
<tr class="separator:a4d4b7c6814fb1f53a83c2e8355d72efa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34c4a74208a88c0f956e697d5e183f5c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a34c4a74208a88c0f956e697d5e183f5c">three_edge_connected_components_dense</a> (size_t node_count, size_t first_root, const function&lt; void(size_t, const function&lt; void(size_t)&gt; &amp;)&gt; &amp;for_each_connected_node, const function&lt; void(const function&lt; void(const function&lt; void(size_t)&gt; &amp;)&gt; &amp;)&gt; &amp;component_callback)</td></tr>
<tr class="separator:a34c4a74208a88c0f956e697d5e183f5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57de725b70b138394479863428f9d2eb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a57de725b70b138394479863428f9d2eb">three_edge_connected_components_dense_cactus</a> (size_t node_count, const function&lt; void(size_t, const function&lt; void(size_t)&gt; &amp;)&gt; &amp;for_each_connected_node, const function&lt; void(const function&lt; void(const function&lt; void(size_t)&gt; &amp;)&gt; &amp;)&gt; &amp;component_callback)</td></tr>
<tr class="separator:a57de725b70b138394479863428f9d2eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4677e69f0b8ceb8580bc019cc8fbea8"><td class="memTemplParams" colspan="2">template&lt;typename TECCNode &gt; </td></tr>
<tr class="memitem:ae4677e69f0b8ceb8580bc019cc8fbea8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ae4677e69f0b8ceb8580bc019cc8fbea8">three_edge_connected_components</a> (const function&lt; void(const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;for_each_node, const function&lt; void(TECCNode, const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;for_each_connected_node, const function&lt; void(const function&lt; void(const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;)&gt; &amp;component_callback)</td></tr>
<tr class="separator:ae4677e69f0b8ceb8580bc019cc8fbea8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7215192f2cc6536b6b3aadef4e95c64a"><td class="memTemplParams" colspan="2">template&lt;typename TECCNode &gt; </td></tr>
<tr class="memitem:a7215192f2cc6536b6b3aadef4e95c64a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a7215192f2cc6536b6b3aadef4e95c64a">three_edge_connected_component_merges</a> (const function&lt; void(const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;for_each_node, const function&lt; void(TECCNode, const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;for_each_connected_node, const function&lt; void(TECCNode, TECCNode)&gt; &amp;same_component)</td></tr>
<tr class="separator:a7215192f2cc6536b6b3aadef4e95c64a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1ad4f4eccc7041eb1e700463492540"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ace1ad4f4eccc7041eb1e700463492540">for_each_walk</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, size_t k, size_t edge_max, const std::function&lt; void(const <a class="el" href="structvg_1_1algorithms_1_1walk__t.html">walk_t</a> &amp;)&gt; &amp;lambda)</td></tr>
<tr class="memdesc:ace1ad4f4eccc7041eb1e700463492540"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iterate over all the walks in the graph, running lambda on each.  <a href="namespacevg_1_1algorithms.html#ace1ad4f4eccc7041eb1e700463492540">More...</a><br /></td></tr>
<tr class="separator:ace1ad4f4eccc7041eb1e700463492540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58ec8c8d09fde1a6e83194ec7126ed4e"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a58ec8c8d09fde1a6e83194ec7126ed4e">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structvg_1_1algorithms_1_1walk__t.html">walk_t</a> &amp;walk)</td></tr>
<tr class="memdesc:a58ec8c8d09fde1a6e83194ec7126ed4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a <a class="el" href="structvg_1_1algorithms_1_1walk__t.html" title="Record a &lt;=k-length walk in the context of a graph.">walk_t</a> to a stream.  <a href="namespacevg_1_1algorithms.html#a58ec8c8d09fde1a6e83194ec7126ed4e">More...</a><br /></td></tr>
<tr class="separator:a58ec8c8d09fde1a6e83194ec7126ed4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4af5e9c480c0dc7d0843cf981cd52c32"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a4af5e9c480c0dc7d0843cf981cd52c32">walk_haplotype_frequency</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const gbwt::GBWT &amp;haplotypes, const <a class="el" href="structvg_1_1algorithms_1_1walk__t.html">walk_t</a> &amp;walk)</td></tr>
<tr class="separator:a4af5e9c480c0dc7d0843cf981cd52c32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe9cb62b2ae1c6eb08b10f172980788d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#abe9cb62b2ae1c6eb08b10f172980788d">walk_haplotype_names</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const gbwt::GBWT &amp;haplotypes, const <a class="el" href="structvg_1_1algorithms_1_1walk__t.html">walk_t</a> &amp;walk)</td></tr>
<tr class="separator:abe9cb62b2ae1c6eb08b10f172980788d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a6a606c26b5751d935c71d7971a92d99b"><td class="memItemLeft" align="right" valign="top">std::function&lt; size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a6a606c26b5751d935c71d7971a92d99b">pad_band_random_walk</a> (double band_padding_multiplier=1.0, size_t band_padding_memo_size=2000, size_t max_padding=std::numeric_limits&lt; size_t &gt;::max())</td></tr>
<tr class="separator:a6a606c26b5751d935c71d7971a92d99b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3363cc23e6c71e1bb5faac975af7920d"><td class="memItemLeft" align="right" valign="top">std::function&lt; size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a3363cc23e6c71e1bb5faac975af7920d">pad_band_min_random_walk</a> (double band_padding_multiplier=1.0, size_t band_padding_memo_size=2000, size_t max_padding=std::numeric_limits&lt; size_t &gt;::max())</td></tr>
<tr class="separator:a3363cc23e6c71e1bb5faac975af7920d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab48342aedc7d81e2334c52bb320223c2"><td class="memItemLeft" align="right" valign="top">std::function&lt; size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#ab48342aedc7d81e2334c52bb320223c2">pad_band_constant</a> (size_t band_padding)</td></tr>
<tr class="memdesc:ab48342aedc7d81e2334c52bb320223c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a band padding function that uses a constant value.  <a href="namespacevg_1_1algorithms.html#ab48342aedc7d81e2334c52bb320223c2">More...</a><br /></td></tr>
<tr class="separator:ab48342aedc7d81e2334c52bb320223c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f4abe5d8279f14a52b56ffb47fff34"><td class="memItemLeft" align="right" valign="top">constexpr size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html#a64f4abe5d8279f14a52b56ffb47fff34">PRUNE_THREAD_BUFFER_SIZE</a> = 1024 * 1024</td></tr>
<tr class="separator:a64f4abe5d8279f14a52b56ffb47fff34"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="acf8cb40a8f834b42f1ec89af0ef140b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf8cb40a8f834b42f1ec89af0ef140b9">&#9670;&nbsp;</a></span>BinnedDepthIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg_1_1algorithms.html#acf8cb40a8f834b42f1ec89af0ef140b9">vg::algorithms::BinnedDepthIndex</a> = typedef unordered_map&lt;string, map&lt;size_t, map&lt;size_t, pair&lt;float, float&gt; &gt;&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the above function to retrieve the binned depths of a list of paths, and store them indexed by start coordinate. If std_err is true, store &lt;mean, stderr&gt; instead of &lt;mean, variance&gt; For each path, a series of indexes is computed, for bin sizes from min_bin_size, min_bin_size^(exp_growth_factor), etc. </p>

</div>
</div>
<a id="a6474017f8ab54b0c6e20095206a880a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6474017f8ab54b0c6e20095206a880a8">&#9670;&nbsp;</a></span>path_offset_collection_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">vg::algorithms::path_offset_collection_t</a> = typedef unordered_map&lt;<a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, vector&lt;pair&lt;size_t, bool&gt; &gt;&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents a set of positions and orientations, along a collection of paths. Positions and orientations may or may not be stored sorted. </p>

</div>
</div>
<a id="ad64245b7dca5a8144ae8720a92b65685"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad64245b7dca5a8144ae8720a92b65685">&#9670;&nbsp;</a></span>transition_iteratee</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg_1_1algorithms.html#ad64245b7dca5a8144ae8720a92b65685">vg::algorithms::transition_iteratee</a> = typedef std::function&lt;void(size_t from_anchor, size_t to_anchor, size_t read_distance, size_t graph_distance)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iteratee function type which can be called with each transition between anchors.</p>
<p>Takes two anchor numbers (source and destination), and their read and graph distances, in that order. </p>

</div>
</div>
<a id="a79c214c1e7f1d7cc5fe322b8c9fb260c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79c214c1e7f1d7cc5fe322b8c9fb260c">&#9670;&nbsp;</a></span>transition_iterator</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg_1_1algorithms.html#a79c214c1e7f1d7cc5fe322b8c9fb260c">vg::algorithms::transition_iterator</a> = typedef std::function&lt;void(const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt;<a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a>&gt;&amp; to_chain, const SnarlDistanceIndex&amp; distance_index, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a>&amp; graph, size_t max_indel_bases, const <a class="el" href="namespacevg_1_1algorithms.html#ad64245b7dca5a8144ae8720a92b65685">transition_iteratee</a>&amp; callback)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterator function type which lets you iterate over transitions between items, by calling a callback.</p>
<p>Implementation will go throuch all the anchors and call the given callback with pairs of anchor numbers, and their read and graph distances.</p>
<p>Transitions are always between anchors earlier and later in the read.</p>
<p>Transitions are from the first anchor, to the second.</p>
<p>Transitions are visited in order: all transititions to an anchor are visited before any transitions from it.</p>
<p>to_chain must be sorted by read start. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5af5b6f1083925669832ae59d0e549e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5af5b6f1083925669832ae59d0e549e7">&#9670;&nbsp;</a></span>a_star()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class DistHeuristic &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; vg::algorithms::a_star </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const DistHeuristic &amp;&#160;</td>
          <td class="paramname"><em>dist_heuristic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>find_min</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>extremal_distance</em> = <code>numeric_limits&lt;int64_t&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>monotonic_heuristic</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Implements the A* heuristic-guided search algorithm. Returns the path from pos_1 to pos_2 that is either minimal or maximal length, according to the parameters. Allows an extremal distance beyond which the algorithm will cease looking for paths (this should be a large value when looking for minimal paths and a small value when looking for maximum paths). If there is no path between the positions, or none within the extremal length, an empty vector will be returned. </p>

</div>
</div>
<a id="a6347e00229560b4adb7cc7cb6332b21a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6347e00229560b4adb7cc7cb6332b21a">&#9670;&nbsp;</a></span>add_connecting_edges_to_subgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::add_connecting_edges_to_subgraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We can accumulate a subgraph without accumulating all the edges between its nodes this helper ensures that we get the full set </p>

</div>
</div>
<a id="a90946d442f4b518bb61154cde44d109c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90946d442f4b518bb61154cde44d109c">&#9670;&nbsp;</a></span>add_subpaths_to_subgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::add_subpaths_to_subgraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html">MutablePathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add subpaths to the subgraph for all paths visiting its nodes in the source graph.</p>
<p>Always generates correct path metadata, and a path for each contiguous fragment of any base path. Assumes the source graph does not contain any overlapping path fragments on a given base path, and that the subgraph does not already contain any paths on a base path also present in the source graph. </p>

</div>
</div>
<a id="aead0aa069554bbc1a3fcce05ca4d1127"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aead0aa069554bbc1a3fcce05ca4d1127">&#9670;&nbsp;</a></span>alignment_path_offsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; vg::algorithms::alignment_path_offsets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>just_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>nearby</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>search_limit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *&#160;</td>
          <td class="paramname"><em>path_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gives the path positions of the alignment. If just_min is set, gives the minimum position on each path. Else, gives all <a class="el" href="structvg_1_1Mapping.html">Mapping</a> start positions on each path. If nearby is set, will search for a nearby path. Will recurse with nearby set if it is not set on initial call and no positions are found. Respects search_limit in bp in that case. If search_limit is 0, read length is used. If search_limit is -1, no search will be performed and only actually-visited nodes will be used.</p>
<p>If path_filter is set, and it returns false for a path, that path is not used to annotate the read. </p>

</div>
</div>
<a id="a3c1bbf062eb429066c7b46da24704cdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c1bbf062eb429066c7b46da24704cdf">&#9670;&nbsp;</a></span>annotate_with_initial_path_positions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::annotate_with_initial_path_positions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>search_limit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *&#160;</td>
          <td class="paramname"><em>path_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the graph to annotate an <a class="el" href="structvg_1_1Alignment.html">Alignment</a> with the first position it touches on each reference path. Thread safe.</p>
<p>search_limit gives the maximum distance to search for a path if the alignment does not actually touch any paths. If 0, the alignment's sequence length is used. If search_limit is -1, no search will be performed and only actually-visited nodes will be used.</p>
<p>If path_filter is set, and it returns false for a path, that path is not used to annotate the read. </p>

</div>
</div>
<a id="a29c8bb498d4cab7c964783dbf98dae28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29c8bb498d4cab7c964783dbf98dae28">&#9670;&nbsp;</a></span>annotate_with_initial_path_positions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::annotate_with_initial_path_positions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>search_limit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *&#160;</td>
          <td class="paramname"><em>path_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the graph annotate Alignments with the first position they touch on each reference path. Thread safe.</p>
<p>search_limit gives the maximum distance to search for a path if the alignment does not actually touch any paths. If 0, the alignment's sequence length is used. If search_limit is -1, no search will be performed and only actually-visited nodes will be used.</p>
<p>If path_filter is set, and it returns false for a path, that path is not used to annotate the read. </p>

</div>
</div>
<a id="ad2151b93596855953805b98d78ac83c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2151b93596855953805b98d78ac83c6">&#9670;&nbsp;</a></span>annotate_with_node_path_positions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::annotate_with_node_path_positions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>search_limit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *&#160;</td>
          <td class="paramname"><em>path_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the graph to annotate an <a class="el" href="structvg_1_1Alignment.html">Alignment</a> with the first position it touches on each node it visits in each reference path. Thread safe. If no nodes on any path are visited, searches for a nearby path position to use.</p>
<p>search_limit gives the maximum distance to search for a path if the alignment does not actually touch any paths. If 0, the alignment's sequence length is used. If search_limit is -1, no search will be performed and only actually-visited nodes will be used.</p>
<p>If path_filter is set, and it returns false for a path, that path is not used to annotate the read. </p>

</div>
</div>
<a id="a66e67738fef35591e953849387e94d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e67738fef35591e953849387e94d58">&#9670;&nbsp;</a></span>annotate_with_path_positions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::annotate_with_path_positions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>just_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>search_limit</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *&#160;</td>
          <td class="paramname"><em>path_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the graph to annotate an <a class="el" href="structvg_1_1Alignment.html">Alignment</a> with positions on each reference path. Thread safe.</p>
<p>If just_min is set, gives the minimum position on each path. Else, gives all <a class="el" href="structvg_1_1Mapping.html">Mapping</a> start positions on each path. If no positions on the path are found, looks for nearby path positions in graph space. Respects search_limit in bp in that case. If search_limit is 0, read length is used. If search_limit is -1, no search will be performed and only actually-visited nodes will be used.</p>
<p>If path_filter is set, and it returns false for a path, that path is not used to annotate the read. </p>

</div>
</div>
<a id="ae5ff6fdbf4ef393faf59f22365c46bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5ff6fdbf4ef393faf59f22365c46bbb">&#9670;&nbsp;</a></span>append_mapping_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::append_mapping_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>node_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>use the given oriented node sequence and the mapping to reconstruct the sequence represented by the mapping </p>

</div>
</div>
<a id="a0d0e29a34fb2e1f712751a8a8fda6f03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0e29a34fb2e1f712751a8a8fda6f03">&#9670;&nbsp;</a></span>back_translate_in_place() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::back_translate_in_place </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> *&#160;</td>
          <td class="paramname"><em>translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translate the given <a class="el" href="structvg_1_1Path.html">Path</a> in place from node ID space to named segment space. </p>

</div>
</div>
<a id="a0fb0b1f6ca5892b532032ecddd8fde19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fb0b1f6ca5892b532032ecddd8fde19">&#9670;&nbsp;</a></span>back_translate_in_place() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::back_translate_in_place </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> *&#160;</td>
          <td class="paramname"><em>translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translate the given <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes.">Snarl</a> in place from node ID space to named segment space. </p>

</div>
</div>
<a id="a0efe72c9db6dd4c1828dae311795e9b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0efe72c9db6dd4c1828dae311795e9b0">&#9670;&nbsp;</a></span>back_translate_in_place() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::back_translate_in_place </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> *&#160;</td>
          <td class="paramname"><em>translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>traversal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translate the given <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> in place from node ID space to named segment space. Visits that end up being to snarls where both boundaries are from the same orientation of the same segment will be removed. Multiple visits in a row to the same orientation of the same segment will be elided.</p>
<p>TODO: Work out a way to preserve traversals around cycles while not repeating ourselves for visits to diffrent pieces of the same chopped segment. </p>

</div>
</div>
<a id="a0e04f69397f1d7e1f33b99f0ff145af5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e04f69397f1d7e1f33b99f0ff145af5">&#9670;&nbsp;</a></span>back_translate_in_place() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::back_translate_in_place </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> *&#160;</td>
          <td class="paramname"><em>translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>visit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translate the given <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> in place from node ID space to named segment space. </p>

</div>
</div>
<a id="af51e5eafc2c18f33dd6a120c753247a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af51e5eafc2c18f33dd6a120c753247a3">&#9670;&nbsp;</a></span>bellman_ford_shortest_cycle_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::bellman_ford_shortest_cycle_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; size_t, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>feedback_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An implementation of Bellman-Ford with Yen's ordering improvement applied to a layout ideally has a small feedback arc set </p>

</div>
</div>
<a id="a8fb3df22b1d7955546bbcc8c438f6efc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fb3df22b1d7955546bbcc8c438f6efc">&#9670;&nbsp;</a></span>binned_packed_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; tuple&lt; size_t, size_t, double, double &gt; &gt; vg::algorithms::binned_packed_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;&#160;</td>
          <td class="paramname"><em>packer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bin_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_deletions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use all available threads to estimate the binned packed coverage of a path using above fucntion Each element is a bin's 0-based open-ended interval in the path, and its coverage mean,variance. <br  />
 </p>

</div>
</div>
<a id="af05e00ad1e6a7b34cde8c37aa9dbbdbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05e00ad1e6a7b34cde8c37aa9dbbdbc">&#9670;&nbsp;</a></span>binned_packed_depth_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg_1_1algorithms.html#acf8cb40a8f834b42f1ec89af0ef140b9">BinnedDepthIndex</a> vg::algorithms::binned_packed_depth_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;&#160;</td>
          <td class="paramname"><em>packer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_bin_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_bin_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>exp_growth_factor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_deletions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>std_err</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d48562b230a318ee15820aa508867fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d48562b230a318ee15820aa508867fc">&#9670;&nbsp;</a></span>binned_path_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; tuple&lt; size_t, size_t, double, double &gt; &gt; vg::algorithms::binned_path_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bin_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>count_cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2fda86d465d26d7f101e00f3431564e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fda86d465d26d7f101e00f3431564e8">&#9670;&nbsp;</a></span>chain_items_dp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a> vg::algorithms::chain_items_dp </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>chain_scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>to_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gap_open</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gap_extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg_1_1algorithms.html#a79c214c1e7f1d7cc5fe322b8c9fb260c">transition_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>for_each_transition</em> = <code><a class="el" href="namespacevg_1_1algorithms.html#ac8e2917f0a06c55852e4ef044548f2bb">lookback_transition_iterator</a>(150,&#160;0,&#160;100)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>item_bonus</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>item_scale</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gap_scale</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>points_per_possible_match</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_indel_bases</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_work</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill in the given DP table for the explored chain scores ending with each item. Returns the best observed score overall from that table, with provenance to its location in the table, if tracked in the type. Assumes some items exist.</p>
<p>We keep all the options to allow us to do multiple tracebacks and find multiple good (ideally disjoint) chains.</p>
<p>Input items must be sorted by start position in the read.</p>
<p>Takes the given per-item bonus for each item collected, and scales item scores by the given scale.</p>
<p>Uses a transition iterator to enumerate where we can come from to reach an item.</p>
<p>Limits transitions to those involving indels of the given size or less, to avoid very bad transitions. </p>

</div>
</div>
<a id="a7a9239fd23ed6838263f4dd05828d18c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a9239fd23ed6838263f4dd05828d18c">&#9670;&nbsp;</a></span>chain_items_traceback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; vector&lt; size_t &gt;, int &gt; &gt; vg::algorithms::chain_items_traceback </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>chain_scores</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>to_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a> &amp;&#160;</td>
          <td class="paramname"><em>best_past_ending_score_ever</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>item_bonus</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>item_scale</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_tracebacks</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Trace back through in the given DP table from the best chain score.</p>
<p>Returns tracebacks that visit disjoint sets of items, in score order, along with their penalties from the optimal score. The best_past_ending_score_ever is <em>not</em> always the source of the first traceback, if there is a tie.</p>
<p>Tracebacks are constrained to be nonoverlapping by stopping each traceback when the optimum place to come from has already been used. The second-best place to come from is <em>not</em> considered. It might be possible that two returned tracebacks could be pasted together to get a higher score, but it won't be possible to recombine two tracebacks to get a higher score; no edges followed between items will ever need to be cut. </p>

</div>
</div>
<a id="a51f810108840ab4014eb58b2bfe19ac1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51f810108840ab4014eb58b2bfe19ac1">&#9670;&nbsp;</a></span>component_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &gt; vg::algorithms::component_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a10b07f6f41f8dd36c5d3b1ff9a03ce93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b07f6f41f8dd36c5d3b1ff9a03ce93">&#9670;&nbsp;</a></span>component_paths_parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &gt; vg::algorithms::component_paths_parallel </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e5fdb03a21f88395e1d69f53821ae59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5fdb03a21f88395e1d69f53821ae59">&#9670;&nbsp;</a></span>component_sizes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; size_t &gt; vg::algorithms::component_sizes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ae1eba2313c3ce068851c85b8d019e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae1eba2313c3ce068851c85b8d019e2">&#9670;&nbsp;</a></span>compute_min_cut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; vector&lt; unordered_set&lt; size_t &gt; &gt;, size_t &gt; vg::algorithms::compute_min_cut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a>&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b477c1e232c9d4f1e689a95dd55861d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b477c1e232c9d4f1e689a95dd55861d">&#9670;&nbsp;</a></span>count_covered()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::count_covered </td>
          <td>(</td>
          <td class="paramtype">Collection &amp;&#160;</td>
          <td class="paramname"><em>segments</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Count, from begin to end, the number of positions covered by ranges in the given collection. The collection will be sorted in place.</p>
<p>The collection must be a have a begin(), end(), and random [] access (like a vector).</p>
<p>No boundaries are needed because no positions can be covered without segments representing them. </p>

</div>
</div>
<a id="ac89d8d2356483ef348082609dc310b80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac89d8d2356483ef348082609dc310b80">&#9670;&nbsp;</a></span>dfs() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::dfs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_begin_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_end_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>break_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a2ca7e29cbf4769c5f6432499a45e23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2ca7e29cbf4769c5f6432499a45e23">&#9670;&nbsp;</a></span>dfs() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::dfs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_begin_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_end_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>break_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>tree_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_curr_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>edge_cross_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sinks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade95900b3f3715ae3ecf9b3aee79961f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade95900b3f3715ae3ecf9b3aee79961f">&#9670;&nbsp;</a></span>dfs() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::dfs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_begin_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_end_fn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sinks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a40d6162a9f0dba28306c836d07d7d6e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40d6162a9f0dba28306c836d07d7d6e3">&#9670;&nbsp;</a></span>dijkstra_shortest_cycle_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::dijkstra_shortest_cycle_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Simple Dijkstra implementation that computes shortest cycle. </p>

</div>
</div>
<a id="a38ba5a6719f9f5496130c72a047ad890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ba5a6719f9f5496130c72a047ad890">&#9670;&nbsp;</a></span>disjoint_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">list&lt; bdsg::HashGraph &gt; vg::algorithms::disjoint_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a list of graphs, one for each connected component in the original graph. <a class="el" href="structvg_1_1algorithms_1_1Node.html">Node</a> IDs are preserved from the original graph. </p>

</div>
</div>
<a id="a187fd628ac942c540a1a5fde0e27b0ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a187fd628ac942c540a1a5fde0e27b0ef">&#9670;&nbsp;</a></span>distance_to_head() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::algorithms::distance_to_head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a33aca5bac60aa4d0a4c402ed607b06a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33aca5bac60aa4d0a4c402ed607b06a3">&#9670;&nbsp;</a></span>distance_to_head() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::algorithms::distance_to_head </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_set&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the distance in bases from start of node to start of closest head node of graph, or -1 if that distance exceeds the limit. dist increases by the number of bases of each previous node until you reach the head node seen is a set that holds the nodes that you have already gotten the distance of, but starts off empty </p>

</div>
</div>
<a id="a458c768a87a1182eae38b362aa7b5ad7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a458c768a87a1182eae38b362aa7b5ad7">&#9670;&nbsp;</a></span>distance_to_tail() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::algorithms::distance_to_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8fb0ce9a4ccbb1505e661a1caa266f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8fb0ce9a4ccbb1505e661a1caa266f8">&#9670;&nbsp;</a></span>distance_to_tail() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::algorithms::distance_to_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_set&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the distance in bases from end of node to end of closest tail node of graph, or -1 if that distance exceeds the limit. dist increases by the number of bases of each previous node until you reach the head node seen is a set that holds the nodes that you have already gotten the distance of, but starts off empty </p>

</div>
</div>
<a id="aec7fcd701af4fdcbb87e83f0ea5b420a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec7fcd701af4fdcbb87e83f0ea5b420a">&#9670;&nbsp;</a></span>expand_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::expand_context </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_forward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_backward</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a238775e0e0ecf0b7576f7c2265dfd5e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a238775e0e0ecf0b7576f7c2265dfd5e0">&#9670;&nbsp;</a></span>expand_context_by_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::expand_context_by_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_forward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_backward</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a354ea4a2a6aed208945fc0994ec50d9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a354ea4a2a6aed208945fc0994ec50d9d">&#9670;&nbsp;</a></span>expand_context_by_steps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::expand_context_by_steps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_forward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_backward</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8a0c0c6d333cb438f96e5df6faec3621"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a0c0c6d333cb438f96e5df6faec3621">&#9670;&nbsp;</a></span>expand_context_with_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::expand_context_with_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_forward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_backward</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b57bed3b0fc8427419ccddc077fe20c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b57bed3b0fc8427419ccddc077fe20c">&#9670;&nbsp;</a></span>expand_subgraph_by_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::expand_subgraph_by_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forward_only</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>expand the subgraph iteratively to include at least length new sequence </p>

</div>
</div>
<a id="ac8ff68675a6735fbd34ce736e67a9d52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8ff68675a6735fbd34ce736e67a9d52">&#9670;&nbsp;</a></span>expand_subgraph_by_steps()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::expand_subgraph_by_steps </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forward_only</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>expand the subgraph iteratively for this many steps </p>

</div>
</div>
<a id="aa93f6a90a43d95f7340318a0d9ac4fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa93f6a90a43d95f7340318a0d9ac4fe6">&#9670;&nbsp;</a></span>expand_subgraph_to_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::expand_subgraph_to_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forward_only</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>expand the subgraph iterativel until its total sequence length is greater than length </p>

</div>
</div>
<a id="ae1998da7905d222d25839ca3b9b6c52c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1998da7905d222d25839ca3b9b6c52c">&#9670;&nbsp;</a></span>expand_subgraph_to_node_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::expand_subgraph_to_node_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forward_only</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>expand the subgraph iteratively until its node count is at least node_count </p>

</div>
</div>
<a id="ac0d0446bde00e10bd77816c968ae97b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0d0446bde00e10bd77816c968ae97b0">&#9670;&nbsp;</a></span>extract_connecting_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; vg::algorithms::extract_connecting_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict_max_len</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills a DeletableHandleGraph with the subgraph of a HandleGraph that connects two positions. The nodes that contain the two positions will be 'cut' at the position and will be tips in the returned graph. The algorithm guarantees that 'into' contains all walks between pos_1 and pos_2 under the maximum length except walks that include a cycle involving either position. If no walk between the two positions under the maximum length exists, 'into' will be left empty. An error is thrown if 'into' is not empty when passed to function.</p>
<p>If pos_1 and pos_2 face each other on the same node, the intervening portion of the node is produced in into. If they are on the same node but do not face each other, portions of the original node will exist as distinct nodes in into, and the one correspondign to pos_1 will have the lower node ID.</p>
<p><a class="el" href="structvg_1_1algorithms_1_1Node.html">Node</a> local forward orientations are not changed.</p>
<p>Unless strict_max_len is set, the graph may contain additional nodes not actually on a connecting path under the given length, some of which may be tips.</p>
<p>Args: source graph to extract subgraph from into graph to extract into max_len guarantee finding walks along which pos_1 and pos_2 are this distance apart pos_1 start position, subgraph walks begin from here in same orientation pos_2 end position, subgraph walks end here in the same orientation strict_max_len only extract nodes and edges if they fall on some walk between pos_1 and pos_2 that is under the maximum length (implies only_walks = true)</p>
<p>Returns: a map from node ids in the extracted graph to the node ids in the original graph. The map and the graph will have the same number of entries. </p>

</div>
</div>
<a id="a4270da794ad0185dacef1874a1e4d3c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4270da794ad0185dacef1874a1e4d3c2">&#9670;&nbsp;</a></span>extract_containing_graph() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::extract_containing_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>position_forward_max_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>position_backward_max_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>reversing_walk_length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same semantics as previous except that there is a separate maximum distance for different positions in the graph and for each search direction. Each distance is associated with the position with the same index. The forward distance is in the same orientation as the position, and the backward distance is in the reverse orientation of the position. Throws an error if the position and distance vectors are not the same length. </p>

</div>
</div>
<a id="ab31b1b707c93f96d6f013e579c4d8783"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab31b1b707c93f96d6f013e579c4d8783">&#9670;&nbsp;</a></span>extract_containing_graph() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::extract_containing_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>position_max_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>reversing_walk_length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same semantics as previous except that there is a separate maximum distance for different positions in the graph. Each distance is associated with the position with the same index. Throws an error if the position and distance vectors are not the same length. </p>

</div>
</div>
<a id="a0ecd79b7d4b622b583a8e08df594e45c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ecd79b7d4b622b583a8e08df594e45c">&#9670;&nbsp;</a></span>extract_containing_graph() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::extract_containing_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>reversing_walk_length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills graph 'into' with the subgraph of the handle graph 'source' that contains all of the positions in the positions vector and all other nodes and edges that can be reached within a maximum distance from any of these positions. Optionally also finds nodes and edges that can be reached within some distance from the previously mentioned nodes, except along non- proper bidirected walks. <a class="el" href="structvg_1_1algorithms_1_1Node.html">Node</a> IDs in the subgraph are retained from the source graph.</p>
<p>Args: source graph to extract subgraph from into graph to extract into positions search outward from these positions max_dist include all nodes and edges that can be reached in at most this distance reversing_walk_length also find graph material that can be reached </p>

</div>
</div>
<a id="a38ea20ebc7800702ec0cdb96920c6184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38ea20ebc7800702ec0cdb96920c6184">&#9670;&nbsp;</a></span>extract_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::extract_context </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint64_t &amp;&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fwd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>expand the context around a single handle position </p>

</div>
</div>
<a id="a1f600eb589d48607c2616bed69ff2e27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f600eb589d48607c2616bed69ff2e27">&#9670;&nbsp;</a></span>extract_extending_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; vg::algorithms::extract_extending_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>into</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>backward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_cycles_on_src_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills graph 'into' with the subgraph of the handle graph 'source' that extends in one direction from a given position, up to a maximum distance. The node containing the position will be "cut" so that only the portion that is forward in the search direction remains. <a class="el" href="structvg_1_1algorithms_1_1Node.html">Node</a> IDs may be changed in the extracted graph, but they can be translated back to node IDs in the original graph with the returned map, although that translation procedure MUST handle the node that pos is on specially, as it may be cut. translate_node_ids from <a class="el" href="path_8hpp.html">path.hpp</a> can do this as long as you pass along what part of the node was removed. The node containing the source position may optionally be duplicated to preserve cycles on it after its cut, but no other nodes will will duplicated.</p>
<p>Args: source graph to extract subgraph from into graph to extract into max_dist include all nodes and edges that can be reached in at most this distance pos extend from this position backward extend in this direction preserve_cycles_on_src if necessary, duplicate starting node to preserve cycles after cutting it </p>

</div>
</div>
<a id="ac53dd7f2ff1b53bec309f368a79db951"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac53dd7f2ff1b53bec309f368a79db951">&#9670;&nbsp;</a></span>extract_id_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::extract_id_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">nid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>id1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">nid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>id2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>extract the node id range </p>

</div>
</div>
<a id="a6da60961fae57a5568354ef5b541bcf7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6da60961fae57a5568354ef5b541bcf7">&#9670;&nbsp;</a></span>extract_path_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::extract_path_range </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td>
          <td class="paramname"><em>path_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>extract the path range nodes aren't cut, so the returned graph may start before start and/or end after end if end &lt; 0, then it will walk to the end of the path </p>

</div>
</div>
<a id="ac3f3eeb71fb9bd08889b08aa20fe9605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f3eeb71fb9bd08889b08aa20fe9605">&#9670;&nbsp;</a></span>find_best_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; int, vector&lt; size_t &gt; &gt; vg::algorithms::find_best_chain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>to_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gap_open</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gap_extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg_1_1algorithms.html#a79c214c1e7f1d7cc5fe322b8c9fb260c">transition_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>for_each_transition</em> = <code><a class="el" href="namespacevg_1_1algorithms.html#ac8e2917f0a06c55852e4ef044548f2bb">lookback_transition_iterator</a>(150,&#160;0,&#160;100)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>item_bonus</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>item_scale</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gap_scale</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>points_per_possible_match</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_indel_bases</em> = <code>100</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Chain up the given group of items. Determines the best score and traceback that can be obtained by chaining items together.</p>
<p>Input items must be sorted by start position in the read.</p>
<p>Returns the score and the list of indexes of items visited to achieve that score, in order. </p>

</div>
</div>
<a id="a67dc5da4c5935ba307303798c521c1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67dc5da4c5935ba307303798c521c1c8">&#9670;&nbsp;</a></span>find_best_chains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; int, vector&lt; size_t &gt; &gt; &gt; vg::algorithms::find_best_chains </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>to_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gap_open</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gap_extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_chains</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg_1_1algorithms.html#a79c214c1e7f1d7cc5fe322b8c9fb260c">transition_iterator</a> &amp;&#160;</td>
          <td class="paramname"><em>for_each_transition</em> = <code><a class="el" href="namespacevg_1_1algorithms.html#ac8e2917f0a06c55852e4ef044548f2bb">lookback_transition_iterator</a>(150,&#160;0,&#160;100)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>item_bonus</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>item_scale</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>gap_scale</em> = <code>1.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>points_per_possible_match</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_indel_bases</em> = <code>100</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_work</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Chain up the given group of items. Determines the best scores and tracebacks that can be obtained by chaining items together.</p>
<p>Input items must be sorted by start position in the read.</p>
<p>Returns the scores and the list of indexes of items visited to achieve that score, in order, with multiple tracebacks in descending score order. </p>

</div>
</div>
<a id="a8529f1718d5f0330dbb301d1148f12e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8529f1718d5f0330dbb301d1148f12e1">&#9670;&nbsp;</a></span>find_edges_to_prune()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1pair__hash__set.html">pair_hash_set</a>&lt;<a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a>&gt; vg::algorithms::find_edges_to_prune </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edge_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92780d34d13ab2a6be9fe477543179ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92780d34d13ab2a6be9fe477543179ce">&#9670;&nbsp;</a></span>find_gbwt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const gbwt::GBWT * vg::algorithms::find_gbwt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the GBWT that is part of the given handle graph, if any exists. Works on GBWTGraphs and GBZGraphs. Returns null if no such GBWT exists. </p>

</div>
</div>
<a id="a5783b30c1ad6ea3ff4bc4576f447b615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5783b30c1ad6ea3ff4bc4576f447b615">&#9670;&nbsp;</a></span>find_gbwt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const gbwt::GBWT * vg::algorithms::find_gbwt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; gbwt::GBWT &gt; &amp;&#160;</td>
          <td class="paramname"><em>holder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find a GBWT either by getting it from the given graph or loading it from the given filename into the given unique_ptr. </p>

</div>
</div>
<a id="a1e8867ea22636dc22aa53bd8fe1d0aaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e8867ea22636dc22aa53bd8fe1d0aaa">&#9670;&nbsp;</a></span>find_gbwtgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const gbwtgraph::GBWTGraph * vg::algorithms::find_gbwtgraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the GBWTGraph that is part of the given handle graph, if any exists. Works on GBWTGraphs and GBZGraphs. Returns null if no such GBWTGraph exists. </p>

</div>
</div>
<a id="af38c05b9c1e56c79faccfbbf6b3ade95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af38c05b9c1e56c79faccfbbf6b3ade95">&#9670;&nbsp;</a></span>find_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">NamedNodeBackTranslation</a> * vg::algorithms::find_translation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the NamedNodeBackTranslation defining e.g. GFA segment space for the given handle graph, if any exists. Works on GFAs that have been loaded and finds their path space information. </p>

</div>
</div>
<a id="a30b8fd7a0d56e1827faa3aa56c8828f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30b8fd7a0d56e1827faa3aa56c8828f0">&#9670;&nbsp;</a></span>for_each_kmer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::for_each_kmer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edge_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="structvg_1_1algorithms_1_1kmer__t.html">kmer_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over all the kmers in the graph, running lambda on each. </p>

</div>
</div>
<a id="ace1ad4f4eccc7041eb1e700463492540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1ad4f4eccc7041eb1e700463492540">&#9670;&nbsp;</a></span>for_each_walk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::for_each_walk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>edge_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(const <a class="el" href="structvg_1_1algorithms_1_1walk__t.html">walk_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Iterate over all the walks in the graph, running lambda on each. </p>

</div>
</div>
<a id="a4152fa019243d9fd4c41c73fafce2241"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4152fa019243d9fd4c41c73fafce2241">&#9670;&nbsp;</a></span>get_depth_from_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; float, float &gt; vg::algorithms::get_depth_from_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg_1_1algorithms.html#acf8cb40a8f834b42f1ec89af0ef140b9">BinnedDepthIndex</a> &amp;&#160;</td>
          <td class="paramname"><em>depth_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query index created above. </p>

</div>
</div>
<a id="a0b788763f4e6747ba55e5340de9da855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b788763f4e6747ba55e5340de9da855">&#9670;&nbsp;</a></span>get_graph_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::get_graph_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get distance in the graph, or <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">std::numeric_limits&lt;size_t&gt;::max()</a> if unreachable or beyond the limit. </p>

</div>
</div>
<a id="a5d8762b533e64039ce1a917b047097d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8762b533e64039ce1a917b047097d8">&#9670;&nbsp;</a></span>get_read_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::get_read_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get distance in the read, or <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">std::numeric_limits&lt;size_t&gt;::max()</a> if unreachable. </p>

</div>
</div>
<a id="adca14b7dcba0bb21f3fdb0c98d867c72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adca14b7dcba0bb21f3fdb0c98d867c72">&#9670;&nbsp;</a></span>gfa_to_handle_graph() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::gfa_to_handle_graph </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>translation_filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload which serializes its translation to a file internally. </p>

</div>
</div>
<a id="aedfca626dc003dc3fee77c6bbfcde297"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedfca626dc003dc3fee77c6bbfcde297">&#9670;&nbsp;</a></span>gfa_to_handle_graph() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::gfa_to_handle_graph </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1GFAIDMapInfo.html">GFAIDMapInfo</a> *&#160;</td>
          <td class="paramname"><em>translation</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a GFA file for a blunt-ended graph into a HandleGraph. Give "-" as a filename for stdin.</p>
<p>Throws <a class="el" href="structvg_1_1algorithms_1_1GFAFormatError.html" title="This exception will be thrown if the GFA data is not acceptable.">GFAFormatError</a> if the GFA file is not acceptable, and std::ios_base::failure if an IO operation fails. Throws invalid_argument if otherwise misused. Does not give max ID hints, and so might be very slow when loading into an ODGI graph. </p>

</div>
</div>
<a id="a031cb6d0db20a6aaee020c5a6909ba80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a031cb6d0db20a6aaee020c5a6909ba80">&#9670;&nbsp;</a></span>gfa_to_handle_graph() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::gfa_to_handle_graph </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1GFAIDMapInfo.html">GFAIDMapInfo</a> *&#160;</td>
          <td class="paramname"><em>translation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a GFA from a stream (assumed not to be seekable or reopenable) into a HandleGraph. </p>

</div>
</div>
<a id="a9f5c41c06269c778d2c97f39cbc79de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f5c41c06269c778d2c97f39cbc79de8">&#9670;&nbsp;</a></span>gfa_to_path_handle_graph() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::gfa_to_path_handle_graph </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1GFAIDMapInfo.html">GFAIDMapInfo</a> *&#160;</td>
          <td class="paramname"><em>translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_rgfa_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_set&lt; <a class="el" href="namespacehandlegraph.html#ab3d3683c53bb48b8af63a6d94497271c">PathSense</a> &gt; *&#160;</td>
          <td class="paramname"><em>ignore_sense</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as gfa_to_handle_graph but also adds path elements from the GFA to the graph. </p>

</div>
</div>
<a id="a61f2c7006c531ad5dd319ea30ec0087f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61f2c7006c531ad5dd319ea30ec0087f">&#9670;&nbsp;</a></span>gfa_to_path_handle_graph() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::gfa_to_path_handle_graph </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_rgfa_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>translation_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_set&lt; <a class="el" href="namespacehandlegraph.html#ab3d3683c53bb48b8af63a6d94497271c">PathSense</a> &gt; *&#160;</td>
          <td class="paramname"><em>ignore_sense</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Overload which serializes its translation to a file internally. </p>

</div>
</div>
<a id="a8baa82611439357dc02996ba17ce6aa9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8baa82611439357dc02996ba17ce6aa9">&#9670;&nbsp;</a></span>gfa_to_path_handle_graph() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::gfa_to_path_handle_graph </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1GFAIDMapInfo.html">GFAIDMapInfo</a> *&#160;</td>
          <td class="paramname"><em>translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_rgfa_rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_set&lt; <a class="el" href="namespacehandlegraph.html#ab3d3683c53bb48b8af63a6d94497271c">PathSense</a> &gt; *&#160;</td>
          <td class="paramname"><em>ignore_sense</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a GFA from a stream (assumed not to be seekable or reopenable) into a PathHandleGraph. </p>

</div>
</div>
<a id="a54730e9452c2609633da201ba85a8bca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54730e9452c2609633da201ba85a8bca">&#9670;&nbsp;</a></span>id_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; vg::algorithms::id_order </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Order all the handles in the graph in ID order. All orientations are forward. </p>

</div>
</div>
<a id="a9ce4dabb6661657c7d72593afc3f41df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ce4dabb6661657c7d72593afc3f41df">&#9670;&nbsp;</a></span>intersect_path_offsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::algorithms::intersect_path_offsets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a> &amp;&#160;</td>
          <td class="paramname"><em>a_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a> &amp;&#160;</td>
          <td class="paramname"><em>b_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maximum_distance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given two maps from path handle to (position, orientation) pair vectors, determine if any positions in the two sets are on the same path, within the given maximum distance.</p>
<p>The set expected to have more visits should be passed first.</p>
<p>Orientation is ignored.</p>
<p>The first set must be sorted, for binary search. We run binary search for each item in the second set, so the first set should be the larger one.</p>
<p>We run in b log a time. </p>

</div>
</div>
<a id="aa4cb6665721af1f7c749ca8f73472d6c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4cb6665721af1f7c749ca8f73472d6c">&#9670;&nbsp;</a></span>is_head_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::algorithms::is_head_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac8e4eb795d14d441c4b2944c070a1d78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e4eb795d14d441c4b2944c070a1d78">&#9670;&nbsp;</a></span>is_tail_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::algorithms::is_tail_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>h</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>g</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a633a1600c6a7e447c040fefb1432e508"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a633a1600c6a7e447c040fefb1432e508">&#9670;&nbsp;</a></span>jump_along_closest_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &gt; vg::algorithms::jump_along_closest_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>jump_dist</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_search_dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>returns a vector of positions that are found by jumping a fixed oriented distance along path(s) from the given position. if the position is not on a path, searches from the position to a path and adds/subtracts the search distance to the jump depending on the search direction. returns an empty vector if there is no path within the max search distance or if the jump distance goes past the end of the path </p>

</div>
</div>
<a id="a0820d23864c46dc1bc71ec68aee4e55e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0820d23864c46dc1bc71ec68aee4e55e">&#9670;&nbsp;</a></span>kargers_min_cut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; vector&lt; unordered_set&lt; size_t &gt; &gt;, size_t &gt; vg::algorithms::kargers_min_cut </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a>&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa015cfde6842fff0d0dcd81f7130c659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa015cfde6842fff0d0dcd81f7130c659">&#9670;&nbsp;</a></span>locally_expand_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::locally_expand_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add to a subgraph (with same node ID space as parent) by walking forward from a given node and adding all walks up to a maximum distance away. The handle provided graph should be from the subgraph, not the parent graph. </p>

</div>
</div>
<a id="ac8e2917f0a06c55852e4ef044548f2bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8e2917f0a06c55852e4ef044548f2bb">&#9670;&nbsp;</a></span>lookback_transition_iterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg_1_1algorithms.html#a79c214c1e7f1d7cc5fe322b8c9fb260c">transition_iterator</a> vg::algorithms::lookback_transition_iterator </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_lookback_bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_lookback_items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lookback_item_hard_cap</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a transition iterator that iterates along the read and uses the given lookback control parameters to filter transitions. Closes over the arguments by value. </p>

</div>
</div>
<a id="a91a6bbd822f6380421a973f75036c3d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91a6bbd822f6380421a973f75036c3d3">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html">handlegraph::MutablePathDeletableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge the given ranges of bases on the given handles together, rewriting paths. Sequences must match. Handles to a single node may occur no more than once. </p>

</div>
</div>
<a id="ae18b50d29d9accb763b44d6e065dac58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae18b50d29d9accb763b44d6e065dac58">&#9670;&nbsp;</a></span>min_approx_path_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::min_approx_path_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max_search</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>use the embedded paths to get an estimated minimum distance between the positions </p>

</div>
</div>
<a id="a5cd4d23b1a702613134895c2d5618154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cd4d23b1a702613134895c2d5618154">&#9670;&nbsp;</a></span>min_cut_decomposition()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; unordered_set&lt; size_t &gt; &gt; vg::algorithms::min_cut_decomposition </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a>&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0cecedaa8dd475e634b513af5be028b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0cecedaa8dd475e634b513af5be028b">&#9670;&nbsp;</a></span>multipath_alignment_path_offsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; vg::algorithms::multipath_alignment_path_offsets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mp_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *&#160;</td>
          <td class="paramname"><em>path_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the position of a multipath alignment on paths. Returns the lowest offset position on a path for each contiguous stretch of the multipath alignment, but multiple positions on the same path may be returned if the multipath alignment is disconnected or fans out toward the sources or sinks.</p>
<p>If path_filter is set, and it returns false for a path, that path is not used to annotate the read. </p>

</div>
</div>
<a id="a477330d3ab29cbd3c48e4830d51b3e0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a477330d3ab29cbd3c48e4830d51b3e0f">&#9670;&nbsp;</a></span>nearest_offsets_in_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a> vg::algorithms::nearest_offsets_in_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;)&gt; *&#160;</td>
          <td class="paramname"><em>path_filter</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return, for the nearest position in a path to the given position, subject to the given max search distance, a mapping from path handle to all positions on each path where that pos_t occurs. Stops search when path(s) are ancountered.</p>
<p>If path_filter is set, ignores paths for which it returns false. </p>

</div>
</div>
<a id="a22d03c4f50c51d0d537811ba88895688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22d03c4f50c51d0d537811ba88895688">&#9670;&nbsp;</a></span>next_pos_chars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a>, char &gt; vg::algorithms::next_pos_chars </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb6a93eb17739d744908d61ca6650f4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb6a93eb17739d744908d61ca6650f4c">&#9670;&nbsp;</a></span>normalize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::normalize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html">handlegraph::MutablePathDeletableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_iter</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>can_merge</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Normalize a graph, performing up to the given number of iterations. Simplifies siblings and unchops runs of nodes, in a loop.</p>
<p>if "can_merge" specified, it must return true in order for a pair of nodes to get merged </p>

</div>
</div>
<a id="aa84bd9740e748431857b5fd8a0397183"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84bd9740e748431857b5fd8a0397183">&#9670;&nbsp;</a></span>num_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::num_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aef24fa77dadb09d5920ec94b88af2128"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef24fa77dadb09d5920ec94b88af2128">&#9670;&nbsp;</a></span>offsets_in_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; vg::algorithms::offsets_in_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrapper for the above to support some earlier code. Only looks for paths that directly touch the position, and returns the paths by name. </p>

</div>
</div>
<a id="aafbc78daa41b0c018cd39b7cccbaf53a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafbc78daa41b0c018cd39b7cccbaf53a">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::algorithms::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &amp;&#160;</td>
          <td class="paramname"><em>anchor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Explain an <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> to the given stream. </p>

</div>
</div>
<a id="a503ad2215490c5c599530d7331a70120"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a503ad2215490c5c599530d7331a70120">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::algorithms::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1algorithms_1_1TracedScore.html">TracedScore</a> &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print operator. </p>

</div>
</div>
<a id="a3961418e3f3af94c4275118e4693a2fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3961418e3f3af94c4275118e4693a2fe">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; vg::algorithms::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1algorithms_1_1kmer__t.html">kmer_t</a> &amp;&#160;</td>
          <td class="paramname"><em>kmer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a <a class="el" href="structvg_1_1algorithms_1_1kmer__t.html" title="Stores a kmer in the context of a graph.">kmer_t</a> to a stream. </p>

</div>
</div>
<a id="a58ec8c8d09fde1a6e83194ec7126ed4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58ec8c8d09fde1a6e83194ec7126ed4e">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; vg::algorithms::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1algorithms_1_1walk__t.html">walk_t</a> &amp;&#160;</td>
          <td class="paramname"><em>walk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a <a class="el" href="structvg_1_1algorithms_1_1walk__t.html" title="Record a &lt;=k-length walk in the context of a graph.">walk_t</a> to a stream. </p>

</div>
</div>
<a id="a62ebbcbfe1250940eb8ebf0a2dcbc19a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62ebbcbfe1250940eb8ebf0a2dcbc19a">&#9670;&nbsp;</a></span>packed_depth_of_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; double, double &gt; vg::algorithms::packed_depth_of_bin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;&#160;</td>
          <td class="paramname"><em>packer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td>
          <td class="paramname"><em>start_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td>
          <td class="paramname"><em>end_plus_one_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_deletions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Estimate the coverage along a given reference path interval [start_step, end_plus_one_step) Coverage is obtained only from positions along the path, and variation is not counted Except if "include_deletions" is true, then reference path positions covered by a deletion edge (which is contained in the bin) will get the deletion edge's coverage counted. Other types of events (such as SNPs) can throw off coverage in similar ways but deletions tend to be bigger (and easier to find), so we hope that counting them is enough. If one wants to infer deletions from the coverage, obviously this should be false, but if looking for a background coverage for genotyping, then setting it to true may be helpful </p>

</div>
</div>
<a id="abd431ebd9786d796f708a7046e643e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd431ebd9786d796f708a7046e643e2e">&#9670;&nbsp;</a></span>packed_depths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::packed_depths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;&#160;</td>
          <td class="paramname"><em>packer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out_stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>print path-name offset base-coverage for every base on a path (just like samtools depth) ignoring things below min_coverage. offsets are 1-based in output stream </p>

</div>
</div>
<a id="aaab5b2261edb66897af9d1158e7758d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaab5b2261edb66897af9d1158e7758d8">&#9670;&nbsp;</a></span>pad_band_constant()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a>&amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a>&amp;)&gt; vg::algorithms::pad_band_constant </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a25a37b51facd101b8a29b1a57661f74f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a37b51facd101b8a29b1a57661f74f">&#9670;&nbsp;</a></span>pad_band_min_random_walk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a>&amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a>&amp;)&gt; vg::algorithms::pad_band_min_random_walk </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>band_padding_multiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_memo_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1294ed71274673b7e4cc1d40e9472666"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1294ed71274673b7e4cc1d40e9472666">&#9670;&nbsp;</a></span>pad_band_random_walk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a>&amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a>&amp;)&gt; vg::algorithms::pad_band_random_walk </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>band_padding_multiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_memo_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9957e925ee25c57698383d4e1df21f0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9957e925ee25c57698383d4e1df21f0d">&#9670;&nbsp;</a></span>pad_band_random_walk_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a>&amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a>&amp;)&gt; vg::algorithms::pad_band_random_walk_internal </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>band_padding_multiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding_memo_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_padding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>size_function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8c66507d55ed6e10e9d77e1281d4bcfc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c66507d55ed6e10e9d77e1281d4bcfc">&#9670;&nbsp;</a></span>path_depth_of_bin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; double, double &gt; vg::algorithms::path_depth_of_bin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td>
          <td class="paramname"><em>start_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>&#160;</td>
          <td class="paramname"><em>end_plus_one_step</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>count_cycles</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>like packed_depth_of_bin (above), but use paths (as in path_depths) for measuring coverage </p>

</div>
</div>
<a id="a85250c33b7d32346be371ab7e4404471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85250c33b7d32346be371ab7e4404471">&#9670;&nbsp;</a></span>path_depths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::path_depths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>count_cycles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out_stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>print path-name offset base-coverage for every base on a path (just like samtools depth) ignoring things below min_coverage. offsets are 1-based in output stream coverage here is the number of steps from (unique) other paths </p>

</div>
</div>
<a id="a7acc0acf3d99939a0943ca9e0b86e48a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acc0acf3d99939a0943ca9e0b86e48a">&#9670;&nbsp;</a></span>path_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vg::algorithms::path_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>use the given graph and the path to determine our path string </p>

</div>
</div>
<a id="a09b6e838b2991d13e272ddcb41aacfbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09b6e838b2991d13e272ddcb41aacfbc">&#9670;&nbsp;</a></span>prune_complex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::prune_complex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>path_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take all nodes that would introduce paths of &gt; edge_max edge crossings, remove them, and link their neighbors to head_node or tail_node depending on which direction the path extension was stopped. For pruning graph prior to indexing with gcsa2. Returns the number of edges removed. </p>

</div>
</div>
<a id="a784ee29876a24431a865541426f42dee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a784ee29876a24431a865541426f42dee">&#9670;&nbsp;</a></span>prune_complex_with_head_tail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::prune_complex_with_head_tail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>path_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>edge_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Wrap the graph with heads and tails (for GCSA2 indexing) and then prune as with prune_complex. Returns the number of edges removed. </p>

</div>
</div>
<a id="a83e87cf3f8a5ca4362776cf1a3050242"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83e87cf3f8a5ca4362776cf1a3050242">&#9670;&nbsp;</a></span>prune_short_subgraphs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::prune_short_subgraphs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove any weakly connected components that have total sequence length under the minimum size. Returns the number of nodes removed. </p>

</div>
</div>
<a id="a3d74c519ccaa204e7735d5bd26c5095a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d74c519ccaa204e7735d5bd26c5095a">&#9670;&nbsp;</a></span>prune_to_connecting_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::prune_to_connecting_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove all parts of the graph that are not on some path between the two handles. </p>

</div>
</div>
<a id="acd891e00c4846e53f760d504434ead12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd891e00c4846e53f760d504434ead12">&#9670;&nbsp;</a></span>reallocate_atomic_int_vector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int1 , typename Int2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::reallocate_atomic_int_vector </td>
          <td>(</td>
          <td class="paramtype">vector&lt; atomic&lt; Int1 &gt;&gt; *&amp;&#160;</td>
          <td class="paramname"><em>vec1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; atomic&lt; Int2 &gt;&gt; *&amp;&#160;</td>
          <td class="paramname"><em>vec2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5e4dc632e98b58b67a99af6749d9e05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5e4dc632e98b58b67a99af6749d9e05">&#9670;&nbsp;</a></span>ref_path_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::algorithms::ref_path_distance </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_search_dist</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Search the local region around two positions and return the longest distance between them along any paths found during this search. Returns <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">numeric_limits&lt;int64_t&gt;::max()</a> if no shared path is found. </p>

</div>
</div>
<a id="a96020f05a81255adfca3821f538c02b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96020f05a81255adfca3821f538c02b9">&#9670;&nbsp;</a></span>remove_high_degree_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::remove_high_degree_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">DeletableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_degree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove nodes with &gt;= max_degree total edges on each side. Note that end-to-start self loops count twice. Returns the number of nodes removed. </p>

</div>
</div>
<a id="a80703607cfe21f1f593f7b2f03c08b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80703607cfe21f1f593f7b2f03c08b40">&#9670;&nbsp;</a></span>sample_gam_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;double, double&gt; vg::algorithms::sample_gam_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>random_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_mapq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16bd0de261a829b2d81ec48eed9d6482"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16bd0de261a829b2d81ec48eed9d6482">&#9670;&nbsp;</a></span>sample_mapping_depth() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; double, double &gt; vg::algorithms::sample_mapping_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>input_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>random_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_mapq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>format</em> = <code>&quot;GAM&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the mean and variance of coverage of randomly sampled nodes from a mappings file Nodes with less than min_coverage are ignored The input_filename can be - for stdin The stream is scanned in parallel with all threads max_nodes is used to keep memory down valid formats are "GAM" and "GAF" </p>

</div>
</div>
<a id="a244822514c71473756cfd5ad87f79e08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a244822514c71473756cfd5ad87f79e08">&#9670;&nbsp;</a></span>sample_mapping_depth() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;double, double&gt; vg::algorithms::sample_mapping_depth </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>random_seed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_mapq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As above, but read a vector instead of a stream. </p>

</div>
</div>
<a id="a175ee345e226732cb1c37da13a2f045e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a175ee345e226732cb1c37da13a2f045e">&#9670;&nbsp;</a></span>sample_minimal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::sample_minimal </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>element_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>window_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>sequence_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; size_t(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>get_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(size_t, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>should_beat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; void(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sample the minimal elements in windows of the given size. Uses get_bounds to get inclusive-start, exclusive-end coordinates for elements. Uses should_beat to compare elements. If an element is minimal for a window, calls sample for that element.</p>
<p>You can use should_beat to control tie behavior. If it acts as a less-than comparator, and returns false for ties, tied elements will all be sampled. If it acts as less-than-or-equal-to, and returns true for ties, the latest-occurring element will be sampled in case of ties.</p>
<p>Elements must be sorted by start and all the same length.</p>
<p>Unlike the minimizer sampling algorithm given in Jain et al. 2020., we have to make sure to support multiple elements on the same start position, and zero elements on some start positions.</p>
<p>sample will be called at least once for each element minimal in some window. It will not necessarily be called once per window. </p>

</div>
</div>
<a id="ad91b7ceb67d3923a4c5cace56a5c4f6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad91b7ceb67d3923a4c5cace56a5c4f6e">&#9670;&nbsp;</a></span>score_best_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::algorithms::score_best_chain </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>to_chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gap_open</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>gap_extension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Score the given group of items. Determines the best score that can be obtained by chaining items together.</p>
<p>Input items must be sorted by start position in the read. </p>

</div>
</div>
<a id="abdc2933db32d78a14a8e439f7e9643ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc2933db32d78a14a8e439f7e9643ab">&#9670;&nbsp;</a></span>score_chain_gap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::algorithms::score_chain_gap </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance_difference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>base_seed_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute a gap score like minimap2.</p>
<p>They say they use the average anchor length, but really we need to use the minimizer/base seed length here. Otherwise gaps cost more as your fragments that you are chaining get longer, and cost more at chaining than at fragmenting.</p>
<p>Returns a negative value (gap score).</p>
<p>Score a chaining gap using the Minimap2 method. See <a href="https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6137996/">https://www.ncbi.nlm.nih.gov/pmc/articles/PMC6137996/</a> near equation 2. This produces a penalty (positive number). </p>

</div>
</div>
<a id="a012fced2754c445ec404ff5420018982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a012fced2754c445ec404ff5420018982">&#9670;&nbsp;</a></span>shortest_cycle_length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::shortest_cycle_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of the shortest cycle in the entire graph, or <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">numeric_limits&lt;size_t&gt;::max()</a> if no cycle exists. </p>

</div>
</div>
<a id="acfe6f985e8bedbad1b33861c62379772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe6f985e8bedbad1b33861c62379772">&#9670;&nbsp;</a></span>shortest_cycle_length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::shortest_cycle_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the length of the shortest cycle containing the source node, or <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">numeric_limits&lt;size_t&gt;::max()</a> if no cycle exists. </p>

</div>
</div>
<a id="aa87ca8c58307fdb47d448deb2ec43389"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa87ca8c58307fdb47d448deb2ec43389">&#9670;&nbsp;</a></span>shortest_cycle_length_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::algorithms::shortest_cycle_length_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>layout</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>handle_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; size_t, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>feedback_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ddb73ef3cf5a8891aa82001f272c3c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ddb73ef3cf5a8891aa82001f272c3c4">&#9670;&nbsp;</a></span>simple_offsets_in_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a> vg::algorithms::simple_offsets_in_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacehandlegraph.html#a0abc3c64da852112ad2bc0fc9dd5afce">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A "simple" model for path position getting for debugging. </p>

</div>
</div>
<a id="a9e4cebdfc1e901db4588c4612653df96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e4cebdfc1e901db4588c4612653df96">&#9670;&nbsp;</a></span>simplify_siblings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::algorithms::simplify_siblings </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html">handlegraph::MutablePathDeletableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>can_merge</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simplify siblings in the given graph.</p>
<p>When one base has two successors with the same base value, and those successors have the same set of predecessors, the successors will be merged.</p>
<p>Performs only a subset of the possible merges. Can only merge in from one side of a given node in a single invocation. Returns true if it made progress and there may be more merging to do.</p>
<p>Preserves paths.</p>
<p>Optional can_merge callback will only let nodes get merged together if this pairwise check returns true. </p>

</div>
</div>
<a id="aaeeaa766337fc50f0a9b4d3214271923"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeeaa766337fc50f0a9b4d3214271923">&#9670;&nbsp;</a></span>sort_anchor_indexes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::sort_anchor_indexes </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="classvg_1_1algorithms_1_1Anchor.html">Anchor</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>items</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>indexes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort indexes in the given list by by read start position (and end position) of the anchors they refer to. </p>

</div>
</div>
<a id="ad8e5913b682c7c14f119543eca7e7548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8e5913b682c7c14f119543eca7e7548">&#9670;&nbsp;</a></span>sort_path_offsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::sort_path_offsets </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg_1_1algorithms.html#a6474017f8ab54b0c6e20095206a880a8">path_offset_collection_t</a> &amp;&#160;</td>
          <td class="paramname"><em>offsets</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort path offsets, so <a class="el" href="namespacevg_1_1algorithms.html#a9ce4dabb6661657c7d72593afc3f41df">intersect_path_offsets()</a> can use them as a target. </p>

</div>
</div>
<a id="a64bd6b3ff0d2e22bf752e29e3522a98d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64bd6b3ff0d2e22bf752e29e3522a98d">&#9670;&nbsp;</a></span>sorted_id_ranges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &gt; vg::algorithms::sorted_id_ranges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a sorted list of inclusive ranges of IDs used in the given HandleGraph. </p>

</div>
</div>
<a id="a7215192f2cc6536b6b3aadef4e95c64a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7215192f2cc6536b6b3aadef4e95c64a">&#9670;&nbsp;</a></span>three_edge_connected_component_merges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TECCNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::three_edge_connected_component_merges </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>for_each_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(TECCNode, const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>for_each_connected_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(TECCNode, TECCNode)&gt; &amp;&#160;</td>
          <td class="paramname"><em>same_component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the three-edge-connected components of an arbitrary graph (not necessarily a handle graph). Only recognizes one kind of edge and one kind of node. Nodes are arbitrary value types (which may need to be hashable).</p>
<p>Takes a function that loops an iteratee over all nodes, and a function that, given a node, loops an iteratee over all nodes connected to it.</p>
<p>Calls same_component with pairs of nodes in (at least) a spanning tree of the set of nodes in each component (not restricted to the input graph). Doing merge operations on a union-find can get you the set of components. The callback MUST NOT modify the graph!</p>
<p>If you have a graph where you can easily rank the nodes, don't use this. Use <a class="el" href="namespacevg_1_1algorithms.html#a34c4a74208a88c0f956e697d5e183f5c">three_edge_connected_components_dense()</a> instead. The first thing this function does is asign nodes a dense, 0-based rank space. <br  />
 </p>

</div>
</div>
<a id="a4d4b7c6814fb1f53a83c2e8355d72efa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d4b7c6814fb1f53a83c2e8355d72efa">&#9670;&nbsp;</a></span>three_edge_connected_component_merges_dense()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::three_edge_connected_component_merges_dense </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(size_t, const function&lt; void(size_t)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>for_each_connected_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(size_t, size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>same_component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the three-edge-connected components of an arbitrary graph (not necessarily a handle graph). Only recognizes one kind of edge and one kind of node. Nodes are dense positive integers starting with 0.</p>
<p>Takes a total node count, a suggested root (or 0), and a function that, given a node, loops an iteratee over all nodes connected to it.</p>
<p>Calls same_component with pairs of nodes in (at least) a spanning tree of the set of nodes in each component (not restricted to the input graph). Doing merge operations on a union-find can get you the set of components. The callback MUST NOT modify the graph! </p>
<p>This defines the data we track for each node in the graph</p>
<p>When in the DFS were we first visited?</p>
<p>When in the DFS were we last visited? Needed for finding replacement neighbors to implement path range absorption in part 1.3, when we're asked for a range to a neighbor that got eaten.</p>
<p>What is our "low point" in the search. This is the earliest dfs_counter for a node that this node or any node in its DFS subtree has a back-edge to.</p>
<p>What is the effective degree of this node in the graph with all the absorb-eject modifications applied?</p>
<p>What node has the continuation of this node's path? If equal to <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">numeric_limits&lt;number_t&gt;::max()</a>, the path ends after here. The node's path is the path from this node, into its DFS subtree, to (one of) the nodes in the subtree that has the back-edge that caused this node's low point to be so low. Basically a low point traceback.</p>
<p>Is this node actually on its own path? Nodes can be removed from their paths if those nodes don't matter any more (i.e. got absorbed) but their paths still need to be tails for other paths.</p>
<p>Has the node been visited yet? Must be 0. TODO: Move to its own vector to make zeroing them all free-ish with page table shenanigans.</p>
<p>Track the node that this stack frame represents</p>
<p>Track all the neighbors left to visit. When we visit a neighbor we pop it off the back.</p>
<p>When we look at the neighbors, we need to be able to tell the tree edge to the parent from further back edges to the parent. So we have a flag for whether we have seen the parent tree edge already, and the first neighbors entry that is our parent will get called the tree edge.</p>
<p>Track whether we made a recursive DFS call into the last neighbor or not. If we did, we need to do some work when we come out of it and return to this frame.</p>

</div>
</div>
<a id="ae4677e69f0b8ceb8580bc019cc8fbea8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4677e69f0b8ceb8580bc019cc8fbea8">&#9670;&nbsp;</a></span>three_edge_connected_components()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TECCNode &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::three_edge_connected_components </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>for_each_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(TECCNode, const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>for_each_connected_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const function&lt; void(const function&lt; void(TECCNode)&gt; &amp;)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>component_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the three-edge-connected components of an arbitrary graph (not necessarily a handle graph). Only recognizes one kind of edge and one kind of node. Nodes are arbitrary value types (which may need to be hashable).</p>
<p>Takes a function that loops an iteratee over all nodes, and a function that, given a node, loops an iteratee over all nodes connected to it.</p>
<p>For each component identified, calls the given callback with a function that iterates over all nodes in the component.</p>
<p>If you have a graph where you can easily rank the nodes, don't use this. Use <a class="el" href="namespacevg_1_1algorithms.html#a34c4a74208a88c0f956e697d5e183f5c">three_edge_connected_components_dense()</a> instead. The first thing this function does is asign nodes a dense, 0-based rank space. <br  />
 </p>

</div>
</div>
<a id="a34c4a74208a88c0f956e697d5e183f5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34c4a74208a88c0f956e697d5e183f5c">&#9670;&nbsp;</a></span>three_edge_connected_components_dense()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::three_edge_connected_components_dense </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>first_root</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(size_t, const function&lt; void(size_t)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>for_each_connected_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const function&lt; void(const function&lt; void(size_t)&gt; &amp;)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>component_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the three-edge-connected components of an arbitrary graph (not necessarily a handle graph). Only recognizes one kind of edge and one kind of node. Nodes are dense positive integers starting with 0.</p>
<p>Takes a total node count, a suggested root (or 0), and a function that, given a node, loops an iteratee over all nodes connected to it.</p>
<p>For each component identified, calls the given callback with a function that iterates over all nodes in the component. </p>

</div>
</div>
<a id="a57de725b70b138394479863428f9d2eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57de725b70b138394479863428f9d2eb">&#9670;&nbsp;</a></span>three_edge_connected_components_dense_cactus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::three_edge_connected_components_dense_cactus </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(size_t, const function&lt; void(size_t)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>for_each_connected_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const function&lt; void(const function&lt; void(size_t)&gt; &amp;)&gt; &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>component_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the three-edge-connected components of an arbitrary graph (not necessarily a handle graph). Only recognizes one kind of edge and one kind of node. Nodes are dense positive integers starting with 0.</p>
<p>Wraps the known good the 3 edge connected components algorithm from the pinchesAndCacti library.</p>
<p>Takes a total node count, and a function that, given a node, loops an iteratee over all nodes connected to it.</p>
<p>For each component identified, calls the given callback with a function that iterates over all nodes in the component. </p>

</div>
</div>
<a id="a6341683f1b89495d2ac1558ed2875343"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6341683f1b89495d2ac1558ed2875343">&#9670;&nbsp;</a></span>traverse_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::algorithms::traverse_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>on_new_comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>on_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4af5e9c480c0dc7d0843cf981cd52c32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4af5e9c480c0dc7d0843cf981cd52c32">&#9670;&nbsp;</a></span>walk_haplotype_frequency()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::algorithms::walk_haplotype_frequency </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>haplotypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1algorithms_1_1walk__t.html">walk_t</a> &amp;&#160;</td>
          <td class="paramname"><em>walk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe9cb62b2ae1c6eb08b10f172980788d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe9cb62b2ae1c6eb08b10f172980788d">&#9670;&nbsp;</a></span>walk_haplotype_names()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; vg::algorithms::walk_haplotype_names </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>haplotypes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1algorithms_1_1walk__t.html">walk_t</a> &amp;&#160;</td>
          <td class="paramname"><em>walk</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08c6d85f2dc09c22c5d14ed81808769e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08c6d85f2dc09c22c5d14ed81808769e">&#9670;&nbsp;</a></span>widest_dijkstra()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; double, vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &gt; vg::algorithms::widest_dijkstra </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; double(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>node_weight_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; double(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>edge_weight_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>is_node_ignored_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; bool(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>is_edge_ignored_callbback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>greedy_avg</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This Dijkstra is the same underlying algorithm as the one in dijkstra.hpp but the interface is different enough that I opted to make it a seprate thing rather than add loads of optional arguments. The key differences are these generalizations: &ndash; looks for the "widest" path (maximum minimum weight) instead of shortest &ndash; counts node and edge weights (via callbakcs) &ndash; returns the path as well as the score &ndash; option for ignoring certain nodes and edges in search (required by Yen's algorithm) &ndash; greedy_avg option switches the algorithm to a heuristic (no optimal guarantee) search using the running averages support instead of min-flow support as objective function. </p>

</div>
</div>
<a id="ad9a715606bdd30499dc9db88583c6573"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9a715606bdd30499dc9db88583c6573">&#9670;&nbsp;</a></span>yens_k_widest_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; double, vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &gt; &gt; vg::algorithms::yens_k_widest_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>sink</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>K</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; double(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>node_weight_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; double(const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>edge_weight_callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>greedy_avg</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_path_length</em> = <code>numeric_limits&lt;&#160;size_t&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find the k widest paths Search is aborted (and current list returned) if a path longer than max_path_length is added to the results </p>

</div>
</div>
<a id="aa186cef438679cb79232d24f64be1f89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa186cef438679cb79232d24f64be1f89">&#9670;&nbsp;</a></span>zip_tree_transition_iterator()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg_1_1algorithms.html#a79c214c1e7f1d7cc5fe322b8c9fb260c">transition_iterator</a> vg::algorithms::zip_tree_transition_iterator </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structvg_1_1SnarlDistanceIndexClusterer_1_1Seed.html">SnarlDistanceIndexClusterer::Seed</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>seeds</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1ZipCodeTree.html">ZipCodeTree</a> &amp;&#160;</td>
          <td class="paramname"><em>zip_code_tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_graph_lookback_bases</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_read_lookback_bases</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return a transition iterator that uses zip code tree iteration to select traversals.</p>
<p>Enumerates transitions under the max graph lookback bases, and filters them by the max read lookback bases. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ab48342aedc7d81e2334c52bb320223c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab48342aedc7d81e2334c52bb320223c2">&#9670;&nbsp;</a></span>pad_band_constant</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a>&amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a>&amp;)&gt; vg::algorithms::pad_band_constant(size_t band_padding)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a band padding function that uses a constant value. </p>

</div>
</div>
<a id="a3363cc23e6c71e1bb5faac975af7920d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3363cc23e6c71e1bb5faac975af7920d">&#9670;&nbsp;</a></span>pad_band_min_random_walk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a>&amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a>&amp;)&gt; vg::algorithms::pad_band_min_random_walk(double band_padding_multiplier=1.0, size_t band_padding_memo_size=2000, size_t max_padding=std::numeric_limits&lt; size_t &gt;::max())</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a band padding function that scales the expected distance of a random walk, memoized out to the given length, using the minimum of graph size and read size as the length. </p>

</div>
</div>
<a id="a6a606c26b5751d935c71d7971a92d99b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a606c26b5751d935c71d7971a92d99b">&#9670;&nbsp;</a></span>pad_band_random_walk</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::function&lt;size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a>&amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a>&amp;)&gt; vg::algorithms::pad_band_random_walk(double band_padding_multiplier=1.0, size_t band_padding_memo_size=2000, size_t max_padding=std::numeric_limits&lt; size_t &gt;::max())</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a band padding function that scales with the expected distance of a random walk, memoized out to the given length. </p>

</div>
</div>
<a id="a64f4abe5d8279f14a52b56ffb47fff34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f4abe5d8279f14a52b56ffb47fff34">&#9670;&nbsp;</a></span>PRUNE_THREAD_BUFFER_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_t vg::algorithms::PRUNE_THREAD_BUFFER_SIZE = 1024 * 1024</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">constexpr</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
