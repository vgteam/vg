<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: handlegraph::HandleGraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacehandlegraph.html">handlegraph</a></li><li class="navelem"><a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="classhandlegraph_1_1HandleGraph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">handlegraph::HandleGraph Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;handle_graph.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for handlegraph::HandleGraph:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classhandlegraph_1_1HandleGraph.png" usemap="#handlegraph::HandleGraph_map" alt=""/>
  <map id="handlegraph::HandleGraph_map" name="handlegraph::HandleGraph_map">
<area href="classhandlegraph_1_1ExpandingOverlayGraph.html" alt="handlegraph::ExpandingOverlayGraph" shape="rect" coords="239,56,468,80"/>
<area href="classhandlegraph_1_1MutableHandleGraph.html" alt="handlegraph::MutableHandleGraph" shape="rect" coords="239,112,468,136"/>
<area href="classhandlegraph_1_1PathHandleGraph.html" alt="handlegraph::PathHandleGraph" shape="rect" coords="239,168,468,192"/>
<area href="classhandlegraph_1_1RankedHandleGraph.html" alt="handlegraph::RankedHandleGraph" shape="rect" coords="239,224,468,248"/>
<area href="classvg_1_1ExtraNodeGraph.html" alt="vg::ExtraNodeGraph" shape="rect" coords="239,280,468,304"/>
<area href="classvg_1_1IndexedVG.html" alt="vg::IndexedVG" shape="rect" coords="239,336,468,360"/>
<area href="classvg_1_1JoinedSpliceGraph.html" alt="vg::JoinedSpliceGraph" shape="rect" coords="239,392,468,416"/>
<area href="classvg_1_1NetGraph.html" alt="vg::NetGraph" shape="rect" coords="239,448,468,472"/>
<area href="classvg_1_1SnarlGraph.html" alt="vg::SnarlGraph" shape="rect" coords="239,504,468,528"/>
<area href="classvg_1_1SubgraphOverlay.html" alt="vg::SubgraphOverlay" shape="rect" coords="239,560,468,584"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a24fb796441c9ad8c870fdb716a82b305"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a24fb796441c9ad8c870fdb716a82b305">~HandleGraph</a> ()=default</td></tr>
<tr class="separator:a24fb796441c9ad8c870fdb716a82b305"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e58a79001cd7d839ac1f1adaff34dfb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a6e58a79001cd7d839ac1f1adaff34dfb">has_node</a> (<a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">nid_t</a> node_id) const =0</td></tr>
<tr class="memdesc:a6e58a79001cd7d839ac1f1adaff34dfb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Method to check if a node exists by ID.  <a href="classhandlegraph_1_1HandleGraph.html#a6e58a79001cd7d839ac1f1adaff34dfb">More...</a><br /></td></tr>
<tr class="separator:a6e58a79001cd7d839ac1f1adaff34dfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd9d70931835f5c75518b23a780b744"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a6dd9d70931835f5c75518b23a780b744">get_handle</a> (const <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">nid_t</a> &amp;node_id, bool is_reverse=false) const =0</td></tr>
<tr class="memdesc:a6dd9d70931835f5c75518b23a780b744"><td class="mdescLeft">&#160;</td><td class="mdescRight">Look up the handle for the node with the given ID in the given orientation.  <a href="classhandlegraph_1_1HandleGraph.html#a6dd9d70931835f5c75518b23a780b744">More...</a><br /></td></tr>
<tr class="separator:a6dd9d70931835f5c75518b23a780b744"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7f6e144bf2a59679f7b2eddad934eb"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#adb7f6e144bf2a59679f7b2eddad934eb">get_id</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const =0</td></tr>
<tr class="memdesc:adb7f6e144bf2a59679f7b2eddad934eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID from a handle.  <a href="classhandlegraph_1_1HandleGraph.html#adb7f6e144bf2a59679f7b2eddad934eb">More...</a><br /></td></tr>
<tr class="separator:adb7f6e144bf2a59679f7b2eddad934eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92773f90eb58f18adb9418a4440223c1"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a92773f90eb58f18adb9418a4440223c1">get_is_reverse</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const =0</td></tr>
<tr class="memdesc:a92773f90eb58f18adb9418a4440223c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the orientation of a handle.  <a href="classhandlegraph_1_1HandleGraph.html#a92773f90eb58f18adb9418a4440223c1">More...</a><br /></td></tr>
<tr class="separator:a92773f90eb58f18adb9418a4440223c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa3f94ae7e884408ef6e8ca8fd45c7d7"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#aaa3f94ae7e884408ef6e8ca8fd45c7d7">flip</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const =0</td></tr>
<tr class="memdesc:aaa3f94ae7e884408ef6e8ca8fd45c7d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert the orientation of a handle (potentially without getting its ID)  <a href="classhandlegraph_1_1HandleGraph.html#aaa3f94ae7e884408ef6e8ca8fd45c7d7">More...</a><br /></td></tr>
<tr class="separator:aaa3f94ae7e884408ef6e8ca8fd45c7d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a569ff35fb85c725b0b6b6933ed303e49"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a569ff35fb85c725b0b6b6933ed303e49">get_length</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const =0</td></tr>
<tr class="memdesc:a569ff35fb85c725b0b6b6933ed303e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the length of a node.  <a href="classhandlegraph_1_1HandleGraph.html#a569ff35fb85c725b0b6b6933ed303e49">More...</a><br /></td></tr>
<tr class="separator:a569ff35fb85c725b0b6b6933ed303e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cc2ab8a1292e30ba5e167a823f66d92"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a8cc2ab8a1292e30ba5e167a823f66d92">get_sequence</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const =0</td></tr>
<tr class="separator:a8cc2ab8a1292e30ba5e167a823f66d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f95108e6c3f68f404fa93bd3306e4c6"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a9f95108e6c3f68f404fa93bd3306e4c6">get_node_count</a> () const =0</td></tr>
<tr class="memdesc:a9f95108e6c3f68f404fa93bd3306e4c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the number of nodes in the graph.  <a href="classhandlegraph_1_1HandleGraph.html#a9f95108e6c3f68f404fa93bd3306e4c6">More...</a><br /></td></tr>
<tr class="separator:a9f95108e6c3f68f404fa93bd3306e4c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85c52fe4b5f483504ed142d0ad94a969"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a85c52fe4b5f483504ed142d0ad94a969">min_node_id</a> () const =0</td></tr>
<tr class="separator:a85c52fe4b5f483504ed142d0ad94a969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2e2b1ea6a29b3f4b34a6abcb6dbc50"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a5a2e2b1ea6a29b3f4b34a6abcb6dbc50">max_node_id</a> () const =0</td></tr>
<tr class="separator:a5a2e2b1ea6a29b3f4b34a6abcb6dbc50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d21f30e62ad0b0c5919b2fe95e6f8aa"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a4d21f30e62ad0b0c5919b2fe95e6f8aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a4d21f30e62ad0b0c5919b2fe95e6f8aa">follow_edges</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const Iteratee &amp;iteratee) const</td></tr>
<tr class="separator:a4d21f30e62ad0b0c5919b2fe95e6f8aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a928bdeabd328d357b538e30590164ab4"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a928bdeabd328d357b538e30590164ab4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a928bdeabd328d357b538e30590164ab4">for_each_handle</a> (const Iteratee &amp;iteratee, bool parallel=false) const</td></tr>
<tr class="separator:a928bdeabd328d357b538e30590164ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab259e3aba0da47b0ef1c9b5e43c7d209"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#ab259e3aba0da47b0ef1c9b5e43c7d209">get_degree</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left) const</td></tr>
<tr class="separator:ab259e3aba0da47b0ef1c9b5e43c7d209"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a069448fbe58665b9ff531ad0b8c5af57"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a069448fbe58665b9ff531ad0b8c5af57">has_edge</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const</td></tr>
<tr class="separator:a069448fbe58665b9ff531ad0b8c5af57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6171cdd6036c73623c96656f8b44fe9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a6171cdd6036c73623c96656f8b44fe9d">has_edge</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge) const</td></tr>
<tr class="memdesc:a6171cdd6036c73623c96656f8b44fe9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenient wrapper of has_edge for edge_t argument.  <a href="classhandlegraph_1_1HandleGraph.html#a6171cdd6036c73623c96656f8b44fe9d">More...</a><br /></td></tr>
<tr class="separator:a6171cdd6036c73623c96656f8b44fe9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ff62014d7f0f0c01ada8a3d40a278d"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a20ff62014d7f0f0c01ada8a3d40a278d">get_edge_count</a> () const</td></tr>
<tr class="separator:a20ff62014d7f0f0c01ada8a3d40a278d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c98da99e0d32ebcc9fd31be4b779e29"><td class="memItemLeft" align="right" valign="top">virtual size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a4c98da99e0d32ebcc9fd31be4b779e29">get_total_length</a> () const</td></tr>
<tr class="separator:a4c98da99e0d32ebcc9fd31be4b779e29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64d58c3e26e9e7954dd25c3eff7af521"><td class="memItemLeft" align="right" valign="top">virtual char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a64d58c3e26e9e7954dd25c3eff7af521">get_base</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t index) const</td></tr>
<tr class="separator:a64d58c3e26e9e7954dd25c3eff7af521"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74c6fcda357516b1160996c63ed40d63"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a74c6fcda357516b1160996c63ed40d63">get_subsequence</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, size_t index, size_t size) const</td></tr>
<tr class="separator:a74c6fcda357516b1160996c63ed40d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e946bb4ed53f9423072955cdaab6386"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a9e946bb4ed53f9423072955cdaab6386">forward</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle) const</td></tr>
<tr class="memdesc:a9e946bb4ed53f9423072955cdaab6386"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the locally forward version of a handle.  <a href="classhandlegraph_1_1HandleGraph.html#a9e946bb4ed53f9423072955cdaab6386">More...</a><br /></td></tr>
<tr class="separator:a9e946bb4ed53f9423072955cdaab6386"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3766f1aca1cbdbf827f2a12aaf2078ec"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a3766f1aca1cbdbf827f2a12aaf2078ec">edge_handle</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;right) const</td></tr>
<tr class="separator:a3766f1aca1cbdbf827f2a12aaf2078ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af167b0664299cfd4eac610f129fa5fee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#af167b0664299cfd4eac610f129fa5fee">traverse_edge_handle</a> (const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;edge, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;left) const</td></tr>
<tr class="separator:af167b0664299cfd4eac610f129fa5fee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61570ded026f825d62ea7608a1e92349"><td class="memTemplParams" colspan="2">template&lt;typename Iteratee &gt; </td></tr>
<tr class="memitem:a61570ded026f825d62ea7608a1e92349"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a61570ded026f825d62ea7608a1e92349">for_each_edge</a> (const Iteratee &amp;iteratee, bool parallel=false) const</td></tr>
<tr class="separator:a61570ded026f825d62ea7608a1e92349"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a89bbc118fe1e8e1acb162c14be33e8b5"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#a89bbc118fe1e8e1acb162c14be33e8b5">follow_edges_impl</a> (const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle, bool go_left, const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee) const =0</td></tr>
<tr class="separator:a89bbc118fe1e8e1acb162c14be33e8b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48ba081fcb810267dc50e3a3e7ad391"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classhandlegraph_1_1HandleGraph.html#af48ba081fcb810267dc50e3a3e7ad391">for_each_handle_impl</a> (const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;iteratee, bool parallel=false) const =0</td></tr>
<tr class="separator:af48ba081fcb810267dc50e3a3e7ad391"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is the interface that a graph that uses handles needs to support. It is also the interface that users should code against. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a24fb796441c9ad8c870fdb716a82b305"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24fb796441c9ad8c870fdb716a82b305">&#9670;&nbsp;</a></span>~HandleGraph()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual handlegraph::HandleGraph::~HandleGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3766f1aca1cbdbf827f2a12aaf2078ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3766f1aca1cbdbf827f2a12aaf2078ec">&#9670;&nbsp;</a></span>edge_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::pair&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; handlegraph::HandleGraph::edge_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A pair of handles can be used as an edge. When so used, the handles have a canonical order and orientation. </p>

</div>
</div>
<a id="aaa3f94ae7e884408ef6e8ca8fd45c7d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa3f94ae7e884408ef6e8ca8fd45c7d7">&#9670;&nbsp;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> handlegraph::HandleGraph::flip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert the orientation of a handle (potentially without getting its ID) </p>

<p>Implemented in <a class="el" href="classvg_1_1SnarlGraph.html#afacfbb0fb244f3004ff0d8c9fbf76f37">vg::SnarlGraph</a>, <a class="el" href="classvg_1_1NetGraph.html#a4f1db15a73fdce232fcd55a547986f82">vg::NetGraph</a>, <a class="el" href="classxg_1_1XG.html#acc7c6296fefeacf908acca84e5d6d14c">xg::XG</a>, <a class="el" href="classvg_1_1JoinedSpliceGraph.html#a603e8b014c4f3c9041ac8edfcdc355e0">vg::JoinedSpliceGraph</a>, <a class="el" href="classvg_1_1VG.html#a48a5e160f098327f149b7a8a7a5b3558">vg::VG</a>, <a class="el" href="classvg_1_1IndexedVG.html#a984084b7b8770329963b23845c53e820">vg::IndexedVG</a>, <a class="el" href="classvg_1_1IncrementalSubgraph.html#a1dad5cc9948fd536f67bdd2f40ef6765">vg::IncrementalSubgraph</a>, <a class="el" href="classvg_1_1TreeSubgraph.html#af2ff96076aa4e658f15c4a6d4c1460e3">vg::TreeSubgraph</a>, <a class="el" href="classvg_1_1SourceSinkOverlay.html#a1679195a16f99684463e3560352339a4">vg::SourceSinkOverlay</a>, <a class="el" href="classvg_1_1ExtraNodeGraph.html#a755ee2394bad62e0f4e6d17aa0212a72">vg::ExtraNodeGraph</a>, <a class="el" href="classvg_1_1DozeuPinningOverlay.html#aa28af0d1bfc6cc3952bec3904b688e7a">vg::DozeuPinningOverlay</a>, <a class="el" href="classvg_1_1SubgraphOverlay.html#a7520f901a2194ed3241b4097ce720481">vg::SubgraphOverlay</a>, <a class="el" href="classvg_1_1PathSubgraph.html#ae898f2e9d1b456f2e35f5307e2045283">vg::PathSubgraph</a>, <a class="el" href="classvg_1_1SubHandleGraph.html#a00c5d8d2c19e965ee99a76bb4cd353bf">vg::SubHandleGraph</a>, <a class="el" href="classhandlegraph_1_1algorithms_1_1SubHandleGraph.html#af37976fbc4774d7cc444a7839b65c849">handlegraph::algorithms::SubHandleGraph</a>, <a class="el" href="classvg_1_1StrandSplitGraph.html#a6e4ce04f8b55b54e737e5f9d102b6149">vg::StrandSplitGraph</a>, <a class="el" href="classvg_1_1MemoizingGraph.html#afc634cf011767c68b0de3c205d24c251">vg::MemoizingGraph</a>, <a class="el" href="classvg_1_1ReverseGraph.html#a9a074446252aeab52d5922480c861e4f">vg::ReverseGraph</a>, <a class="el" href="classvg_1_1DagifiedGraph.html#a570cd39e720ecbaadb6ff49ae3f0e23e">vg::DagifiedGraph</a>, <a class="el" href="classvg_1_1IdentityOverlay.html#a34ea51454cdd3a12d73992563f514f02">vg::IdentityOverlay</a>, and <a class="el" href="classvg_1_1NullMaskingGraph.html#ade5b77f51f0749cba197c55d741ceb89">vg::NullMaskingGraph</a>.</p>

</div>
</div>
<a id="a4d21f30e62ad0b0c5919b2fe95e6f8aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d21f30e62ad0b0c5919b2fe95e6f8aa">&#9670;&nbsp;</a></span>follow_edges()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iteratee &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::HandleGraph::follow_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iteratee &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loop over all the handles to next/previous (right/left) nodes. Passes them to a callback. If called with a bool-returning invocable thing, can stop early when the function returns false. Returns true if we finished and false if we stopped early. </p>

</div>
</div>
<a id="a89bbc118fe1e8e1acb162c14be33e8b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89bbc118fe1e8e1acb162c14be33e8b5">&#9670;&nbsp;</a></span>follow_edges_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handlegraph::HandleGraph::follow_edges_impl </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the handles to next/previous (right/left) nodes. Passes them to a callback which returns false to stop iterating and true to continue. Returns true if we finished and false if we stopped early. </p>

<p>Implemented in <a class="el" href="classvg_1_1SnarlGraph.html#a058d9545317220176574196c0856771c">vg::SnarlGraph</a>, <a class="el" href="classxg_1_1XG.html#a6c68a283c56d458bbb66d77684be0583">xg::XG</a>, and <a class="el" href="classvg_1_1SubgraphOverlay.html#a421ab670d9cfbdf1faff768e77b854a0">vg::SubgraphOverlay</a>.</p>

</div>
</div>
<a id="a61570ded026f825d62ea7608a1e92349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61570ded026f825d62ea7608a1e92349">&#9670;&nbsp;</a></span>for_each_edge()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iteratee &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::HandleGraph::for_each_edge </td>
          <td>(</td>
          <td class="paramtype">const Iteratee &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loop over all edges in their canonical orientation (as returned by edge_handle) as edge_t items and execute an iteratee on each one. If the iteratee returns bool, and it returns false, stop iteration. Return true if the iteration completed and false if it stopped early. If run in parallel (parallel = true), stopping early is best-effort. </p>

</div>
</div>
<a id="a928bdeabd328d357b538e30590164ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a928bdeabd328d357b538e30590164ab4">&#9670;&nbsp;</a></span>for_each_handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iteratee &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::HandleGraph::for_each_handle </td>
          <td>(</td>
          <td class="paramtype">const Iteratee &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Loop over all the nodes in the graph in their local forward orientations, in their internal stored order. If called with a bool-returning invocable thing, can stop early when the function returns false. Returns true if we finished and false if we stopped early. Can be told to run in parallel, in which case stopping after a false return value is on a best-effort basis and iteration order is not defined. </p>

</div>
</div>
<a id="af48ba081fcb810267dc50e3a3e7ad391"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af48ba081fcb810267dc50e3a3e7ad391">&#9670;&nbsp;</a></span>for_each_handle_impl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handlegraph::HandleGraph::for_each_handle_impl </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; bool(const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>parallel</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Loop over all the nodes in the graph in their local forward orientations, in their internal stored order. Stop if the iteratee returns false. Can be told to run in parallel, in which case stopping after a false return value is on a best-effort basis and iteration order is not defined. Returns true if we finished and false if we stopped early. </p>

<p>Implemented in <a class="el" href="classvg_1_1SnarlGraph.html#a2312825b11c4c4046e79a35cacadfe27">vg::SnarlGraph</a>, <a class="el" href="classxg_1_1XG.html#af0b6c8a9c8e12575b345ab8a5209874b">xg::XG</a>, and <a class="el" href="classvg_1_1SubgraphOverlay.html#a054f387a6c02302e47815f501034a068">vg::SubgraphOverlay</a>.</p>

</div>
</div>
<a id="a9e946bb4ed53f9423072955cdaab6386"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e946bb4ed53f9423072955cdaab6386">&#9670;&nbsp;</a></span>forward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> handlegraph::HandleGraph::forward </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the locally forward version of a handle. </p>

</div>
</div>
<a id="a64d58c3e26e9e7954dd25c3eff7af521"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64d58c3e26e9e7954dd25c3eff7af521">&#9670;&nbsp;</a></span>get_base()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char handlegraph::HandleGraph::get_base </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns one base of a handle's sequence, in the orientation of the handle. </p>

<p>Reimplemented in <a class="el" href="classxg_1_1XG.html#a355dd79f8449b462e7d98916f1a22d9f">xg::XG</a>, <a class="el" href="classvg_1_1JoinedSpliceGraph.html#a7dcc1d1e3e9c2e1058a5995785b0a224">vg::JoinedSpliceGraph</a>, <a class="el" href="classvg_1_1VG.html#a7cb582e352f75cc9d66e6eff0f4ba659">vg::VG</a>, and <a class="el" href="classvg_1_1IncrementalSubgraph.html#a6ff73a10a56b8116b7d07c32d3f3160a">vg::IncrementalSubgraph</a>.</p>

</div>
</div>
<a id="ab259e3aba0da47b0ef1c9b5e43c7d209"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab259e3aba0da47b0ef1c9b5e43c7d209">&#9670;&nbsp;</a></span>get_degree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t handlegraph::HandleGraph::get_degree </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>go_left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the number of edges on the right (go_left = false) or left (go_left = true) side of the given handle. The default implementation is O(n) in the number of edges returned, but graph implementations that track this information more efficiently can override this method. </p>

<p>Reimplemented in <a class="el" href="classvg_1_1VG.html#afc0ac00267e00156e04c849a10b1cb74">vg::VG</a>, <a class="el" href="classvg_1_1IncrementalSubgraph.html#ae3365d87d1cd6bfe12d3433197d06a85">vg::IncrementalSubgraph</a>, <a class="el" href="classvg_1_1SourceSinkOverlay.html#a8bfc476463b487d42c77bda6bdfe2a7d">vg::SourceSinkOverlay</a>, and <a class="el" href="classvg_1_1ExtraNodeGraph.html#a0cc5cb40e81623b3a3e11bea359e41c5">vg::ExtraNodeGraph</a>.</p>

</div>
</div>
<a id="a20ff62014d7f0f0c01ada8a3d40a278d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ff62014d7f0f0c01ada8a3d40a278d">&#9670;&nbsp;</a></span>get_edge_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t handlegraph::HandleGraph::get_edge_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total number of edges in the graph. If not overridden, counts them all in linear time. </p>

<p>Reimplemented in <a class="el" href="classxg_1_1XG.html#aa624840475fc83351c00ef2728480355">xg::XG</a>, <a class="el" href="classvg_1_1VG.html#ad4577be9213932c313efd3d016b88a31">vg::VG</a>, and <a class="el" href="classvg_1_1IncrementalSubgraph.html#aeab323f77d0363867dc60be6dafe73ce">vg::IncrementalSubgraph</a>.</p>

</div>
</div>
<a id="a6dd9d70931835f5c75518b23a780b744"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd9d70931835f5c75518b23a780b744">&#9670;&nbsp;</a></span>get_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> handlegraph::HandleGraph::get_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">nid_t</a> &amp;&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Look up the handle for the node with the given ID in the given orientation. </p>

<p>Implemented in <a class="el" href="classvg_1_1SnarlGraph.html#a8c06fedda57c3e031d8d3b7fbcb696a8">vg::SnarlGraph</a>, <a class="el" href="classxg_1_1XG.html#adc5660ffe20948888aeca0c6e6bba90a">xg::XG</a>, <a class="el" href="classvg_1_1VG.html#a70f50e6766af9262c732de26243658f5">vg::VG</a>, <a class="el" href="classvg_1_1SubgraphOverlay.html#ab36d552e3882740962729d19069f9ddc">vg::SubgraphOverlay</a>, <a class="el" href="classhandlegraph_1_1algorithms_1_1SubHandleGraph.html#a0a950e73c94a514de69f95be80f96b7e">handlegraph::algorithms::SubHandleGraph</a>, <a class="el" href="classvg_1_1NetGraph.html#a639a1a278626238fe98568320590c64f">vg::NetGraph</a>, <a class="el" href="classvg_1_1JoinedSpliceGraph.html#a17636cfa63438f4b5941d54b7632d64b">vg::JoinedSpliceGraph</a>, <a class="el" href="classvg_1_1IndexedVG.html#ad9779976b07decd5b593b7a097cac44e">vg::IndexedVG</a>, <a class="el" href="classvg_1_1IncrementalSubgraph.html#ac2d018cb5a59b4f43e24a4f30643e0f1">vg::IncrementalSubgraph</a>, <a class="el" href="classvg_1_1TreeSubgraph.html#ab7b56b78b8750cc6453180e7e531d925">vg::TreeSubgraph</a>, <a class="el" href="classvg_1_1DozeuPinningOverlay.html#a78c76b68997b94da8bb714ad87b6ce55">vg::DozeuPinningOverlay</a>, <a class="el" href="classvg_1_1PathSubgraph.html#a9d2fc4747e6c86125ba149c90041abcd">vg::PathSubgraph</a>, <a class="el" href="classvg_1_1SubHandleGraph.html#a4cf66400a93dee8a1e49fcc88ab24eb5">vg::SubHandleGraph</a>, <a class="el" href="classvg_1_1StrandSplitGraph.html#a97db8ec5efb4280bfe358b0859e96659">vg::StrandSplitGraph</a>, <a class="el" href="classvg_1_1MemoizingGraph.html#aa0b891348a82fe4fad7f60ab87fbd4b4">vg::MemoizingGraph</a>, <a class="el" href="classvg_1_1ReverseGraph.html#a34a79e8c3f5d5f029d5a1427ca10cfbd">vg::ReverseGraph</a>, <a class="el" href="classvg_1_1DagifiedGraph.html#a57e727b78f3eac1ee34b5dabf08a278f">vg::DagifiedGraph</a>, <a class="el" href="classvg_1_1IdentityOverlay.html#a3fc814950bd9b0b003b82637be9c1d06">vg::IdentityOverlay</a>, <a class="el" href="classvg_1_1NullMaskingGraph.html#aea8062f2a253f0397a91005b3924475e">vg::NullMaskingGraph</a>, <a class="el" href="classvg_1_1SourceSinkOverlay.html#a7cc144d829750cfb85341d42bd4f7e4a">vg::SourceSinkOverlay</a>, and <a class="el" href="classvg_1_1ExtraNodeGraph.html#a76226cecc78c23a95db06f2765138e6f">vg::ExtraNodeGraph</a>.</p>

</div>
</div>
<a id="adb7f6e144bf2a59679f7b2eddad934eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7f6e144bf2a59679f7b2eddad934eb">&#9670;&nbsp;</a></span>get_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">nid_t</a> handlegraph::HandleGraph::get_id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID from a handle. </p>

<p>Implemented in <a class="el" href="classvg_1_1SnarlGraph.html#aba421b2e2cd40a7d489c13e0ab81f179">vg::SnarlGraph</a>, <a class="el" href="classvg_1_1NetGraph.html#a9964476cfff61404eeb9d65cc182aa4a">vg::NetGraph</a>, <a class="el" href="classxg_1_1XG.html#a0a9d6bce054a3ebf14807869883e9b98">xg::XG</a>, <a class="el" href="classvg_1_1JoinedSpliceGraph.html#a716f0b44bb48b6148617dc772d66959c">vg::JoinedSpliceGraph</a>, <a class="el" href="classvg_1_1VG.html#a6f4b9ac16f23eb0420544ce8357736a3">vg::VG</a>, <a class="el" href="classvg_1_1IndexedVG.html#ad23ba69aad4d8c94f58319bb657e3235">vg::IndexedVG</a>, <a class="el" href="classvg_1_1IncrementalSubgraph.html#a825edf9eddd3fa6093f2045656ae98f1">vg::IncrementalSubgraph</a>, <a class="el" href="classvg_1_1TreeSubgraph.html#ae48a59a93737e729ada7660a39fafa50">vg::TreeSubgraph</a>, <a class="el" href="classvg_1_1SourceSinkOverlay.html#a9c10b6562749e62bc1038ef23e8b9b28">vg::SourceSinkOverlay</a>, <a class="el" href="classvg_1_1ExtraNodeGraph.html#aef3ca5fb2071fdb33a7a8f663473de32">vg::ExtraNodeGraph</a>, <a class="el" href="classvg_1_1DozeuPinningOverlay.html#ad84aae5d9cce852e254d5da05da40fa8">vg::DozeuPinningOverlay</a>, <a class="el" href="classvg_1_1SubgraphOverlay.html#a301c8016ac2769d041c611cebd738c1e">vg::SubgraphOverlay</a>, <a class="el" href="classvg_1_1PathSubgraph.html#a47ff1fe374dccd07542ed1523327553e">vg::PathSubgraph</a>, <a class="el" href="classvg_1_1SubHandleGraph.html#af40f7f453c71d4e52273479d0b600612">vg::SubHandleGraph</a>, <a class="el" href="classhandlegraph_1_1algorithms_1_1SubHandleGraph.html#a8150ada3f96723110a2ec7c1ed16323b">handlegraph::algorithms::SubHandleGraph</a>, <a class="el" href="classvg_1_1StrandSplitGraph.html#a07bd24e1ed6a14843ddb87108a11c7f8">vg::StrandSplitGraph</a>, <a class="el" href="classvg_1_1MemoizingGraph.html#a23b6df961f0e8253fba88423f2bcf128">vg::MemoizingGraph</a>, <a class="el" href="classvg_1_1ReverseGraph.html#aef09dbb8dd08735bdd123b2a9d0066e0">vg::ReverseGraph</a>, <a class="el" href="classvg_1_1DagifiedGraph.html#ae510cacf154e272f63b37a3207046c96">vg::DagifiedGraph</a>, <a class="el" href="classvg_1_1IdentityOverlay.html#ab144f5ecbf4a5f49a5ffbea80ebd56ec">vg::IdentityOverlay</a>, and <a class="el" href="classvg_1_1NullMaskingGraph.html#a541f81de46db62d5e8f37e3cfc51f08e">vg::NullMaskingGraph</a>.</p>

</div>
</div>
<a id="a92773f90eb58f18adb9418a4440223c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92773f90eb58f18adb9418a4440223c1">&#9670;&nbsp;</a></span>get_is_reverse()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handlegraph::HandleGraph::get_is_reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the orientation of a handle. </p>

<p>Implemented in <a class="el" href="classvg_1_1SnarlGraph.html#a9deed0e8a0312d6ff12868e86c83cc0f">vg::SnarlGraph</a>, <a class="el" href="classvg_1_1NetGraph.html#a4581f8ffa5738a409e9e856f15c48a99">vg::NetGraph</a>, <a class="el" href="classxg_1_1XG.html#a7a52d5c8396e40930cfed5f79ea9c201">xg::XG</a>, <a class="el" href="classvg_1_1JoinedSpliceGraph.html#a7179e1f5120aebb9670120b6cddf51ca">vg::JoinedSpliceGraph</a>, <a class="el" href="classvg_1_1VG.html#a53e796617804bffe0203e422f2a23148">vg::VG</a>, <a class="el" href="classvg_1_1IndexedVG.html#acf50f1ad8e40ac18d8a5469d63155a50">vg::IndexedVG</a>, <a class="el" href="classvg_1_1IncrementalSubgraph.html#ad4282dc0e503dc17e3724a41dbb0462c">vg::IncrementalSubgraph</a>, <a class="el" href="classvg_1_1TreeSubgraph.html#aa581eda84f6ae51edb0363b76075fe47">vg::TreeSubgraph</a>, <a class="el" href="classvg_1_1SourceSinkOverlay.html#a274359d605130e8efec7c14791d5044b">vg::SourceSinkOverlay</a>, <a class="el" href="classvg_1_1ExtraNodeGraph.html#ab3b496b4e1d8067cd7ed0e0ae9fb0aa9">vg::ExtraNodeGraph</a>, <a class="el" href="classvg_1_1DozeuPinningOverlay.html#a02b35f6198096c08f660df1170d556b4">vg::DozeuPinningOverlay</a>, <a class="el" href="classvg_1_1SubgraphOverlay.html#a797e1524539c9c96ef96dc5454d35c3a">vg::SubgraphOverlay</a>, <a class="el" href="classvg_1_1PathSubgraph.html#a5305f2276ec4eecae4a59a4892cb63ab">vg::PathSubgraph</a>, <a class="el" href="classvg_1_1SubHandleGraph.html#a050d46f68a21d9169d17a6e9580a542f">vg::SubHandleGraph</a>, <a class="el" href="classhandlegraph_1_1algorithms_1_1SubHandleGraph.html#ade72d1d3264d1022227c44edc9329a26">handlegraph::algorithms::SubHandleGraph</a>, <a class="el" href="classvg_1_1StrandSplitGraph.html#a2882b925a09ba0ee35cdf8bdac0c4605">vg::StrandSplitGraph</a>, <a class="el" href="classvg_1_1MemoizingGraph.html#aac8372783c6657f5473b1d33b4495e7c">vg::MemoizingGraph</a>, <a class="el" href="classvg_1_1ReverseGraph.html#aaa65f6a0677677af70608a0294ec36f5">vg::ReverseGraph</a>, <a class="el" href="classvg_1_1DagifiedGraph.html#a0a5fa33f94733bb8470ccbc49e608a0d">vg::DagifiedGraph</a>, <a class="el" href="classvg_1_1IdentityOverlay.html#aa7bba299ded8eb2fff2af0adeb52000b">vg::IdentityOverlay</a>, and <a class="el" href="classvg_1_1NullMaskingGraph.html#ab99a483165208a4aabc1e2275f126a18">vg::NullMaskingGraph</a>.</p>

</div>
</div>
<a id="a569ff35fb85c725b0b6b6933ed303e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a569ff35fb85c725b0b6b6933ed303e49">&#9670;&nbsp;</a></span>get_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t handlegraph::HandleGraph::get_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the length of a node. </p>

<p>Implemented in <a class="el" href="classvg_1_1SnarlGraph.html#ac521452a597e9159b8c281cc49239ccb">vg::SnarlGraph</a>, <a class="el" href="classvg_1_1NetGraph.html#a8170045aa0032b33628858c0717cc74a">vg::NetGraph</a>, <a class="el" href="classxg_1_1XG.html#aa52bb123eca4dbff84b316a7f56a98cc">xg::XG</a>, <a class="el" href="classvg_1_1JoinedSpliceGraph.html#aafba33cc8aa854fb9dc8d654bb2a3325">vg::JoinedSpliceGraph</a>, <a class="el" href="classvg_1_1VG.html#aff75e522e40559f5a5257a5cef776cdc">vg::VG</a>, <a class="el" href="classvg_1_1IndexedVG.html#a235824616974770831a2ce006a954bbe">vg::IndexedVG</a>, <a class="el" href="classvg_1_1IncrementalSubgraph.html#a84ee16f64d60195d6ead2a57933af720">vg::IncrementalSubgraph</a>, <a class="el" href="classvg_1_1TreeSubgraph.html#ac6d8e68e5bff645f58f741291a810abe">vg::TreeSubgraph</a>, <a class="el" href="classvg_1_1SourceSinkOverlay.html#a03f1de876e4731012b5e7168556d5236">vg::SourceSinkOverlay</a>, <a class="el" href="classvg_1_1ExtraNodeGraph.html#ab4385934c980deef266d30118b83a4df">vg::ExtraNodeGraph</a>, <a class="el" href="classvg_1_1DozeuPinningOverlay.html#a0d9fc0dbb4e18cfe9d7496b72d0f63fb">vg::DozeuPinningOverlay</a>, <a class="el" href="classvg_1_1SubgraphOverlay.html#a5bc6640c35b21807f14332a51f84a2d9">vg::SubgraphOverlay</a>, <a class="el" href="classvg_1_1PathSubgraph.html#a777f23f7156addc72dd508d08f069cc7">vg::PathSubgraph</a>, <a class="el" href="classvg_1_1SubHandleGraph.html#a829ddac36b7fcb67ca87c058fe691a88">vg::SubHandleGraph</a>, <a class="el" href="classhandlegraph_1_1algorithms_1_1SubHandleGraph.html#af858e2c9467b674d836879d39f049a05">handlegraph::algorithms::SubHandleGraph</a>, <a class="el" href="classvg_1_1StrandSplitGraph.html#a46c7611ab9f71f86e3192a34406860b4">vg::StrandSplitGraph</a>, <a class="el" href="classvg_1_1MemoizingGraph.html#ab5f66c5dae9ddc74750cb86595fef07e">vg::MemoizingGraph</a>, <a class="el" href="classvg_1_1ReverseGraph.html#a54f7adad266466143efaa59270432d8f">vg::ReverseGraph</a>, <a class="el" href="classvg_1_1DagifiedGraph.html#a5feaa48467ad288848fb2d1ffcd29fc1">vg::DagifiedGraph</a>, <a class="el" href="classvg_1_1IdentityOverlay.html#a659b0f5b71286479ef910bd984c525e6">vg::IdentityOverlay</a>, and <a class="el" href="classvg_1_1NullMaskingGraph.html#a2144c791b97d05bf625a50442649def2">vg::NullMaskingGraph</a>.</p>

</div>
</div>
<a id="a9f95108e6c3f68f404fa93bd3306e4c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f95108e6c3f68f404fa93bd3306e4c6">&#9670;&nbsp;</a></span>get_node_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual size_t handlegraph::HandleGraph::get_node_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the number of nodes in the graph. </p>

<p>Implemented in <a class="el" href="classvg_1_1SnarlGraph.html#aa797abb0b6518ca38b557759d074cd33">vg::SnarlGraph</a>, <a class="el" href="classvg_1_1NetGraph.html#a49f4b9958557920e8b81c3f6b6c62de2">vg::NetGraph</a>, <a class="el" href="classxg_1_1XG.html#ae7b3b8008c6779aafb72b8e2fc47d4a1">xg::XG</a>, <a class="el" href="classvg_1_1JoinedSpliceGraph.html#a15ac4bff9b6862ec0d7c6cefabb916c9">vg::JoinedSpliceGraph</a>, <a class="el" href="classvg_1_1VG.html#a495649c1646b865d6c88b8dc126589b0">vg::VG</a>, <a class="el" href="classvg_1_1IndexedVG.html#aa275aa5b547bf464b95ce162e9a2fcd5">vg::IndexedVG</a>, <a class="el" href="classvg_1_1IncrementalSubgraph.html#a076dbda3b4b724157cad61f5f7b76b2b">vg::IncrementalSubgraph</a>, <a class="el" href="classvg_1_1TreeSubgraph.html#a63dd0c1a1fce7a59a563be0448085246">vg::TreeSubgraph</a>, <a class="el" href="classvg_1_1SourceSinkOverlay.html#ac49954276cde4384262f3501f4ed70ce">vg::SourceSinkOverlay</a>, <a class="el" href="classvg_1_1DozeuPinningOverlay.html#ab324121c34fdc2ab5edfaf742f26280d">vg::DozeuPinningOverlay</a>, <a class="el" href="classvg_1_1ExtraNodeGraph.html#a0c55bc093996c9148a3b6c4e46634759">vg::ExtraNodeGraph</a>, <a class="el" href="classvg_1_1PathSubgraph.html#a52f431143ff624475a16629fa46898f0">vg::PathSubgraph</a>, <a class="el" href="classvg_1_1SubHandleGraph.html#a0ea741c8d98e8c12b9f83b3427bee115">vg::SubHandleGraph</a>, <a class="el" href="classhandlegraph_1_1algorithms_1_1SubHandleGraph.html#a0c17ba8c59000d2562fb0318a1faaa7c">handlegraph::algorithms::SubHandleGraph</a>, <a class="el" href="classvg_1_1StrandSplitGraph.html#a2a4f01cb39da9b46431a7ea3b46f540f">vg::StrandSplitGraph</a>, <a class="el" href="classvg_1_1MemoizingGraph.html#a4276a59439fc7edc984fe6e666e3b69e">vg::MemoizingGraph</a>, <a class="el" href="classvg_1_1ReverseGraph.html#a075661952d5a567b1e09ad9a5624c5a7">vg::ReverseGraph</a>, <a class="el" href="classvg_1_1DagifiedGraph.html#a46afdba1fbffa6ffebce5966a1829918">vg::DagifiedGraph</a>, <a class="el" href="classvg_1_1IdentityOverlay.html#a9a58eb7938308dad847ded70b1abec56">vg::IdentityOverlay</a>, <a class="el" href="classvg_1_1NullMaskingGraph.html#a7a7eeb58c5787789e6b8ae8a9e58101b">vg::NullMaskingGraph</a>, and <a class="el" href="classvg_1_1SubgraphOverlay.html#a40d036bc03e5bb02b1b0fe657b283b2b">vg::SubgraphOverlay</a>.</p>

</div>
</div>
<a id="a8cc2ab8a1292e30ba5e167a823f66d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cc2ab8a1292e30ba5e167a823f66d92">&#9670;&nbsp;</a></span>get_sequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string handlegraph::HandleGraph::get_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the sequence of a node, presented in the handle's local forward orientation. </p>

<p>Implemented in <a class="el" href="classvg_1_1SnarlGraph.html#a4a97ed146e23b853fd66a0ad827823e5">vg::SnarlGraph</a>, <a class="el" href="classvg_1_1NetGraph.html#a4278d3e414d6e5b8e8055d7bdf87c7ac">vg::NetGraph</a>, <a class="el" href="classxg_1_1XG.html#ad748df5f6e521774c1d5871ab3519bd8">xg::XG</a>, <a class="el" href="classvg_1_1JoinedSpliceGraph.html#a6b4f089ed86cdb7ff6ba9177d1187066">vg::JoinedSpliceGraph</a>, <a class="el" href="classvg_1_1VG.html#a353df9b2449ac859804359632283078b">vg::VG</a>, <a class="el" href="classvg_1_1IndexedVG.html#a64c03afcfd0c1c210e8b84a9b78a06dc">vg::IndexedVG</a>, <a class="el" href="classvg_1_1IncrementalSubgraph.html#a61eef0cd10c65efae0cac12816084bb2">vg::IncrementalSubgraph</a>, <a class="el" href="classvg_1_1TreeSubgraph.html#ae9859d1486d3023b44ab83b3f8c5438c">vg::TreeSubgraph</a>, <a class="el" href="classvg_1_1SourceSinkOverlay.html#a4a3eb7401c1b90b33d97672f50a17d39">vg::SourceSinkOverlay</a>, <a class="el" href="classvg_1_1ExtraNodeGraph.html#a4b9d7578f0f601b186295d365cf7e487">vg::ExtraNodeGraph</a>, <a class="el" href="classvg_1_1DozeuPinningOverlay.html#ab7eabd260a4585f04809d8da64b7f2f4">vg::DozeuPinningOverlay</a>, <a class="el" href="classvg_1_1SubgraphOverlay.html#af924de823a9ef5c1a846136eb34637f4">vg::SubgraphOverlay</a>, <a class="el" href="classvg_1_1PathSubgraph.html#a1549c36d974dfc4e8bcc54e0e9950646">vg::PathSubgraph</a>, <a class="el" href="classvg_1_1SubHandleGraph.html#ae9915dd52c55a51616822713509afab0">vg::SubHandleGraph</a>, <a class="el" href="classhandlegraph_1_1algorithms_1_1SubHandleGraph.html#a4c93978f2d225b926991b34b27528bfd">handlegraph::algorithms::SubHandleGraph</a>, <a class="el" href="classvg_1_1StrandSplitGraph.html#a878c4be6f6ad6652d3b33f2691bbb570">vg::StrandSplitGraph</a>, <a class="el" href="classvg_1_1MemoizingGraph.html#a841433ccb7c64a657e43130c81c47c39">vg::MemoizingGraph</a>, <a class="el" href="classvg_1_1ReverseGraph.html#ad815813ebd0d2b33515473bc974c53ad">vg::ReverseGraph</a>, <a class="el" href="classvg_1_1DagifiedGraph.html#a5d47d90eeaac4f0a6f1e12f0ed2d197e">vg::DagifiedGraph</a>, <a class="el" href="classvg_1_1IdentityOverlay.html#ada02cf10738e4fc81c7bb21ecf5d4b56">vg::IdentityOverlay</a>, and <a class="el" href="classvg_1_1NullMaskingGraph.html#a7a92b5f2747dca58d2fe63368e1294d4">vg::NullMaskingGraph</a>.</p>

</div>
</div>
<a id="a74c6fcda357516b1160996c63ed40d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74c6fcda357516b1160996c63ed40d63">&#9670;&nbsp;</a></span>get_subsequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string handlegraph::HandleGraph::get_subsequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a substring of a handle's sequence, in the orientation of the handle. If the indicated substring would extend beyond the end of the handle's sequence, the return value is truncated to the sequence's end. By default O(n) in the size of the handle's sequence, but can be overriden. </p>

<p>Reimplemented in <a class="el" href="classxg_1_1XG.html#a0368861cc6c99d2a1d40c059db62c2a9">xg::XG</a>, <a class="el" href="classvg_1_1JoinedSpliceGraph.html#a2348c9a3357615ce0eea301366344376">vg::JoinedSpliceGraph</a>, <a class="el" href="classvg_1_1VG.html#a45075c22efc7cfb1ed06a8996fec119c">vg::VG</a>, and <a class="el" href="classvg_1_1IncrementalSubgraph.html#a258698c76e4d96ecefd38505894f778b">vg::IncrementalSubgraph</a>.</p>

</div>
</div>
<a id="a4c98da99e0d32ebcc9fd31be4b779e29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c98da99e0d32ebcc9fd31be4b779e29">&#9670;&nbsp;</a></span>get_total_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t handlegraph::HandleGraph::get_total_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the total length of all nodes in the graph, in bp. If not overridden, loops over all nodes in linear time. </p>

<p>Reimplemented in <a class="el" href="classxg_1_1XG.html#a4437293fdec75f15a296fb545a6d539d">xg::XG</a>.</p>

</div>
</div>
<a id="a6171cdd6036c73623c96656f8b44fe9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6171cdd6036c73623c96656f8b44fe9d">&#9670;&nbsp;</a></span>has_edge() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::HandleGraph::has_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convenient wrapper of has_edge for edge_t argument. </p>

</div>
</div>
<a id="a069448fbe58665b9ff531ad0b8c5af57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a069448fbe58665b9ff531ad0b8c5af57">&#9670;&nbsp;</a></span>has_edge() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool handlegraph::HandleGraph::has_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns true if there is an edge that allows traversal from the left handle to the right handle. By default O(n) in the number of edges on left, but can be overridden with more efficient implementations. </p>

<p>Reimplemented in <a class="el" href="classvg_1_1VG.html#a501886a0c593ac3231cfcc6989911ced">vg::VG</a>.</p>

</div>
</div>
<a id="a6e58a79001cd7d839ac1f1adaff34dfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e58a79001cd7d839ac1f1adaff34dfb">&#9670;&nbsp;</a></span>has_node()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool handlegraph::HandleGraph::has_node </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">nid_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Method to check if a node exists by ID. </p>

<p>Implemented in <a class="el" href="classvg_1_1SnarlGraph.html#a43e8f719e0d3b9814e3328d14c28c85e">vg::SnarlGraph</a>, <a class="el" href="classxg_1_1XG.html#a60dd1cf3ec755863aabc99e6948011e0">xg::XG</a>, <a class="el" href="classvg_1_1SubgraphOverlay.html#aaa8aca387ac5ba4f962d03da956979a2">vg::SubgraphOverlay</a>, <a class="el" href="classhandlegraph_1_1algorithms_1_1SubHandleGraph.html#a29475639dafe548f44b4c0e995005083">handlegraph::algorithms::SubHandleGraph</a>, <a class="el" href="classvg_1_1VG.html#ac9339913ecff654569a9c81ae091ebfe">vg::VG</a>, <a class="el" href="classvg_1_1NetGraph.html#a99ddd8990ab25cd314618321a5837ff9">vg::NetGraph</a>, <a class="el" href="classvg_1_1JoinedSpliceGraph.html#af167d082a5c148792ae9a533eac068f0">vg::JoinedSpliceGraph</a>, <a class="el" href="classvg_1_1IndexedVG.html#a184b4de54cd807fc818091c56bac41a8">vg::IndexedVG</a>, <a class="el" href="classvg_1_1IncrementalSubgraph.html#a29fe9b69774ab975e3b6fe15900d1c9e">vg::IncrementalSubgraph</a>, <a class="el" href="classvg_1_1TreeSubgraph.html#a84c11ffd899e018587d6ccb25dd1211b">vg::TreeSubgraph</a>, <a class="el" href="classvg_1_1SourceSinkOverlay.html#ad2e4740b5a84271e053840e6b60fc53c">vg::SourceSinkOverlay</a>, <a class="el" href="classvg_1_1ExtraNodeGraph.html#a89299bba0acddf6e2bb2a8d6cb561b86">vg::ExtraNodeGraph</a>, <a class="el" href="classvg_1_1DozeuPinningOverlay.html#a696d9ff9c1731e98d7235a637d794174">vg::DozeuPinningOverlay</a>, <a class="el" href="classvg_1_1PathSubgraph.html#ad13f4f28e024ac0d43991cb9d162420f">vg::PathSubgraph</a>, <a class="el" href="classvg_1_1SubHandleGraph.html#a66e144a38ed8437cbf71a186a6e8afa0">vg::SubHandleGraph</a>, <a class="el" href="classvg_1_1StrandSplitGraph.html#aad17d3113bdc3f8ec03327a16ccfadd9">vg::StrandSplitGraph</a>, <a class="el" href="classvg_1_1MemoizingGraph.html#a5e5fea73aaa5c9b403b7e63318e15702">vg::MemoizingGraph</a>, <a class="el" href="classvg_1_1ReverseGraph.html#a98c0e584e6cb8246c9b2deb65d92e370">vg::ReverseGraph</a>, <a class="el" href="classvg_1_1DagifiedGraph.html#ad6c8a0d0a6c21fee9c10065927d4ba97">vg::DagifiedGraph</a>, <a class="el" href="classvg_1_1IdentityOverlay.html#a56aabb0a049d7bbf9079733d7824e0db">vg::IdentityOverlay</a>, and <a class="el" href="classvg_1_1NullMaskingGraph.html#a550edf96fd717710f5051804d0d1bafe">vg::NullMaskingGraph</a>.</p>

</div>
</div>
<a id="a5a2e2b1ea6a29b3f4b34a6abcb6dbc50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2e2b1ea6a29b3f4b34a6abcb6dbc50">&#9670;&nbsp;</a></span>max_node_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">nid_t</a> handlegraph::HandleGraph::max_node_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the largest ID in the graph, or some larger number if the largest ID is unavailable. Return value is unspecified if the graph is empty. </p>

<p>Implemented in <a class="el" href="classvg_1_1SnarlGraph.html#a69ce6bde5f346eb5926b6db093122be1">vg::SnarlGraph</a>, <a class="el" href="classvg_1_1NetGraph.html#abb16fbc7ae88f61e3ce9076d2e2a3817">vg::NetGraph</a>, <a class="el" href="classxg_1_1XG.html#ac991d9094b1959ff503d9a94d0a9ed4c">xg::XG</a>, <a class="el" href="classvg_1_1JoinedSpliceGraph.html#abbf5f65b4f075efb985c0978cead8513">vg::JoinedSpliceGraph</a>, <a class="el" href="classvg_1_1VG.html#a5a03ad90e03794944c5e0d4d61780652">vg::VG</a>, <a class="el" href="classvg_1_1IndexedVG.html#ab7e6f41fefb23702e708d23a0dcec9d0">vg::IndexedVG</a>, <a class="el" href="classvg_1_1IncrementalSubgraph.html#aa92bb84a3ea785a09c814932ae56a5a8">vg::IncrementalSubgraph</a>, <a class="el" href="classvg_1_1TreeSubgraph.html#ae8f3ebca4f5d097fe9b5081cdc1f7a96">vg::TreeSubgraph</a>, <a class="el" href="classvg_1_1SourceSinkOverlay.html#ab9be77971160f356b0ba0721ed17983e">vg::SourceSinkOverlay</a>, <a class="el" href="classvg_1_1DozeuPinningOverlay.html#a4962a5c38f363db65a1b0083a05bcfcc">vg::DozeuPinningOverlay</a>, <a class="el" href="classvg_1_1PathSubgraph.html#a7d5368e9b40989fa3e1ecd020468a1da">vg::PathSubgraph</a>, <a class="el" href="classvg_1_1ExtraNodeGraph.html#ab7384a54f90e4351cb7e6d0a99f3290d">vg::ExtraNodeGraph</a>, <a class="el" href="classvg_1_1SubHandleGraph.html#afd0e51c2e81f5b51f4e21167e3e691f3">vg::SubHandleGraph</a>, <a class="el" href="classhandlegraph_1_1algorithms_1_1SubHandleGraph.html#a599303e41c6f9913424933778893f1c6">handlegraph::algorithms::SubHandleGraph</a>, <a class="el" href="classvg_1_1StrandSplitGraph.html#a83194bc2415f2f0fa2e23ce970d2f932">vg::StrandSplitGraph</a>, <a class="el" href="classvg_1_1MemoizingGraph.html#a7a9052b566d4062493432265aa1c9e70">vg::MemoizingGraph</a>, <a class="el" href="classvg_1_1ReverseGraph.html#ac276a2df66a605842304eec2d9ef340c">vg::ReverseGraph</a>, <a class="el" href="classvg_1_1DagifiedGraph.html#a511c81e2e65250eeeac52936bfe3ae0e">vg::DagifiedGraph</a>, <a class="el" href="classvg_1_1IdentityOverlay.html#a5aba68df4094870dd2324613d2db1d63">vg::IdentityOverlay</a>, <a class="el" href="classvg_1_1NullMaskingGraph.html#a768717b98ae295bb52a68028db0145ec">vg::NullMaskingGraph</a>, and <a class="el" href="classvg_1_1SubgraphOverlay.html#ab2858c7e55226d9754eb388654da88ab">vg::SubgraphOverlay</a>.</p>

</div>
</div>
<a id="a85c52fe4b5f483504ed142d0ad94a969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85c52fe4b5f483504ed142d0ad94a969">&#9670;&nbsp;</a></span>min_node_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">nid_t</a> handlegraph::HandleGraph::min_node_id </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the smallest ID in the graph, or some smaller number if the smallest ID is unavailable. Return value is unspecified if the graph is empty. </p>

<p>Implemented in <a class="el" href="classvg_1_1SnarlGraph.html#a6e61014fadcbc2703a8fe3b208132ee4">vg::SnarlGraph</a>, <a class="el" href="classvg_1_1NetGraph.html#a9b3c2b7f61f5c0133e844fa5edc4ea6d">vg::NetGraph</a>, <a class="el" href="classxg_1_1XG.html#a9195d1b18542de3b89b80bb14ce1ca0a">xg::XG</a>, <a class="el" href="classvg_1_1JoinedSpliceGraph.html#aa92df9f1002415710b4ffa4e6074cb5b">vg::JoinedSpliceGraph</a>, <a class="el" href="classvg_1_1VG.html#ac27674d67445ddc135c3c8ab4d3d5231">vg::VG</a>, <a class="el" href="classvg_1_1IndexedVG.html#ac496219064127ecd533ab41f77fc5da6">vg::IndexedVG</a>, <a class="el" href="classvg_1_1IncrementalSubgraph.html#a2d34ac8b129c82511c38f267644918d5">vg::IncrementalSubgraph</a>, <a class="el" href="classvg_1_1TreeSubgraph.html#a1ac845e3e2d75d7da5ff81b79aba3d08">vg::TreeSubgraph</a>, <a class="el" href="classvg_1_1SourceSinkOverlay.html#ad91d6241e1a962eaf4b4f1c92f2d94c8">vg::SourceSinkOverlay</a>, <a class="el" href="classvg_1_1DozeuPinningOverlay.html#ac48d1492dd478af9811307c52954e517">vg::DozeuPinningOverlay</a>, <a class="el" href="classvg_1_1ExtraNodeGraph.html#ae07290cc251f0843de41551e25ffd4bf">vg::ExtraNodeGraph</a>, <a class="el" href="classvg_1_1PathSubgraph.html#a472e93221aa3a728984d07aa6b7f0cc0">vg::PathSubgraph</a>, <a class="el" href="classvg_1_1SubHandleGraph.html#a180704728aa79aaf37189c644995cf91">vg::SubHandleGraph</a>, <a class="el" href="classhandlegraph_1_1algorithms_1_1SubHandleGraph.html#af944543089a7fae6c052decc4ff0a4c4">handlegraph::algorithms::SubHandleGraph</a>, <a class="el" href="classvg_1_1StrandSplitGraph.html#aaeaf9231d44d7e0260ef5439f49e5e40">vg::StrandSplitGraph</a>, <a class="el" href="classvg_1_1MemoizingGraph.html#afcbf2c9b526deaddee36140a362f4640">vg::MemoizingGraph</a>, <a class="el" href="classvg_1_1ReverseGraph.html#adf486245a2201f1685e2af41a57a98f3">vg::ReverseGraph</a>, <a class="el" href="classvg_1_1DagifiedGraph.html#a59e1c5556c2f5a984d9680cdaf8be41d">vg::DagifiedGraph</a>, <a class="el" href="classvg_1_1IdentityOverlay.html#a9a689ba99fa1452b5434a8a523e142c1">vg::IdentityOverlay</a>, <a class="el" href="classvg_1_1NullMaskingGraph.html#ab970c84b4caea2d00fd43a77f0826a95">vg::NullMaskingGraph</a>, and <a class="el" href="classvg_1_1SubgraphOverlay.html#a0d876d83943a078f6d9114bd08216086">vg::SubgraphOverlay</a>.</p>

</div>
</div>
<a id="af167b0664299cfd4eac610f129fa5fee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af167b0664299cfd4eac610f129fa5fee">&#9670;&nbsp;</a></span>traverse_edge_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> handlegraph::HandleGraph::traverse_edge_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">edge_t</a> &amp;&#160;</td>
          <td class="paramname"><em>edge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>left</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Such a pair can be viewed from either inward end handle and produce the outward handle you would arrive at. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>deps/libhandlegraph/src/include/handlegraph/<a class="el" href="handle__graph_8hpp.html">handle_graph.hpp</a></li>
<li>deps/libhandlegraph/src/<a class="el" href="handle__graph_8cpp.html">handle_graph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
