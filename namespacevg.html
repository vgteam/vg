<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">vg Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacevg_1_1algorithms"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1algorithms.html">algorithms</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevg_1_1io"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1io.html">io</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevg_1_1subcommand"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1subcommand.html">subcommand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacevg_1_1temp__file"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg_1_1temp__file.html">temp_file</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AbstractReadSampler.html">AbstractReadSampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AliasGraph.html">AliasGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Aligner.html">Aligner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html">AlignerClient</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Alignment.html">Alignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1alignment__index__t.html">alignment_index_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignmentChainModel.html">AlignmentChainModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignmentChainModelVertex.html">AlignmentChainModelVertex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1AlignmentValidity.html">AlignmentValidity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Annotation.html">Annotation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1AppendHaplotypeCommand.html">AppendHaplotypeCommand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1AugmentedGraph.html">AugmentedGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BackTranslatingAlignmentEmitter.html">BackTranslatingAlignmentEmitter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BandedGlobalAligner.html">BandedGlobalAligner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseAligner.html">BaseAligner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html">BaseMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseOption.html">BaseOption</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1BasePileup.html">BasePileup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1BBEdgeHash.html">BBEdgeHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1BenchmarkResult.html">BenchmarkResult</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BitString.html">BitString</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BitStringTree.html">BitStringTree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1BREAKPOINT.html">BREAKPOINT</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1CachedPackedTraversalSupportFinder.html">CachedPackedTraversalSupportFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1CactusSide.html">CactusSide</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1CactusSnarlFinder.html">CactusSnarlFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Colors.html">Colors</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1CompletedTranscriptPath.html">CompletedTranscriptPath</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ComponentMinDistanceClusterer.html">ComponentMinDistanceClusterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Configurable.html">Configurable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ConfigurableParser.html">ConfigurableParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Connection.html">Connection</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An edge in a <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> between Subpaths that may not be contiguous in the graph.  <a href="structvg_1_1Connection.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1connection__t.html">connection_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ConsistencyCalculator.html">ConsistencyCalculator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ConstructedChunk.html">ConstructedChunk</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Constructor.html">Constructor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ContractingGraph.html">ContractingGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1count__back__inserter.html">count_back_inserter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Counts.html">Counts</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DagifiedGraph.html">DagifiedGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Deconstructor.html">Deconstructor</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1DeleteHaplotypeCommand.html">DeleteHaplotypeCommand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DeletionAligner.html">DeletionAligner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DiagramExplainer.html">DiagramExplainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DinucleotideMachine.html">DinucleotideMachine</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1discrete__distribution.html">discrete_distribution</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">We provide a partial <a class="el" href="classvg_1_1discrete__distribution.html" title="We provide a partial discrete_distribution implementation that is just the parts we need.">discrete_distribution</a> implementation that is just the parts we need.  <a href="classvg_1_1discrete__distribution.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DistanceHeuristic.html">DistanceHeuristic</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DotDumpExplainer.html">DotDumpExplainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuInterface.html">DozeuInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1DozeuPinningOverlay.html">DozeuPinningOverlay</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Edge.html">Edge</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1EdgePileup.html">EdgePileup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep pileup-like record for reads that span edges.  <a href="structvg_1_1EdgePileup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Edit.html">Edit</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1edit__t.html">edit_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1EditedTranscriptPath.html">EditedTranscriptPath</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1endianness.html">endianness</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ExhaustiveTraversalFinder.html">ExhaustiveTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Exon.html">Exon</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Explainer.html">Explainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ExtraNodeGraph.html">ExtraNodeGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1FeatureSet.html">FeatureSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Filter.html">Filter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1FixedGenotypePriorCalculator.html">FixedGenotypePriorCalculator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1FlatFileBackTranslation.html">FlatFileBackTranslation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1FlowCaller.html">FlowCaller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1FlowSort.html">FlowSort</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1FlowTraversalFinder.html">FlowTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1FragmentLengthDistribution.html">FragmentLengthDistribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1FragmentLengthStatistics.html">FragmentLengthStatistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Funnel.html">Funnel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GAFOutputCaller.html">GAFOutputCaller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GaplessExtender.html">GaplessExtender</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1GBWTHandler.html">GBWTHandler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GBWTTraversalFinder.html">GBWTTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GBZGraph.html">GBZGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GenomeState.html">GenomeState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1GenomeStateCommand.html">GenomeStateCommand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Genotype.html">Genotype</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a genotype at a particular locus.  <a href="structvg_1_1Genotype.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GenotypeLikelihoodCalculator.html">GenotypeLikelihoodCalculator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GenotypePriorCalculator.html">GenotypePriorCalculator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Genotyper.html">Genotyper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GFAHandleGraph.html">GFAHandleGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Use to load in GFAs and remember where they came from.  <a href="classvg_1_1GFAHandleGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GFFReader.html">GFFReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1GFFRecord.html">GFFRecord</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Graph.html">Graph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GraphCaller.html">GraphCaller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GraphSynchronizer.html">GraphSynchronizer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GreedyMinDistanceClusterer.html">GreedyMinDistanceClusterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HandleGraphNodeSet.html">HandleGraphNodeSet</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HandleGraphSnarlFinder.html">HandleGraphSnarlFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypeIndexer.html">HaplotypeIndexer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HaplotypePartitioner.html">HaplotypePartitioner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Haplotypes.html">Haplotypes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1hash__map.html">hash_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1hash__map_3_01K_01_5_00_01V_01_4.html">hash_map&lt; K *, V &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1hash__set.html">hash_set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1hash__set_3_01K_01_5_01_4.html">hash_set&lt; K * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSAlignmentEmitter.html">HTSAlignmentEmitter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1HTSWriter.html">HTSWriter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IdentityOverlay.html">IdentityOverlay</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1IDScanner.html">IDScanner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IncrementalSubgraph.html">IncrementalSubgraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1IncrementIter.html">IncrementIter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IndexedVG.html">IndexedVG</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IndexFile.html">IndexFile</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1IndexingParameters.html">IndexingParameters</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IndexingPlan.html">IndexingPlan</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1IndexRecipe.html">IndexRecipe</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IndexRegistry.html">IndexRegistry</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1InsertHaplotypeCommand.html">InsertHaplotypeCommand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1InsufficientInputException.html">InsufficientInputException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1IntegratedSnarlFinder.html">IntegratedSnarlFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1is__instantiation__of.html">is_instantiation_of</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1is__instantiation__of_3_01Predicate_3_01PredicateArgs_8_8_8_01_4_00_01Predicate_01_4.html">is_instantiation_of&lt; Predicate&lt; PredicateArgs... &gt;, Predicate &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1JobSchedule.html">JobSchedule</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1JoinedSpliceGraph.html">JoinedSpliceGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1kff__recoding__t.html">kff_recoding_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A mapping of character values from KFF encoding to minimizer index encoding.  <a href="structvg_1_1kff__recoding__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1kmer__t.html">kmer_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1KmerMatch.html">KmerMatch</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Used to serialize kmer matches.  <a href="structvg_1_1KmerMatch.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1KmerPosition.html">KmerPosition</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1LazyRNG.html">LazyRNG</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1LegacyCaller.html">LegacyCaller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1LocationSupport.html">LocationSupport</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele.">Support</a> pinned to a location, which can be either a node or an edge.  <a href="structvg_1_1LocationSupport.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Locus.html">Locus</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a genetic locus with multiple possible alleles, a genotype, and observational support.  <a href="structvg_1_1Locus.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Mapper.html">Mapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Mapping.html">Mapping</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1mapping__t.html">mapping_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1MappingHash.html">MappingHash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1MatchPos.html">MatchPos</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MCMCCaller.html">MCMCCaller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MCMCGenotyper.html">MCMCGenotyper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MEMAccelerator.html">MEMAccelerator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MEMChainModel.html">MEMChainModel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MEMChainModelVertex.html">MEMChainModelVertex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MEMClusterer.html">MEMClusterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MemoizingGraph.html">MemoizingGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinDistanceClusterer.html">MinDistanceClusterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MinimizerMapper.html">MinimizerMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1MIPayload.html">MIPayload</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1MIPayloadValues.html">MIPayloadValues</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MSAConverter.html">MSAConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentEmitter.html">MultipathAlignmentEmitter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathMapper.html">MultipathMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1MultipathProblem.html">MultipathProblem</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NameMapper.html">NameMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NestedCachedPackedTraversalSupportFinder.html">NestedCachedPackedTraversalSupportFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NestedFlowCaller.html">NestedFlowCaller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NestedTraversalFinder.html">NestedTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NetGraph.html">NetGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NGSSimulator.html">NGSSimulator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NoAlignmentInBandException.html">NoAlignmentInBandException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Node.html">Node</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><em>Nodes</em> store sequence data.  <a href="structvg_1_1Node.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1NodePileup.html">NodePileup</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1normal__distribution.html">normal_distribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NullClusterer.html">NullClusterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1NullMaskingGraph.html">NullMaskingGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Option.html">Option</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Option_3_01vector_3_01Item_01_4_00_01Parser_01_4.html">Option&lt; vector&lt; Item &gt;, Parser &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OptionInterface.html">OptionInterface</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OptionValueParser.html">OptionValueParser</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OptionValueParser_3_01vector_3_01Item_01_4_01_4.html">OptionValueParser&lt; vector&lt; Item &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceClusterer.html">OrientedDistanceClusterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1OrientedDistanceMeasurer.html">OrientedDistanceMeasurer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PackedTraversalSupportFinder.html">PackedTraversalSupportFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Packer.html">Packer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Packers.html">Packers</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1pair__hash__map.html">pair_hash_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1pair__hash__set.html">pair_hash_set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PairedEndMapper.html">PairedEndMapper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ParallelKFFReader.html">ParallelKFFReader</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Path.html">Path</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1path__mapping__t.html">path_mapping_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1path__t.html">path_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PathBasedTraversalFinder.html">PathBasedTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathBranch.html">PathBranch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PathChunker.html">PathChunker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PathComponentIndex.html">PathComponentIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PathIndex.html">PathIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PathNode.html">PathNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PathOrientedDistanceMeasurer.html">PathOrientedDistanceMeasurer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PathRestrictedTraversalFinder.html">PathRestrictedTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Paths.html">Paths</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PathSubgraph.html">PathSubgraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PathSubgraphOverlay.html">PathSubgraphOverlay</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PathTraversalFinder.html">PathTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhasedGenome.html">PhasedGenome</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PhaseUnfolder.html">PhaseUnfolder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pictographs.html">Pictographs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Pileup.html">Pileup</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Bundle up <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a> and <a class="el" href="structvg_1_1Edge.html">Edge</a> pileups.  <a href="structvg_1_1Pileup.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1PoissonSupportSnarlCaller.html">PoissonSupportSnarlCaller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Position.html">Position</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1position__t.html">position_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1PositionIDScanner.html">PositionIDScanner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ProblemDumpExplainer.html">ProblemDumpExplainer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Progressive.html">Progressive</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1QualAdjXdropAligner.html">QualAdjXdropAligner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Range.html">Range</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1RareVariantSimplifier.html">RareVariantSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1RatioSupportSnarlCaller.html">RatioSupportSnarlCaller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1read__alignment__index__t.html">read_alignment_index_t</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type to point to an alignment of a known read.  <a href="structvg_1_1read__alignment__index__t.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadFilter.html">ReadFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadMasker.html">ReadMasker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReadRestrictedTraversalFinder.html">ReadRestrictedTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1RebuildJob.html">RebuildJob</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1RebuildParameters.html">RebuildParameters</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parameters for <code>rebuild_gbwt</code>.  <a href="structvg_1_1RebuildParameters.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Recombinator.html">Recombinator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Region.html">Region</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1RegionExpander.html">RegionExpander</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ReplaceLocalHaplotypeCommand.html">ReplaceLocalHaplotypeCommand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ReplaceSnarlHaplotypeCommand.html">ReplaceSnarlHaplotypeCommand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1RepresentativeTraversalFinder.html">RepresentativeTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ReverseGraph.html">ReverseGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1RewindPlanException.html">RewindPlanException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Sampler.html">Sampler</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1SeqComplexity.html">SeqComplexity</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ShuffledPairs.html">ShuffledPairs</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SimpleConsistencyCalculator.html">SimpleConsistencyCalculator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SimpleTraversalSupportCalculator.html">SimpleTraversalSupportCalculator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SizeLimitExceededException.html">SizeLimitExceededException</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SmallBitset.html">SmallBitset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SmallSnarlSimplifier.html">SmallSnarlSimplifier</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Snarl.html">Snarl</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a subgraph that is connected to the rest of the graph by two nodes.  <a href="structvg_1_1Snarl.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlCaller.html">SnarlCaller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlDistanceIndexClusterer.html">SnarlDistanceIndexClusterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlFinder.html">SnarlFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlGraph.html">SnarlGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlMinDistance.html">SnarlMinDistance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlOrientedDistanceMeasurer.html">SnarlOrientedDistanceMeasurer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SnarlState.html">SnarlState</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SourceSinkOverlay.html">SourceSinkOverlay</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SparseUnionFind.html">SparseUnionFind</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SplicedHTSAlignmentEmitter.html">SplicedHTSAlignmentEmitter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SpliceRegion.html">SpliceRegion</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SpliceStats.html">SpliceStats</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SSWAligner.html">SSWAligner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1state__hash.html">state_hash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StrandSplitGraph.html">StrandSplitGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndex.html">StreamIndex</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html">StreamIndexBase</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamSorter.html">StreamSorter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1string__hash__map.html">string_hash_map</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1string__hash__set.html">string_hash_set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SubgraphOverlay.html">SubgraphOverlay</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SubHandleGraph.html">SubHandleGraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Subpath.html">Subpath</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A non-branching path of a <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>.  <a href="structvg_1_1Subpath.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1subpath__t.html">subpath_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1SummaryStatistics.html">SummaryStatistics</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Support.html">Support</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aggregates information about the reads supporting an allele.  <a href="structvg_1_1Support.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1SupportAugmentedGraph.html">SupportAugmentedGraph</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Augmented <a class="el" href="structvg_1_1Graph.html">Graph</a> that holds some <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele.">Support</a> annotation data specific to vg call.  <a href="structvg_1_1SupportAugmentedGraph.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportBasedSnarlCaller.html">SupportBasedSnarlCaller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SupportRestrictedTraversalFinder.html">SupportRestrictedTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1SurjectingAlignmentEmitter.html">SurjectingAlignmentEmitter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Surjector.html">Surjector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1SwapHaplotypesCommand.html">SwapHaplotypesCommand</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1TargetValueSearch.html">TargetValueSearch</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1TipAnchoredMaxDistance.html">TipAnchoredMaxDistance</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Transcript.html">Transcript</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Transcriptome.html">Transcriptome</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1TranscriptPath.html">TranscriptPath</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Translation.html">Translation</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Translator.html">Translator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1TraversalFinder.html">TraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1TraversalSupportCalculator.html">TraversalSupportCalculator</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1TraversalSupportFinder.html">TraversalSupportFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Tree.html">Tree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1TreeNode.html">TreeNode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1TreeSubgraph.html">TreeSubgraph</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1TrivialTraversalFinder.html">TrivialTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1truncated__normal__distribution.html">truncated_normal_distribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1TVSClusterer.html">TVSClusterer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1uniform__int__distribution.html">uniform_int_distribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1uniform__real__distribution.html">uniform_real_distribution</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VariantAdder.html">VariantAdder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VcfBuffer.html">VcfBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VCFGenotyper.html">VCFGenotyper</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VCFOutputCaller.html">VCFOutputCaller</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VcfRecordConverter.html">VcfRecordConverter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VcfRecordFilter.html">VcfRecordFilter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VCFTraversalFinder.html">VCFTraversalFinder</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1VectorView.html">VectorView</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VectorViewInverse.html">VectorViewInverse</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Version.html">Version</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Class for holding vg version and build environment information.  <a href="classvg_1_1Version.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VG.html">VG</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1VGIndexes.html">VGIndexes</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1VGset.html">VGset</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1Visit.html">Visit</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Describes a step of a walk through a <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes.">Snarl</a> either on a node or through a child <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes.">Snarl</a>.  <a href="structvg_1_1Visit.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Viz.html">Viz</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1wang__hash.html">wang_hash</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1wang__hash_3_01handle__t_01_4.html">wang_hash&lt; handle_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1wang__hash_3_01handlegraph_1_1net__handle__t_01_4.html">wang_hash&lt; handlegraph::net_handle_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1wang__hash_3_01NodeSide_01_4.html">wang_hash&lt; NodeSide &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1wang__hash_3_01NodeTraversal_01_4.html">wang_hash&lt; NodeTraversal &gt;</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">hash function for NodeTraversals  <a href="structvg_1_1wang__hash_3_01NodeTraversal_01_4.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1wang__hash_3_01path__handle__t_01_4.html">wang_hash&lt; path_handle_t &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1wang__hash_3_01std_1_1pair_3_01A_00_01B_01_4_01_4.html">wang_hash&lt; std::pair&lt; A, B &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1wang__hash_3_01T_01_5_01_4.html">wang_hash&lt; T * &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1wang__hash_3_01T_00_01typename_01std_1_1enable__if_3_01std_1_1is__integral_3_01T_01_4_1_1value_01_4_1_1type_01_4.html">wang_hash&lt; T, typename std::enable_if&lt; std::is_integral&lt; T &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Watchdog.html">Watchdog</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1WFAAlignment.html">WFAAlignment</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1WFAExtender.html">WFAExtender</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1WFANode.html">WFANode</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1WFAPoint.html">WFAPoint</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1WFATree.html">WFATree</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1WideningPRNG.html">WideningPRNG</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1WindowedVcfBuffer.html">WindowedVcfBuffer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1WrappingPositionScanner.html">WrappingPositionScanner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1XdropAligner.html">XdropAligner</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a4ab10687f0a0cca11ecfd062d9bb0a07"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4ab10687f0a0cca11ecfd062d9bb0a07">benchtime</a> = chrono::nanoseconds</td></tr>
<tr class="memdesc:a4ab10687f0a0cca11ecfd062d9bb0a07"><td class="mdescLeft">&#160;</td><td class="mdescRight">We define a duration type for expressing benchmark times in.  <a href="namespacevg.html#a4ab10687f0a0cca11ecfd062d9bb0a07">More...</a><br /></td></tr>
<tr class="separator:a4ab10687f0a0cca11ecfd062d9bb0a07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0942a662fe36dad76d2d0e310ec66e3f"><td class="memItemLeft" align="right" valign="top">typedef unordered_set&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0942a662fe36dad76d2d0e310ec66e3f">HandleSet</a></td></tr>
<tr class="separator:a0942a662fe36dad76d2d0e310ec66e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7143bc6d4008d03bc4a0ac4d4ba26948"><td class="memItemLeft" align="right" valign="top">typedef unordered_map&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7143bc6d4008d03bc4a0ac4d4ba26948">Handle2Component</a></td></tr>
<tr class="separator:a7143bc6d4008d03bc4a0ac4d4ba26948"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a29090bbc6b842c2362f9da44a4a57c"><td class="memItemLeft" align="right" valign="top">typedef std::map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, std::vector&lt; <a class="el" href="structvg_1_1Edge.html">Edge</a> * &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7a29090bbc6b842c2362f9da44a4a57c">EdgeMapping</a></td></tr>
<tr class="separator:a7a29090bbc6b842c2362f9da44a4a57c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaed4a2b7bc668cf2e076733ee26e036a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aaed4a2b7bc668cf2e076733ee26e036a">handle_t</a> = <a class="el" href="structhandlegraph_1_1handle__t.html">handlegraph::handle_t</a></td></tr>
<tr class="separator:aaed4a2b7bc668cf2e076733ee26e036a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26f660292f00451f15d1c95d9b8c6ffb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> = <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">handlegraph::nid_t</a></td></tr>
<tr class="separator:a26f660292f00451f15d1c95d9b8c6ffb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe223f2c7890c76de5e00b43ceb37add"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afe223f2c7890c76de5e00b43ceb37add">offset_t</a> = <a class="el" href="namespacehandlegraph.html#a5aba28c40bd7f181cac4e8d73d6edef8">handlegraph::offset_t</a></td></tr>
<tr class="separator:afe223f2c7890c76de5e00b43ceb37add"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae28b502adf2ce7302acbb3138280f06c"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae28b502adf2ce7302acbb3138280f06c">subrange_t</a> = <a class="el" href="namespacehandlegraph.html#a097e656b1ffb02a80c0b530b1987984a">handlegraph::subrange_t</a></td></tr>
<tr class="separator:ae28b502adf2ce7302acbb3138280f06c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf7aeec04909c1aac0ad991764d48e24"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aaf7aeec04909c1aac0ad991764d48e24">path_handle_t</a> = <a class="el" href="structhandlegraph_1_1path__handle__t.html">handlegraph::path_handle_t</a></td></tr>
<tr class="separator:aaf7aeec04909c1aac0ad991764d48e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15c1e75e93ab89aacd0eb7e1f0299724"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a15c1e75e93ab89aacd0eb7e1f0299724">PathSense</a> = <a class="el" href="namespacehandlegraph.html#ab3d3683c53bb48b8af63a6d94497271c">handlegraph::PathSense</a></td></tr>
<tr class="separator:a15c1e75e93ab89aacd0eb7e1f0299724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40b137bbd07d198ca2b77962eeeaf7c8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a40b137bbd07d198ca2b77962eeeaf7c8">step_handle_t</a> = <a class="el" href="structhandlegraph_1_1step__handle__t.html">handlegraph::step_handle_t</a></td></tr>
<tr class="separator:a40b137bbd07d198ca2b77962eeeaf7c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3de8fe5f38b1730a36af4ad9c4258963"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3de8fe5f38b1730a36af4ad9c4258963">edge_t</a> = <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">handlegraph::edge_t</a></td></tr>
<tr class="separator:a3de8fe5f38b1730a36af4ad9c4258963"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf54b55d1c1d16a3d64f1bae268a58af"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acf54b55d1c1d16a3d64f1bae268a58af">oriented_node_range_t</a> = <a class="el" href="namespacehandlegraph.html#aa9a6ea7613d52c42947d4faa2a189bba">handlegraph::oriented_node_range_t</a></td></tr>
<tr class="separator:acf54b55d1c1d16a3d64f1bae268a58af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5781c55c25f1446e1fc74c72c051c62"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad5781c55c25f1446e1fc74c72c051c62">HandleGraph</a> = <a class="el" href="classhandlegraph_1_1HandleGraph.html">handlegraph::HandleGraph</a></td></tr>
<tr class="separator:ad5781c55c25f1446e1fc74c72c051c62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a215e44b59d26cf0745f02218dfd902a2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a215e44b59d26cf0745f02218dfd902a2">RankedHandleGraph</a> = <a class="el" href="classhandlegraph_1_1RankedHandleGraph.html">handlegraph::RankedHandleGraph</a></td></tr>
<tr class="separator:a215e44b59d26cf0745f02218dfd902a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a293aa7465cc63a2581914d6a85a0e4b8"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a293aa7465cc63a2581914d6a85a0e4b8">MutableHandleGraph</a> = <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">handlegraph::MutableHandleGraph</a></td></tr>
<tr class="separator:a293aa7465cc63a2581914d6a85a0e4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f7f6692a7600f1fa62428255c5bb61"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab5f7f6692a7600f1fa62428255c5bb61">PathMetadata</a> = <a class="el" href="classhandlegraph_1_1PathMetadata.html">handlegraph::PathMetadata</a></td></tr>
<tr class="separator:ab5f7f6692a7600f1fa62428255c5bb61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb2636bd0db3101259ef6803cb4e591"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abeb2636bd0db3101259ef6803cb4e591">PathHandleGraph</a> = <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">handlegraph::PathHandleGraph</a></td></tr>
<tr class="separator:abeb2636bd0db3101259ef6803cb4e591"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2481be7fa8c46933b9b99108e4c797b3"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2481be7fa8c46933b9b99108e4c797b3">PathPositionHandleGraph</a> = <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">handlegraph::PathPositionHandleGraph</a></td></tr>
<tr class="separator:a2481be7fa8c46933b9b99108e4c797b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24350c08e6d69244e6930f41fee00e1f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a24350c08e6d69244e6930f41fee00e1f">MutablePathHandleGraph</a> = <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html">handlegraph::MutablePathHandleGraph</a></td></tr>
<tr class="separator:a24350c08e6d69244e6930f41fee00e1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2f83c48d4ecdcfd8f2604f10e863aea"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa2f83c48d4ecdcfd8f2604f10e863aea">MutablePathMutableHandleGraph</a> = <a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">handlegraph::MutablePathMutableHandleGraph</a></td></tr>
<tr class="separator:aa2f83c48d4ecdcfd8f2604f10e863aea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6df851edf21daea75fc6dc1dd81a78f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa6df851edf21daea75fc6dc1dd81a78f">DeletableHandleGraph</a> = <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">handlegraph::DeletableHandleGraph</a></td></tr>
<tr class="separator:aa6df851edf21daea75fc6dc1dd81a78f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f0cc7bac7a4f92b2b523357f8940aa5"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2f0cc7bac7a4f92b2b523357f8940aa5">MutablePathDeletableHandleGraph</a> = <a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html">handlegraph::MutablePathDeletableHandleGraph</a></td></tr>
<tr class="separator:a2f0cc7bac7a4f92b2b523357f8940aa5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7378a177b4ed2e7be87e02a9bfcb7d4e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7378a177b4ed2e7be87e02a9bfcb7d4e">SerializableHandleGraph</a> = <a class="el" href="classhandlegraph_1_1SerializableHandleGraph.html">handlegraph::SerializableHandleGraph</a></td></tr>
<tr class="separator:a7378a177b4ed2e7be87e02a9bfcb7d4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449aa64ac606119e59f71cecb8a3b218"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a449aa64ac606119e59f71cecb8a3b218">VectorizableHandleGraph</a> = <a class="el" href="classhandlegraph_1_1VectorizableHandleGraph.html">handlegraph::VectorizableHandleGraph</a></td></tr>
<tr class="separator:a449aa64ac606119e59f71cecb8a3b218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c7b4f84e5a75aee3d3abf4b65b0000f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2c7b4f84e5a75aee3d3abf4b65b0000f">NamedNodeBackTranslation</a> = <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">handlegraph::NamedNodeBackTranslation</a></td></tr>
<tr class="separator:a2c7b4f84e5a75aee3d3abf4b65b0000f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31b8b476fb46de6667b26514b7b24fd2"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a31b8b476fb46de6667b26514b7b24fd2">thread_t</a> = vector&lt; gbwt::node_type &gt;</td></tr>
<tr class="separator:a31b8b476fb46de6667b26514b7b24fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7027e98a84fa4b0fa42f72bf4a1d862f"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7027e98a84fa4b0fa42f72bf4a1d862f">IndexName</a> = string</td></tr>
<tr class="separator:a7027e98a84fa4b0fa42f72bf4a1d862f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96bc10f0ba77bc672e88a9f7d6e126b6"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a96bc10f0ba77bc672e88a9f7d6e126b6">IndexGroup</a> = set&lt; <a class="el" href="namespacevg.html#a7027e98a84fa4b0fa42f72bf4a1d862f">IndexName</a> &gt;</td></tr>
<tr class="separator:a96bc10f0ba77bc672e88a9f7d6e126b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6119d0b9707c042b0c2cde5d77b670cb"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6119d0b9707c042b0c2cde5d77b670cb">RecipeName</a> = pair&lt; <a class="el" href="namespacevg.html#a96bc10f0ba77bc672e88a9f7d6e126b6">IndexGroup</a>, size_t &gt;</td></tr>
<tr class="separator:a6119d0b9707c042b0c2cde5d77b670cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff09b399af11722aeee121ae6f4fd9b"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1ff09b399af11722aeee121ae6f4fd9b">RecipeFunc</a> = function&lt; vector&lt; vector&lt; string &gt; &gt;(const vector&lt; const <a class="el" href="classvg_1_1IndexFile.html">IndexFile</a> * &gt; &amp;, const <a class="el" href="classvg_1_1IndexingPlan.html">IndexingPlan</a> *, <a class="el" href="classvg_1_1AliasGraph.html">AliasGraph</a> &amp;, const <a class="el" href="namespacevg.html#a96bc10f0ba77bc672e88a9f7d6e126b6">IndexGroup</a> &amp;)&gt;</td></tr>
<tr class="separator:a1ff09b399af11722aeee121ae6f4fd9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1aa2d026eb3edc0c692e19e5a493feef"><td class="memItemLeft" align="right" valign="top">typedef std::pair&lt; uint32_t, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1aa2d026eb3edc0c692e19e5a493feef">pareto_point</a></td></tr>
<tr class="separator:a1aa2d026eb3edc0c692e19e5a493feef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aceea01d66677e39af71921f1bb1911f0"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> = vector&lt; pair&lt; const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *, bool &gt; &gt;</td></tr>
<tr class="separator:aceea01d66677e39af71921f1bb1911f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7392de2ef03532b2ec3461ebb178c75a"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> = long double</td></tr>
<tr class="separator:a7392de2ef03532b2ec3461ebb178c75a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b677be2f409ffcbefd5d9f6149c80c1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9b677be2f409ffcbefd5d9f6149c80c1">GAMIndex</a> = <a class="el" href="classvg_1_1StreamIndex.html">StreamIndex</a>&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;</td></tr>
<tr class="memdesc:a9b677be2f409ffcbefd5d9f6149c80c1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define a GAM index as a stream index over a stream of Alignments.  <a href="namespacevg.html#a9b677be2f409ffcbefd5d9f6149c80c1">More...</a><br /></td></tr>
<tr class="separator:a9b677be2f409ffcbefd5d9f6149c80c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c00bf57d75db83e41ac19a88882c043"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6c00bf57d75db83e41ac19a88882c043">GAMSorter</a> = <a class="el" href="classvg_1_1StreamSorter.html">StreamSorter</a>&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;</td></tr>
<tr class="separator:a6c00bf57d75db83e41ac19a88882c043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae488d495e344881cbcf599ebdd2355"><td class="memItemLeft" align="right" valign="top">typedef vector&lt; gbwt::node_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8ae488d495e344881cbcf599ebdd2355">exon_nodes_t</a></td></tr>
<tr class="separator:a8ae488d495e344881cbcf599ebdd2355"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c7b3ebb9ad8d6c01a0c54668b102c26"><td class="memItemLeft" align="right" valign="top">typedef vector&lt; gbwt::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5c7b3ebb9ad8d6c01a0c54668b102c26">thread_ids_t</a></td></tr>
<tr class="separator:a5c7b3ebb9ad8d6c01a0c54668b102c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afaa15fd8bdfd688d48561e1b12aee821"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">handlegraph::nid_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a></td></tr>
<tr class="separator:afaa15fd8bdfd688d48561e1b12aee821"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8232142f432c4dd8e7cfe96e1f50e039"><td class="memItemLeft" align="right" valign="top">typedef std::tuple&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool, <a class="el" href="namespacevg.html#afe223f2c7890c76de5e00b43ceb37add">offset_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a></td></tr>
<tr class="separator:a8232142f432c4dd8e7cfe96e1f50e039"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a43fe994695e911cc22e05195e327f5b5"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a43fe994695e911cc22e05195e327f5b5">alignment_emitter_flags_t</a> { <br />
&#160;&#160;<a class="el" href="namespacevg.html#a43fe994695e911cc22e05195e327f5b5a77d3ea80cba8f3d89e573bf723ea7f4f">ALIGNMENT_EMITTER_FLAG_NONE</a> = 0, 
<a class="el" href="namespacevg.html#a43fe994695e911cc22e05195e327f5b5a311ead9579740c16ac55d9eaff3953e0">ALIGNMENT_EMITTER_FLAG_HTS_RAW</a> = 1, 
<a class="el" href="namespacevg.html#a43fe994695e911cc22e05195e327f5b5a3388a03ab2e5b8dec8d422db673b00b3">ALIGNMENT_EMITTER_FLAG_HTS_SPLICED</a> = 2, 
<a class="el" href="namespacevg.html#a43fe994695e911cc22e05195e327f5b5ad2539e657e6f87051e9f12489f9bb557">ALIGNMENT_EMITTER_FLAG_HTS_PRUNE_SUSPICIOUS_ANCHORS</a> = 4, 
<br />
&#160;&#160;<a class="el" href="namespacevg.html#a43fe994695e911cc22e05195e327f5b5a3ea893f3dade371704d31df4070e95fd">ALIGNMENT_EMITTER_FLAG_VG_USE_SEGMENT_NAMES</a> = 8
<br />
 }</td></tr>
<tr class="separator:a43fe994695e911cc22e05195e327f5b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8af508a4586e2447fdbf2a30a213b39"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39">MappingQualityMethod</a> { <a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39a9ab31888ec6c2da1a29c051c49f2d5ea">Approx</a>, 
<a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39a71ab21548d5ec730cee91982aa78275e">Exact</a>, 
<a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39a0f1da9e8a7bb929e940b4fa8be187340">Adaptive</a>, 
<a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39aa676d6ce23c4076e354ffb65936c03d1">None</a>
 }</td></tr>
<tr class="separator:ae8af508a4586e2447fdbf2a30a213b39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac47f059d08b97304ea21d00dfc19cd97"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac47f059d08b97304ea21d00dfc19cd97">SnarlType</a> { <a class="el" href="namespacevg.html#ac47f059d08b97304ea21d00dfc19cd97a7db3292851220acc20f75deebe0924ff">UNCLASSIFIED</a> = 0, 
<a class="el" href="namespacevg.html#ac47f059d08b97304ea21d00dfc19cd97aea6b4b85aa567a940c7434df2fcb56fb">ULTRABUBBLE</a> = 1, 
<a class="el" href="namespacevg.html#ac47f059d08b97304ea21d00dfc19cd97a0e62c0ff8521d5960a5cc819a7bf7230">UNARY</a> = 2
 }</td></tr>
<tr class="memdesc:ac47f059d08b97304ea21d00dfc19cd97"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enumeration of the classifications of snarls.  <a href="namespacevg.html#ac47f059d08b97304ea21d00dfc19cd97">More...</a><br /></td></tr>
<tr class="separator:ac47f059d08b97304ea21d00dfc19cd97"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aea0e7a0965b967bed3ff54e6ff630f91"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aea0e7a0965b967bed3ff54e6ff630f91">score_gap</a> (size_t gap_length, int32_t gap_open, int32_t gap_extension)</td></tr>
<tr class="memdesc:aea0e7a0965b967bed3ff54e6ff630f91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Score a gap with the given open and extension scores.  <a href="namespacevg.html#aea0e7a0965b967bed3ff54e6ff630f91">More...</a><br /></td></tr>
<tr class="separator:aea0e7a0965b967bed3ff54e6ff630f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f1e53242cb6ccf3d567c73c0895c4ca"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1f1e53242cb6ccf3d567c73c0895c4ca">hts_for_each</a> (string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda, const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph)</td></tr>
<tr class="separator:a1f1e53242cb6ccf3d567c73c0895c4ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7abb14966c1c20cff85c5744a47de0e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad7abb14966c1c20cff85c5744a47de0e">hts_for_each</a> (string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:ad7abb14966c1c20cff85c5744a47de0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c0d37c85747f2bce6ba3356a813524a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7c0d37c85747f2bce6ba3356a813524a">hts_for_each_parallel</a> (string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda, const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph)</td></tr>
<tr class="separator:a7c0d37c85747f2bce6ba3356a813524a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59c6c494c2e7663fb14e40c978b4f9e5"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a59c6c494c2e7663fb14e40c978b4f9e5">hts_for_each_parallel</a> (string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:a59c6c494c2e7663fb14e40c978b4f9e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0676eec9e08d9589fe286cabdd16ffb3"><td class="memItemLeft" align="right" valign="top">bam_hdr_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0676eec9e08d9589fe286cabdd16ffb3">hts_file_header</a> (string &amp;filename, string &amp;header)</td></tr>
<tr class="separator:a0676eec9e08d9589fe286cabdd16ffb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc01af3a6e386a06a2971c17a0e6d1b1"><td class="memItemLeft" align="right" valign="top">bam_hdr_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abc01af3a6e386a06a2971c17a0e6d1b1">hts_string_header</a> (string &amp;header, const map&lt; string, int64_t &gt; &amp;path_length, const map&lt; string, string &gt; &amp;rg_sample)</td></tr>
<tr class="separator:abc01af3a6e386a06a2971c17a0e6d1b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb8cd62602cb90541b2270a79aed7595"><td class="memItemLeft" align="right" valign="top">bam_hdr_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aeb8cd62602cb90541b2270a79aed7595">hts_string_header</a> (string &amp;header, const vector&lt; pair&lt; string, int64_t &gt;&gt; &amp;path_order_and_length, const map&lt; string, string &gt; &amp;rg_sample)</td></tr>
<tr class="separator:aeb8cd62602cb90541b2270a79aed7595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f91415350a5b07bb4b4f90dd531658d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4f91415350a5b07bb4b4f90dd531658d">get_next_alignment_from_fastq</a> (gzFile fp, char *buffer, size_t len, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:a4f91415350a5b07bb4b4f90dd531658d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb9108ffcadb902a9d82ca882919a38c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afb9108ffcadb902a9d82ca882919a38c">get_next_interleaved_alignment_pair_from_fastq</a> (gzFile fp, char *buffer, size_t len, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;mate1, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;mate2)</td></tr>
<tr class="separator:afb9108ffcadb902a9d82ca882919a38c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e9fd0ae285f5f9dd8605c9f5343e071"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6e9fd0ae285f5f9dd8605c9f5343e071">get_next_alignment_pair_from_fastqs</a> (gzFile fp1, gzFile fp2, char *buffer, size_t len, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;mate1, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;mate2)</td></tr>
<tr class="separator:a6e9fd0ae285f5f9dd8605c9f5343e071"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9be9503a9e2519d984303added3fa549"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9be9503a9e2519d984303added3fa549">fastq_unpaired_for_each_parallel</a> (const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda, uint64_t batch_size)</td></tr>
<tr class="separator:a9be9503a9e2519d984303added3fa549"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade9b61525b8a059f3cb0c131e1c0a93c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ade9b61525b8a059f3cb0c131e1c0a93c">fastq_paired_interleaved_for_each_parallel</a> (const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda, uint64_t batch_size)</td></tr>
<tr class="separator:ade9b61525b8a059f3cb0c131e1c0a93c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac13b99e544cff2a419dfa9d64a03d210"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac13b99e544cff2a419dfa9d64a03d210">fastq_paired_two_files_for_each_parallel</a> (const string &amp;file1, const string &amp;file2, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda, uint64_t batch_size)</td></tr>
<tr class="separator:ac13b99e544cff2a419dfa9d64a03d210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affe4f02b57454f05982949fe74467ac6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#affe4f02b57454f05982949fe74467ac6">fastq_paired_interleaved_for_each_parallel_after_wait</a> (const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda, function&lt; bool(void)&gt; single_threaded_until_true, uint64_t batch_size)</td></tr>
<tr class="separator:affe4f02b57454f05982949fe74467ac6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70ee85be3dab6bf495cb73163bc2379"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af70ee85be3dab6bf495cb73163bc2379">fastq_paired_two_files_for_each_parallel_after_wait</a> (const string &amp;file1, const string &amp;file2, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda, function&lt; bool(void)&gt; single_threaded_until_true, uint64_t batch_size)</td></tr>
<tr class="separator:af70ee85be3dab6bf495cb73163bc2379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581952a0bdf921e9388ace316dbe3a63"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a581952a0bdf921e9388ace316dbe3a63">fastq_unpaired_for_each</a> (const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:a581952a0bdf921e9388ace316dbe3a63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50976b47c0b2b13fb095a0ef92b3b027"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a50976b47c0b2b13fb095a0ef92b3b027">fastq_paired_interleaved_for_each</a> (const string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:a50976b47c0b2b13fb095a0ef92b3b027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedcdef25c312dba95a599ff9c1b44b50"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aedcdef25c312dba95a599ff9c1b44b50">fastq_paired_two_files_for_each</a> (const string &amp;file1, const string &amp;file2, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:aedcdef25c312dba95a599ff9c1b44b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637c855dffc0296c6575ae8a4cac6b43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a637c855dffc0296c6575ae8a4cac6b43">parse_rg_sample_map</a> (char *hts_header, map&lt; string, string &gt; &amp;rg_sample)</td></tr>
<tr class="memdesc:a637c855dffc0296c6575ae8a4cac6b43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Populate a mapping from read group to sample name, given the text BAM header.  <a href="namespacevg.html#a637c855dffc0296c6575ae8a4cac6b43">More...</a><br /></td></tr>
<tr class="separator:a637c855dffc0296c6575ae8a4cac6b43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc66619671bdc564023a9b3259558785"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abc66619671bdc564023a9b3259558785">parse_tid_path_handle_map</a> (const bam_hdr_t *hts_header, const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> *graph, map&lt; int, <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;tid_path_handle)</td></tr>
<tr class="separator:abc66619671bdc564023a9b3259558785"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0471358e141f59c271b38dd64854371"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af0471358e141f59c271b38dd64854371">alignment_to_sam_internal</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const string &amp;refseq, const int32_t refpos, const bool refrev, const vector&lt; pair&lt; int, char &gt;&gt; &amp;cigar, const string &amp;mateseq, const int32_t matepos, bool materev, const int32_t tlen, bool paired, const int32_t tlen_max)</td></tr>
<tr class="separator:af0471358e141f59c271b38dd64854371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa3eeb1e344417323232103c7e38747f"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afa3eeb1e344417323232103c7e38747f">determine_flag</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const string &amp;refseq, const int32_t refpos, const bool refrev, const string &amp;mateseq, const int32_t matepos, bool materev, const int32_t tlen, bool paired, const int32_t tlen_max)</td></tr>
<tr class="memdesc:afa3eeb1e344417323232103c7e38747f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the SAM bit-coded flag for alignment with.  <a href="namespacevg.html#afa3eeb1e344417323232103c7e38747f">More...</a><br /></td></tr>
<tr class="separator:afa3eeb1e344417323232103c7e38747f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d06ec05d079a41bf301a4f5f93b635b"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8d06ec05d079a41bf301a4f5f93b635b">alignment_to_sam</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const string &amp;refseq, const int32_t refpos, const bool refrev, const vector&lt; pair&lt; int, char &gt;&gt; &amp;cigar, const string &amp;mateseq, const int32_t matepos, bool materev, const int32_t tlen, const int32_t tlen_max)</td></tr>
<tr class="separator:a8d06ec05d079a41bf301a4f5f93b635b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afec7360276d2d875f4368057d528572a"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afec7360276d2d875f4368057d528572a">alignment_to_sam</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const string &amp;refseq, const int32_t refpos, const bool refrev, const vector&lt; pair&lt; int, char &gt;&gt; &amp;cigar)</td></tr>
<tr class="separator:afec7360276d2d875f4368057d528572a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a815420ed5a7dce52d484c346271fbd71"><td class="memItemLeft" align="right" valign="top">bam1_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a815420ed5a7dce52d484c346271fbd71">alignment_to_bam_internal</a> (bam_hdr_t *header, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const string &amp;refseq, const int32_t refpos, const bool refrev, const vector&lt; pair&lt; int, char &gt;&gt; &amp;cigar, const string &amp;mateseq, const int32_t matepos, bool materev, const int32_t tlen, bool paired, const int32_t tlen_max)</td></tr>
<tr class="separator:a815420ed5a7dce52d484c346271fbd71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b59157d021eca5f39da96ca23f33f08"><td class="memItemLeft" align="right" valign="top">bam1_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1b59157d021eca5f39da96ca23f33f08">alignment_to_bam</a> (bam_hdr_t *bam_header, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const string &amp;refseq, const int32_t refpos, const bool refrev, const vector&lt; pair&lt; int, char &gt;&gt; &amp;cigar, const string &amp;mateseq, const int32_t matepos, bool materev, const int32_t tlen, const int32_t tlen_max)</td></tr>
<tr class="separator:a1b59157d021eca5f39da96ca23f33f08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d064f9483fe862fe937abc9e7474e57"><td class="memItemLeft" align="right" valign="top">bam1_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0d064f9483fe862fe937abc9e7474e57">alignment_to_bam</a> (bam_hdr_t *bam_header, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const string &amp;refseq, const int32_t refpos, const bool refrev, const vector&lt; pair&lt; int, char &gt;&gt; &amp;cigar)</td></tr>
<tr class="separator:a0d064f9483fe862fe937abc9e7474e57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a022b99db4260a7fd77a248bf27c50041"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a022b99db4260a7fd77a248bf27c50041">cigar_string</a> (const vector&lt; pair&lt; int, char &gt; &gt; &amp;cigar)</td></tr>
<tr class="separator:a022b99db4260a7fd77a248bf27c50041"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad993b1f289a57f3413b85840984b459c"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad993b1f289a57f3413b85840984b459c">mapping_string</a> (const string &amp;source, const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mapping)</td></tr>
<tr class="separator:ad993b1f289a57f3413b85840984b459c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a814bb77cffb64c258d06bbc9a79252d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a814bb77cffb64c258d06bbc9a79252d9">mapping_cigar</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mapping, vector&lt; pair&lt; int, char &gt;&gt; &amp;cigar)</td></tr>
<tr class="separator:a814bb77cffb64c258d06bbc9a79252d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81755bb87928f81a864e4a752973bd69"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a81755bb87928f81a864e4a752973bd69">cigar_mapping</a> (const bam1_t *b, <a class="el" href="structvg_1_1Mapping.html">Mapping</a> *mapping)</td></tr>
<tr class="separator:a81755bb87928f81a864e4a752973bd69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad2e7730a993652e18d80ca77dac73713"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad2e7730a993652e18d80ca77dac73713">mapping_against_path</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const bam1_t *b, const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph, bool on_reverse_strand)</td></tr>
<tr class="separator:ad2e7730a993652e18d80ca77dac73713"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43ac2d1903fa51a20a2366a865f5f0a4"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; int, char &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a43ac2d1903fa51a20a2366a865f5f0a4">cigar_against_path</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, bool on_reverse_strand, int64_t &amp;pos, size_t path_len, size_t softclip_suppress)</td></tr>
<tr class="separator:a43ac2d1903fa51a20a2366a865f5f0a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a553c3fcfd7de2e51f41a6f174c313947"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a553c3fcfd7de2e51f41a6f174c313947">simplify_cigar</a> (vector&lt; pair&lt; int, char &gt;&gt; &amp;cigar)</td></tr>
<tr class="separator:a553c3fcfd7de2e51f41a6f174c313947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3824b96906cc229f270166a06a7a625"><td class="memItemLeft" align="right" valign="top">pair&lt; int32_t, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad3824b96906cc229f270166a06a7a625">compute_template_lengths</a> (const int64_t &amp;pos1, const vector&lt; pair&lt; int, char &gt;&gt; &amp;cigar1, const int64_t &amp;pos2, const vector&lt; pair&lt; int, char &gt;&gt; &amp;cigar2)</td></tr>
<tr class="separator:ad3824b96906cc229f270166a06a7a625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae37c6d66a01cef6f92707d367ebf4cdb"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae37c6d66a01cef6f92707d367ebf4cdb">sam_flag</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, bool on_reverse_strand, bool paired)</td></tr>
<tr class="separator:ae37c6d66a01cef6f92707d367ebf4cdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a461b5385c79e073ab10d8fe860ff9428"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a461b5385c79e073ab10d8fe860ff9428">bam_to_alignment</a> (const bam1_t *b, const map&lt; string, string &gt; &amp;rg_sample, const map&lt; int, <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;tid_path_handle, const bam_hdr_t *bh, const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph)</td></tr>
<tr class="separator:a461b5385c79e073ab10d8fe860ff9428"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f8705957c0972a6b4778efb5036c6aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1f8705957c0972a6b4778efb5036c6aa">bam_to_alignment</a> (const bam1_t *b, const map&lt; string, string &gt; &amp;rg_sample, const map&lt; int, <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;tid_path_handle)</td></tr>
<tr class="separator:a1f8705957c0972a6b4778efb5036c6aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38cb960f8c643934d65c03f0cc85442c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a38cb960f8c643934d65c03f0cc85442c">alignment_to_length</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;a)</td></tr>
<tr class="separator:a38cb960f8c643934d65c03f0cc85442c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4defc9906e81731eab06f8acaa28369"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae4defc9906e81731eab06f8acaa28369">alignment_from_length</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;a)</td></tr>
<tr class="separator:ae4defc9906e81731eab06f8acaa28369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6786ea9551b426f95fba325beff138"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acd6786ea9551b426f95fba325beff138">strip_from_start</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, size_t drop)</td></tr>
<tr class="separator:acd6786ea9551b426f95fba325beff138"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbe45b79675104ebc36691774d4124c4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#adbe45b79675104ebc36691774d4124c4">strip_from_end</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, size_t drop)</td></tr>
<tr class="separator:adbe45b79675104ebc36691774d4124c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad83da8607e104967dd51d9230f4b51bb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad83da8607e104967dd51d9230f4b51bb">trim_alignment</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos1, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos2)</td></tr>
<tr class="separator:ad83da8607e104967dd51d9230f4b51bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc3ca4569facd77e26c78ba583e4f0a"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acdc3ca4569facd77e26c78ba583e4f0a">alignment_ends</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, size_t len1, size_t len2)</td></tr>
<tr class="separator:acdc3ca4569facd77e26c78ba583e4f0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15b82cc5c99cc3e8f78229ac971ec9c3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a15b82cc5c99cc3e8f78229ac971ec9c3">alignment_middle</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, int len)</td></tr>
<tr class="separator:a15b82cc5c99cc3e8f78229ac971ec9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed045b02277d7704e997cbede67c2662"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aed045b02277d7704e997cbede67c2662">reverse_complement_alignments</a> (const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alns, const function&lt; int64_t(int64_t)&gt; &amp;node_length)</td></tr>
<tr class="separator:aed045b02277d7704e997cbede67c2662"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98e512ed0fca2503ccc370435591a6c1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a98e512ed0fca2503ccc370435591a6c1">reverse_complement_alignment</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;node_length)</td></tr>
<tr class="separator:a98e512ed0fca2503ccc370435591a6c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab96610ffc81d6207e0b13f675296c234"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab96610ffc81d6207e0b13f675296c234">reverse_complement_alignment_in_place</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> *aln, const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;node_length)</td></tr>
<tr class="separator:ab96610ffc81d6207e0b13f675296c234"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa2d2a5d955cff1e7a99369055ebe75d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afa2d2a5d955cff1e7a99369055ebe75d">merge_alignments</a> (const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alns)</td></tr>
<tr class="separator:afa2d2a5d955cff1e7a99369055ebe75d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a491e9c11712ae965b8c6745ab33aba21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a491e9c11712ae965b8c6745ab33aba21">extend_alignment</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;a1, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;a2, bool debug)</td></tr>
<tr class="separator:a491e9c11712ae965b8c6745ab33aba21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d71527a132d7e6bf364d2108b269e09"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9d71527a132d7e6bf364d2108b269e09">merge_alignments</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;a1, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;a2, bool debug)</td></tr>
<tr class="separator:a9d71527a132d7e6bf364d2108b269e09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98dcd16f2a4eae4c223a374dd2ab2da4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a98dcd16f2a4eae4c223a374dd2ab2da4">translate_nodes</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;a, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt; &gt; &amp;ids, const std::function&lt; size_t(int64_t)&gt; &amp;node_length)</td></tr>
<tr class="separator:a98dcd16f2a4eae4c223a374dd2ab2da4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4eaa1a100e433af698e794afa8857b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1f4eaa1a100e433af698e794afa8857b">flip_nodes</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;a, const set&lt; int64_t &gt; &amp;ids, const std::function&lt; size_t(int64_t)&gt; &amp;node_length)</td></tr>
<tr class="separator:a1f4eaa1a100e433af698e794afa8857b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae838e7d89edc59dd87747238cee49b49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae838e7d89edc59dd87747238cee49b49">non_match_start</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:ae838e7d89edc59dd87747238cee49b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ec2e2ef9679291d966bc348a47c3537"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3ec2e2ef9679291d966bc348a47c3537">non_match_end</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:a3ec2e2ef9679291d966bc348a47c3537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f2af92a34fdf5fb4ddfee8f8880b48"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a90f2af92a34fdf5fb4ddfee8f8880b48">softclip_start</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:a90f2af92a34fdf5fb4ddfee8f8880b48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05d6d0388148a996d9423524fa4bcc91"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a05d6d0388148a996d9423524fa4bcc91">softclip_end</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:a05d6d0388148a996d9423524fa4bcc91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a947760b26fa8669d55f2f420174a578c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a947760b26fa8669d55f2f420174a578c">softclip_trim</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:a947760b26fa8669d55f2f420174a578c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acffe466a3ca83097eceac30a09b9a010"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acffe466a3ca83097eceac30a09b9a010">query_overlap</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln1, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln2)</td></tr>
<tr class="separator:acffe466a3ca83097eceac30a09b9a010"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2610da8a8fbe723e13519d79ac2d0afe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2610da8a8fbe723e13519d79ac2d0afe">edit_count</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:a2610da8a8fbe723e13519d79ac2d0afe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad47f373b3433b3190f9f1c0f5f17274d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad47f373b3433b3190f9f1c0f5f17274d">to_length_after_pos</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos)</td></tr>
<tr class="separator:ad47f373b3433b3190f9f1c0f5f17274d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b4e98d0d99a9b58b56f0946f49b1ab"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a59b4e98d0d99a9b58b56f0946f49b1ab">from_length_after_pos</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos)</td></tr>
<tr class="separator:a59b4e98d0d99a9b58b56f0946f49b1ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa40f0cfd74a9eeaa7b6ffecbc0926a6d"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa40f0cfd74a9eeaa7b6ffecbc0926a6d">to_length_before_pos</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos)</td></tr>
<tr class="separator:aa40f0cfd74a9eeaa7b6ffecbc0926a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21d316f0ae049289cacab5117678d6ab"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a21d316f0ae049289cacab5117678d6ab">from_length_before_pos</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos)</td></tr>
<tr class="separator:a21d316f0ae049289cacab5117678d6ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f469aebb2be5b0028c337108d253fb"><td class="memItemLeft" align="right" valign="top">const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a94f469aebb2be5b0028c337108d253fb">hash_alignment</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="separator:a94f469aebb2be5b0028c337108d253fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a486054f13a4dc43e37c0f0131f6a51ad"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a486054f13a4dc43e37c0f0131f6a51ad">simplify</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;a, bool trim_internal_deletions)</td></tr>
<tr class="separator:a486054f13a4dc43e37c0f0131f6a51ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa0c54720b2b1007ae540dc70b5b8024"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afa0c54720b2b1007ae540dc70b5b8024">normalize_alignment</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="memdesc:afa0c54720b2b1007ae540dc70b5b8024"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge adjacent edits of the same type and convert all N matches to mismatches.  <a href="namespacevg.html#afa0c54720b2b1007ae540dc70b5b8024">More...</a><br /></td></tr>
<tr class="separator:afa0c54720b2b1007ae540dc70b5b8024"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd966c42f332957a1b9317faa3d26407"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acd966c42f332957a1b9317faa3d26407">uses_Us</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="separator:acd966c42f332957a1b9317faa3d26407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a256962a964ea02f3d4ec54c5c48d72a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a256962a964ea02f3d4ec54c5c48d72a8">convert_alignment_char</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, char from, char to)</td></tr>
<tr class="separator:a256962a964ea02f3d4ec54c5c48d72a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdc8589575aed95e82c0bb70828ab036"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abdc8589575aed95e82c0bb70828ab036">convert_Us_to_Ts</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="memdesc:abdc8589575aed95e82c0bb70828ab036"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces any U's in the sequence or the <a class="el" href="structvg_1_1Path.html">Path</a> with T's.  <a href="namespacevg.html#abdc8589575aed95e82c0bb70828ab036">More...</a><br /></td></tr>
<tr class="separator:abdc8589575aed95e82c0bb70828ab036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add9a4cf274b29df3caf222d0360805f3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#add9a4cf274b29df3caf222d0360805f3">convert_Ts_to_Us</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="memdesc:add9a4cf274b29df3caf222d0360805f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces any T's in the sequence or the <a class="el" href="structvg_1_1Path.html">Path</a> with U's.  <a href="namespacevg.html#add9a4cf274b29df3caf222d0360805f3">More...</a><br /></td></tr>
<tr class="separator:add9a4cf274b29df3caf222d0360805f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a4413a5d745c8fdc6339efdcd13310c"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, int &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2a4413a5d745c8fdc6339efdcd13310c">alignment_quality_per_node</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="separator:a2a4413a5d745c8fdc6339efdcd13310c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7848d492a243a93f37b1ac52a541a96a"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7848d492a243a93f37b1ac52a541a96a">middle_signature</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, int len)</td></tr>
<tr class="separator:a7848d492a243a93f37b1ac52a541a96a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64c67658563ff567bc0b103ef1d8af4"><td class="memItemLeft" align="right" valign="top">pair&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af64c67658563ff567bc0b103ef1d8af4">middle_signature</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln1, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln2, int len)</td></tr>
<tr class="separator:af64c67658563ff567bc0b103ef1d8af4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2616dde2763b947a15ac562fd631e688"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2616dde2763b947a15ac562fd631e688">signature</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="separator:a2616dde2763b947a15ac562fd631e688"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134fc6762c4b66dd4847078b0ddbfdd6"><td class="memItemLeft" align="right" valign="top">pair&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a134fc6762c4b66dd4847078b0ddbfdd6">signature</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln1, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln2)</td></tr>
<tr class="separator:a134fc6762c4b66dd4847078b0ddbfdd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a736f4c7b5d03a7efe78315b4c5490f15"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a736f4c7b5d03a7efe78315b4c5490f15">parse_bed_regions</a> (istream &amp;bedstream, const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; *out_alignments)</td></tr>
<tr class="separator:a736f4c7b5d03a7efe78315b4c5490f15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55cc20d96f38b54c590af4f3f3ac2498"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a55cc20d96f38b54c590af4f3f3ac2498">parse_gff_regions</a> (istream &amp;gffstream, const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; *out_alignments)</td></tr>
<tr class="separator:a55cc20d96f38b54c590af4f3f3ac2498"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7f897cb4a7bbbd40edcb938cdbd4e7c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab7f897cb4a7bbbd40edcb938cdbd4e7c">alignment_start</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="separator:ab7f897cb4a7bbbd40edcb938cdbd4e7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa63fccb24f075243da0ba145eb8d6aca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa63fccb24f075243da0ba145eb8d6aca">alignment_end</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="separator:aa63fccb24f075243da0ba145eb8d6aca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad13bf14c3488a2d7a86931831ce25d"><td class="memItemLeft" align="right" valign="top">map&lt; string,vector&lt; pair&lt; size_t, bool &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3ad13bf14c3488a2d7a86931831ce25d">alignment_refpos_to_path_offsets</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="memdesc:a3ad13bf14c3488a2d7a86931831ce25d"><td class="mdescLeft">&#160;</td><td class="mdescRight">return the path offsets as cached in the alignment  <a href="namespacevg.html#a3ad13bf14c3488a2d7a86931831ce25d">More...</a><br /></td></tr>
<tr class="separator:a3ad13bf14c3488a2d7a86931831ce25d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c45c724ede7f4892b24ad654d68fbef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6c45c724ede7f4892b24ad654d68fbef">alignment_set_distance_to_correct</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;base, const unordered_map&lt; string, string &gt; *translation)</td></tr>
<tr class="separator:a6c45c724ede7f4892b24ad654d68fbef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7c6a6b96f1c4c2ca04b0b6df8f384b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab7c6a6b96f1c4c2ca04b0b6df8f384b3">alignment_set_distance_to_correct</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const map&lt; string, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; &amp;base_offsets, const unordered_map&lt; string, string &gt; *translation)</td></tr>
<tr class="separator:ab7c6a6b96f1c4c2ca04b0b6df8f384b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02344193099beceed3ee60119c63fa1f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1AlignmentValidity.html">AlignmentValidity</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a02344193099beceed3ee60119c63fa1f">alignment_is_valid</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *hgraph)</td></tr>
<tr class="separator:a02344193099beceed3ee60119c63fa1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac712c04180499746dab8cdc6c8795c56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac712c04180499746dab8cdc6c8795c56">target_alignment</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph, const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, size_t pos1, size_t pos2, const string &amp;feature, bool is_reverse, <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;<a class="el" href="namespacevg.html#a81755bb87928f81a864e4a752973bd69">cigar_mapping</a>)</td></tr>
<tr class="separator:ac712c04180499746dab8cdc6c8795c56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08575acb0012ffaabd9859324e404562"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a08575acb0012ffaabd9859324e404562">target_alignment</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph, const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;path, size_t pos1, size_t pos2, const string &amp;feature, bool is_reverse)</td></tr>
<tr class="separator:a08575acb0012ffaabd9859324e404562"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99b58aa1a0c067044f1fcbf97627e390"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a99b58aa1a0c067044f1fcbf97627e390">fastq_for_each</a> (string &amp;filename, function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt; lambda)</td></tr>
<tr class="separator:a99b58aa1a0c067044f1fcbf97627e390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81c8bc6d3b973fd1a34c3457a9d2e401"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a81c8bc6d3b973fd1a34c3457a9d2e401">write_alignment_to_file</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const string &amp;filename)</td></tr>
<tr class="separator:a81c8bc6d3b973fd1a34c3457a9d2e401"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27af27aefacd2822744823bee4fe9366"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a27af27aefacd2822744823bee4fe9366">mapping_cigar</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mapping, vector&lt; pair&lt; int, char &gt; &gt; &amp;cigar)</td></tr>
<tr class="separator:a27af27aefacd2822744823bee4fe9366"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a598379872a84d4be8ff74df6242abf10"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a598379872a84d4be8ff74df6242abf10">cigar_mapping</a> (const bam1_t *b, <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mapping)</td></tr>
<tr class="separator:a598379872a84d4be8ff74df6242abf10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083d5edb5192697a269a3e5b8815bccd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a083d5edb5192697a269a3e5b8815bccd">append_cigar_operation</a> (const int length, const char operation, vector&lt; pair&lt; int, char &gt;&gt; &amp;cigar)</td></tr>
<tr class="separator:a083d5edb5192697a269a3e5b8815bccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c59e7d46046fad0d349a3c747ffd6b3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6c59e7d46046fad0d349a3c747ffd6b3">alignment_set_distance_to_correct</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const map&lt; string, vector&lt; pair&lt; size_t, bool &gt;&gt;&gt; &amp;base_offsets, const unordered_map&lt; string, string &gt; *translation=nullptr)</td></tr>
<tr class="separator:a6c59e7d46046fad0d349a3c747ffd6b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34f4e73b242fa5b34d30ecc4da496835"><td class="memTemplParams" colspan="2">template&lt;typename Annotated &gt; </td></tr>
<tr class="memitem:a34f4e73b242fa5b34d30ecc4da496835"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a34f4e73b242fa5b34d30ecc4da496835">has_annotation</a> (const Annotated &amp;annotated, const string &amp;name)</td></tr>
<tr class="memdesc:a34f4e73b242fa5b34d30ecc4da496835"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if the Protobuf object has an annotation with this name.  <a href="namespacevg.html#a34f4e73b242fa5b34d30ecc4da496835">More...</a><br /></td></tr>
<tr class="separator:a34f4e73b242fa5b34d30ecc4da496835"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fda752e24eaed100f6c30904d2ca3e1"><td class="memTemplParams" colspan="2">template&lt;typename AnnotationType , typename Annotated &gt; </td></tr>
<tr class="memitem:a1fda752e24eaed100f6c30904d2ca3e1"><td class="memTemplItemLeft" align="right" valign="top">AnnotationType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1fda752e24eaed100f6c30904d2ca3e1">get_annotation</a> (const Annotated &amp;annotated, const string &amp;name)</td></tr>
<tr class="separator:a1fda752e24eaed100f6c30904d2ca3e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c9f371af54160a44a44afd80c6cf71a"><td class="memTemplParams" colspan="2">template&lt;typename AnnotationType , typename Annotated &gt; </td></tr>
<tr class="memitem:a1c9f371af54160a44a44afd80c6cf71a"><td class="memTemplItemLeft" align="right" valign="top">AnnotationType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1c9f371af54160a44a44afd80c6cf71a">get_annotation</a> (Annotated *annotated, const string &amp;name)</td></tr>
<tr class="separator:a1c9f371af54160a44a44afd80c6cf71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adea29af7b94ac90b1db0eacd908511c0"><td class="memTemplParams" colspan="2">template&lt;typename AnnotationType , typename Annotated &gt; </td></tr>
<tr class="memitem:adea29af7b94ac90b1db0eacd908511c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#adea29af7b94ac90b1db0eacd908511c0">set_annotation</a> (Annotated *annotated, const string &amp;name, const AnnotationType &amp;annotation)</td></tr>
<tr class="separator:adea29af7b94ac90b1db0eacd908511c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54bcd5d5fc5318bbdbe784f224b906bd"><td class="memTemplParams" colspan="2">template&lt;typename AnnotationType , typename Annotated &gt; </td></tr>
<tr class="memitem:a54bcd5d5fc5318bbdbe784f224b906bd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a54bcd5d5fc5318bbdbe784f224b906bd">set_annotation</a> (Annotated &amp;annotated, const string &amp;name, const AnnotationType &amp;annotation)</td></tr>
<tr class="separator:a54bcd5d5fc5318bbdbe784f224b906bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad970d2836c53996c21e5c5d9d3e0a6d8"><td class="memTemplParams" colspan="2">template&lt;typename Annotated &gt; </td></tr>
<tr class="memitem:ad970d2836c53996c21e5c5d9d3e0a6d8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad970d2836c53996c21e5c5d9d3e0a6d8">clear_annotation</a> (Annotated *annotated, const string &amp;name)</td></tr>
<tr class="memdesc:ad970d2836c53996c21e5c5d9d3e0a6d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the annotation with the given name.  <a href="namespacevg.html#ad970d2836c53996c21e5c5d9d3e0a6d8">More...</a><br /></td></tr>
<tr class="separator:ad970d2836c53996c21e5c5d9d3e0a6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae414970cfc37049b4dc9b308d9ed5f59"><td class="memTemplParams" colspan="2">template&lt;typename Annotated &gt; </td></tr>
<tr class="memitem:ae414970cfc37049b4dc9b308d9ed5f59"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae414970cfc37049b4dc9b308d9ed5f59">clear_annotation</a> (Annotated &amp;annotated, const string &amp;name)</td></tr>
<tr class="memdesc:ae414970cfc37049b4dc9b308d9ed5f59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear the annotation with the given name.  <a href="namespacevg.html#ae414970cfc37049b4dc9b308d9ed5f59">More...</a><br /></td></tr>
<tr class="separator:ae414970cfc37049b4dc9b308d9ed5f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f0eee097c87cbab2bc44f096b463d8b"><td class="memTemplParams" colspan="2">template&lt;typename Annotated &gt; </td></tr>
<tr class="memitem:a8f0eee097c87cbab2bc44f096b463d8b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8f0eee097c87cbab2bc44f096b463d8b">for_each_basic_annotation</a> (const Annotated &amp;annotated, const function&lt; void(const string &amp;)&gt; null_lambda, const function&lt; void(const string &amp;, double)&gt; double_lambda, const function&lt; void(const string &amp;, bool)&gt; bool_lambda, const function&lt; void(const string &amp;, const string &amp;)&gt; string_lambda)</td></tr>
<tr class="separator:a8f0eee097c87cbab2bc44f096b463d8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76fc86953f8c080621c080cd35bc9ae0"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a76fc86953f8c080621c080cd35bc9ae0"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a76fc86953f8c080621c080cd35bc9ae0">value_cast</a> (const google::protobuf::Value &amp;value)</td></tr>
<tr class="memdesc:a76fc86953f8c080621c080cd35bc9ae0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a Protobuf generic Value to any type.  <a href="namespacevg.html#a76fc86953f8c080621c080cd35bc9ae0">More...</a><br /></td></tr>
<tr class="separator:a76fc86953f8c080621c080cd35bc9ae0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac84a9621d5108f53976d51f1188e7214"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac84a9621d5108f53976d51f1188e7214"><td class="memTemplItemLeft" align="right" valign="top">google::protobuf::Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac84a9621d5108f53976d51f1188e7214">value_cast</a> (const T &amp;wrap)</td></tr>
<tr class="memdesc:ac84a9621d5108f53976d51f1188e7214"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast any type to a generic Protobuf value.  <a href="namespacevg.html#ac84a9621d5108f53976d51f1188e7214">More...</a><br /></td></tr>
<tr class="separator:ac84a9621d5108f53976d51f1188e7214"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac90d23f22ad3ec78da4e03dc011cabf8"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac90d23f22ad3ec78da4e03dc011cabf8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac90d23f22ad3ec78da4e03dc011cabf8">value_cast&lt; bool &gt;</a> (const google::protobuf::Value &amp;value)</td></tr>
<tr class="separator:ac90d23f22ad3ec78da4e03dc011cabf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a0cc45e4277281efeedb821c1444f6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a13a0cc45e4277281efeedb821c1444f6"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a13a0cc45e4277281efeedb821c1444f6">value_cast&lt; double &gt;</a> (const google::protobuf::Value &amp;value)</td></tr>
<tr class="separator:a13a0cc45e4277281efeedb821c1444f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16575a017d153499fe4a0976e801be61"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a16575a017d153499fe4a0976e801be61"><td class="memTemplItemLeft" align="right" valign="top">string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a16575a017d153499fe4a0976e801be61">value_cast&lt; string &gt;</a> (const google::protobuf::Value &amp;value)</td></tr>
<tr class="separator:a16575a017d153499fe4a0976e801be61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab572dfa4b65db43984f1572d74a94036"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ab572dfa4b65db43984f1572d74a94036"><td class="memTemplItemLeft" align="right" valign="top">google::protobuf::Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab572dfa4b65db43984f1572d74a94036">value_cast&lt; bool &gt;</a> (const bool &amp;wrap)</td></tr>
<tr class="separator:ab572dfa4b65db43984f1572d74a94036"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac16fdb4078f95e252450a80a1e9e14f2"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac16fdb4078f95e252450a80a1e9e14f2"><td class="memTemplItemLeft" align="right" valign="top">google::protobuf::Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac16fdb4078f95e252450a80a1e9e14f2">value_cast&lt; double &gt;</a> (const double &amp;wrap)</td></tr>
<tr class="separator:ac16fdb4078f95e252450a80a1e9e14f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e6a112ff1115272420d46ca4316f63"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a51e6a112ff1115272420d46ca4316f63"><td class="memTemplItemLeft" align="right" valign="top">google::protobuf::Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a51e6a112ff1115272420d46ca4316f63">value_cast&lt; string &gt;</a> (const string &amp;wrap)</td></tr>
<tr class="separator:a51e6a112ff1115272420d46ca4316f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a12578ee636d9d929a9c1205e7c8525"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a2a12578ee636d9d929a9c1205e7c8525"><td class="memTemplItemLeft" align="right" valign="top">google::protobuf::Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2a12578ee636d9d929a9c1205e7c8525">value_cast&lt; size_t &gt;</a> (const size_t &amp;wrap)</td></tr>
<tr class="separator:a2a12578ee636d9d929a9c1205e7c8525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1ca627c13de536f96efbc08934edb62"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad1ca627c13de536f96efbc08934edb62"><td class="memTemplItemLeft" align="right" valign="top">google::protobuf::Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad1ca627c13de536f96efbc08934edb62">value_cast&lt; int &gt;</a> (const int &amp;wrap)</td></tr>
<tr class="separator:ad1ca627c13de536f96efbc08934edb62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12109d27c9801031e32a408e75af2bd1"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:a12109d27c9801031e32a408e75af2bd1"><td class="memTemplItemLeft" align="right" valign="top">Container&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a12109d27c9801031e32a408e75af2bd1">value_cast</a> (const google::protobuf::Value &amp;value)</td></tr>
<tr class="memdesc:a12109d27c9801031e32a408e75af2bd1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Cast a Protobuf generic Value to any type.  <a href="namespacevg.html#a12109d27c9801031e32a408e75af2bd1">More...</a><br /></td></tr>
<tr class="separator:a12109d27c9801031e32a408e75af2bd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca53457219a2ced000f439df5bd0d71f"><td class="memTemplParams" colspan="2">template&lt;typename Container &gt; </td></tr>
<tr class="memitem:aca53457219a2ced000f439df5bd0d71f"><td class="memTemplItemLeft" align="right" valign="top">google::protobuf::Value&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#aca53457219a2ced000f439df5bd0d71f">value_cast</a> (const Container &amp;wrap)</td></tr>
<tr class="separator:aca53457219a2ced000f439df5bd0d71f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ad955989dbbd240c02052d94a9214e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3ad955989dbbd240c02052d94a9214e2">augment</a> (<a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *graph, const string &amp;gam_path, const string &amp;aln_format, vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; *out_translations, const string &amp;gam_out_path, bool embed_paths, bool break_at_ends, bool remove_softclips, bool filter_out_of_graph_alignments, double min_baseq, double min_mapq, <a class="el" href="classvg_1_1Packer.html">Packer</a> *packer, size_t min_bp_coverage, double max_frac_n, bool edges_only)</td></tr>
<tr class="separator:a3ad955989dbbd240c02052d94a9214e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10c4a321eb33280d58a3ddaf97f52ed2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a10c4a321eb33280d58a3ddaf97f52ed2">augment</a> (<a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *graph, vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;path_vector, const string &amp;aln_format, vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; *out_translations, const string &amp;gam_out_path, bool embed_paths, bool break_at_ends, bool remove_softclips, bool filter_out_of_graph_alignments, double min_baseq, double min_mapq, <a class="el" href="classvg_1_1Packer.html">Packer</a> *packer, size_t min_bp_coverage, double max_frac_n, bool edges_only)</td></tr>
<tr class="separator:a10c4a321eb33280d58a3ddaf97f52ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5be4fdda1799c2f6876f2ac4937da349"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5be4fdda1799c2f6876f2ac4937da349">augment_impl</a> (<a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *graph, function&lt; void(function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;, bool, bool)&gt; iterate_gam, const string &amp;aln_format, vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; *out_translation, const string &amp;gam_out_path, bool embed_paths, bool break_at_ends, bool remove_soft_clips, bool filter_out_of_graph_alignments, double min_baseq, double min_mapq, <a class="el" href="classvg_1_1Packer.html">Packer</a> *packer, size_t min_bp_coverage, double max_frac_n, bool edges_only)</td></tr>
<tr class="memdesc:a5be4fdda1799c2f6876f2ac4937da349"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic version used to implement the above three methods. <br  />
  <a href="namespacevg.html#a5be4fdda1799c2f6876f2ac4937da349">More...</a><br /></td></tr>
<tr class="separator:a5be4fdda1799c2f6876f2ac4937da349"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680a465e72fbddeed584f27a6c3f7b27"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a680a465e72fbddeed584f27a6c3f7b27">get_avg_baseq</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;edit, const string &amp;base_quals, size_t position_in_read)</td></tr>
<tr class="separator:a680a465e72fbddeed584f27a6c3f7b27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac80bc94af296d0a543d983eae79afac0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac80bc94af296d0a543d983eae79afac0">find_breakpoints</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, set&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &gt;&gt; &amp;breakpoints, bool break_ends, const string &amp;base_quals, double min_baseq, double max_frac_n)</td></tr>
<tr class="separator:ac80bc94af296d0a543d983eae79afac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9c975d7bec4a22a46b72736915ceb1"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, set&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9e9c975d7bec4a22a46b72736915ceb1">forwardize_breakpoints</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, set&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &gt;&gt; &amp;breakpoints)</td></tr>
<tr class="memdesc:a9e9c975d7bec4a22a46b72736915ceb1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flips the breakpoints onto the forward strand.  <a href="namespacevg.html#a9e9c975d7bec4a22a46b72736915ceb1">More...</a><br /></td></tr>
<tr class="separator:a9e9c975d7bec4a22a46b72736915ceb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a808481f23dac7bc58c339cf36a9a0aaf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a808481f23dac7bc58c339cf36a9a0aaf">find_packed_breakpoints</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, <a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;packed_breakpoints, bool break_ends=true, const string &amp;base_quals=&quot;&quot;, double min_baseq=0, double max_frac_n=1.)</td></tr>
<tr class="memdesc:a808481f23dac7bc58c339cf36a9a0aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Like "find_breakpoints", but store in packed structure (better for large gams and enables coverage filter)  <a href="namespacevg.html#a808481f23dac7bc58c339cf36a9a0aaf">More...</a><br /></td></tr>
<tr class="separator:a808481f23dac7bc58c339cf36a9a0aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ddba9dd6dcb384cbbea06c535e00d6d"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, set&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5ddba9dd6dcb384cbbea06c535e00d6d">filter_breakpoints_by_coverage</a> (const <a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;packed_breakpoints, size_t min_bp_coverage)</td></tr>
<tr class="separator:a5ddba9dd6dcb384cbbea06c535e00d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac200a1dbeaf55eb41bebbfd2ce4bdf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7ac200a1dbeaf55eb41bebbfd2ce4bdf">add_path_to_graph</a> (<a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html">MutablePathHandleGraph</a> *graph, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:a7ac200a1dbeaf55eb41bebbfd2ce4bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35bec7a1758e5eb88a359da78174d8d9"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a35bec7a1758e5eb88a359da78174d8d9">ensure_breakpoints</a> (<a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *graph, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, set&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &gt;&gt; &amp;breakpoints)</td></tr>
<tr class="separator:a35bec7a1758e5eb88a359da78174d8d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a42e8ba843cd728b9f84738756b30e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad6a42e8ba843cd728b9f84738756b30e">simplify_filtered_edits</a> (<a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, const map&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;node_translation, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, size_t &gt; &amp;orig_node_sizes, double min_baseq, double max_frac_n)</td></tr>
<tr class="separator:ad6a42e8ba843cd728b9f84738756b30e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa7eee80c4c79f0f863d10687714c74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3aa7eee80c4c79f0f863d10687714c74">add_nodes_and_edges</a> (<a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *graph, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, const map&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;node_translation, unordered_map&lt; pair&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, string &gt;, vector&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt;&gt; &amp;added_seqs, unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;added_nodes, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, size_t &gt; &amp;orig_node_sizes, size_t max_node_size=1024)</td></tr>
<tr class="memdesc:a3aa7eee80c4c79f0f863d10687714c74"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version doesn't require a set of dangling sides to populate <br  />
  <a href="namespacevg.html#a3aa7eee80c4c79f0f863d10687714c74">More...</a><br /></td></tr>
<tr class="separator:a3aa7eee80c4c79f0f863d10687714c74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b080c96a3681c4bd64f38eb05acd31b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4b080c96a3681c4bd64f38eb05acd31b">add_nodes_and_edges</a> (<a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *graph, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, const map&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;node_translation, unordered_map&lt; pair&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, string &gt;, vector&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt;&gt; &amp;added_seqs, unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;added_nodes, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, size_t &gt; &amp;orig_node_sizes, set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;dangling, size_t max_node_size)</td></tr>
<tr class="separator:a4b080c96a3681c4bd64f38eb05acd31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a028aa842a68b6993a37a82c7645e0633"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a028aa842a68b6993a37a82c7645e0633">make_translation</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, const map&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;node_translation, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;added_nodes, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, size_t &gt; &amp;orig_node_sizes)</td></tr>
<tr class="memdesc:a028aa842a68b6993a37a82c7645e0633"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce a graph <a class="el" href="structvg_1_1Translation.html">Translation</a> object from information about the editing process.  <a href="namespacevg.html#a028aa842a68b6993a37a82c7645e0633">More...</a><br /></td></tr>
<tr class="separator:a028aa842a68b6993a37a82c7645e0633"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2303a00d9cf0d35e243dc6de7574471"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae2303a00d9cf0d35e243dc6de7574471">add_edges_only</a> (<a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *graph, function&lt; void(function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;, bool, bool)&gt; iterate_gam, double min_mapq, size_t min_bp_coverage)</td></tr>
<tr class="separator:ae2303a00d9cf0d35e243dc6de7574471"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cc9c4d4d792e1e7f38c2c6009207706"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7cc9c4d4d792e1e7f38c2c6009207706">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="structvg_1_1BenchmarkResult.html">BenchmarkResult</a> &amp;result)</td></tr>
<tr class="separator:a7cc9c4d4d792e1e7f38c2c6009207706"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71046fb34dc43f0a3e102e1394ce8697"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a71046fb34dc43f0a3e102e1394ce8697">benchmark_control</a> ()</td></tr>
<tr class="separator:a71046fb34dc43f0a3e102e1394ce8697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac101c453ab2076d74f0324f73d174695"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1BenchmarkResult.html">BenchmarkResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac101c453ab2076d74f0324f73d174695">run_benchmark</a> (const string &amp;name, size_t iterations, const function&lt; void(void)&gt; &amp;under_test)</td></tr>
<tr class="separator:ac101c453ab2076d74f0324f73d174695"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:added44ff3bb1c0ce606563a40923c513"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1BenchmarkResult.html">BenchmarkResult</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#added44ff3bb1c0ce606563a40923c513">run_benchmark</a> (const string &amp;name, size_t iterations, const function&lt; void(void)&gt; &amp;setup, const function&lt; void(void)&gt; &amp;under_test)</td></tr>
<tr class="separator:added44ff3bb1c0ce606563a40923c513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b89433618346e971606020965b10ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a34b89433618346e971606020965b10ed">build_gcsa_lcp</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, gcsa::GCSA *&amp;gcsa, gcsa::LCPArray *&amp;lcp, int kmer_size, size_t doubling_steps, size_t size_limit, const string &amp;base_file_name)</td></tr>
<tr class="separator:a34b89433618346e971606020965b10ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa539af4f481d4e955ede26ee85c320c5"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa539af4f481d4e955ede26ee85c320c5">mergeNodeObjects</a> (void *a, void *b)</td></tr>
<tr class="separator:aa539af4f481d4e955ede26ee85c320c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc613a63afb3f23851c96494006630d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2dc613a63afb3f23851c96494006630d">getReachableBridges2</a> (stCactusEdgeEnd *edgeEnd1, stHash *bridgeEndsToBridgeNodes, stList *bridgeEnds)</td></tr>
<tr class="separator:a2dc613a63afb3f23851c96494006630d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af601021f7ec2c0b0d7404030ee7271c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af601021f7ec2c0b0d7404030ee7271c9">getReachableBridges</a> (stCactusEdgeEnd *edgeEnd1, stList *bridgeEnds)</td></tr>
<tr class="separator:af601021f7ec2c0b0d7404030ee7271c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a948a49f6716e35c8da05e84497dc01e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a948a49f6716e35c8da05e84497dc01e4">addArbitraryTelomerePair</a> (vector&lt; stCactusEdgeEnd * &gt; ends, stList *telomeres)</td></tr>
<tr class="separator:a948a49f6716e35c8da05e84497dc01e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d4e7ee3d7394e2318e874dc98dd8320"><td class="memItemLeft" align="right" valign="top">pair&lt; stCactusGraph *, stList * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3d4e7ee3d7394e2318e874dc98dd8320">handle_graph_to_cactus</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;graph, const unordered_set&lt; string &gt; &amp;hint_paths, bool single_component)</td></tr>
<tr class="separator:a3d4e7ee3d7394e2318e874dc98dd8320"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf53e86632a6d1d4b54370e6d948d08c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#adf53e86632a6d1d4b54370e6d948d08c">cactus_to_vg</a> (stCactusGraph *cactus_graph)</td></tr>
<tr class="separator:adf53e86632a6d1d4b54370e6d948d08c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4d05bc207717708d48e1da09f83eec6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa4d05bc207717708d48e1da09f83eec6">cactusify</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph)</td></tr>
<tr class="separator:aa4d05bc207717708d48e1da09f83eec6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3a49e3aea82c8e552e4cf9fd8396ad4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae3a49e3aea82c8e552e4cf9fd8396ad4">visit_contained_snarls</a> (const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph, const vector&lt; <a class="el" href="structvg_1_1Region.html">Region</a> &gt; &amp;regions, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;snarl_manager, bool include_endpoints, function&lt; void(const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, int64_t, int64_t, bool, const <a class="el" href="structvg_1_1Region.html">Region</a> *)&gt; visit_fn)</td></tr>
<tr class="separator:ae3a49e3aea82c8e552e4cf9fd8396ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab273ea17c855b1b0a32fc4e98405519e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab273ea17c855b1b0a32fc4e98405519e">delete_nodes_and_chop_paths</a> (<a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *graph, const unordered_set&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;nodes_to_delete, const unordered_set&lt; <a class="el" href="namespacevg.html#a3de8fe5f38b1730a36af4ad9c4258963">edge_t</a> &gt; &amp;edges_to_delete, int64_t min_fragment_len, unordered_map&lt; string, size_t &gt; *fragments_per_path)</td></tr>
<tr class="separator:ab273ea17c855b1b0a32fc4e98405519e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:affb16bab122c9abe8aa4282992b8fe12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#affb16bab122c9abe8aa4282992b8fe12">clip_contained_snarls</a> (<a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *graph, <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *pp_graph, const vector&lt; <a class="el" href="structvg_1_1Region.html">Region</a> &gt; &amp;regions, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;snarl_manager, bool include_endpoints, int64_t min_fragment_len, size_t max_nodes, size_t max_edges, size_t max_nodes_shallow, size_t max_edges_shallow, double max_avg_degree, double max_reflen_prop, size_t max_reflen, bool out_bed, bool verbose)</td></tr>
<tr class="separator:affb16bab122c9abe8aa4282992b8fe12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c4eb49afa34726115d01e380372669a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1c4eb49afa34726115d01e380372669a">clip_low_depth_nodes_and_edges_generic</a> (<a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *graph, function&lt; void(function&lt; void(<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, const <a class="el" href="structvg_1_1Region.html">Region</a> *)&gt;)&gt; iterate_handles, function&lt; void(function&lt; void(<a class="el" href="namespacevg.html#a3de8fe5f38b1730a36af4ad9c4258963">edge_t</a>, const <a class="el" href="structvg_1_1Region.html">Region</a> *)&gt;)&gt; iterate_edges, int64_t min_depth, const vector&lt; string &gt; &amp;ref_prefixes, int64_t min_fragment_len, bool verbose)</td></tr>
<tr class="separator:a1c4eb49afa34726115d01e380372669a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaa0f9143fd06ff6948f2b548e4dde12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aeaa0f9143fd06ff6948f2b548e4dde12">clip_low_depth_nodes_and_edges</a> (<a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *graph, int64_t min_depth, const vector&lt; string &gt; &amp;ref_prefixes, int64_t min_fragment_len, bool verbose)</td></tr>
<tr class="separator:aeaa0f9143fd06ff6948f2b548e4dde12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afca0783176bbca00f50e9c8f4b53515c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afca0783176bbca00f50e9c8f4b53515c">clip_contained_low_depth_nodes_and_edges</a> (<a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *graph, <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *pp_graph, const vector&lt; <a class="el" href="structvg_1_1Region.html">Region</a> &gt; &amp;regions, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;snarl_manager, bool include_endpoints, int64_t min_depth, int64_t min_fragment_len, bool verbose)</td></tr>
<tr class="separator:afca0783176bbca00f50e9c8f4b53515c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f58b3aa775dcde39a1d511a9d838b97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4f58b3aa775dcde39a1d511a9d838b97">clip_deletion_edges</a> (<a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *graph, int64_t max_deletion, int64_t context_steps, const vector&lt; string &gt; &amp;ref_prefixes, int64_t min_fragment_len, bool verbose)</td></tr>
<tr class="separator:a4f58b3aa775dcde39a1d511a9d838b97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba796b34b1f89333758ff6cb4271f708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aba796b34b1f89333758ff6cb4271f708">clip_stubs_generic</a> (<a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *graph, function&lt; void(function&lt; void(<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, const <a class="el" href="structvg_1_1Region.html">Region</a> *)&gt;)&gt; iterate_handles, function&lt; bool(<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>)&gt; handle_in_range, const vector&lt; string &gt; &amp;ref_prefixes, int64_t min_fragment_len, bool verbose)</td></tr>
<tr class="separator:aba796b34b1f89333758ff6cb4271f708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae596e7d9757cad372b5aaeb5e8a5146e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae596e7d9757cad372b5aaeb5e8a5146e">clip_stubs</a> (<a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *graph, const vector&lt; string &gt; &amp;ref_prefixes, int64_t min_fragment_len, bool verbose)</td></tr>
<tr class="separator:ae596e7d9757cad372b5aaeb5e8a5146e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1766ad15ac6853f074a743d19873fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afc1766ad15ac6853f074a743d19873fc">clip_contained_stubs</a> (<a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *graph, <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *pp_graph, const vector&lt; <a class="el" href="structvg_1_1Region.html">Region</a> &gt; &amp;regions, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;snarl_manager, bool include_endpoints, int64_t min_fragment_len, bool verbose)</td></tr>
<tr class="separator:afc1766ad15ac6853f074a743d19873fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65ea58e40ea30264407f9fdbce2a83d"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; gcsa::node_type, size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa65ea58e40ea30264407f9fdbce2a83d">mem_node_start_positions</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const <a class="el" href="classvg_1_1MaximalExactMatch.html">vg::MaximalExactMatch</a> &amp;mem)</td></tr>
<tr class="memdesc:aa65ea58e40ea30264407f9fdbce2a83d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the handles that a mem covers  <a href="namespacevg.html#aa65ea58e40ea30264407f9fdbce2a83d">More...</a><br /></td></tr>
<tr class="separator:aa65ea58e40ea30264407f9fdbce2a83d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9f1bd05c1d67c074797eded33151e88"><td class="memItemLeft" align="right" valign="top">bdsg::HashGraph&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae9f1bd05c1d67c074797eded33151e88">cluster_subgraph_containing</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;base, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">vg::MaximalExactMatch</a> &gt; &amp;cluster, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *aligner)</td></tr>
<tr class="memdesc:ae9f1bd05c1d67c074797eded33151e88"><td class="mdescLeft">&#160;</td><td class="mdescRight">return a containing subgraph connecting the mems  <a href="namespacevg.html#ae9f1bd05c1d67c074797eded33151e88">More...</a><br /></td></tr>
<tr class="separator:ae9f1bd05c1d67c074797eded33151e88"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac20a47954c6352afbd98da5b7d4f2d95"><td class="memItemLeft" align="right" valign="top">bdsg::HashGraph&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac20a47954c6352afbd98da5b7d4f2d95">cluster_subgraph_walk</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;base, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">vg::MaximalExactMatch</a> &gt; &amp;mems, double expansion)</td></tr>
<tr class="separator:ac20a47954c6352afbd98da5b7d4f2d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5674e45f23020370046d49c674fd691f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a5674e45f23020370046d49c674fd691f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5674e45f23020370046d49c674fd691f">convert</a> (const std::string &amp;s, T &amp;r)</td></tr>
<tr class="separator:a5674e45f23020370046d49c674fd691f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7b1ca8b13ad1732d0679723bb206f18"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad7b1ca8b13ad1732d0679723bb206f18"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad7b1ca8b13ad1732d0679723bb206f18">convert</a> (const T &amp;r)</td></tr>
<tr class="separator:ad7b1ca8b13ad1732d0679723bb206f18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d771862cc44504508267240462cb043"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8d771862cc44504508267240462cb043">stacktrace_manually</a> (ostream &amp;out, int signalNumber, void *ip, void **bp)</td></tr>
<tr class="separator:a8d771862cc44504508267240462cb043"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40556998a17c0f59c8ecc682af3a99a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a40556998a17c0f59c8ecc682af3a99a3">emit_stacktrace</a> (int signalNumber, siginfo_t *signalInfo, void *signalContext)</td></tr>
<tr class="memdesc:a40556998a17c0f59c8ecc682af3a99a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Emit a stack trace when something bad happens. Add as a signal handler with sigaction.  <a href="namespacevg.html#a40556998a17c0f59c8ecc682af3a99a3">More...</a><br /></td></tr>
<tr class="separator:a40556998a17c0f59c8ecc682af3a99a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f4461f901aba4b67353768ee25e23d7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1f4461f901aba4b67353768ee25e23d7">enable_crash_handling</a> ()</td></tr>
<tr class="memdesc:a1f4461f901aba4b67353768ee25e23d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Main should call this to turn on our stack tracing support.  <a href="namespacevg.html#a1f4461f901aba4b67353768ee25e23d7">More...</a><br /></td></tr>
<tr class="separator:a1f4461f901aba4b67353768ee25e23d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac801de9444375b2f131d3c21d125e83b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac801de9444375b2f131d3c21d125e83b">set_crash_context</a> (const std::string &amp;message)</td></tr>
<tr class="memdesc:ac801de9444375b2f131d3c21d125e83b"><td class="mdescLeft">&#160;</td><td class="mdescRight">User code should call this when it has context for a failure in its thread.  <a href="namespacevg.html#ac801de9444375b2f131d3c21d125e83b">More...</a><br /></td></tr>
<tr class="separator:ac801de9444375b2f131d3c21d125e83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64359d12f27f1035ce70e4ff1622f9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af64359d12f27f1035ce70e4ff1622f9c">clear_crash_context</a> ()</td></tr>
<tr class="memdesc:af64359d12f27f1035ce70e4ff1622f9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">User code should call this when it wants to clear context for a failure in its thread.  <a href="namespacevg.html#af64359d12f27f1035ce70e4ff1622f9c">More...</a><br /></td></tr>
<tr class="separator:af64359d12f27f1035ce70e4ff1622f9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d2cbe5fe5e1b8a33b7d707f7059b3c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1d2cbe5fe5e1b8a33b7d707f7059b3c6">with_exception_handling</a> (const std::function&lt; void(void)&gt; &amp;body)</td></tr>
<tr class="memdesc:a1d2cbe5fe5e1b8a33b7d707f7059b3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">User code should call this to get all its exceptions handled.  <a href="namespacevg.html#a1d2cbe5fe5e1b8a33b7d707f7059b3c6">More...</a><br /></td></tr>
<tr class="separator:a1d2cbe5fe5e1b8a33b7d707f7059b3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a638a54aabac7956dae6fd882468a86fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a638a54aabac7956dae6fd882468a86fe">report_exception</a> (const std::exception &amp;ex)</td></tr>
<tr class="separator:a638a54aabac7956dae6fd882468a86fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ca4eebd30887a3625fb8561c3d240d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0ca4eebd30887a3625fb8561c3d240d8">crash_unless_impl</a> (bool condition, const std::string &amp;condition_string, const std::string &amp;file, int line, const std::string &amp;function)</td></tr>
<tr class="memdesc:a0ca4eebd30887a3625fb8561c3d240d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">crash_unless calls into this function for a real implementation.  <a href="namespacevg.html#a0ca4eebd30887a3625fb8561c3d240d8">More...</a><br /></td></tr>
<tr class="separator:a0ca4eebd30887a3625fb8561c3d240d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3165438256db24864e88601839197df"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac3165438256db24864e88601839197df">entropy</a> (const string &amp;st)</td></tr>
<tr class="separator:ac3165438256db24864e88601839197df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77c1cb6069f865239d0365b55649bc8a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a77c1cb6069f865239d0365b55649bc8a">entropy</a> (const char *st, size_t len)</td></tr>
<tr class="separator:a77c1cb6069f865239d0365b55649bc8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caa19999a88016c7aedf3fefb8ca69c"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3caa19999a88016c7aedf3fefb8ca69c">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="classvg_1_1Funnel.html#a23e7fd0c49df53dd8a9e25934fe06c85">Funnel::State</a> &amp;state)</td></tr>
<tr class="separator:a3caa19999a88016c7aedf3fefb8ca69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a62239efefb85e451fcec6519644186d1"><td class="memTemplParams" colspan="2">template&lt;class Element &gt; </td></tr>
<tr class="memitem:a62239efefb85e451fcec6519644186d1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a62239efefb85e451fcec6519644186d1">in_place_subvector</a> (std::vector&lt; Element &gt; &amp;vec, size_t head, size_t tail)</td></tr>
<tr class="separator:a62239efefb85e451fcec6519644186d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b05a1318d7be5ecf3547a3eca837618"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3b05a1318d7be5ecf3547a3eca837618">set_score</a> (<a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &amp;extension, const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *aligner)</td></tr>
<tr class="separator:a3b05a1318d7be5ecf3547a3eca837618"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1defb1ef0b163389ff84745294d1d0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4b1defb1ef0b163389ff84745294d1d0">match_initial</a> (<a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &amp;match, const std::string &amp;seq, gbwtgraph::view_type target)</td></tr>
<tr class="separator:a4b1defb1ef0b163389ff84745294d1d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcb300141666ec86856482f6a59cec4c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abcb300141666ec86856482f6a59cec4c">match_forward</a> (<a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &amp;match, const std::string &amp;seq, gbwtgraph::view_type target, uint32_t mismatch_limit)</td></tr>
<tr class="separator:abcb300141666ec86856482f6a59cec4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3495eb8e73ceeece9957079280edc921"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3495eb8e73ceeece9957079280edc921">match_backward</a> (<a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &amp;match, const std::string &amp;seq, gbwtgraph::view_type target, uint32_t mismatch_limit)</td></tr>
<tr class="separator:a3495eb8e73ceeece9957079280edc921"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a536dfd4326c17ad4d072d2c9021e4b7c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a536dfd4326c17ad4d072d2c9021e4b7c">handle_full_length</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, std::vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;result, double overlap_threshold)</td></tr>
<tr class="separator:a536dfd4326c17ad4d072d2c9021e4b7c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d00fa3c72ac473353496aab96965e60"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5d00fa3c72ac473353496aab96965e60">remove_duplicates</a> (std::vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;result)</td></tr>
<tr class="separator:a5d00fa3c72ac473353496aab96965e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050aedf4b2e047e04f31a6e8b7ad55ce"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a050aedf4b2e047e04f31a6e8b7ad55ce">find_mismatches</a> (const std::string &amp;seq, const gbwtgraph::CachedGBWTGraph &amp;graph, std::vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;result)</td></tr>
<tr class="separator:a050aedf4b2e047e04f31a6e8b7ad55ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9467900ec651b93d47190413208cdf6f"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9467900ec651b93d47190413208cdf6f">interval_length</a> (std::pair&lt; size_t, size_t &gt; interval)</td></tr>
<tr class="separator:a9467900ec651b93d47190413208cdf6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d972910bf64084a1ee50ca4350c5b59"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3d972910bf64084a1ee50ca4350c5b59">get_path</a> (const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;first, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> second)</td></tr>
<tr class="separator:a3d972910bf64084a1ee50ca4350c5b59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5fc35eee866d216357a5818cd1fb927"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa5fc35eee866d216357a5818cd1fb927">get_path</a> (<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> first, const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;second)</td></tr>
<tr class="separator:aa5fc35eee866d216357a5818cd1fb927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a162ed4c8f358ca4c33ab05a27f8349cb"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a162ed4c8f358ca4c33ab05a27f8349cb">get_path</a> (const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;first, gbwt::node_type second)</td></tr>
<tr class="separator:a162ed4c8f358ca4c33ab05a27f8349cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66796444cb3b92c35ebeddbb7a9bc6bf"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a66796444cb3b92c35ebeddbb7a9bc6bf">get_path</a> (gbwt::node_type reverse_first, const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;second)</td></tr>
<tr class="separator:a66796444cb3b92c35ebeddbb7a9bc6bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77211f457b4e1f61915d771faf06cda0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a77211f457b4e1f61915d771faf06cda0">trim_mismatches</a> (<a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &amp;extension, const gbwtgraph::CachedGBWTGraph &amp;graph, const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> &amp;aligner)</td></tr>
<tr class="separator:a77211f457b4e1f61915d771faf06cda0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fbb5dfd532a055d9e8251d2dcab3e58"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1fbb5dfd532a055d9e8251d2dcab3e58">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="structvg_1_1WFAAlignment.html#a1ce899c26978ebac4bc7a31623809eeb">WFAAlignment::Edit</a> &amp;edit)</td></tr>
<tr class="memdesc:a1fbb5dfd532a055d9e8251d2dcab3e58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow printing an <a class="el" href="structvg_1_1Edit.html">Edit</a>.  <a href="namespacevg.html#a1fbb5dfd532a055d9e8251d2dcab3e58">More...</a><br /></td></tr>
<tr class="separator:a1fbb5dfd532a055d9e8251d2dcab3e58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bcecf9fe02b7f50dd5e72e40dcd98e1"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8bcecf9fe02b7f50dd5e72e40dcd98e1">parseGenotypes</a> (const std::string &amp;vcf_line, size_t num_samples)</td></tr>
<tr class="separator:a8bcecf9fe02b7f50dd5e72e40dcd98e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d1c00a44e9aeb5c4294edd60fcbaa61"><td class="memItemLeft" align="right" valign="top">gbwt::vector_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0d1c00a44e9aeb5c4294edd60fcbaa61">extract_as_gbwt_path</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;graph, const std::string &amp;path_name)</td></tr>
<tr class="memdesc:a0d1c00a44e9aeb5c4294edd60fcbaa61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract a path as a GBWT path. If the path does not exist, it is treated as empty.  <a href="namespacevg.html#a0d1c00a44e9aeb5c4294edd60fcbaa61">More...</a><br /></td></tr>
<tr class="separator:a0d1c00a44e9aeb5c4294edd60fcbaa61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72aa312e964fab8a03b93ec897f355ec"><td class="memItemLeft" align="right" valign="top">gbwt::vector_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a72aa312e964fab8a03b93ec897f355ec">path_predecessors</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;graph, const std::string &amp;path_name)</td></tr>
<tr class="separator:a72aa312e964fab8a03b93ec897f355ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada6300e45d21f1171c5ff2b71f4d173b"><td class="memItemLeft" align="right" valign="top">gbwt::size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ada6300e45d21f1171c5ff2b71f4d173b">gbwt_node_width</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:ada6300e45d21f1171c5ff2b71f4d173b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Determine the node width in bits for the GBWT nodes based on the given graph.  <a href="namespacevg.html#ada6300e45d21f1171c5ff2b71f4d173b">More...</a><br /></td></tr>
<tr class="separator:ada6300e45d21f1171c5ff2b71f4d173b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac2fee40d55dfda86b1e0cc2f2500b280"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac2fee40d55dfda86b1e0cc2f2500b280">finish_gbwt_constuction</a> (gbwt::GBWTBuilder &amp;builder, const std::vector&lt; std::string &gt; &amp;sample_names, const std::vector&lt; std::string &gt; &amp;contig_names, size_t haplotype_count, bool <a class="el" href="gbwt__main_8cpp.html#af705c69cda26007b3ea9bb76849e21b1">print_metadata</a>, const std::string &amp;header=&quot;GBWT&quot;)</td></tr>
<tr class="memdesc:ac2fee40d55dfda86b1e0cc2f2500b280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Finish GBWT construction and optionally print the metadata.  <a href="namespacevg.html#ac2fee40d55dfda86b1e0cc2f2500b280">More...</a><br /></td></tr>
<tr class="separator:ac2fee40d55dfda86b1e0cc2f2500b280"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af077c13bde9c0e8f5ee88d7000a0803e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af077c13bde9c0e8f5ee88d7000a0803e">load_gbwt</a> (gbwt::GBWT &amp;index, const std::string &amp;filename, bool show_progress=false)</td></tr>
<tr class="memdesc:af077c13bde9c0e8f5ee88d7000a0803e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a compressed GBWT from the file.  <a href="namespacevg.html#af077c13bde9c0e8f5ee88d7000a0803e">More...</a><br /></td></tr>
<tr class="separator:af077c13bde9c0e8f5ee88d7000a0803e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5197b188ae631a5adcd9689a18138042"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5197b188ae631a5adcd9689a18138042">load_gbwt</a> (gbwt::DynamicGBWT &amp;index, const std::string &amp;filename, bool show_progress=false)</td></tr>
<tr class="memdesc:a5197b188ae631a5adcd9689a18138042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a dynamic GBWT from the file.  <a href="namespacevg.html#a5197b188ae631a5adcd9689a18138042">More...</a><br /></td></tr>
<tr class="separator:a5197b188ae631a5adcd9689a18138042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ab05fd111751cbf31c3a6a5189a76ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4ab05fd111751cbf31c3a6a5189a76ff">load_r_index</a> (gbwt::FastLocate &amp;index, const std::string &amp;filename, bool show_progress=false)</td></tr>
<tr class="memdesc:a4ab05fd111751cbf31c3a6a5189a76ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load an r-index from the file.  <a href="namespacevg.html#a4ab05fd111751cbf31c3a6a5189a76ff">More...</a><br /></td></tr>
<tr class="separator:a4ab05fd111751cbf31c3a6a5189a76ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a790122d8b3f28068aaf09f1eb5b966a9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a790122d8b3f28068aaf09f1eb5b966a9">save_gbwt</a> (const gbwt::GBWT &amp;index, const std::string &amp;filename, bool show_progress=false)</td></tr>
<tr class="memdesc:a790122d8b3f28068aaf09f1eb5b966a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a compressed GBWT to the file.  <a href="namespacevg.html#a790122d8b3f28068aaf09f1eb5b966a9">More...</a><br /></td></tr>
<tr class="separator:a790122d8b3f28068aaf09f1eb5b966a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8385d575383b7bae35726e90851a2795"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8385d575383b7bae35726e90851a2795">save_gbwt</a> (const gbwt::DynamicGBWT &amp;index, const std::string &amp;filename, bool show_progress=false)</td></tr>
<tr class="memdesc:a8385d575383b7bae35726e90851a2795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a dynamic GBWT to the file.  <a href="namespacevg.html#a8385d575383b7bae35726e90851a2795">More...</a><br /></td></tr>
<tr class="separator:a8385d575383b7bae35726e90851a2795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d4b5eef7efd656daeb423af1f6a3c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a50d4b5eef7efd656daeb423af1f6a3c6">save_r_index</a> (const gbwt::FastLocate &amp;index, const std::string &amp;filename, bool show_progress=false)</td></tr>
<tr class="memdesc:a50d4b5eef7efd656daeb423af1f6a3c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save an r-index to the file.  <a href="namespacevg.html#a50d4b5eef7efd656daeb423af1f6a3c6">More...</a><br /></td></tr>
<tr class="separator:a50d4b5eef7efd656daeb423af1f6a3c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a802baeeacfe4ee75781afabac562588b"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::vector&lt; gbwt::size_type &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a802baeeacfe4ee75781afabac562588b">partition_gbwt_sequences</a> (const gbwt::GBWT &amp;gbwt_index, const std::unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, size_t &gt; &amp;node_to_job, size_t num_jobs)</td></tr>
<tr class="separator:a802baeeacfe4ee75781afabac562588b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4970f98c4a004a1c07c1beaec524ae"><td class="memItemLeft" align="right" valign="top">gbwt::GBWT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aec4970f98c4a004a1c07c1beaec524ae">rebuild_gbwt_job</a> (const gbwt::GBWT &amp;gbwt_index, const <a class="el" href="structvg_1_1RebuildJob.html">RebuildJob</a> &amp;job, const std::vector&lt; gbwt::size_type &gt; &amp;sequences, const <a class="el" href="structvg_1_1RebuildParameters.html">RebuildParameters</a> &amp;parameters)</td></tr>
<tr class="separator:aec4970f98c4a004a1c07c1beaec524ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2237df8adff809619083730f10d0e2e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab2237df8adff809619083730f10d0e2e">copy_metadata</a> (const gbwt::GBWT &amp;source, gbwt::GBWT &amp;target, const std::vector&lt; std::vector&lt; gbwt::size_type &gt;&gt; &amp;jobs, const std::vector&lt; size_t &gt; &amp;job_order)</td></tr>
<tr class="separator:ab2237df8adff809619083730f10d0e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95d54bf0a30125f9ded043bb099cb25f"><td class="memItemLeft" align="right" valign="top">gbwt::GBWT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a95d54bf0a30125f9ded043bb099cb25f">rebuild_gbwt</a> (const gbwt::GBWT &amp;gbwt_index, const std::vector&lt; <a class="el" href="structvg_1_1RebuildJob.html">RebuildJob</a> &gt; &amp;jobs, const std::unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, size_t &gt; &amp;node_to_job, const <a class="el" href="structvg_1_1RebuildParameters.html">RebuildParameters</a> &amp;parameters)</td></tr>
<tr class="separator:a95d54bf0a30125f9ded043bb099cb25f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5b1e6daa5da7101533d444d3d8ff41"><td class="memItemLeft" align="right" valign="top">gbwt::GBWT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ade5b1e6daa5da7101533d444d3d8ff41">rebuild_gbwt</a> (const gbwt::GBWT &amp;gbwt_index, const std::vector&lt; <a class="el" href="structvg_1_1RebuildJob.html#afdbb259fb3fc369a7824f6420b2043c0">RebuildJob::mapping_type</a> &gt; &amp;mappings)</td></tr>
<tr class="memdesc:ade5b1e6daa5da7101533d444d3d8ff41"><td class="mdescLeft">&#160;</td><td class="mdescRight">As the general <code>rebuild_gbwt</code>, but always using a single job with default parameters.  <a href="namespacevg.html#ade5b1e6daa5da7101533d444d3d8ff41">More...</a><br /></td></tr>
<tr class="separator:ade5b1e6daa5da7101533d444d3d8ff41"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d4b0a9961f932a8caccb1d0723fd171"><td class="memItemLeft" align="right" valign="top">std::vector&lt; gbwt::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2d4b0a9961f932a8caccb1d0723fd171">threads_for_sample</a> (const gbwt::GBWT &amp;gbwt_index, const std::string &amp;sample_name)</td></tr>
<tr class="memdesc:a2d4b0a9961f932a8caccb1d0723fd171"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of thread ids / gbwt path ids for the given sample.  <a href="namespacevg.html#a2d4b0a9961f932a8caccb1d0723fd171">More...</a><br /></td></tr>
<tr class="separator:a2d4b0a9961f932a8caccb1d0723fd171"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5813ee7997572d371f9ff7b45bbe4843"><td class="memItemLeft" align="right" valign="top">std::vector&lt; gbwt::size_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5813ee7997572d371f9ff7b45bbe4843">threads_for_contig</a> (const gbwt::GBWT &amp;gbwt_index, const std::string &amp;contig_name)</td></tr>
<tr class="memdesc:a5813ee7997572d371f9ff7b45bbe4843"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the list of thread ids / gbwt path ids for the given contig.  <a href="namespacevg.html#a5813ee7997572d371f9ff7b45bbe4843">More...</a><br /></td></tr>
<tr class="separator:a5813ee7997572d371f9ff7b45bbe4843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bf4a7dd2a81bb5b873127156a2dfb33"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9bf4a7dd2a81bb5b873127156a2dfb33">insert_gbwt_path</a> (<a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html">MutablePathHandleGraph</a> &amp;graph, const gbwt::GBWT &amp;gbwt_index, gbwt::size_type <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, std::string path_name)</td></tr>
<tr class="separator:a9bf4a7dd2a81bb5b873127156a2dfb33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a768828fcd9f2ecf7661e7d873f23bc58"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a768828fcd9f2ecf7661e7d873f23bc58">extract_gbwt_path</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const gbwt::GBWT &amp;gbwt_index, gbwt::size_type <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="separator:a768828fcd9f2ecf7661e7d873f23bc58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bb552d73f5ed9ca37d1227acacee4a"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a04bb552d73f5ed9ca37d1227acacee4a">compose_short_path_name</a> (const gbwt::GBWT &amp;gbwt_index, gbwt::size_type <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="separator:a04bb552d73f5ed9ca37d1227acacee4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a571047c58b73b78d02a767c3ab6ec222"><td class="memItemLeft" align="right" valign="top">gbwt::GBWT&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a571047c58b73b78d02a767c3ab6ec222">get_gbwt</a> (const std::vector&lt; gbwt::vector_type &gt; &amp;paths)</td></tr>
<tr class="memdesc:a571047c58b73b78d02a767c3ab6ec222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transform the paths into a GBWT index. Primarily for testing.  <a href="namespacevg.html#a571047c58b73b78d02a767c3ab6ec222">More...</a><br /></td></tr>
<tr class="separator:a571047c58b73b78d02a767c3ab6ec222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11a634196a7420547646dc30d2c57b18"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; string, vector&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a11a634196a7420547646dc30d2c57b18">load_translation_map</a> (ifstream &amp;input_stream)</td></tr>
<tr class="separator:a11a634196a7420547646dc30d2c57b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cde90cbb8b1fc46d2b830bf87dba997"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, pair&lt; string, size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3cde90cbb8b1fc46d2b830bf87dba997">load_translation_back_map</a> (<a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, ifstream &amp;input_stream)</td></tr>
<tr class="separator:a3cde90cbb8b1fc46d2b830bf87dba997"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28c93b1c4a71fadf62fc2582cc8f0ed2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a28c93b1c4a71fadf62fc2582cc8f0ed2">gbwt_to_handle</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, gbwt::node_type node)</td></tr>
<tr class="memdesc:a28c93b1c4a71fadf62fc2582cc8f0ed2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert gbwt::node_type to handle_t.  <a href="namespacevg.html#a28c93b1c4a71fadf62fc2582cc8f0ed2">More...</a><br /></td></tr>
<tr class="separator:a28c93b1c4a71fadf62fc2582cc8f0ed2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7b5f995eb3e1e824cc4e7db99c81042"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae7b5f995eb3e1e824cc4e7db99c81042">gbwt_to_pos</a> (gbwt::node_type node, size_t <a class="el" href="namespacevg.html#ad48a54a3ddd5e6ffd8e3e6296fb9c037">offset</a>)</td></tr>
<tr class="memdesc:ae7b5f995eb3e1e824cc4e7db99c81042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert gbwt::node_type and an offset as size_t to pos_t.  <a href="namespacevg.html#ae7b5f995eb3e1e824cc4e7db99c81042">More...</a><br /></td></tr>
<tr class="separator:ae7b5f995eb3e1e824cc4e7db99c81042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa5cc80bff735a8803aa9f564c29994"><td class="memItemLeft" align="right" valign="top">gbwt::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1fa5cc80bff735a8803aa9f564c29994">handle_to_gbwt</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> handle)</td></tr>
<tr class="memdesc:a1fa5cc80bff735a8803aa9f564c29994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert handle_t to gbwt::node_type.  <a href="namespacevg.html#a1fa5cc80bff735a8803aa9f564c29994">More...</a><br /></td></tr>
<tr class="separator:a1fa5cc80bff735a8803aa9f564c29994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1296fd4e352a120122d4be0a0007819"><td class="memItemLeft" align="right" valign="top">gbwt::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae1296fd4e352a120122d4be0a0007819">pos_to_gbwt</a> (<a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> pos)</td></tr>
<tr class="memdesc:ae1296fd4e352a120122d4be0a0007819"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract gbwt::node_type from pos_t.  <a href="namespacevg.html#ae1296fd4e352a120122d4be0a0007819">More...</a><br /></td></tr>
<tr class="separator:ae1296fd4e352a120122d4be0a0007819"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace1a7180fda8bb98abba24fb19183e9d"><td class="memItemLeft" align="right" valign="top">gbwt::node_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ace1a7180fda8bb98abba24fb19183e9d">mapping_to_gbwt</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mapping)</td></tr>
<tr class="memdesc:ace1a7180fda8bb98abba24fb19183e9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <a class="el" href="structvg_1_1Mapping.html">Mapping</a> to gbwt::node_type.  <a href="namespacevg.html#ace1a7180fda8bb98abba24fb19183e9d">More...</a><br /></td></tr>
<tr class="separator:ace1a7180fda8bb98abba24fb19183e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a529e3aef69e8c01934184726b7937c37"><td class="memItemLeft" align="right" valign="top">gbwt::vector_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a529e3aef69e8c01934184726b7937c37">path_to_gbwt</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="memdesc:a529e3aef69e8c01934184726b7937c37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert <a class="el" href="structvg_1_1Path.html">Path</a> to a GBWT path.  <a href="namespacevg.html#a529e3aef69e8c01934184726b7937c37">More...</a><br /></td></tr>
<tr class="separator:a529e3aef69e8c01934184726b7937c37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab35317ee2bc53165662dd776516f341d"><td class="memItemLeft" align="right" valign="top">gbwtgraph::GFAParsingParameters&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab35317ee2bc53165662dd776516f341d">get_best_gbwtgraph_gfa_parsing_parameters</a> ()</td></tr>
<tr class="separator:ab35317ee2bc53165662dd776516f341d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83417b41cb483c6cad692b718c2bc02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af83417b41cb483c6cad692b718c2bc02">load_gbwtgraph</a> (gbwtgraph::GBWTGraph &amp;graph, const std::string &amp;filename, bool show_progress)</td></tr>
<tr class="separator:af83417b41cb483c6cad692b718c2bc02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f775d6f61207052e3c157e5ad6cfcf0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7f775d6f61207052e3c157e5ad6cfcf0">load_gbz</a> (gbwtgraph::GBZ &amp;gbz, const std::string &amp;filename, bool show_progress=false)</td></tr>
<tr class="memdesc:a7f775d6f61207052e3c157e5ad6cfcf0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load GBZ from the file.  <a href="namespacevg.html#a7f775d6f61207052e3c157e5ad6cfcf0">More...</a><br /></td></tr>
<tr class="separator:a7f775d6f61207052e3c157e5ad6cfcf0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a142177e721683d3e4d428f6cb8f22981"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a142177e721683d3e4d428f6cb8f22981">load_gbz</a> (gbwt::GBWT &amp;index, gbwtgraph::GBWTGraph &amp;graph, const std::string &amp;filename, bool show_progress=false)</td></tr>
<tr class="memdesc:a142177e721683d3e4d428f6cb8f22981"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load GBWT and GBWTGraph from the GBZ file.  <a href="namespacevg.html#a142177e721683d3e4d428f6cb8f22981">More...</a><br /></td></tr>
<tr class="separator:a142177e721683d3e4d428f6cb8f22981"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd12c27c337a889da2db07d54d2e1d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1bd12c27c337a889da2db07d54d2e1d6">load_gbz</a> (gbwtgraph::GBZ &amp;gbz, const std::string &amp;gbwt_name, const std::string &amp;graph_name, bool show_progress=false)</td></tr>
<tr class="memdesc:a1bd12c27c337a889da2db07d54d2e1d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load GBZ from separate GBWT / GBWTGraph files.  <a href="namespacevg.html#a1bd12c27c337a889da2db07d54d2e1d6">More...</a><br /></td></tr>
<tr class="separator:a1bd12c27c337a889da2db07d54d2e1d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a649b144d7ce85a247af73055577c4d91"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a649b144d7ce85a247af73055577c4d91">load_minimizer</a> (gbwtgraph::DefaultMinimizerIndex &amp;index, const std::string &amp;filename, bool show_progress=false)</td></tr>
<tr class="memdesc:a649b144d7ce85a247af73055577c4d91"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a minimizer index from the file.  <a href="namespacevg.html#a649b144d7ce85a247af73055577c4d91">More...</a><br /></td></tr>
<tr class="separator:a649b144d7ce85a247af73055577c4d91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea7640260b1c70795335439f3d6c2eac"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aea7640260b1c70795335439f3d6c2eac">save_gbwtgraph</a> (const gbwtgraph::GBWTGraph &amp;graph, const std::string &amp;filename, bool show_progress=false)</td></tr>
<tr class="memdesc:aea7640260b1c70795335439f3d6c2eac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save GBWTGraph to the file.  <a href="namespacevg.html#aea7640260b1c70795335439f3d6c2eac">More...</a><br /></td></tr>
<tr class="separator:aea7640260b1c70795335439f3d6c2eac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a017e7cda40a98b4b044507ab78a34da9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a017e7cda40a98b4b044507ab78a34da9">save_gbz</a> (const gbwtgraph::GBZ &amp;gbz, const std::string &amp;filename, bool show_progress=false)</td></tr>
<tr class="memdesc:a017e7cda40a98b4b044507ab78a34da9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save GBZ to the file.  <a href="namespacevg.html#a017e7cda40a98b4b044507ab78a34da9">More...</a><br /></td></tr>
<tr class="separator:a017e7cda40a98b4b044507ab78a34da9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6beaace0e6d90b654dc9c382afb39ce0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6beaace0e6d90b654dc9c382afb39ce0">save_gbz</a> (const gbwt::GBWT &amp;index, gbwtgraph::GBWTGraph &amp;graph, const std::string &amp;filename, bool show_progress=false)</td></tr>
<tr class="memdesc:a6beaace0e6d90b654dc9c382afb39ce0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save GBWT and GBWTGraph to the GBZ file.  <a href="namespacevg.html#a6beaace0e6d90b654dc9c382afb39ce0">More...</a><br /></td></tr>
<tr class="separator:a6beaace0e6d90b654dc9c382afb39ce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7669e457f62e6f197f3120086a091e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af7669e457f62e6f197f3120086a091e2">save_gbz</a> (const gbwtgraph::GBZ &amp;gbz, const std::string &amp;gbwt_name, const std::string &amp;graph_name, bool show_progress=false)</td></tr>
<tr class="memdesc:af7669e457f62e6f197f3120086a091e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save GBZ to separate GBWT / GBWTGraph files.  <a href="namespacevg.html#af7669e457f62e6f197f3120086a091e2">More...</a><br /></td></tr>
<tr class="separator:af7669e457f62e6f197f3120086a091e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7885143ca20185816afadc669813f12"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af7885143ca20185816afadc669813f12">save_minimizer</a> (const gbwtgraph::DefaultMinimizerIndex &amp;index, const std::string &amp;filename, bool show_progress=false)</td></tr>
<tr class="memdesc:af7885143ca20185816afadc669813f12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save a minimizer index to the file.  <a href="namespacevg.html#af7885143ca20185816afadc669813f12">More...</a><br /></td></tr>
<tr class="separator:af7885143ca20185816afadc669813f12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a709e93bb1c0dbdcdbc928960e42688ec"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; string, vector&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a709e93bb1c0dbdcdbc928960e42688ec">load_translation_map</a> (const gbwtgraph::GBWTGraph &amp;graph)</td></tr>
<tr class="memdesc:a709e93bb1c0dbdcdbc928960e42688ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a mapping of the original segment ids to a list of chopped node ids.  <a href="namespacevg.html#a709e93bb1c0dbdcdbc928960e42688ec">More...</a><br /></td></tr>
<tr class="separator:a709e93bb1c0dbdcdbc928960e42688ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b717077a15106d70c8ce4cc035ca890"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, pair&lt; string, size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0b717077a15106d70c8ce4cc035ca890">load_translation_back_map</a> (const gbwtgraph::GBWTGraph &amp;graph)</td></tr>
<tr class="memdesc:a0b717077a15106d70c8ce4cc035ca890"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a backwards mapping of chopped node to original segment position (id,offset pair)  <a href="namespacevg.html#a0b717077a15106d70c8ce4cc035ca890">More...</a><br /></td></tr>
<tr class="separator:a0b717077a15106d70c8ce4cc035ca890"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc47f14b546282cf0818ba47826a9110"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#adc47f14b546282cf0818ba47826a9110">to_string_gbwtgraph</a> (<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> handle)</td></tr>
<tr class="memdesc:adc47f14b546282cf0818ba47826a9110"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of a GBWTGraph handle.  <a href="namespacevg.html#adc47f14b546282cf0818ba47826a9110">More...</a><br /></td></tr>
<tr class="separator:adc47f14b546282cf0818ba47826a9110"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93282dbd7c3a7daaf92b75f77c28dc29"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a93282dbd7c3a7daaf92b75f77c28dc29">to_string_gbwtgraph</a> (gbwt::node_type node)</td></tr>
<tr class="memdesc:a93282dbd7c3a7daaf92b75f77c28dc29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string representation of a GBWTGraph node.  <a href="namespacevg.html#a93282dbd7c3a7daaf92b75f77c28dc29">More...</a><br /></td></tr>
<tr class="separator:a93282dbd7c3a7daaf92b75f77c28dc29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8811548042613f9e65545d1ed377643e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8811548042613f9e65545d1ed377643e">empty_gbwtgraph_handle</a> ()</td></tr>
<tr class="memdesc:a8811548042613f9e65545d1ed377643e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an empty GBWTGraph handle corresponding to the GBWT endmarker.  <a href="namespacevg.html#a8811548042613f9e65545d1ed377643e">More...</a><br /></td></tr>
<tr class="separator:a8811548042613f9e65545d1ed377643e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb0e46d1a71de77dddab10d147ac0538"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afb0e46d1a71de77dddab10d147ac0538">load_gcsa</a> (gcsa::GCSA &amp;index, const std::string &amp;filename, bool show_progress=false)</td></tr>
<tr class="memdesc:afb0e46d1a71de77dddab10d147ac0538"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load GCSA from the file.  <a href="namespacevg.html#afb0e46d1a71de77dddab10d147ac0538">More...</a><br /></td></tr>
<tr class="separator:afb0e46d1a71de77dddab10d147ac0538"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0679feb8bafbf4be20c4bffa633223c6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0679feb8bafbf4be20c4bffa633223c6">load_lcp</a> (gcsa::LCPArray &amp;lcp, const std::string &amp;filename, bool show_progress=false)</td></tr>
<tr class="memdesc:a0679feb8bafbf4be20c4bffa633223c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load LCP array from the file.  <a href="namespacevg.html#a0679feb8bafbf4be20c4bffa633223c6">More...</a><br /></td></tr>
<tr class="separator:a0679feb8bafbf4be20c4bffa633223c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2840fc8dbdb12c000769a3baa39b808"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa2840fc8dbdb12c000769a3baa39b808">save_gcsa</a> (const gcsa::GCSA &amp;index, const std::string &amp;filename, bool show_progress=false)</td></tr>
<tr class="memdesc:aa2840fc8dbdb12c000769a3baa39b808"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save GCSA to the file.  <a href="namespacevg.html#aa2840fc8dbdb12c000769a3baa39b808">More...</a><br /></td></tr>
<tr class="separator:aa2840fc8dbdb12c000769a3baa39b808"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a604f783fb59cb6c3e7fcc783a8286822"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a604f783fb59cb6c3e7fcc783a8286822">save_lcp</a> (const gcsa::LCPArray &amp;lcp, const std::string &amp;filename, bool show_progress=false)</td></tr>
<tr class="memdesc:a604f783fb59cb6c3e7fcc783a8286822"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save LCP array to the file.  <a href="namespacevg.html#a604f783fb59cb6c3e7fcc783a8286822">More...</a><br /></td></tr>
<tr class="separator:a604f783fb59cb6c3e7fcc783a8286822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a871d5cdd29e1806636314021d0b6d451"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a871d5cdd29e1806636314021d0b6d451">get_traversal_of_snarl</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *snarl, const <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;manager, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:a871d5cdd29e1806636314021d0b6d451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94385b32246fc81a0a44ea1b47d994ee"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a94385b32246fc81a0a44ea1b47d994ee">traversal_to_string</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph, const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;path)</td></tr>
<tr class="separator:a94385b32246fc81a0a44ea1b47d994ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c0ae5cc687e77bb7cee28e975a005b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1c0ae5cc687e77bb7cee28e975a005b3">make_support</a> (double forward, double <a class="el" href="namespacevg.html#a91adfc6327b5709dc73fcc7edbe5da57">reverse</a>, double quality)</td></tr>
<tr class="separator:a1c0ae5cc687e77bb7cee28e975a005b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a064dd8829b2100c6a38780311073f3"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0a064dd8829b2100c6a38780311073f3">total</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;support)</td></tr>
<tr class="separator:a0a064dd8829b2100c6a38780311073f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c2ae4c37201ebbc6f6d4faaf27fe4de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3c2ae4c37201ebbc6f6d4faaf27fe4de">support_min</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;a, const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;b)</td></tr>
<tr class="separator:a3c2ae4c37201ebbc6f6d4faaf27fe4de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3787b0a7fc02bbfe45dc5eb082d5779"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac3787b0a7fc02bbfe45dc5eb082d5779">support_max</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;a, const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;b)</td></tr>
<tr class="separator:ac3787b0a7fc02bbfe45dc5eb082d5779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8a651561299e3236ec62af61d509112"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad8a651561299e3236ec62af61d509112">flip</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;to_flip)</td></tr>
<tr class="separator:ad8a651561299e3236ec62af61d509112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27dd5c8f7c6d984a396665cbab5eba01"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a27dd5c8f7c6d984a396665cbab5eba01">operator+</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;one, const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;other)</td></tr>
<tr class="separator:a27dd5c8f7c6d984a396665cbab5eba01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f550213560bfa3c3ad8446478be24d8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4f550213560bfa3c3ad8446478be24d8">operator+=</a> (<a class="el" href="structvg_1_1Support.html">Support</a> &amp;one, const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;other)</td></tr>
<tr class="separator:a4f550213560bfa3c3ad8446478be24d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab554a977204c1f756bd0e2738a797447"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab554a977204c1f756bd0e2738a797447">operator&lt;</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;a, const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;b)</td></tr>
<tr class="separator:ab554a977204c1f756bd0e2738a797447"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a955d56fb4c95213de77c1fcce44c77b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a955d56fb4c95213de77c1fcce44c77b8">operator&gt;</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;a, const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;b)</td></tr>
<tr class="separator:a955d56fb4c95213de77c1fcce44c77b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a141fbf9c40f389909c5c46132ab6c615"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a141fbf9c40f389909c5c46132ab6c615">operator&lt;&lt;</a> (ostream &amp;stream, const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;support)</td></tr>
<tr class="separator:a141fbf9c40f389909c5c46132ab6c615"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a420f2fd8ef6d04f1a34a08af2a3dee0e"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a420f2fd8ef6d04f1a34a08af2a3dee0e">to_vcf_genotype</a> (const <a class="el" href="structvg_1_1Genotype.html">Genotype</a> &amp;gt)</td></tr>
<tr class="separator:a420f2fd8ef6d04f1a34a08af2a3dee0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84dfc966c7511b05c234d215e3b6aec7"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a84dfc966c7511b05c234d215e3b6aec7"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a84dfc966c7511b05c234d215e3b6aec7">operator*</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;support, const Scalar &amp;scale)</td></tr>
<tr class="separator:a84dfc966c7511b05c234d215e3b6aec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe7831ba6fe294e8be36fa0359a63848"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:abe7831ba6fe294e8be36fa0359a63848"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#abe7831ba6fe294e8be36fa0359a63848">operator*=</a> (<a class="el" href="structvg_1_1Support.html">Support</a> &amp;support, const Scalar &amp;scale)</td></tr>
<tr class="separator:abe7831ba6fe294e8be36fa0359a63848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10844a7c14d7ff54051bad20c75d012e"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a10844a7c14d7ff54051bad20c75d012e"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a10844a7c14d7ff54051bad20c75d012e">operator*</a> (const Scalar &amp;scale, const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;support)</td></tr>
<tr class="separator:a10844a7c14d7ff54051bad20c75d012e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a9eefddbec41755309a378fb150071c"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a5a9eefddbec41755309a378fb150071c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5a9eefddbec41755309a378fb150071c">operator/</a> (const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;support, const Scalar &amp;scale)</td></tr>
<tr class="separator:a5a9eefddbec41755309a378fb150071c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1807752a0b6b83fd5952d36cc64b758d"><td class="memTemplParams" colspan="2">template&lt;typename Scalar &gt; </td></tr>
<tr class="memitem:a1807752a0b6b83fd5952d36cc64b758d"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1807752a0b6b83fd5952d36cc64b758d">operator/=</a> (<a class="el" href="structvg_1_1Support.html">Support</a> &amp;support, const Scalar &amp;scale)</td></tr>
<tr class="separator:a1807752a0b6b83fd5952d36cc64b758d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b46a0183527dc1713f3ab30ef85b185"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3b46a0183527dc1713f3ab30ef85b185">allele_to_string</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;allele)</td></tr>
<tr class="separator:a3b46a0183527dc1713f3ab30ef85b185"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a234b2ca417edb50a3c738991fcfc269a"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a234b2ca417edb50a3c738991fcfc269a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a234b2ca417edb50a3c738991fcfc269a">set_intersection</a> (const unordered_set&lt; T &gt; &amp;set_1, const unordered_set&lt; T &gt; &amp;set_2, unordered_set&lt; T &gt; *out_intersection)</td></tr>
<tr class="separator:a234b2ca417edb50a3c738991fcfc269a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8c4a075bb9301c8050d89ed8e6a33b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad8c4a075bb9301c8050d89ed8e6a33b9">graph_to_gfa</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> *graph, ostream &amp;out, const set&lt; string &gt; &amp;rgfa_paths, bool rgfa_pline, bool use_w_lines)</td></tr>
<tr class="separator:ad8c4a075bb9301c8050d89ed8e6a33b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984c1d2199f90f58677096772b870390"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a984c1d2199f90f58677096772b870390">sort_by_id_dedup_and_clean</a> (<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a984c1d2199f90f58677096772b870390"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove duplicates and sort by id  <a href="namespacevg.html#a984c1d2199f90f58677096772b870390">More...</a><br /></td></tr>
<tr class="separator:a984c1d2199f90f58677096772b870390"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecd2e49750e94ed6f9de917dd9c72ac2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aecd2e49750e94ed6f9de917dd9c72ac2">remove_duplicates</a> (<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:aecd2e49750e94ed6f9de917dd9c72ac2"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove duplicate nodes and edges  <a href="namespacevg.html#aecd2e49750e94ed6f9de917dd9c72ac2">More...</a><br /></td></tr>
<tr class="separator:aecd2e49750e94ed6f9de917dd9c72ac2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add4d3a3d1917566a8df138c80b38e548"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#add4d3a3d1917566a8df138c80b38e548">remove_duplicate_edges</a> (<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:add4d3a3d1917566a8df138c80b38e548"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove duplicate edges  <a href="namespacevg.html#add4d3a3d1917566a8df138c80b38e548">More...</a><br /></td></tr>
<tr class="separator:add4d3a3d1917566a8df138c80b38e548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dbe8468f2f2bcf8ceb859e6a0f8b4b1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6dbe8468f2f2bcf8ceb859e6a0f8b4b1">remove_duplicate_nodes</a> (<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a6dbe8468f2f2bcf8ceb859e6a0f8b4b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove duplicate nodes  <a href="namespacevg.html#a6dbe8468f2f2bcf8ceb859e6a0f8b4b1">More...</a><br /></td></tr>
<tr class="separator:a6dbe8468f2f2bcf8ceb859e6a0f8b4b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b38f4f0d7e63b1f7f20d2dc985f88c4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0b38f4f0d7e63b1f7f20d2dc985f88c4">remove_orphan_edges</a> (<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a0b38f4f0d7e63b1f7f20d2dc985f88c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">remove edges that link to a node that is not in the graph  <a href="namespacevg.html#a0b38f4f0d7e63b1f7f20d2dc985f88c4">More...</a><br /></td></tr>
<tr class="separator:a0b38f4f0d7e63b1f7f20d2dc985f88c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af25c227066a422379ff06d81b5990865"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af25c227066a422379ff06d81b5990865">sort_by_id</a> (<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:af25c227066a422379ff06d81b5990865"><td class="mdescLeft">&#160;</td><td class="mdescRight">order the nodes and edges in the graph by id  <a href="namespacevg.html#af25c227066a422379ff06d81b5990865">More...</a><br /></td></tr>
<tr class="separator:af25c227066a422379ff06d81b5990865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb37b16823e6e26cfd8571a1bb621651"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afb37b16823e6e26cfd8571a1bb621651">sort_nodes_by_id</a> (<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:afb37b16823e6e26cfd8571a1bb621651"><td class="mdescLeft">&#160;</td><td class="mdescRight">order the nodes in the graph by id  <a href="namespacevg.html#afb37b16823e6e26cfd8571a1bb621651">More...</a><br /></td></tr>
<tr class="separator:afb37b16823e6e26cfd8571a1bb621651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90cc117e3ac781c77cf8fdaa7802048b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a90cc117e3ac781c77cf8fdaa7802048b">sort_edges_by_id</a> (<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a90cc117e3ac781c77cf8fdaa7802048b"><td class="mdescLeft">&#160;</td><td class="mdescRight">order the edges in the graph by id pairs  <a href="namespacevg.html#a90cc117e3ac781c77cf8fdaa7802048b">More...</a><br /></td></tr>
<tr class="separator:a90cc117e3ac781c77cf8fdaa7802048b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5570a5685bef6eee6ac2697920ebc6c0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5570a5685bef6eee6ac2697920ebc6c0">is_id_sortable</a> (const <a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a5570a5685bef6eee6ac2697920ebc6c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if the graph is id-sortable (no reverse links)  <a href="namespacevg.html#a5570a5685bef6eee6ac2697920ebc6c0">More...</a><br /></td></tr>
<tr class="separator:a5570a5685bef6eee6ac2697920ebc6c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b545f6474c6e528176031149a8bc570"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1b545f6474c6e528176031149a8bc570">has_inversion</a> (const <a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a1b545f6474c6e528176031149a8bc570"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if we find an edge that may specify an inversion  <a href="namespacevg.html#a1b545f6474c6e528176031149a8bc570">More...</a><br /></td></tr>
<tr class="separator:a1b545f6474c6e528176031149a8bc570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89c2bb28b708cb4acf67eabfaa4b0168"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a89c2bb28b708cb4acf67eabfaa4b0168">flip_doubly_reversed_edges</a> (<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;graph)</td></tr>
<tr class="memdesc:a89c2bb28b708cb4acf67eabfaa4b0168"><td class="mdescLeft">&#160;</td><td class="mdescRight">clean up doubly-reversed edges  <a href="namespacevg.html#a89c2bb28b708cb4acf67eabfaa4b0168">More...</a><br /></td></tr>
<tr class="separator:a89c2bb28b708cb4acf67eabfaa4b0168"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae968813905d72a9d49a1822b390cbe5d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae968813905d72a9d49a1822b390cbe5d">from_handle_graph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;from, <a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;to)</td></tr>
<tr class="separator:ae968813905d72a9d49a1822b390cbe5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0eaa4d69a029a84c1d3028745c84bc4c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0eaa4d69a029a84c1d3028745c84bc4c">from_path_handle_graph</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;from, <a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;to)</td></tr>
<tr class="separator:a0eaa4d69a029a84c1d3028745c84bc4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9774c4df98285526a427ba54e970ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2d9774c4df98285526a427ba54e970ba">trace_haplotypes_and_paths</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;source, const gbwt::GBWT &amp;haplotype_database, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">vg::id_t</a> start_node, int extend_distance, <a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;out_graph, map&lt; string, int &gt; &amp;out_thread_frequencies, bool expand_graph)</td></tr>
<tr class="separator:a2d9774c4df98285526a427ba54e970ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2d79bdac899f70214959ef92dbbad2f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae2d79bdac899f70214959ef92dbbad2f">output_haplotype_counts</a> (ostream &amp;annotation_ostream, vector&lt; pair&lt; <a class="el" href="namespacevg.html#a31b8b476fb46de6667b26514b7b24fd2">thread_t</a>, int &gt;&gt; &amp;haplotype_list)</td></tr>
<tr class="separator:ae2d79bdac899f70214959ef92dbbad2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae62ff63e415416fd298c6f59c8f2da47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae62ff63e415416fd298c6f59c8f2da47">output_graph_with_embedded_paths</a> (vector&lt; pair&lt; <a class="el" href="namespacevg.html#a31b8b476fb46de6667b26514b7b24fd2">thread_t</a>, int &gt;&gt; &amp;haplotype_list, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;source)</td></tr>
<tr class="separator:ae62ff63e415416fd298c6f59c8f2da47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a134ccba76916d6d94e59581932f1b595"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a134ccba76916d6d94e59581932f1b595">output_graph_with_embedded_paths</a> (ostream &amp;subgraph_ostream, vector&lt; pair&lt; <a class="el" href="namespacevg.html#a31b8b476fb46de6667b26514b7b24fd2">thread_t</a>, int &gt;&gt; &amp;haplotype_list, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;source, bool json)</td></tr>
<tr class="separator:a134ccba76916d6d94e59581932f1b595"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24cc1f72643cab5fa0dfcc551f61d50"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa24cc1f72643cab5fa0dfcc551f61d50">thread_to_graph_spanned</a> (<a class="el" href="namespacevg.html#a31b8b476fb46de6667b26514b7b24fd2">thread_t</a> &amp;t, <a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;g, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;source)</td></tr>
<tr class="separator:aa24cc1f72643cab5fa0dfcc551f61d50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2adfa9e81b2553fefdd5e1d6b24c7a77"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2adfa9e81b2553fefdd5e1d6b24c7a77">add_thread_nodes_to_set</a> (<a class="el" href="namespacevg.html#a31b8b476fb46de6667b26514b7b24fd2">thread_t</a> &amp;t, set&lt; int64_t &gt; &amp;nodes)</td></tr>
<tr class="separator:a2adfa9e81b2553fefdd5e1d6b24c7a77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe2d6096dfe672a486e44df018c713c2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afe2d6096dfe672a486e44df018c713c2">add_thread_edges_to_set</a> (<a class="el" href="namespacevg.html#a31b8b476fb46de6667b26514b7b24fd2">thread_t</a> &amp;t, set&lt; pair&lt; int, int &gt; &gt; &amp;edges)</td></tr>
<tr class="separator:afe2d6096dfe672a486e44df018c713c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b7416f4636f53c22bcb1fab81d63de8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5b7416f4636f53c22bcb1fab81d63de8">construct_graph_from_nodes_and_edges</a> (<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;g, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;source, set&lt; int64_t &gt; &amp;nodes, set&lt; pair&lt; int, int &gt; &gt; &amp;edges)</td></tr>
<tr class="separator:a5b7416f4636f53c22bcb1fab81d63de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f225fb74f28ea09c6c8917ec14db73"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab0f225fb74f28ea09c6c8917ec14db73">path_from_thread_t</a> (<a class="el" href="namespacevg.html#a31b8b476fb46de6667b26514b7b24fd2">thread_t</a> &amp;t, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;source)</td></tr>
<tr class="separator:ab0f225fb74f28ea09c6c8917ec14db73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe3c447c811f77c28669a36c4d3376b9"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; vector&lt; gbwt::node_type &gt;, gbwt::SearchState &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abe3c447c811f77c28669a36c4d3376b9">list_haplotypes</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const gbwt::GBWT &amp;gbwt, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> start, function&lt; bool(const vector&lt; gbwt::node_type &gt; &amp;)&gt; stop_fn)</td></tr>
<tr class="separator:abe3c447c811f77c28669a36c4d3376b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa95de659d860fc90fda95df414c89baf"><td class="memItemLeft" align="right" valign="top">unique_ptr&lt; <a class="el" href="classvg_1_1io_1_1AlignmentEmitter.html">AlignmentEmitter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa95de659d860fc90fda95df414c89baf">get_alignment_emitter</a> (const string &amp;filename, const string &amp;format, const vector&lt; tuple&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, size_t, size_t &gt;&gt; &amp;paths, size_t max_threads, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, int flags)</td></tr>
<tr class="separator:aa95de659d860fc90fda95df414c89baf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa381cdc7f966379fc7cc9ea11257f632"><td class="memItemLeft" align="right" valign="top">pair&lt; vector&lt; pair&lt; string, int64_t &gt; &gt;, unordered_map&lt; string, int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa381cdc7f966379fc7cc9ea11257f632">extract_path_metadata</a> (const vector&lt; tuple&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, size_t, size_t &gt;&gt; &amp;paths, const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;graph, bool subpath_support)</td></tr>
<tr class="separator:aa381cdc7f966379fc7cc9ea11257f632"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e23f130325e05c894696771e50f2636"><td class="memItemLeft" align="right" valign="top">vector&lt; tuple&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, size_t, size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2e23f130325e05c894696771e50f2636">get_sequence_dictionary</a> (const string &amp;filename, const vector&lt; string &gt; &amp;path_names, const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;graph)</td></tr>
<tr class="separator:a2e23f130325e05c894696771e50f2636"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c2f1e37da37dda61d25e9d8bb6552d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1c2f1e37da37dda61d25e9d8bb6552d6">copy_file</a> (const string &amp;from_fp, const string &amp;to_fp)</td></tr>
<tr class="separator:a1c2f1e37da37dda61d25e9d8bb6552d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53098c7c826c3d8d2aab804ba5500fd5"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a53098c7c826c3d8d2aab804ba5500fd5">get_file_size</a> (const string &amp;filename)</td></tr>
<tr class="separator:a53098c7c826c3d8d2aab804ba5500fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f065676bdbe54b44e45961d7d40d8a5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8f065676bdbe54b44e45961d7d40d8a5">is_gzipped</a> (const string &amp;filename)</td></tr>
<tr class="separator:a8f065676bdbe54b44e45961d7d40d8a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe9d79548464e7842327275008447299"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afe9d79548464e7842327275008447299">get_num_samples</a> (const string &amp;vcf_filename)</td></tr>
<tr class="separator:afe9d79548464e7842327275008447299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a665fe802cdb44d2dba6052fc9063513d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a665fe802cdb44d2dba6052fc9063513d">approx_num_vars</a> (const string &amp;vcf_filename)</td></tr>
<tr class="separator:a665fe802cdb44d2dba6052fc9063513d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ae70effc22331b3e4667ed48808602c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3ae70effc22331b3e4667ed48808602c">format_multiplier</a> ()</td></tr>
<tr class="separator:a3ae70effc22331b3e4667ed48808602c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3cceb7b721a218a1be1c948138526a"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3d3cceb7b721a218a1be1c948138526a">approx_graph_memory</a> (const vector&lt; string &gt; &amp;fasta_filenames, const vector&lt; string &gt; &amp;vcf_filenames)</td></tr>
<tr class="separator:a3d3cceb7b721a218a1be1c948138526a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a104aaf42bb3f44518626b9417a4db2d5"><td class="memItemLeft" align="right" valign="top">vector&lt; int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a104aaf42bb3f44518626b9417a4db2d5">each_approx_graph_memory</a> (const vector&lt; string &gt; &amp;fasta_filenames, const vector&lt; string &gt; &amp;vcf_filenames)</td></tr>
<tr class="separator:a104aaf42bb3f44518626b9417a4db2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a16cd88bceed4db044decd94211833d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4a16cd88bceed4db044decd94211833d">approx_graph_memory</a> (const string &amp;fasta_filename, const string &amp;vcf_filename)</td></tr>
<tr class="separator:a4a16cd88bceed4db044decd94211833d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa588389795ea8613480df1c7eeeafaf8"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa588389795ea8613480df1c7eeeafaf8">approx_graph_memory</a> (const string &amp;gfa_filename)</td></tr>
<tr class="separator:aa588389795ea8613480df1c7eeeafaf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a745a31f5e7853868dbf903f33a986480"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a745a31f5e7853868dbf903f33a986480">approx_gbwt_memory</a> (const string &amp;vcf_filename)</td></tr>
<tr class="separator:a745a31f5e7853868dbf903f33a986480"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0300b12116a047d137e134eebe2e1d"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0d0300b12116a047d137e134eebe2e1d">approx_graph_load_memory</a> (const string &amp;graph_filename)</td></tr>
<tr class="separator:a0d0300b12116a047d137e134eebe2e1d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa44c63a293d251b1bffbbeee59d2b7fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa44c63a293d251b1bffbbeee59d2b7fe">transcript_file_nonempty</a> (const string &amp;transcripts)</td></tr>
<tr class="separator:aa44c63a293d251b1bffbbeee59d2b7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691144860bc63559aaf088d2e052af62"><td class="memItemLeft" align="right" valign="top">vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a691144860bc63559aaf088d2e052af62">vcf_contigs</a> (const string &amp;filename)</td></tr>
<tr class="separator:a691144860bc63559aaf088d2e052af62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac302dd262b1fc457d0711c914a216aef"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac302dd262b1fc457d0711c914a216aef">execute_in_fork</a> (const function&lt; void(void)&gt; &amp;exec)</td></tr>
<tr class="separator:ac302dd262b1fc457d0711c914a216aef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab293dcf09c223de43976346c70763cd8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab293dcf09c223de43976346c70763cd8">kff_is_trivial</a> (const uint8_t *encoding)</td></tr>
<tr class="memdesc:ab293dcf09c223de43976346c70763cd8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns <code>true</code> if the encoding is trivial (0, 1, 2, 3).  <a href="namespacevg.html#ab293dcf09c223de43976346c70763cd8">More...</a><br /></td></tr>
<tr class="separator:ab293dcf09c223de43976346c70763cd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afff8c68e07248aa6b304c3b9f45f8e4b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afff8c68e07248aa6b304c3b9f45f8e4b">kff_invert</a> (const uint8_t *encoding)</td></tr>
<tr class="memdesc:afff8c68e07248aa6b304c3b9f45f8e4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverts the KFF encoding into a packed -&gt; char table.  <a href="namespacevg.html#afff8c68e07248aa6b304c3b9f45f8e4b">More...</a><br /></td></tr>
<tr class="separator:afff8c68e07248aa6b304c3b9f45f8e4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1429f1c00018d575e753609329896f31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1kff__recoding__t.html">kff_recoding_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1429f1c00018d575e753609329896f31">kff_recoding</a> (const uint8_t *encoding)</td></tr>
<tr class="memdesc:a1429f1c00018d575e753609329896f31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a recoding for the given encoding.  <a href="namespacevg.html#a1429f1c00018d575e753609329896f31">More...</a><br /></td></tr>
<tr class="separator:a1429f1c00018d575e753609329896f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3021a605be981221a7454ed41329abb"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac3021a605be981221a7454ed41329abb">kff_parse</a> (const uint8_t *data, size_t bytes)</td></tr>
<tr class="memdesc:ac3021a605be981221a7454ed41329abb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parses a big-endian integer from KFF data.  <a href="namespacevg.html#ac3021a605be981221a7454ed41329abb">More...</a><br /></td></tr>
<tr class="separator:ac3021a605be981221a7454ed41329abb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703f0e894fc3faab71d1f56963a1b1f2"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a703f0e894fc3faab71d1f56963a1b1f2">kff_encode</a> (const std::string &amp;kmer, size_t start, size_t limit, const uint8_t *encoding)</td></tr>
<tr class="separator:a703f0e894fc3faab71d1f56963a1b1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8ec52a5e105f9ff5dc0ee6a882f11ef"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad8ec52a5e105f9ff5dc0ee6a882f11ef">kff_encode</a> (const std::string &amp;kmer, const uint8_t *encoding)</td></tr>
<tr class="separator:ad8ec52a5e105f9ff5dc0ee6a882f11ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbd931ab5e8c6d8549262292b5fd1bdb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#adbd931ab5e8c6d8549262292b5fd1bdb">kff_decode</a> (uint8_t byte, size_t chars, const std::string &amp;decoding, std::string &amp;output)</td></tr>
<tr class="separator:adbd931ab5e8c6d8549262292b5fd1bdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a508b66314d777de73b671860cc1ba66f"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a508b66314d777de73b671860cc1ba66f">kff_decode</a> (const uint8_t *kmer, size_t k, const std::string &amp;decoding)</td></tr>
<tr class="memdesc:a508b66314d777de73b671860cc1ba66f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decodes a kmer in KFF format according to the given encoding.  <a href="namespacevg.html#a508b66314d777de73b671860cc1ba66f">More...</a><br /></td></tr>
<tr class="separator:a508b66314d777de73b671860cc1ba66f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d573b735cb520c77d373fe1231fb94d"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1d573b735cb520c77d373fe1231fb94d">kff_recode</a> (gbwtgraph::Key64::value_type kmer, size_t k, size_t chars, const uint8_t *encoding)</td></tr>
<tr class="separator:a1d573b735cb520c77d373fe1231fb94d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc31374a96e3cd653324ab57eb9714ff"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acc31374a96e3cd653324ab57eb9714ff">kff_recode</a> (gbwtgraph::Key64::value_type kmer, size_t k, const uint8_t *encoding)</td></tr>
<tr class="memdesc:acc31374a96e3cd653324ab57eb9714ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Recodes a kmer from a minimizer index in KFF format according to the given encoding.  <a href="namespacevg.html#acc31374a96e3cd653324ab57eb9714ff">More...</a><br /></td></tr>
<tr class="separator:acc31374a96e3cd653324ab57eb9714ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b770ea79c9b74e89ecff6f5e347bf6"><td class="memItemLeft" align="right" valign="top">gbwtgraph::Key64::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab6b770ea79c9b74e89ecff6f5e347bf6">kff_recode</a> (const uint8_t *kmer, size_t k, <a class="el" href="structvg_1_1kff__recoding__t.html">kff_recoding_t</a> recoding)</td></tr>
<tr class="separator:ab6b770ea79c9b74e89ecff6f5e347bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad52eac0801905a9d5f2ba805f1387213"><td class="memItemLeft" align="right" valign="top">gbwtgraph::Key64::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad52eac0801905a9d5f2ba805f1387213">kff_recode_trivial</a> (const uint8_t *kmer, size_t k, size_t bytes)</td></tr>
<tr class="separator:ad52eac0801905a9d5f2ba805f1387213"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ba361b3ec6a01bac17e71af08d2223"><td class="memItemLeft" align="right" valign="top">std::vector&lt; gbwtgraph::Key64::value_type &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a92ba361b3ec6a01bac17e71af08d2223">kff_recode</a> (const uint8_t *kmers, size_t n, size_t k, <a class="el" href="structvg_1_1kff__recoding__t.html">kff_recoding_t</a> recoding)</td></tr>
<tr class="separator:a92ba361b3ec6a01bac17e71af08d2223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a971fa4f581aa13c4d3a29728485a496a"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a971fa4f581aa13c4d3a29728485a496a">kff_get</a> (const uint8_t *kmer, size_t i)</td></tr>
<tr class="separator:a971fa4f581aa13c4d3a29728485a496a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78d3175e64e6a9c019275b5b3e17fe5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad78d3175e64e6a9c019275b5b3e17fe5">kff_set</a> (std::vector&lt; uint8_t &gt; &amp;kmer, size_t i, uint8_t value)</td></tr>
<tr class="separator:ad78d3175e64e6a9c019275b5b3e17fe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a213d22fbc9d8056efb8082e529ab0f22"><td class="memItemLeft" align="right" valign="top">std::vector&lt; uint8_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a213d22fbc9d8056efb8082e529ab0f22">kff_reverse_complement</a> (const uint8_t *kmer, size_t k, const uint8_t *encoding)</td></tr>
<tr class="memdesc:a213d22fbc9d8056efb8082e529ab0f22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reverse complement of a KFF kmer.  <a href="namespacevg.html#a213d22fbc9d8056efb8082e529ab0f22">More...</a><br /></td></tr>
<tr class="separator:a213d22fbc9d8056efb8082e529ab0f22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4b8625853b4a17f731c9fbd5a040fd7"><td class="memItemLeft" align="right" valign="top">gbwtgraph::Key64::value_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae4b8625853b4a17f731c9fbd5a040fd7">minimizer_reverse_complement</a> (gbwtgraph::Key64::value_type kmer, size_t k)</td></tr>
<tr class="memdesc:ae4b8625853b4a17f731c9fbd5a040fd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the reverse complement of a minimizer index kmer.  <a href="namespacevg.html#ae4b8625853b4a17f731c9fbd5a040fd7">More...</a><br /></td></tr>
<tr class="separator:ae4b8625853b4a17f731c9fbd5a040fd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8290bb0f46f4410bd8d19a9214f42d9"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae8290bb0f46f4410bd8d19a9214f42d9">kff_bytes</a> (size_t k)</td></tr>
<tr class="memdesc:ae8290bb0f46f4410bd8d19a9214f42d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of bytes required for a kmer in KFF format.  <a href="namespacevg.html#ae8290bb0f46f4410bd8d19a9214f42d9">More...</a><br /></td></tr>
<tr class="separator:ae8290bb0f46f4410bd8d19a9214f42d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3d4de4fa2fda6bfcd6eaa77080c67ad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab3d4de4fa2fda6bfcd6eaa77080c67ad">for_each_kmer</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, size_t k, const function&lt; void(const <a class="el" href="structvg_1_1kmer__t.html">kmer_t</a> &amp;)&gt; &amp;lambda, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> head_id, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> tail_id, atomic&lt; int &gt; *stop_flag)</td></tr>
<tr class="separator:ab3d4de4fa2fda6bfcd6eaa77080c67ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e459d4a7dda13edf5b79ea8996cfd82"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0e459d4a7dda13edf5b79ea8996cfd82">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="structvg_1_1kmer__t.html">kmer_t</a> &amp;kmer)</td></tr>
<tr class="memdesc:a0e459d4a7dda13edf5b79ea8996cfd82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a <a class="el" href="structvg_1_1kmer__t.html">kmer_t</a> to a stream.  <a href="namespacevg.html#a0e459d4a7dda13edf5b79ea8996cfd82">More...</a><br /></td></tr>
<tr class="separator:a0e459d4a7dda13edf5b79ea8996cfd82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a661fc17618ee9ff7bd9d469c74c63369"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a661fc17618ee9ff7bd9d469c74c63369">kmer_to_gcsa_kmers</a> (const <a class="el" href="structvg_1_1kmer__t.html">kmer_t</a> &amp;kmer, const gcsa::Alphabet &amp;alpha, const function&lt; void(const gcsa::KMer &amp;)&gt; &amp;lambda)</td></tr>
<tr class="memdesc:a661fc17618ee9ff7bd9d469c74c63369"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the <a class="el" href="structvg_1_1kmer__t.html">kmer_t</a> to a set of gcsa2 binary kmers which are exposed via a callback.  <a href="namespacevg.html#a661fc17618ee9ff7bd9d469c74c63369">More...</a><br /></td></tr>
<tr class="separator:a661fc17618ee9ff7bd9d469c74c63369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa25419c15b3dcae6b217f893c243c487"><td class="memItemLeft" align="right" valign="top">gcsa::byte_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa25419c15b3dcae6b217f893c243c487">encode_chars</a> (const vector&lt; char &gt; &amp;chars, const gcsa::Alphabet &amp;alpha)</td></tr>
<tr class="memdesc:aa25419c15b3dcae6b217f893c243c487"><td class="mdescLeft">&#160;</td><td class="mdescRight">Encode the chars into the gcsa2 byte.  <a href="namespacevg.html#aa25419c15b3dcae6b217f893c243c487">More...</a><br /></td></tr>
<tr class="separator:aa25419c15b3dcae6b217f893c243c487"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d8c71ff9f77ddd4a366119e83122771"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6d8c71ff9f77ddd4a366119e83122771">write_gcsa_kmers</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, int kmer_size, ostream &amp;out, size_t &amp;size_limit, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> head_id, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> tail_id)</td></tr>
<tr class="separator:a6d8c71ff9f77ddd4a366119e83122771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d9326cbc013aed614bc052c8c224e6"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a38d9326cbc013aed614bc052c8c224e6">write_gcsa_kmers_to_tmpfile</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, int kmer_size, size_t &amp;size_limit, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> head_id, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> tail_id, const string &amp;base_file_name)</td></tr>
<tr class="separator:a38d9326cbc013aed614bc052c8c224e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ff1638bd636bb4b9746545dc261aea1"><td class="memItemLeft" align="right" valign="top">vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3ff1638bd636bb4b9746545dc261aea1">make_prefix_suffix_table</a> (const char *pattern, size_t len)</td></tr>
<tr class="separator:a3ff1638bd636bb4b9746545dc261aea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f32c345e847a3627afcee659116730c"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4f32c345e847a3627afcee659116730c">kmp_search</a> (const char *text, size_t text_len, const char *pattern, size_t pattern_len, const vector&lt; size_t &gt; &amp;prefix_suffix_table)</td></tr>
<tr class="separator:a4f32c345e847a3627afcee659116730c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63c41956b73af429507b469108d1759"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab63c41956b73af429507b469108d1759">sub_overlaps_of_first_aln</a> (const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;alns, float overlap_fraction)</td></tr>
<tr class="separator:ab63c41956b73af429507b469108d1759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3240e7b9bf787fb218d6324389ea234e"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3240e7b9bf787fb218d6324389ea234e">gcsa_nodes_to_positions</a> (const vector&lt; gcsa::node_type &gt; &amp;nodes)</td></tr>
<tr class="separator:a3240e7b9bf787fb218d6324389ea234e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7211eb89509ce3ca625333936c08ec9b"><td class="memItemLeft" align="right" valign="top">const int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7211eb89509ce3ca625333936c08ec9b">balanced_stride</a> (int read_length, int kmer_size, int stride)</td></tr>
<tr class="separator:a7211eb89509ce3ca625333936c08ec9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab7caa49b187d9fc25833daa572cdf770"><td class="memItemLeft" align="right" valign="top">const vector&lt; string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab7caa49b187d9fc25833daa572cdf770">balanced_kmers</a> (const string &amp;seq, const int kmer_size, const int stride)</td></tr>
<tr class="separator:ab7caa49b187d9fc25833daa572cdf770"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1678438e6011469b88ddf3b54023013"><td class="memItemLeft" align="right" valign="top">pair&lt; int64_t, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae1678438e6011469b88ddf3b54023013">mem_min_oriented_distances</a> (const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;m1, const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;m2)</td></tr>
<tr class="separator:ae1678438e6011469b88ddf3b54023013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af94d73312bfd787493e87d207398d73a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af94d73312bfd787493e87d207398d73a">operator==</a> (const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;m1, const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;m2)</td></tr>
<tr class="separator:af94d73312bfd787493e87d207398d73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac476fcc21a47f34d00b4a449b28c686b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac476fcc21a47f34d00b4a449b28c686b">operator&lt;</a> (const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;m1, const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;m2)</td></tr>
<tr class="separator:ac476fcc21a47f34d00b4a449b28c686b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a4b11db620d43a7e20886d5563e5b8"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af0a4b11db620d43a7e20886d5563e5b8">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;mem)</td></tr>
<tr class="separator:af0a4b11db620d43a7e20886d5563e5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0bec9992b4441128754ac4ed1a330e8"><td class="memItemLeft" align="right" valign="top">const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab0bec9992b4441128754ac4ed1a330e8">mems_to_json</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems)</td></tr>
<tr class="separator:ab0bec9992b4441128754ac4ed1a330e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3e65f9aafb5ab9ce5455cc72fa0b56"><td class="memItemLeft" align="right" valign="top">vector&lt; string::const_iterator &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afe3e65f9aafb5ab9ce5455cc72fa0b56">cluster_cover</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;cluster)</td></tr>
<tr class="separator:afe3e65f9aafb5ab9ce5455cc72fa0b56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3380e0f81fc879601afe493949814a4d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3380e0f81fc879601afe493949814a4d">cluster_coverage</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;cluster)</td></tr>
<tr class="separator:a3380e0f81fc879601afe493949814a4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa412de4741b61d2a8b863f50f31209e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa412de4741b61d2a8b863f50f31209e0">mems_overlap</a> (const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;mem1, const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;mem2)</td></tr>
<tr class="separator:aa412de4741b61d2a8b863f50f31209e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5d04132733b3487e3dab20729645850"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af5d04132733b3487e3dab20729645850">mems_overlap_length</a> (const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;mem1, const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;mem2)</td></tr>
<tr class="separator:af5d04132733b3487e3dab20729645850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af67eb440256877ac857d6649052d7db1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af67eb440256877ac857d6649052d7db1">clusters_overlap_in_read</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;cluster1, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;cluster2)</td></tr>
<tr class="separator:af67eb440256877ac857d6649052d7db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50260b7d42777dd7f352a5ba40ac655e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a50260b7d42777dd7f352a5ba40ac655e">clusters_overlap_length</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;cluster1, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;cluster2)</td></tr>
<tr class="separator:a50260b7d42777dd7f352a5ba40ac655e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6c60d6eb4cafd02a45384cf71a12bfe"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af6c60d6eb4cafd02a45384cf71a12bfe">cluster_nodes</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;cluster)</td></tr>
<tr class="separator:af6c60d6eb4cafd02a45384cf71a12bfe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d8947e51da3156529e12ae131c25a47"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9d8947e51da3156529e12ae131c25a47">clusters_overlap_in_graph</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;cluster1, const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;cluster2)</td></tr>
<tr class="separator:a9d8947e51da3156529e12ae131c25a47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bc1837d8c1cca33ab223957402b70ba"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4bc1837d8c1cca33ab223957402b70ba">translate_mems</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt; &gt; &amp;trans)</td></tr>
<tr class="separator:a4bc1837d8c1cca33ab223957402b70ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fb67697fd1e49bcb389a735ba9fa8f2"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9fb67697fd1e49bcb389a735ba9fa8f2">get_proc_status_value</a> (const string &amp;name)</td></tr>
<tr class="memdesc:a9fb67697fd1e49bcb389a735ba9fa8f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the string value for a field in /proc/self/status by name, or "" if unsupported or not found.  <a href="namespacevg.html#a9fb67697fd1e49bcb389a735ba9fa8f2">More...</a><br /></td></tr>
<tr class="separator:a9fb67697fd1e49bcb389a735ba9fa8f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a546b60e87f7fc326074f6dcf2cdd0659"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a546b60e87f7fc326074f6dcf2cdd0659">get_max_rss_kb</a> ()</td></tr>
<tr class="memdesc:a546b60e87f7fc326074f6dcf2cdd0659"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the max RSS usage ever, in kb, or 0 if unsupported.  <a href="namespacevg.html#a546b60e87f7fc326074f6dcf2cdd0659">More...</a><br /></td></tr>
<tr class="separator:a546b60e87f7fc326074f6dcf2cdd0659"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a917d8892f93a31e2d8c3161de264fea1"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a917d8892f93a31e2d8c3161de264fea1">get_max_vmem_kb</a> ()</td></tr>
<tr class="memdesc:a917d8892f93a31e2d8c3161de264fea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the max virtual memory size ever, in kb, or 0 if unsupported.  <a href="namespacevg.html#a917d8892f93a31e2d8c3161de264fea1">More...</a><br /></td></tr>
<tr class="separator:a917d8892f93a31e2d8c3161de264fea1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cd30aaebcab130194ac375f23e6f098"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8cd30aaebcab130194ac375f23e6f098">get_current_vmem_kb</a> ()</td></tr>
<tr class="memdesc:a8cd30aaebcab130194ac375f23e6f098"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the current virtual memory size, in kb, or 0 if unsupported.  <a href="namespacevg.html#a8cd30aaebcab130194ac375f23e6f098">More...</a><br /></td></tr>
<tr class="separator:a8cd30aaebcab130194ac375f23e6f098"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1dcbe73351c8eaeea745f4b5191b8f0"><td class="memItemLeft" align="right" valign="top">vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab1dcbe73351c8eaeea745f4b5191b8f0">subpath_topological_order</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, bool do_index)</td></tr>
<tr class="memdesc:ab1dcbe73351c8eaeea745f4b5191b8f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return either the vector of topological order by index or the vector of indexes within the topological order.  <a href="namespacevg.html#ab1dcbe73351c8eaeea745f4b5191b8f0">More...</a><br /></td></tr>
<tr class="separator:ab1dcbe73351c8eaeea745f4b5191b8f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ca9ccb5a2301ed1ce48f6334b3c4937"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3ca9ccb5a2301ed1ce48f6334b3c4937">topologically_order_subpaths</a> (<a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln)</td></tr>
<tr class="memdesc:a3ca9ccb5a2301ed1ce48f6334b3c4937"><td class="mdescLeft">&#160;</td><td class="mdescRight">Put subpaths in topological order (assumed to be true for other algorithms)  <a href="namespacevg.html#a3ca9ccb5a2301ed1ce48f6334b3c4937">More...</a><br /></td></tr>
<tr class="separator:a3ca9ccb5a2301ed1ce48f6334b3c4937"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3fb034fcd6d50c2b84f40026b40f284"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af3fb034fcd6d50c2b84f40026b40f284">remove_empty_alignment_sections</a> (<a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln)</td></tr>
<tr class="separator:af3fb034fcd6d50c2b84f40026b40f284"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0844cc3c2da56dfed0e9436d7f0dd7de"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0844cc3c2da56dfed0e9436d7f0dd7de">identify_start_subpaths</a> (<a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln)</td></tr>
<tr class="separator:a0844cc3c2da56dfed0e9436d7f0dd7de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0406641335bb841c51b0c103219a29da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0406641335bb841c51b0c103219a29da">clear_alignment</a> (<a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln)</td></tr>
<tr class="memdesc:a0406641335bb841c51b0c103219a29da"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clear all of the field associated with the alignment.  <a href="namespacevg.html#a0406641335bb841c51b0c103219a29da">More...</a><br /></td></tr>
<tr class="separator:a0406641335bb841c51b0c103219a29da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae57a78071537c87e2f0f57bfea18ba71"><td class="memItemLeft" align="right" valign="top">tuple&lt; <a class="el" href="structvg_1_1MultipathProblem.html">MultipathProblem</a>, int64_t, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae57a78071537c87e2f0f57bfea18ba71">run_multipath_dp</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, bool subpath_global=false, bool forward=true)</td></tr>
<tr class="separator:ae57a78071537c87e2f0f57bfea18ba71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a191bf7b238ea717afbf8118df0afa999"><td class="memTemplParams" colspan="2">template&lt;typename TracebackIterator &gt; </td></tr>
<tr class="memitem:a191bf7b238ea717afbf8118df0afa999"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a191bf7b238ea717afbf8118df0afa999">populate_path_from_traceback</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, const <a class="el" href="structvg_1_1MultipathProblem.html">MultipathProblem</a> &amp;problem, TracebackIterator traceback_start, TracebackIterator traceback_end, <a class="el" href="structvg_1_1Path.html">Path</a> *output)</td></tr>
<tr class="separator:a191bf7b238ea717afbf8118df0afa999"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caee9d564f3a803a6ad69642269c5b6"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3caee9d564f3a803a6ad69642269c5b6">optimal_alignment_internal</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> *aln_out, bool subpath_global)</td></tr>
<tr class="separator:a3caee9d564f3a803a6ad69642269c5b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e3c0f0d0f60a6a6ef1c301b63e9a21e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4e3c0f0d0f60a6a6ef1c301b63e9a21e">optimal_alignment</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln_out, bool subpath_global)</td></tr>
<tr class="separator:a4e3c0f0d0f60a6a6ef1c301b63e9a21e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3548ef9766130a155ba65420c0e7c0e"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad3548ef9766130a155ba65420c0e7c0e">optimal_alignment_score</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, bool subpath_global)</td></tr>
<tr class="separator:ad3548ef9766130a155ba65420c0e7c0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2c6fbf0d030acabb7dd6b8d428e143"><td class="memItemLeft" align="right" valign="top">int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8e2c6fbf0d030acabb7dd6b8d428e143">worst_alignment_score</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln)</td></tr>
<tr class="separator:a8e2c6fbf0d030acabb7dd6b8d428e143"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea49989e31a688e22265eb41291c0ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0ea49989e31a688e22265eb41291c0ae">remove_low_scoring_sections</a> (<a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, int32_t max_score_diff)</td></tr>
<tr class="separator:a0ea49989e31a688e22265eb41291c0ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada4d6b6771c5d7e5b2367b18ca8f76f3"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ada4d6b6771c5d7e5b2367b18ca8f76f3">optimal_alignments</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, size_t count)</td></tr>
<tr class="separator:ada4d6b6771c5d7e5b2367b18ca8f76f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af711577f7d293ffc1c8002c868081bb1"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af711577f7d293ffc1c8002c868081bb1">optimal_alignments_with_disjoint_subpaths</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, size_t count)</td></tr>
<tr class="separator:af711577f7d293ffc1c8002c868081bb1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5a2adbf9370dc37be337d927341f9db"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab5a2adbf9370dc37be337d927341f9db">haplotype_consistent_alignments</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, const <a class="el" href="classhaplo_1_1ScoreProvider.html">haplo::ScoreProvider</a> &amp;score_provider, size_t soft_count, size_t hard_count, bool optimal_first)</td></tr>
<tr class="separator:ab5a2adbf9370dc37be337d927341f9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b337b4ea1b6ad514093ce1b9d44b598"><td class="memItemLeft" align="right" valign="top">pair&lt; int64_t, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3b337b4ea1b6ad514093ce1b9d44b598">aligned_interval</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln)</td></tr>
<tr class="memdesc:a3b337b4ea1b6ad514093ce1b9d44b598"><td class="mdescLeft">&#160;</td><td class="mdescRight">The indexes on the read sequence of the portion of the read that is aligned outside of soft clips.  <a href="namespacevg.html#a3b337b4ea1b6ad514093ce1b9d44b598">More...</a><br /></td></tr>
<tr class="separator:a3b337b4ea1b6ad514093ce1b9d44b598"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d802144c81c58c86f814507e1f99e22"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4d802144c81c58c86f814507e1f99e22">rev_comp_subpath</a> (const <a class="el" href="classvg_1_1subpath__t.html">subpath_t</a> &amp;subpath, const function&lt; int64_t(int64_t)&gt; &amp;node_length, <a class="el" href="classvg_1_1subpath__t.html">subpath_t</a> &amp;rev_comp_out)</td></tr>
<tr class="separator:a4d802144c81c58c86f814507e1f99e22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a785f128b2eeb9aa2a4ee5477e5b9942b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a785f128b2eeb9aa2a4ee5477e5b9942b">rev_comp_multipath_alignment</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, const function&lt; int64_t(int64_t)&gt; &amp;node_length, <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;rev_comp_out)</td></tr>
<tr class="separator:a785f128b2eeb9aa2a4ee5477e5b9942b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9aa92b68bb45684a3b751060508c709"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab9aa92b68bb45684a3b751060508c709">rev_comp_multipath_alignment_in_place</a> (<a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> *multipath_aln, const function&lt; int64_t(int64_t)&gt; &amp;node_length)</td></tr>
<tr class="separator:ab9aa92b68bb45684a3b751060508c709"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f29020dbd628bd21a9a039ee718b29b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1f29020dbd628bd21a9a039ee718b29b">convert_multipath_alignment_char</a> (<a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, char from, char to)</td></tr>
<tr class="separator:a1f29020dbd628bd21a9a039ee718b29b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a6e3cc99aac92404ec33126dbbd9192"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5a6e3cc99aac92404ec33126dbbd9192">convert_Us_to_Ts</a> (<a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln)</td></tr>
<tr class="memdesc:a5a6e3cc99aac92404ec33126dbbd9192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all U's in the sequence and the aligned <a class="el" href="classvg_1_1Paths.html">Paths</a> with T's.  <a href="namespacevg.html#a5a6e3cc99aac92404ec33126dbbd9192">More...</a><br /></td></tr>
<tr class="separator:a5a6e3cc99aac92404ec33126dbbd9192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c7d384c096b813501b23730e308796"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a92c7d384c096b813501b23730e308796">convert_Ts_to_Us</a> (<a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln)</td></tr>
<tr class="memdesc:a92c7d384c096b813501b23730e308796"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces all T's in the sequence and the aligned <a class="el" href="classvg_1_1Paths.html">Paths</a> with U's.  <a href="namespacevg.html#a92c7d384c096b813501b23730e308796">More...</a><br /></td></tr>
<tr class="separator:a92c7d384c096b813501b23730e308796"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57c3f88ce9f85ceae2d77c32fd9de04d"><td class="memTemplParams" colspan="2">template&lt;class ProtoAlignment &gt; </td></tr>
<tr class="memitem:a57c3f88ce9f85ceae2d77c32fd9de04d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a57c3f88ce9f85ceae2d77c32fd9de04d">transfer_from_proto_annotation</a> (const ProtoAlignment &amp;from, <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;to)</td></tr>
<tr class="separator:a57c3f88ce9f85ceae2d77c32fd9de04d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90a76dfce70406755151cf45e6990848"><td class="memTemplParams" colspan="2">template&lt;class ProtoAlignment &gt; </td></tr>
<tr class="memitem:a90a76dfce70406755151cf45e6990848"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a90a76dfce70406755151cf45e6990848">transfer_to_proto_annotation</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;from, ProtoAlignment &amp;to)</td></tr>
<tr class="separator:a90a76dfce70406755151cf45e6990848"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0534767a787eae1a5f93444bf21b2a1"><td class="memTemplParams" colspan="2">template&lt;class ProtoAlignment1 , class ProtoAlignment2 &gt; </td></tr>
<tr class="memitem:ac0534767a787eae1a5f93444bf21b2a1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac0534767a787eae1a5f93444bf21b2a1">transfer_between_proto_annotation</a> (const ProtoAlignment1 &amp;from, ProtoAlignment2 &amp;to)</td></tr>
<tr class="separator:ac0534767a787eae1a5f93444bf21b2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf827b04e42865ece378b51482df898"><td class="memTemplParams" colspan="2">template&lt;class Alignment1 , class Alignment2 &gt; </td></tr>
<tr class="memitem:adbf827b04e42865ece378b51482df898"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#adbf827b04e42865ece378b51482df898">transfer_uniform_metadata</a> (const Alignment1 &amp;from, Alignment2 &amp;to)</td></tr>
<tr class="separator:adbf827b04e42865ece378b51482df898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f8f0e54cfa0c3279c18748c503ccbe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8f8f0e54cfa0c3279c18748c503ccbe9">to_proto_multipath_alignment</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;proto_multipath_aln_out)</td></tr>
<tr class="memdesc:a8f8f0e54cfa0c3279c18748c503ccbe9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert an STL-based <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> to a protobuf <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>.  <a href="namespacevg.html#a8f8f0e54cfa0c3279c18748c503ccbe9">More...</a><br /></td></tr>
<tr class="separator:a8f8f0e54cfa0c3279c18748c503ccbe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8630566250dfefc57ec84cbf6c22c3e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8630566250dfefc57ec84cbf6c22c3e2">from_proto_multipath_alignment</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;proto_multipath_aln, <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln_out)</td></tr>
<tr class="memdesc:a8630566250dfefc57ec84cbf6c22c3e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a protobuf <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> to an STL-based <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a>.  <a href="namespacevg.html#a8630566250dfefc57ec84cbf6c22c3e2">More...</a><br /></td></tr>
<tr class="separator:a8630566250dfefc57ec84cbf6c22c3e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27656a1e271730b6a62263dc2af8055d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a27656a1e271730b6a62263dc2af8055d">to_multipath_alignment</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln_out)</td></tr>
<tr class="separator:a27656a1e271730b6a62263dc2af8055d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a195fc7fa6da6fecfa7e9fa31e5cf6f0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a195fc7fa6da6fecfa7e9fa31e5cf6f0c">transfer_read_metadata</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;from, <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;to)</td></tr>
<tr class="separator:a195fc7fa6da6fecfa7e9fa31e5cf6f0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acac375591689f0066f6c723dc25fb834"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acac375591689f0066f6c723dc25fb834">transfer_read_metadata</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;from, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;to)</td></tr>
<tr class="separator:acac375591689f0066f6c723dc25fb834"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0995c3042ff642b9e8aeaa1727dccb5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad0995c3042ff642b9e8aeaa1727dccb5">transfer_read_metadata</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;from, <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;to)</td></tr>
<tr class="separator:ad0995c3042ff642b9e8aeaa1727dccb5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54b4f608ad692caffd8fce4df9a1e4ef"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a54b4f608ad692caffd8fce4df9a1e4ef">transfer_read_metadata</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;from, <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;to)</td></tr>
<tr class="separator:a54b4f608ad692caffd8fce4df9a1e4ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d8929c8f610705661da889830b0b7b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2d8929c8f610705661da889830b0b7b9">transfer_read_metadata</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;from, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;to)</td></tr>
<tr class="separator:a2d8929c8f610705661da889830b0b7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af48acb91edce241c75a9a4fd02745620"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af48acb91edce241c75a9a4fd02745620">transfer_read_metadata</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;from, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;to)</td></tr>
<tr class="separator:af48acb91edce241c75a9a4fd02745620"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0582a68dfa130c9f0a2bdaa1c7ac5ef5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0582a68dfa130c9f0a2bdaa1c7ac5ef5">transfer_proto_metadata</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;from, <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;to)</td></tr>
<tr class="separator:a0582a68dfa130c9f0a2bdaa1c7ac5ef5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6476e86221a660dda1fa85254e9436d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad6476e86221a660dda1fa85254e9436d">transfer_proto_metadata</a> (const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;from, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;to)</td></tr>
<tr class="separator:ad6476e86221a660dda1fa85254e9436d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86fd22ae591c4923588d20b9b5c52e43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a86fd22ae591c4923588d20b9b5c52e43">merge_non_branching_subpaths</a> (<a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, const unordered_set&lt; size_t &gt; *prohibited_merges)</td></tr>
<tr class="separator:a86fd22ae591c4923588d20b9b5c52e43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37c256d47f5d50349766d6f8085b017f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a37c256d47f5d50349766d6f8085b017f">connected_comps_do</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, function&lt; void(void)&gt; &amp;on_new_component, function&lt; void(size_t)&gt; &amp;on_new_node)</td></tr>
<tr class="separator:a37c256d47f5d50349766d6f8085b017f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ac45a06bc04f88ba6c2321d7af304c6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1ac45a06bc04f88ba6c2321d7af304c6">num_connected_components</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln)</td></tr>
<tr class="memdesc:a1ac45a06bc04f88ba6c2321d7af304c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the number of connected components in the multipath alignment.  <a href="namespacevg.html#a1ac45a06bc04f88ba6c2321d7af304c6">More...</a><br /></td></tr>
<tr class="separator:a1ac45a06bc04f88ba6c2321d7af304c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68859b86cb7465d17ca9cb68553a8e4c"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a68859b86cb7465d17ca9cb68553a8e4c">connected_components</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln)</td></tr>
<tr class="separator:a68859b86cb7465d17ca9cb68553a8e4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b9703408d4c7160e8d9e83303c4d1c7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2b9703408d4c7160e8d9e83303c4d1c7">extract_sub_multipath_alignment</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, const vector&lt; int64_t &gt; &amp;subpath_indexes, <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;sub_multipath_aln)</td></tr>
<tr class="separator:a2b9703408d4c7160e8d9e83303c4d1c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac93525ce8a55a9394025efe575468488"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac93525ce8a55a9394025efe575468488">append_multipath_alignment</a> (<a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;to_append)</td></tr>
<tr class="memdesc:ac93525ce8a55a9394025efe575468488"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the subpaths of one multipath alignment onto another.  <a href="namespacevg.html#ac93525ce8a55a9394025efe575468488">More...</a><br /></td></tr>
<tr class="separator:ac93525ce8a55a9394025efe575468488"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f65013661cfc322222585843c30773a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3f65013661cfc322222585843c30773a">contains_connection</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln)</td></tr>
<tr class="memdesc:a3f65013661cfc322222585843c30773a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if any subpath has a connection adjacency.  <a href="namespacevg.html#a3f65013661cfc322222585843c30773a">More...</a><br /></td></tr>
<tr class="separator:a3f65013661cfc322222585843c30773a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9d71371be6972c8284b267d42fac754"><td class="memItemLeft" align="right" valign="top">vector&lt; tuple&lt; int64_t, int64_t, int64_t, int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa9d71371be6972c8284b267d42fac754">search_multipath_alignment</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;graph_pos, int64_t seq_pos)</td></tr>
<tr class="separator:aa9d71371be6972c8284b267d42fac754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83257be63a821ae991e1b332b62facd4"><td class="memItemLeft" align="right" valign="top">pair&lt; tuple&lt; int64_t, int64_t, int64_t &gt;, vector&lt; tuple&lt; int64_t, int64_t, int64_t, int64_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a83257be63a821ae991e1b332b62facd4">trace_path</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, int64_t subpath_idx, int64_t mapping_idx, int64_t edit_idx, int64_t base_idx, bool search_left, int64_t search_limit)</td></tr>
<tr class="separator:a83257be63a821ae991e1b332b62facd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accfb6f4fc450e420c5b147cff9e6ae31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#accfb6f4fc450e420c5b147cff9e6ae31">contains_match</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;pos, int64_t read_pos, int64_t match_length)</td></tr>
<tr class="separator:accfb6f4fc450e420c5b147cff9e6ae31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa223d83f7bc78267d7c7a522c909231"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; int, char &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aaa223d83f7bc78267d7c7a522c909231">cigar_against_path</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, const string &amp;path_name, bool rev, int64_t path_pos, const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;graph, int64_t min_splice_length)</td></tr>
<tr class="separator:aaa223d83f7bc78267d7c7a522c909231"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a026842b7758f60f2be6a474cf41d3fe1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a026842b7758f60f2be6a474cf41d3fe1">validate_multipath_alignment</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;handle_graph)</td></tr>
<tr class="separator:a026842b7758f60f2be6a474cf41d3fe1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a411a023efbe439f069829603a2775673"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a411a023efbe439f069829603a2775673">view_multipath_alignment</a> (ostream &amp;out, const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;handle_graph)</td></tr>
<tr class="memdesc:a411a023efbe439f069829603a2775673"><td class="mdescLeft">&#160;</td><td class="mdescRight">Send a formatted string representation of the <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> into the ostream.  <a href="namespacevg.html#a411a023efbe439f069829603a2775673">More...</a><br /></td></tr>
<tr class="separator:a411a023efbe439f069829603a2775673"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716909fc23ddaab59e0d2bf89fdd1ae3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a716909fc23ddaab59e0d2bf89fdd1ae3">view_multipath_alignment_as_dot</a> (ostream &amp;out, const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln, bool show_graph=false)</td></tr>
<tr class="memdesc:a716909fc23ddaab59e0d2bf89fdd1ae3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> to a GraphViz Dot representation, output to the given ostream.  <a href="namespacevg.html#a716909fc23ddaab59e0d2bf89fdd1ae3">More...</a><br /></td></tr>
<tr class="separator:a716909fc23ddaab59e0d2bf89fdd1ae3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae72a83063f59506e0fcd76304b85d842"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae72a83063f59506e0fcd76304b85d842">debug_string</a> (const <a class="el" href="classvg_1_1connection__t.html">connection_t</a> &amp;connection)</td></tr>
<tr class="separator:ae72a83063f59506e0fcd76304b85d842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8401a5ba093820ee017f9db390058087"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8401a5ba093820ee017f9db390058087">debug_string</a> (const <a class="el" href="classvg_1_1subpath__t.html">subpath_t</a> &amp;subpath)</td></tr>
<tr class="separator:a8401a5ba093820ee017f9db390058087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a723cb7c4957a689cb7de6812237dea"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3a723cb7c4957a689cb7de6812237dea">debug_string</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln)</td></tr>
<tr class="separator:a3a723cb7c4957a689cb7de6812237dea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeca2b8e2d5730b1d5b94c1d3861757d7"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aeca2b8e2d5730b1d5b94c1d3861757d7">make_shuffle_seed</a> (const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;aln)</td></tr>
<tr class="memdesc:aeca2b8e2d5730b1d5b94c1d3861757d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Define seed generation for shuffling multipath alignments.  <a href="namespacevg.html#aeca2b8e2d5730b1d5b94c1d3861757d7">More...</a><br /></td></tr>
<tr class="separator:aeca2b8e2d5730b1d5b94c1d3861757d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f5b0dc3732e48a6d9b8d1c895cd8d1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a30f5b0dc3732e48a6d9b8d1c895cd8d1">node_start</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a30f5b0dc3732e48a6d9b8d1c895cd8d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce the start <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a>.  <a href="namespacevg.html#a30f5b0dc3732e48a6d9b8d1c895cd8d1">More...</a><br /></td></tr>
<tr class="separator:a30f5b0dc3732e48a6d9b8d1c895cd8d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a434e32ac84fd027508a6506e80107331"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a434e32ac84fd027508a6506e80107331">node_end</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a434e32ac84fd027508a6506e80107331"><td class="mdescLeft">&#160;</td><td class="mdescRight">Produce the end <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a>.  <a href="namespacevg.html#a434e32ac84fd027508a6506e80107331">More...</a><br /></td></tr>
<tr class="separator:a434e32ac84fd027508a6506e80107331"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b4bea48392e7bb9e745b3b04e5bf223"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9b4bea48392e7bb9e745b3b04e5bf223">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;nodeside)</td></tr>
<tr class="memdesc:a9b4bea48392e7bb9e745b3b04e5bf223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> to a stream.  <a href="namespacevg.html#a9b4bea48392e7bb9e745b3b04e5bf223">More...</a><br /></td></tr>
<tr class="separator:a9b4bea48392e7bb9e745b3b04e5bf223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1bdeb550c6f5fa632ad61454321e001"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad1bdeb550c6f5fa632ad61454321e001">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;nodetraversal)</td></tr>
<tr class="memdesc:ad1bdeb550c6f5fa632ad61454321e001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>.  <a href="namespacevg.html#ad1bdeb550c6f5fa632ad61454321e001">More...</a><br /></td></tr>
<tr class="separator:ad1bdeb550c6f5fa632ad61454321e001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81357f8477c9ed2c3839489e0ada1ced"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a81357f8477c9ed2c3839489e0ada1ced">operator&lt;&lt;</a> (ostream &amp;out, <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> mapping)</td></tr>
<tr class="memdesc:a81357f8477c9ed2c3839489e0ada1ced"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow a <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> to be printed, for debugging purposes.  <a href="namespacevg.html#a81357f8477c9ed2c3839489e0ada1ced">More...</a><br /></td></tr>
<tr class="separator:a81357f8477c9ed2c3839489e0ada1ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75a663b07489d2aba3f800943eeb0eaf"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a75a663b07489d2aba3f800943eeb0eaf">append_path</a> (<a class="el" href="structvg_1_1Path.html">Path</a> &amp;a, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;b)</td></tr>
<tr class="separator:a75a663b07489d2aba3f800943eeb0eaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48108a0abc0fdfc187437d174f88e590"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a48108a0abc0fdfc187437d174f88e590">path_to_length</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:a48108a0abc0fdfc187437d174f88e590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1524b7b1b7e67c048c0c5e88b204de08"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1524b7b1b7e67c048c0c5e88b204de08">path_from_length</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:a1524b7b1b7e67c048c0c5e88b204de08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ef1ccef545dfc30f9123eba61267b4a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9ef1ccef545dfc30f9123eba61267b4a">mapping_to_length</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:a9ef1ccef545dfc30f9123eba61267b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2aa77c6d4db628d13488c0bd82538ed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa2aa77c6d4db628d13488c0bd82538ed">mapping_from_length</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:aa2aa77c6d4db628d13488c0bd82538ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe66eebecbc5017b05c9044413b2b4e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9fe66eebecbc5017b05c9044413b2b4e">softclip_start</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mapping)</td></tr>
<tr class="separator:a9fe66eebecbc5017b05c9044413b2b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa84e4c417206a9b3a910dfde0fec3857"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa84e4c417206a9b3a910dfde0fec3857">softclip_end</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mapping)</td></tr>
<tr class="separator:aa84e4c417206a9b3a910dfde0fec3857"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7557d06abd0fca3d66f9ca73fe81db"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ada7557d06abd0fca3d66f9ca73fe81db">first_path_position</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:ada7557d06abd0fca3d66f9ca73fe81db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1c1e5b8ce9f9607976913317102d6dc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa1c1e5b8ce9f9607976913317102d6dc">last_path_position</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:aa1c1e5b8ce9f9607976913317102d6dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ed83dc32e575ae68b591d142eb38912"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5ed83dc32e575ae68b591d142eb38912">to_length</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:a5ed83dc32e575ae68b591d142eb38912"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83d1f079508a3ee8a2705773109a5a8e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a83d1f079508a3ee8a2705773109a5a8e">from_length</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:a83d1f079508a3ee8a2705773109a5a8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcc55b3037b4e078c4268f08dda7cf4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afcc55b3037b4e078c4268f08dda7cf4b">extend_path</a> (<a class="el" href="structvg_1_1Path.html">Path</a> &amp;path1, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path2)</td></tr>
<tr class="separator:afcc55b3037b4e078c4268f08dda7cf4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7d43d119d665bda802489b3309e0bce"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac7d43d119d665bda802489b3309e0bce">concat_paths</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path1, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path2)</td></tr>
<tr class="separator:ac7d43d119d665bda802489b3309e0bce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86653c665afe3c8932f60cc39163e202"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a86653c665afe3c8932f60cc39163e202">simplify</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;p, bool trim_internal_deletions)</td></tr>
<tr class="separator:a86653c665afe3c8932f60cc39163e202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fc7225da088d27cd1201422ba011f51"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Mapping.html">Mapping</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8fc7225da088d27cd1201422ba011f51">concat_mappings</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m, const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;n, bool trim_internal_deletions)</td></tr>
<tr class="separator:a8fc7225da088d27cd1201422ba011f51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9514446da89671007ae40e420c1297d7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Mapping.html">Mapping</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9514446da89671007ae40e420c1297d7">simplify</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m, bool trim_internal_deletions)</td></tr>
<tr class="separator:a9514446da89671007ae40e420c1297d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfba7a19cbb794cd210116be91c62d96"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abfba7a19cbb794cd210116be91c62d96">edits_are_compatible</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e, const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;f)</td></tr>
<tr class="memdesc:abfba7a19cbb794cd210116be91c62d96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if two edits could be combined into one (assuming adjacency).  <a href="namespacevg.html#abfba7a19cbb794cd210116be91c62d96">More...</a><br /></td></tr>
<tr class="separator:abfba7a19cbb794cd210116be91c62d96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20ebf02d59df03f906550e695a1aa00d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a20ebf02d59df03f906550e695a1aa00d">merge_edits_in_place</a> (<a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;e, const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;f)</td></tr>
<tr class="memdesc:a20ebf02d59df03f906550e695a1aa00d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Glom the second edit into the first, assuming adjacency.  <a href="namespacevg.html#a20ebf02d59df03f906550e695a1aa00d">More...</a><br /></td></tr>
<tr class="separator:a20ebf02d59df03f906550e695a1aa00d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30a83a9e127a0c7d75118dc14a8985f6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Mapping.html">Mapping</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a30a83a9e127a0c7d75118dc14a8985f6">merge_adjacent_edits</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="memdesc:a30a83a9e127a0c7d75118dc14a8985f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge adjacent edits of the same type.  <a href="namespacevg.html#a30a83a9e127a0c7d75118dc14a8985f6">More...</a><br /></td></tr>
<tr class="separator:a30a83a9e127a0c7d75118dc14a8985f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a990f54fb0e09dc439dace1519aff5e9f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a990f54fb0e09dc439dace1519aff5e9f">trim_hanging_ends</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;p)</td></tr>
<tr class="separator:a990f54fb0e09dc439dace1519aff5e9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af26a23818c9426d77ef25b07bbaaf605"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af26a23818c9426d77ef25b07bbaaf605">mappings_equivalent</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m1, const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m2)</td></tr>
<tr class="separator:af26a23818c9426d77ef25b07bbaaf605"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afeef6a4c023183ead5725398b14d443c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afeef6a4c023183ead5725398b14d443c">mapping_ends_in_deletion</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:afeef6a4c023183ead5725398b14d443c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa377b3e776e312c717aedec842216f48"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa377b3e776e312c717aedec842216f48">mapping_starts_in_deletion</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:aa377b3e776e312c717aedec842216f48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d10b5bc5677fdb0ae164f79848bb1bb"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6d10b5bc5677fdb0ae164f79848bb1bb">mapping_is_total_deletion</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:a6d10b5bc5677fdb0ae164f79848bb1bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8ba5042b838f859a078cf014f1a0871"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae8ba5042b838f859a078cf014f1a0871">mapping_is_simple_match</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:ae8ba5042b838f859a078cf014f1a0871"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c4a438edc31c7b0d2aa0731c522e8a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a43c4a438edc31c7b0d2aa0731c522e8a">path_is_simple_match</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;p)</td></tr>
<tr class="separator:a43c4a438edc31c7b0d2aa0731c522e8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b648cd1a51584623d6618565d3ca9c6"><td class="memItemLeft" align="right" valign="top">const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2b648cd1a51584623d6618565d3ca9c6">mapping_sequence</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mp, const string &amp;node_seq)</td></tr>
<tr class="separator:a2b648cd1a51584623d6618565d3ca9c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac23702705b681eacdfd1b3bcbc5254b5"><td class="memItemLeft" align="right" valign="top">const string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac23702705b681eacdfd1b3bcbc5254b5">mapping_sequence</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mp, const <a class="el" href="structvg_1_1Node.html">Node</a> &amp;n)</td></tr>
<tr class="separator:ac23702705b681eacdfd1b3bcbc5254b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7dc3b95a62cfd99b5fa6377c1a9545"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aad7dc3b95a62cfd99b5fa6377c1a9545">path_sequence</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:aad7dc3b95a62cfd99b5fa6377c1a9545"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ce6fa1d8f3ba4f8f361fa77a6fd5261"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Mapping.html">Mapping</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3ce6fa1d8f3ba4f8f361fa77a6fd5261">reverse_complement_mapping</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m, const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;node_length)</td></tr>
<tr class="separator:a3ce6fa1d8f3ba4f8f361fa77a6fd5261"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2dc9d6ee4403027eb5965aa6a71eb4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af2dc9d6ee4403027eb5965aa6a71eb4e">reverse_complement_mapping_in_place</a> (<a class="el" href="structvg_1_1Mapping.html">Mapping</a> *m, const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;node_length)</td></tr>
<tr class="separator:af2dc9d6ee4403027eb5965aa6a71eb4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a463d9eaed29cd6d46a8e2afb645c8fda"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a463d9eaed29cd6d46a8e2afb645c8fda">reverse_complement_path</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;node_length)</td></tr>
<tr class="separator:a463d9eaed29cd6d46a8e2afb645c8fda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2941a3c80481d02c65d9d72bd835807"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af2941a3c80481d02c65d9d72bd835807">reverse_complement_path_in_place</a> (<a class="el" href="structvg_1_1Path.html">Path</a> *path, const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;node_length)</td></tr>
<tr class="separator:af2941a3c80481d02c65d9d72bd835807"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f45a0764dcd0711bb37067151c78d6a"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structvg_1_1Mapping.html">Mapping</a>, <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4f45a0764dcd0711bb37067151c78d6a">cut_mapping</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos)</td></tr>
<tr class="separator:a4f45a0764dcd0711bb37067151c78d6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cb07d52156c2d1a3e13c566bf629760"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a>, <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1cb07d52156c2d1a3e13c566bf629760">cut_mapping</a> (const <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &amp;m, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos)</td></tr>
<tr class="separator:a1cb07d52156c2d1a3e13c566bf629760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e9091c8bf2f73d219522420a705dc1f"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structvg_1_1Mapping.html">Mapping</a>, <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9e9091c8bf2f73d219522420a705dc1f">cut_mapping_offset</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m, size_t <a class="el" href="namespacevg.html#ad48a54a3ddd5e6ffd8e3e6296fb9c037">offset</a>)</td></tr>
<tr class="separator:a9e9091c8bf2f73d219522420a705dc1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455dd0d543b21690c3e71e67ff45e57d"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a>, <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a455dd0d543b21690c3e71e67ff45e57d">cut_mapping_offset</a> (const <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &amp;m, size_t <a class="el" href="namespacevg.html#ad48a54a3ddd5e6ffd8e3e6296fb9c037">offset</a>)</td></tr>
<tr class="separator:a455dd0d543b21690c3e71e67ff45e57d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86cd2447c52bf50d938b0142bf98dc57"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structvg_1_1Mapping.html">Mapping</a>, <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a86cd2447c52bf50d938b0142bf98dc57">cut_mapping</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m, size_t <a class="el" href="namespacevg.html#ad48a54a3ddd5e6ffd8e3e6296fb9c037">offset</a>)</td></tr>
<tr class="separator:a86cd2447c52bf50d938b0142bf98dc57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af98f355163fd3a01d1d23c978fa1dbd3"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a>, <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af98f355163fd3a01d1d23c978fa1dbd3">cut_mapping</a> (const <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &amp;m, size_t <a class="el" href="namespacevg.html#ad48a54a3ddd5e6ffd8e3e6296fb9c037">offset</a>)</td></tr>
<tr class="separator:af98f355163fd3a01d1d23c978fa1dbd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0456e049dd685a689886372f4b0a354d"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structvg_1_1Path.html">Path</a>, <a class="el" href="structvg_1_1Path.html">Path</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0456e049dd685a689886372f4b0a354d">cut_path</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos)</td></tr>
<tr class="separator:a0456e049dd685a689886372f4b0a354d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dbdbb650e0a076cd3890c2a74515260"><td class="memItemLeft" align="right" valign="top">pair&lt; <a class="el" href="structvg_1_1Path.html">Path</a>, <a class="el" href="structvg_1_1Path.html">Path</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1dbdbb650e0a076cd3890c2a74515260">cut_path</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, size_t <a class="el" href="namespacevg.html#ad48a54a3ddd5e6ffd8e3e6296fb9c037">offset</a>)</td></tr>
<tr class="separator:a1dbdbb650e0a076cd3890c2a74515260"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a242b97c26d74e9fc05ad16c31b21dcca"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a242b97c26d74e9fc05ad16c31b21dcca">maps_to_node</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;p, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="separator:a242b97c26d74e9fc05ad16c31b21dcca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c3b1708b878655d0f6a50a2ba589bf9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2c3b1708b878655d0f6a50a2ba589bf9">path_start_position</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:a2c3b1708b878655d0f6a50a2ba589bf9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbe0993e79f4ef7bb4b37456b0b08402"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afbe0993e79f4ef7bb4b37456b0b08402">path_to_string</a> (<a class="el" href="structvg_1_1Path.html">Path</a> p)</td></tr>
<tr class="separator:afbe0993e79f4ef7bb4b37456b0b08402"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af505a96db454fbd06e026f11cb6fbfba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af505a96db454fbd06e026f11cb6fbfba">path_end_position</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:af505a96db454fbd06e026f11cb6fbfba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92de94b4571057762bb3152de1376e51"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a92de94b4571057762bb3152de1376e51">adjacent_mappings</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m1, const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m2)</td></tr>
<tr class="separator:a92de94b4571057762bb3152de1376e51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78ea8a2cf04759a3cfecbe4bf3e926c2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a78ea8a2cf04759a3cfecbe4bf3e926c2">mapping_is_match</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:a78ea8a2cf04759a3cfecbe4bf3e926c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3b0a534daaa4c4eb7204b139fbbe3b7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad3b0a534daaa4c4eb7204b139fbbe3b7">divergence</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;m)</td></tr>
<tr class="separator:ad3b0a534daaa4c4eb7204b139fbbe3b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3c5c7a407962a8c735c1d533cc0b186"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab3c5c7a407962a8c735c1d533cc0b186">identity</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:ab3c5c7a407962a8c735c1d533cc0b186"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90fe8f4de1196dd902ac05f7567b9b7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a90fe8f4de1196dd902ac05f7567b9b7b">decompose</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, map&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, int &gt; &amp;ref_positions, map&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, <a class="el" href="structvg_1_1Edit.html">Edit</a> &gt; &amp;edits)</td></tr>
<tr class="separator:a90fe8f4de1196dd902ac05f7567b9b7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac70d8b120ca61591561cba307dcc1b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aaac70d8b120ca61591561cba307dcc1b">overlap</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;p1, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;p2)</td></tr>
<tr class="separator:aaac70d8b120ca61591561cba307dcc1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af71770196fc31c2e3c9c2a83f3497177"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af71770196fc31c2e3c9c2a83f3497177">translate_node_ids</a> (<a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;translator)</td></tr>
<tr class="memdesc:af71770196fc31c2e3c9c2a83f3497177"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches the node ids in the path to the ones indicated by the translator.  <a href="namespacevg.html#af71770196fc31c2e3c9c2a83f3497177">More...</a><br /></td></tr>
<tr class="separator:af71770196fc31c2e3c9c2a83f3497177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa49e4506c94e5747c88805e39aa18090"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa49e4506c94e5747c88805e39aa18090">translate_node_ids</a> (<a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;translator, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> cut_node, size_t bases_removed, bool from_right)</td></tr>
<tr class="separator:aa49e4506c94e5747c88805e39aa18090"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b0ba7a1d0cf7630b79d03ba0ab65c53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2b0ba7a1d0cf7630b79d03ba0ab65c53">translate_oriented_node_ids</a> (<a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;translator)</td></tr>
<tr class="memdesc:a2b0ba7a1d0cf7630b79d03ba0ab65c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches the node ids and orientations in the path to the ones indicated by the translator.  <a href="namespacevg.html#a2b0ba7a1d0cf7630b79d03ba0ab65c53">More...</a><br /></td></tr>
<tr class="separator:a2b0ba7a1d0cf7630b79d03ba0ab65c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb86c984b743e10c6ddaa57612ca3991"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acb86c984b743e10c6ddaa57612ca3991">translate_oriented_node_ids</a> (<a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;translator)</td></tr>
<tr class="memdesc:acb86c984b743e10c6ddaa57612ca3991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Switches node ids and orientations in the path to the ones indicated by the translator.  <a href="namespacevg.html#acb86c984b743e10c6ddaa57612ca3991">More...</a><br /></td></tr>
<tr class="separator:acb86c984b743e10c6ddaa57612ca3991"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a322ec292675d4891ecc265e56a836db7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a322ec292675d4891ecc265e56a836db7">translate_node_ids</a> (<a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;path, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;translator)</td></tr>
<tr class="separator:a322ec292675d4891ecc265e56a836db7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a449dd4b0d7106c6ee7afceb4f7412d6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a449dd4b0d7106c6ee7afceb4f7412d6d">translate_oriented_node_ids</a> (<a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;path, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;translator)</td></tr>
<tr class="separator:a449dd4b0d7106c6ee7afceb4f7412d6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfebb6e72326ea81b2ed13b4c3b57885"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abfebb6e72326ea81b2ed13b4c3b57885">translate_oriented_node_ids</a> (<a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;path, const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;translator)</td></tr>
<tr class="separator:abfebb6e72326ea81b2ed13b4c3b57885"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd31d3a8dc67801f147d0ba1b0059c3f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acd31d3a8dc67801f147d0ba1b0059c3f">initial_position</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:acd31d3a8dc67801f147d0ba1b0059c3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad435098725ff21d822052abee009d2bd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad435098725ff21d822052abee009d2bd">final_position</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:ad435098725ff21d822052abee009d2bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aef5ee16ad883f8defeaa0f52fc342c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3aef5ee16ad883f8defeaa0f52fc342c">path_from_node_traversals</a> (const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;traversals)</td></tr>
<tr class="separator:a3aef5ee16ad883f8defeaa0f52fc342c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e16e94675197650b9d6edb9e7a9081"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad5e16e94675197650b9d6edb9e7a9081">remove_paths</a> (<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;graph, const function&lt; bool(const string &amp;)&gt; &amp;paths_to_take, std::list&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; *matching)</td></tr>
<tr class="separator:ad5e16e94675197650b9d6edb9e7a9081"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a864fe6e3e163b18e84db0783f9a2e17d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a864fe6e3e163b18e84db0783f9a2e17d">path_from_path_handle</a> (const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;graph, <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> path_handle)</td></tr>
<tr class="separator:a864fe6e3e163b18e84db0783f9a2e17d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcf3c5c3332d721a86740ef23fb9e6e2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abcf3c5c3332d721a86740ef23fb9e6e2">alignment_from_path</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path)</td></tr>
<tr class="separator:abcf3c5c3332d721a86740ef23fb9e6e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b8b4c6f298818989d39189d631980a8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4b8b4c6f298818989d39189d631980a8">from_proto_edit</a> (const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;proto_edit, <a class="el" href="classvg_1_1edit__t.html">edit_t</a> &amp;edit)</td></tr>
<tr class="separator:a4b8b4c6f298818989d39189d631980a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84c5dd6c830450f9100b5e9c11522050"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a84c5dd6c830450f9100b5e9c11522050">to_proto_edit</a> (const <a class="el" href="classvg_1_1edit__t.html">edit_t</a> &amp;edit, <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;proto_edit)</td></tr>
<tr class="separator:a84c5dd6c830450f9100b5e9c11522050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e6878ce34057ea3c8e8c0deacc1726b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1e6878ce34057ea3c8e8c0deacc1726b">from_proto_mapping</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;proto_mapping, <a class="el" href="classvg_1_1path__mapping__t.html">path_mapping_t</a> &amp;mapping)</td></tr>
<tr class="separator:a1e6878ce34057ea3c8e8c0deacc1726b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3da977cb90bf3ffd94166edb2fdb980a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3da977cb90bf3ffd94166edb2fdb980a">to_proto_mapping</a> (const <a class="el" href="classvg_1_1path__mapping__t.html">path_mapping_t</a> &amp;mapping, <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;proto_mapping)</td></tr>
<tr class="separator:a3da977cb90bf3ffd94166edb2fdb980a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01ce1f20da22c85b09e4bae9bf9a3d1f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a01ce1f20da22c85b09e4bae9bf9a3d1f">from_proto_path</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;proto_path, <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;path)</td></tr>
<tr class="separator:a01ce1f20da22c85b09e4bae9bf9a3d1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9473b834c584544cc90c819d6b5bb222"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9473b834c584544cc90c819d6b5bb222">to_proto_path</a> (const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;path, <a class="el" href="structvg_1_1Path.html">Path</a> &amp;proto_path)</td></tr>
<tr class="separator:a9473b834c584544cc90c819d6b5bb222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a151a868062bd12ac34b9aea68dc8d4f0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a151a868062bd12ac34b9aea68dc8d4f0">mapping_from_length</a> (const <a class="el" href="classvg_1_1path__mapping__t.html">path_mapping_t</a> &amp;mapping)</td></tr>
<tr class="separator:a151a868062bd12ac34b9aea68dc8d4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae87f325eb11aaf966e6d77d99be40c54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae87f325eb11aaf966e6d77d99be40c54">path_from_length</a> (const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;path)</td></tr>
<tr class="separator:ae87f325eb11aaf966e6d77d99be40c54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f709a91987a7d669b3974fa00aa8ecd"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3f709a91987a7d669b3974fa00aa8ecd">mapping_to_length</a> (const <a class="el" href="classvg_1_1path__mapping__t.html">path_mapping_t</a> &amp;mapping)</td></tr>
<tr class="separator:a3f709a91987a7d669b3974fa00aa8ecd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b3cfa2fc1c70ce96f7ebc695c8766d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a16b3cfa2fc1c70ce96f7ebc695c8766d">path_to_length</a> (const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;path)</td></tr>
<tr class="separator:a16b3cfa2fc1c70ce96f7ebc695c8766d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc9bd04ab1099c6d9bd655a2accbe52e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abc9bd04ab1099c6d9bd655a2accbe52e">reverse_complement_mapping_in_place</a> (<a class="el" href="classvg_1_1path__mapping__t.html">path_mapping_t</a> *m, const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;node_length)</td></tr>
<tr class="separator:abc9bd04ab1099c6d9bd655a2accbe52e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a798565f048dc7844739ea4913d950d31"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1path__mapping__t.html">path_mapping_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a798565f048dc7844739ea4913d950d31">reverse_complement_mapping</a> (const <a class="el" href="classvg_1_1path__mapping__t.html">path_mapping_t</a> &amp;m, const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;node_length)</td></tr>
<tr class="separator:a798565f048dc7844739ea4913d950d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3df9f25ec47163ccbfa328673bd28ab5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1path__t.html">path_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3df9f25ec47163ccbfa328673bd28ab5">reverse_complement_path</a> (const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;path, const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;node_length)</td></tr>
<tr class="separator:a3df9f25ec47163ccbfa328673bd28ab5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df8f9c5838119e79ee1f671cd823740"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0df8f9c5838119e79ee1f671cd823740">reverse_complement_path_in_place</a> (<a class="el" href="classvg_1_1path__t.html">path_t</a> *path, const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;node_length)</td></tr>
<tr class="separator:a0df8f9c5838119e79ee1f671cd823740"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5273bbd5e5d0f9bbf639c19c962a58dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5273bbd5e5d0f9bbf639c19c962a58dd">initial_position</a> (const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;path)</td></tr>
<tr class="separator:a5273bbd5e5d0f9bbf639c19c962a58dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28e15d36e2ee202f8a194cca31d91d65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a28e15d36e2ee202f8a194cca31d91d65">final_position</a> (const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;path)</td></tr>
<tr class="separator:a28e15d36e2ee202f8a194cca31d91d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a472702e0931449cfaa10a337d7119d63"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a472702e0931449cfaa10a337d7119d63">debug_string</a> (const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;path)</td></tr>
<tr class="separator:a472702e0931449cfaa10a337d7119d63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11592884d28d3865ea95f76232e2fed4"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a11592884d28d3865ea95f76232e2fed4">debug_string</a> (const <a class="el" href="classvg_1_1path__mapping__t.html">path_mapping_t</a> &amp;mapping)</td></tr>
<tr class="separator:a11592884d28d3865ea95f76232e2fed4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51469d56a6d4e55660c15af135c92b46"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a51469d56a6d4e55660c15af135c92b46">debug_string</a> (const <a class="el" href="classvg_1_1edit__t.html">edit_t</a> &amp;edit)</td></tr>
<tr class="separator:a51469d56a6d4e55660c15af135c92b46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9dffafa4fdd05242ff4b73f5aafedd95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9dffafa4fdd05242ff4b73f5aafedd95">corresponding_length_internal</a> (const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;path, int given_length, bool is_from_length, bool from_end)</td></tr>
<tr class="separator:a9dffafa4fdd05242ff4b73f5aafedd95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fa02fa34866aee06ca1e3cead896b8d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1fa02fa34866aee06ca1e3cead896b8d">corresponding_to_length</a> (const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;path, int <a class="el" href="namespacevg.html#a83d1f079508a3ee8a2705773109a5a8e">from_length</a>, bool from_end)</td></tr>
<tr class="separator:a1fa02fa34866aee06ca1e3cead896b8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d3002d98148b82b4f395c7b625b892"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a84d3002d98148b82b4f395c7b625b892">corresponding_from_length</a> (const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;path, int <a class="el" href="namespacevg.html#a5ed83dc32e575ae68b591d142eb38912">to_length</a>, bool from_end)</td></tr>
<tr class="separator:a84d3002d98148b82b4f395c7b625b892"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa6175557c33cd572b8726222cf6547"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9fa6175557c33cd572b8726222cf6547">increment_node_mapping_ids</a> (<a class="el" href="structvg_1_1Path.html">Path</a> &amp;p, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> inc)</td></tr>
<tr class="separator:a9fa6175557c33cd572b8726222cf6547"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b5ffc03255d72f1901a7b1ce34c058a"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1Paths.html">Paths</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1b5ffc03255d72f1901a7b1ce34c058a">paths_from_graph</a> (<a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;g)</td></tr>
<tr class="separator:a1b5ffc03255d72f1901a7b1ce34c058a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c9985bf70965bd36bb54f910ab74e3b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2c9985bf70965bd36bb54f910ab74e3b">merge_adjacent_edits</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;m)</td></tr>
<tr class="memdesc:a2c9985bf70965bd36bb54f910ab74e3b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge adjacent edits of the same type.  <a href="namespacevg.html#a2c9985bf70965bd36bb54f910ab74e3b">More...</a><br /></td></tr>
<tr class="separator:a2c9985bf70965bd36bb54f910ab74e3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bd8aa63fec8b9f6c3ed5808689975e6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">vg::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3bd8aa63fec8b9f6c3ed5808689975e6">path_node</a> (const vector&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">vg::id_t</a>, bool &gt;&gt; &amp;path, size_t i)</td></tr>
<tr class="separator:a3bd8aa63fec8b9f6c3ed5808689975e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6bdd8e00dd9f63a0d9049ffe3461d47"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">vg::id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac6bdd8e00dd9f63a0d9049ffe3461d47">path_node</a> (const gbwt::vector_type &amp;path, size_t i)</td></tr>
<tr class="separator:ac6bdd8e00dd9f63a0d9049ffe3461d47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae876005c9e34df70bdc9e2e97776121"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aae876005c9e34df70bdc9e2e97776121">path_size</a> (const vector&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">vg::id_t</a>, bool &gt;&gt; &amp;path)</td></tr>
<tr class="separator:aae876005c9e34df70bdc9e2e97776121"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c911ba34849a4afd407812fe6373579"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0c911ba34849a4afd407812fe6373579">path_size</a> (const gbwt::vector_type &amp;path)</td></tr>
<tr class="separator:a0c911ba34849a4afd407812fe6373579"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8fcec2fbe4151075a0b33bc6a0dd145"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae8fcec2fbe4151075a0b33bc6a0dd145">path_reverse</a> (const vector&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">vg::id_t</a>, bool &gt;&gt; &amp;path, size_t i)</td></tr>
<tr class="separator:ae8fcec2fbe4151075a0b33bc6a0dd145"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0439b7fcf30da565152d9800ff4473d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa0439b7fcf30da565152d9800ff4473d">path_reverse</a> (const gbwt::vector_type &amp;path, size_t i)</td></tr>
<tr class="separator:aa0439b7fcf30da565152d9800ff4473d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e7a5fc9017560cc1b505641cc4ef6d0"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1e7a5fc9017560cc1b505641cc4ef6d0">operator&lt;&lt;</a> (std::ostream &amp;out, <a class="el" href="structvg_1_1PathBranch.html">PathBranch</a> branch)</td></tr>
<tr class="separator:a1e7a5fc9017560cc1b505641cc4ef6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ed0a4f26673002b2081832a7602e9bd"><td class="memTemplParams" colspan="2">template&lt;class PathType &gt; </td></tr>
<tr class="memitem:a3ed0a4f26673002b2081832a7602e9bd"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3ed0a4f26673002b2081832a7602e9bd">verify_path</a> (const PathType &amp;path, <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;unfolded, const <a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">vg::id_t</a>, std::vector&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">vg::id_t</a> &gt;&gt; &amp;reverse_mapping)</td></tr>
<tr class="separator:a3ed0a4f26673002b2081832a7602e9bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bf8f408b11966feb9695d4bb723dfac"><td class="memTemplParams" colspan="2">template&lt;class Decoder &gt; </td></tr>
<tr class="memitem:a8bf8f408b11966feb9695d4bb723dfac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8bf8f408b11966feb9695d4bb723dfac">printId</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">vg::id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="separator:a8bf8f408b11966feb9695d4bb723dfac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74563bc5f9f3268b9a933688ad1a5edb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1PhaseUnfolder.html#a402b0f84990279594bfbb1cd71ffd8e5">PhaseUnfolder::path_type</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a74563bc5f9f3268b9a933688ad1a5edb">canonical_orientation</a> (const <a class="el" href="classvg_1_1PhaseUnfolder.html#a402b0f84990279594bfbb1cd71ffd8e5">PhaseUnfolder::path_type</a> &amp;path, bool &amp;from_border, bool &amp;to_border)</td></tr>
<tr class="separator:a74563bc5f9f3268b9a933688ad1a5edb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9f0a2379194fb00d706e90d373b378"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2d9f0a2379194fb00d706e90d373b378">make_pos_t</a> (const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos)</td></tr>
<tr class="memdesc:a2d9f0a2379194fb00d706e90d373b378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a <a class="el" href="structvg_1_1Position.html">Position</a> to a (much smaller) pos_t.  <a href="namespacevg.html#a2d9f0a2379194fb00d706e90d373b378">More...</a><br /></td></tr>
<tr class="separator:a2d9f0a2379194fb00d706e90d373b378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b348dcfac955a7030a3721f436e7d5d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1b348dcfac955a7030a3721f436e7d5d">make_pos_t</a> (const <a class="el" href="classvg_1_1position__t.html">position_t</a> &amp;pos)</td></tr>
<tr class="separator:a1b348dcfac955a7030a3721f436e7d5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc066dab7543192bf782959ef160f2d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afc066dab7543192bf782959ef160f2d4">make_pos_t</a> (gcsa::node_type node)</td></tr>
<tr class="memdesc:afc066dab7543192bf782959ef160f2d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pos_t from a gcsa node.  <a href="namespacevg.html#afc066dab7543192bf782959ef160f2d4">More...</a><br /></td></tr>
<tr class="separator:afc066dab7543192bf782959ef160f2d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6247de8deb27aaabf2bc0d6fc755f693"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6247de8deb27aaabf2bc0d6fc755f693">make_position</a> (const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;pos)</td></tr>
<tr class="memdesc:a6247de8deb27aaabf2bc0d6fc755f693"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a pos_t to a <a class="el" href="structvg_1_1Position.html">Position</a>.  <a href="namespacevg.html#a6247de8deb27aaabf2bc0d6fc755f693">More...</a><br /></td></tr>
<tr class="separator:a6247de8deb27aaabf2bc0d6fc755f693"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6af3d55800703f7534ca07a84450580"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac6af3d55800703f7534ca07a84450580">make_position</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, bool <a class="el" href="namespacevg.html#aac725dd44bc5a8f540554d4b1882c1fe">is_rev</a>, <a class="el" href="namespacevg.html#afe223f2c7890c76de5e00b43ceb37add">offset_t</a> off)</td></tr>
<tr class="memdesc:ac6af3d55800703f7534ca07a84450580"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a <a class="el" href="structvg_1_1Position.html">Position</a> from a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a> ID, an orientation flag, and an offset along that strand of the node.  <a href="namespacevg.html#ac6af3d55800703f7534ca07a84450580">More...</a><br /></td></tr>
<tr class="separator:ac6af3d55800703f7534ca07a84450580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cdd9b08b7b6d6e15d00536554f3ca56"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4cdd9b08b7b6d6e15d00536554f3ca56">make_position</a> (gcsa::node_type node)</td></tr>
<tr class="memdesc:a4cdd9b08b7b6d6e15d00536554f3ca56"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="structvg_1_1Position.html">Position</a> from a gcsa node.  <a href="namespacevg.html#a4cdd9b08b7b6d6e15d00536554f3ca56">More...</a><br /></td></tr>
<tr class="separator:a4cdd9b08b7b6d6e15d00536554f3ca56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91adfc6327b5709dc73fcc7edbe5da57"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Position.html">Position</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a91adfc6327b5709dc73fcc7edbe5da57">reverse</a> (const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;pos, size_t node_length)</td></tr>
<tr class="separator:a91adfc6327b5709dc73fcc7edbe5da57"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a973bf2647d54324bc63c323a0aa29a35"><td class="memItemLeft" align="right" valign="top">pair&lt; int64_t, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a973bf2647d54324bc63c323a0aa29a35">min_oriented_distances</a> (const unordered_map&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; &amp;path_offsets1, const unordered_map&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; &amp;path_offsets2)</td></tr>
<tr class="memdesc:a973bf2647d54324bc63c323a0aa29a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find the min distance in the path offsets where the path orientation is the same and different.  <a href="namespacevg.html#a973bf2647d54324bc63c323a0aa29a35">More...</a><br /></td></tr>
<tr class="separator:a973bf2647d54324bc63c323a0aa29a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99864b7ad9781d2c41c424ae69187e2e"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a99864b7ad9781d2c41c424ae69187e2e">debug_string</a> (const <a class="el" href="classvg_1_1position__t.html">position_t</a> &amp;pos)</td></tr>
<tr class="separator:a99864b7ad9781d2c41c424ae69187e2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d3ba6e34f59b610d86a84d0d6c32d1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae7d3ba6e34f59b610d86a84d0d6c32d1">from_proto_position</a> (const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;from, <a class="el" href="classvg_1_1position__t.html">position_t</a> &amp;to)</td></tr>
<tr class="separator:ae7d3ba6e34f59b610d86a84d0d6c32d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ac31e5878660a97207b6ade1418c81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a65ac31e5878660a97207b6ade1418c81">preflight_check</a> ()</td></tr>
<tr class="separator:a65ac31e5878660a97207b6ade1418c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35d8d71a9d6d51760cc7354910d029e9"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a35d8d71a9d6d51760cc7354910d029e9">operator&lt;&lt;</a> (ostream &amp;os, const <a class="el" href="structvg_1_1Counts.html">Counts</a> &amp;counts)</td></tr>
<tr class="separator:a35d8d71a9d6d51760cc7354910d029e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9aadb20454b27a0819f40006556ffe6"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae9aadb20454b27a0819f40006556ffe6">to_string</a> (<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> handle)</td></tr>
<tr class="separator:ae9aadb20454b27a0819f40006556ffe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdd5134ae715117de1b7ba9283fa8651"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="structvg_1_1Haplotypes_1_1Subchain.html#a13b4b76384742f4ee127b52faff37aa6">Haplotypes::Subchain::kmer_type</a>, size_t &gt;::iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afdd5134ae715117de1b7ba9283fa8651">find_kmer</a> (<a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="structvg_1_1Haplotypes_1_1Subchain.html#a13b4b76384742f4ee127b52faff37aa6">Haplotypes::Subchain::kmer_type</a>, size_t &gt; &amp;counts, <a class="el" href="structvg_1_1Haplotypes_1_1Subchain.html#a13b4b76384742f4ee127b52faff37aa6">Haplotypes::Subchain::kmer_type</a> kmer, size_t k)</td></tr>
<tr class="separator:afdd5134ae715117de1b7ba9283fa8651"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaac16668663556af1aea74159a73d4ed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aaac16668663556af1aea74159a73d4ed">sa_to_da</a> (std::vector&lt; <a class="el" href="classvg_1_1HaplotypePartitioner.html#aa06fc618c54377342c05b7306b8dec72">HaplotypePartitioner::sequence_type</a> &gt; &amp;sequences, const gbwt::FastLocate &amp;r_index)</td></tr>
<tr class="separator:aaac16668663556af1aea74159a73d4ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a117021c748aad14cfa190bbd2452405d"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a117021c748aad14cfa190bbd2452405d">generate_haplotype</a> (gbwt::edge_type pos, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> end, size_t start_max, size_t end_max, const gbwtgraph::GBWTGraph &amp;graph)</td></tr>
<tr class="separator:a117021c748aad14cfa190bbd2452405d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc64443321ef5b17233dac0ca11e98ed"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="classvg_1_1HaplotypePartitioner.html#a2780337120cfec8463356829af22aa97">HaplotypePartitioner::kmer_type</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afc64443321ef5b17233dac0ca11e98ed">take_unique_minimizers</a> (const std::string &amp;sequence, const gbwtgraph::DefaultMinimizerIndex &amp;minimizer_index)</td></tr>
<tr class="separator:afc64443321ef5b17233dac0ca11e98ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a348af3d255543b4880fc1240e8ef442f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a348af3d255543b4880fc1240e8ef442f">present_kmers</a> (const std::vector&lt; std::vector&lt; <a class="el" href="classvg_1_1HaplotypePartitioner.html#a2780337120cfec8463356829af22aa97">HaplotypePartitioner::kmer_type</a> &gt;&gt; &amp;sequences, std::vector&lt; std::pair&lt; <a class="el" href="classvg_1_1HaplotypePartitioner.html#a2780337120cfec8463356829af22aa97">HaplotypePartitioner::kmer_type</a>, size_t &gt;&gt; &amp;all_kmers, sdsl::bit_vector &amp;kmers_present)</td></tr>
<tr class="separator:a348af3d255543b4880fc1240e8ef442f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4043431a579c18af5497acef2f414710"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4043431a579c18af5497acef2f414710">add_path</a> (const gbwt::GBWT &amp;source, gbwt::size_type path_id, gbwt::GBWTBuilder &amp;builder)</td></tr>
<tr class="separator:a4043431a579c18af5497acef2f414710"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a253257615743a1cfb948b749be7700e2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a253257615743a1cfb948b749be7700e2">parse_region</a> (const string &amp;target, string &amp;name, int64_t &amp;start, int64_t &amp;end)</td></tr>
<tr class="separator:a253257615743a1cfb948b749be7700e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fd1e3436d98304996aaecece048cb45"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8fd1e3436d98304996aaecece048cb45">parse_bed_regions</a> (const string &amp;bed_path, vector&lt; <a class="el" href="structvg_1_1Region.html">Region</a> &gt; &amp;out_regions, vector&lt; string &gt; *out_names)</td></tr>
<tr class="separator:a8fd1e3436d98304996aaecece048cb45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0a3beb8908adf7a6e4d641243937830"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af0a3beb8908adf7a6e4d641243937830">parse_region</a> (string &amp;region, <a class="el" href="structvg_1_1Region.html">Region</a> &amp;out_region)</td></tr>
<tr class="separator:af0a3beb8908adf7a6e4d641243937830"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a33db744c41ff651da5dacda9578712"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9a33db744c41ff651da5dacda9578712">position_at</a> (<a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *graph_ptr, const string &amp;path_name, const size_t &amp;path_offset, bool is_reverse)</td></tr>
<tr class="separator:a9a33db744c41ff651da5dacda9578712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ec65dd3bb34f37cff811f49c1b9599"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad7ec65dd3bb34f37cff811f49c1b9599">to_string</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> handle)</td></tr>
<tr class="separator:ad7ec65dd3bb34f37cff811f49c1b9599"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75bc48248af00118bc7cdacc00e37db1"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a75bc48248af00118bc7cdacc00e37db1">to_string</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, <a class="el" href="namespacevg.html#a3de8fe5f38b1730a36af4ad9c4258963">edge_t</a> edge)</td></tr>
<tr class="separator:a75bc48248af00118bc7cdacc00e37db1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcbcd550b51078ae43f2b1d87941e1a0"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abcbcd550b51078ae43f2b1d87941e1a0">minimum_distance</a> (const SnarlDistanceIndex &amp;distance_index, <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> pos1, <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> pos2, bool unoriented_distance, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="separator:abcbcd550b51078ae43f2b1d87941e1a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a004ed92d4db665ce8ec4e527f150a7c4"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a004ed92d4db665ce8ec4e527f150a7c4">maximum_distance</a> (const SnarlDistanceIndex &amp;distance_index, <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> pos1, <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> pos2)</td></tr>
<tr class="separator:a004ed92d4db665ce8ec4e527f150a7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac146be1a4fdd34ea5731dfa640e21aab"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac146be1a4fdd34ea5731dfa640e21aab">fill_in_distance_index</a> (SnarlDistanceIndex *distance_index, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, const <a class="el" href="classvg_1_1HandleGraphSnarlFinder.html">HandleGraphSnarlFinder</a> *snarl_finder, size_t size_limit)</td></tr>
<tr class="separator:ac146be1a4fdd34ea5731dfa640e21aab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eec172f798f421f4d059e5c51d6d9ce"><td class="memItemLeft" align="right" valign="top">SnarlDistanceIndex::TemporaryDistanceIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7eec172f798f421f4d059e5c51d6d9ce">make_temporary_distance_index</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, const <a class="el" href="classvg_1_1HandleGraphSnarlFinder.html">HandleGraphSnarlFinder</a> *snarl_finder, size_t size_limit)</td></tr>
<tr class="separator:a7eec172f798f421f4d059e5c51d6d9ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a909f1da1c571aa4c8a82b2e48ac915b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a909f1da1c571aa4c8a82b2e48ac915b2">populate_snarl_index</a> (SnarlDistanceIndex::TemporaryDistanceIndex &amp;temp_index, pair&lt; SnarlDistanceIndex::temp_record_t, size_t &gt; snarl_index, size_t size_limit, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph)</td></tr>
<tr class="separator:a909f1da1c571aa4c8a82b2e48ac915b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff8a7aca57dd525bc2def1369abae3fe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aff8a7aca57dd525bc2def1369abae3fe">subgraph_in_distance_range</a> (const SnarlDistanceIndex &amp;distance_index, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *super_graph, size_t min_distance, size_t max_distance, std::unordered_set&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;subgraph, bool look_forward)</td></tr>
<tr class="separator:aff8a7aca57dd525bc2def1369abae3fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0312bffc43a4f4176aad1c37073b59df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0312bffc43a4f4176aad1c37073b59df">subgraph_in_distance_range_walk_graph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *super_graph, size_t min_distance, size_t max_distance, std::unordered_set&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;subgraph, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, size_t &gt;&gt; &amp;start_nodes, <a class="el" href="classvg_1_1hash__set.html">hash_set</a>&lt; pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt;&gt; &amp;seen_nodes, const pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &amp;traversal_start)</td></tr>
<tr class="separator:a0312bffc43a4f4176aad1c37073b59df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30f08b56f8c117103357ed4b8ebc08b8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a30f08b56f8c117103357ed4b8ebc08b8">subgraph_in_distance_range_walk_across_chain</a> (const SnarlDistanceIndex &amp;distance_index, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *super_graph, std::unordered_set&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;subgraph, <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> current_node, size_t current_distance, vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, size_t &gt;&gt; &amp;search_start_nodes, <a class="el" href="classvg_1_1hash__set.html">hash_set</a>&lt; pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt;&gt; &amp;seen_nodes, const size_t &amp;min_distance, const size_t &amp;max_distance, bool checked_loop)</td></tr>
<tr class="separator:a30f08b56f8c117103357ed4b8ebc08b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc960c295c1e3088dc8e71ab1af5c4d6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acc960c295c1e3088dc8e71ab1af5c4d6">subgraph_containing_path_snarls</a> (const SnarlDistanceIndex &amp;distance_index, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, std::unordered_set&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;subgraph)</td></tr>
<tr class="separator:acc960c295c1e3088dc8e71ab1af5c4d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e91a5d33d2da100b1173bc336ea90ff"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9e91a5d33d2da100b1173bc336ea90ff">add_descendants_to_subgraph</a> (const SnarlDistanceIndex &amp;distance_index, const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;parent, std::unordered_set&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;subgraph)</td></tr>
<tr class="separator:a9e91a5d33d2da100b1173bc336ea90ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13a0b0f632813ff45251135b2b4510c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1MIPayloadValues.html">MIPayloadValues</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a13a0b0f632813ff45251135b2b4510c0">get_minimizer_distances</a> (const SnarlDistanceIndex &amp;distance_index, <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> pos)</td></tr>
<tr class="separator:a13a0b0f632813ff45251135b2b4510c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43f061abac718e0386965aa537398e74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a43f061abac718e0386965aa537398e74">start_backward</a> (const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;chain)</td></tr>
<tr class="separator:a43f061abac718e0386965aa537398e74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acab8d2ef076a0e866c7849aace290124"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acab8d2ef076a0e866c7849aace290124">end_backward</a> (const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;chain)</td></tr>
<tr class="separator:acab8d2ef076a0e866c7849aace290124"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa918cf29c1c8238d88f2bbc94b6abef"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afa918cf29c1c8238d88f2bbc94b6abef">get_start_of</a> (const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;chain)</td></tr>
<tr class="separator:afa918cf29c1c8238d88f2bbc94b6abef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af76e8a5e74f67093a40ed5f2cd15ff28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af76e8a5e74f67093a40ed5f2cd15ff28">get_end_of</a> (const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;chain)</td></tr>
<tr class="separator:af76e8a5e74f67093a40ed5f2cd15ff28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3b14246f4fe83e3fbdadb1ba838faeb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac3b14246f4fe83e3fbdadb1ba838faeb">chain_begin</a> (const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;chain)</td></tr>
<tr class="separator:ac3b14246f4fe83e3fbdadb1ba838faeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0612d7af2f7366ff81c89824f43a5865"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0612d7af2f7366ff81c89824f43a5865">chain_end</a> (const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;chain)</td></tr>
<tr class="separator:a0612d7af2f7366ff81c89824f43a5865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa24387fbb4606765c23a280316bfcb65"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa24387fbb4606765c23a280316bfcb65">chain_rbegin</a> (const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;chain)</td></tr>
<tr class="separator:aa24387fbb4606765c23a280316bfcb65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c65134c67609a001a61291b22337f8d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2c65134c67609a001a61291b22337f8d">chain_rend</a> (const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;chain)</td></tr>
<tr class="separator:a2c65134c67609a001a61291b22337f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aed054b974860f2cc4d5be4b7615de0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7aed054b974860f2cc4d5be4b7615de0">chain_rcbegin</a> (const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;chain)</td></tr>
<tr class="separator:a7aed054b974860f2cc4d5be4b7615de0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1369d5e29159750fd14482f73421660"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae1369d5e29159750fd14482f73421660">chain_rcend</a> (const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;chain)</td></tr>
<tr class="separator:ae1369d5e29159750fd14482f73421660"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefacc656d2c444dfd6e0e445218265cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aefacc656d2c444dfd6e0e445218265cc">chain_begin_from</a> (const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;chain, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *start_snarl, bool snarl_orientation)</td></tr>
<tr class="separator:aefacc656d2c444dfd6e0e445218265cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0627b5d536b881a355d8b419b6f329c6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0627b5d536b881a355d8b419b6f329c6">chain_end_from</a> (const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;chain, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *start_snarl, bool snarl_orientation)</td></tr>
<tr class="separator:a0627b5d536b881a355d8b419b6f329c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1da5277daea16b80ffc4ab75175b1882"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a3de8fe5f38b1730a36af4ad9c4258963">edge_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1da5277daea16b80ffc4ab75175b1882">to_edge</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">handlegraph::HandleGraph</a> &amp;graph, const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;v1, const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;v2)</td></tr>
<tr class="memdesc:a1da5277daea16b80ffc4ab75175b1882"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make an edge_t from a pair of visits.  <a href="namespacevg.html#a1da5277daea16b80ffc4ab75175b1882">More...</a><br /></td></tr>
<tr class="separator:a1da5277daea16b80ffc4ab75175b1882"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b890a4bc73725bbea08984d7510df4"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a87b890a4bc73725bbea08984d7510df4">operator==</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;a, const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;b)</td></tr>
<tr class="separator:a87b890a4bc73725bbea08984d7510df4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb6063b76b70947010198b46c053b578"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abb6063b76b70947010198b46c053b578">operator!=</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;a, const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;b)</td></tr>
<tr class="separator:abb6063b76b70947010198b46c053b578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2e2066b3b4534b62cde6e4423efd81"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9d2e2066b3b4534b62cde6e4423efd81">operator&lt;</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;a, const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;b)</td></tr>
<tr class="separator:a9d2e2066b3b4534b62cde6e4423efd81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab38d6991537581f9ce3f4c549f966a33"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab38d6991537581f9ce3f4c549f966a33">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit)</td></tr>
<tr class="separator:ab38d6991537581f9ce3f4c549f966a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a845213e6efb7204868c05afcae9c926f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a845213e6efb7204868c05afcae9c926f">operator==</a> (const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;a, const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;b)</td></tr>
<tr class="separator:a845213e6efb7204868c05afcae9c926f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24e1e38ea29c615b2c5f5cd8dbaeeb2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a24e1e38ea29c615b2c5f5cd8dbaeeb2a">operator!=</a> (const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;a, const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;b)</td></tr>
<tr class="separator:a24e1e38ea29c615b2c5f5cd8dbaeeb2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea87c61d2cc1d5acf1af1d2d351bdb75"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aea87c61d2cc1d5acf1af1d2d351bdb75">operator&lt;</a> (const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;a, const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;b)</td></tr>
<tr class="separator:aea87c61d2cc1d5acf1af1d2d351bdb75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a387ff1f8cefcf4feb705b0f1225d16c7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a387ff1f8cefcf4feb705b0f1225d16c7">operator==</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;a, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;b)</td></tr>
<tr class="separator:a387ff1f8cefcf4feb705b0f1225d16c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a654eca8448629e42ae87cadd893ee10e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a654eca8448629e42ae87cadd893ee10e">operator!=</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;a, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;b)</td></tr>
<tr class="separator:a654eca8448629e42ae87cadd893ee10e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fd908e60f72bd98dcba364a16ab7190"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0fd908e60f72bd98dcba364a16ab7190">operator&lt;</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;a, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;b)</td></tr>
<tr class="separator:a0fd908e60f72bd98dcba364a16ab7190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0744fdee12e0f4136de643a91c15f77"><td class="memItemLeft" align="right" valign="top">ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae0744fdee12e0f4136de643a91c15f77">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;snarl)</td></tr>
<tr class="separator:ae0744fdee12e0f4136de643a91c15f77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a2e772d69c9e45cbc1c1d1a9e6df842"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5a2e772d69c9e45cbc1c1d1a9e6df842">to_node_traversal</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit, const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph)</td></tr>
<tr class="separator:a5a2e772d69c9e45cbc1c1d1a9e6df842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b4a5c32294bf49aa7f0a6d180cc2832"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0b4a5c32294bf49aa7f0a6d180cc2832">to_rev_node_traversal</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit, const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph)</td></tr>
<tr class="separator:a0b4a5c32294bf49aa7f0a6d180cc2832"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a84d646b72482de0145745a64414ca5df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a84d646b72482de0145745a64414ca5df">to_left_side</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit)</td></tr>
<tr class="memdesc:a84d646b72482de0145745a64414ca5df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> to a node or snarl into a <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> for its left side.  <a href="namespacevg.html#a84d646b72482de0145745a64414ca5df">More...</a><br /></td></tr>
<tr class="separator:a84d646b72482de0145745a64414ca5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74fab09b3ae1d9f799742a31b5206a35"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a74fab09b3ae1d9f799742a31b5206a35">to_right_side</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit)</td></tr>
<tr class="memdesc:a74fab09b3ae1d9f799742a31b5206a35"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> to a node or snarl into a <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> for its right side.  <a href="namespacevg.html#a74fab09b3ae1d9f799742a31b5206a35">More...</a><br /></td></tr>
<tr class="separator:a74fab09b3ae1d9f799742a31b5206a35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a827ce532cdbd4710e86a21ebd986e1cc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a827ce532cdbd4710e86a21ebd986e1cc">to_visit</a> (const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;node_traversal)</td></tr>
<tr class="memdesc:a827ce532cdbd4710e86a21ebd986e1cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> to a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a>.  <a href="namespacevg.html#a827ce532cdbd4710e86a21ebd986e1cc">More...</a><br /></td></tr>
<tr class="separator:a827ce532cdbd4710e86a21ebd986e1cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd53873bb85623cbf5b797f09bf88dc4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acd53873bb85623cbf5b797f09bf88dc4">to_visit</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mapping, bool make_full_node_match=false)</td></tr>
<tr class="separator:acd53873bb85623cbf5b797f09bf88dc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa76433c3398610bc58b842f2a4b462c7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa76433c3398610bc58b842f2a4b462c7">to_visit</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> node_id, bool is_reverse)</td></tr>
<tr class="memdesc:aa76433c3398610bc58b842f2a4b462c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> from a node ID and an orientation.  <a href="namespacevg.html#aa76433c3398610bc58b842f2a4b462c7">More...</a><br /></td></tr>
<tr class="separator:aa76433c3398610bc58b842f2a4b462c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a18238f71586af9b3eba2ba1dac2a6e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0a18238f71586af9b3eba2ba1dac2a6e">to_visit</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;snarl)</td></tr>
<tr class="memdesc:a0a18238f71586af9b3eba2ba1dac2a6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> from a snarl to traverse.  <a href="namespacevg.html#a0a18238f71586af9b3eba2ba1dac2a6e">More...</a><br /></td></tr>
<tr class="separator:a0a18238f71586af9b3eba2ba1dac2a6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7d774bd39780563236dbf2badfc804b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae7d774bd39780563236dbf2badfc804b">to_visit</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">handlegraph::HandleGraph</a> &amp;graph, const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;handle)</td></tr>
<tr class="memdesc:ae7d774bd39780563236dbf2badfc804b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> from a handle in a HandleGraph.  <a href="namespacevg.html#ae7d774bd39780563236dbf2badfc804b">More...</a><br /></td></tr>
<tr class="separator:ae7d774bd39780563236dbf2badfc804b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e300d25fd8281f9453366f68b484196"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2e300d25fd8281f9453366f68b484196">reverse</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit)</td></tr>
<tr class="memdesc:a2e300d25fd8281f9453366f68b484196"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reversed version of a visit.  <a href="namespacevg.html#a2e300d25fd8281f9453366f68b484196">More...</a><br /></td></tr>
<tr class="separator:a2e300d25fd8281f9453366f68b484196"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7164ae8636d1ca7783d6202c8ce316ca"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Visit.html">Visit</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7164ae8636d1ca7783d6202c8ce316ca">to_rev_visit</a> (const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;node_traversal)</td></tr>
<tr class="memdesc:a7164ae8636d1ca7783d6202c8ce316ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> to a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> in the opposite orientation.  <a href="namespacevg.html#a7164ae8636d1ca7783d6202c8ce316ca">More...</a><br /></td></tr>
<tr class="separator:a7164ae8636d1ca7783d6202c8ce316ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28be7f9898d5ad6e075e25b81df512e8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Mapping.html">Mapping</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a28be7f9898d5ad6e075e25b81df512e8">to_mapping</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit, std::function&lt; size_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; node_length)</td></tr>
<tr class="separator:a28be7f9898d5ad6e075e25b81df512e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a128ffce6142542678bbbdc6e2e0b40cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Mapping.html">Mapping</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a128ffce6142542678bbbdc6e2e0b40cd">to_mapping</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;vg)</td></tr>
<tr class="separator:a128ffce6142542678bbbdc6e2e0b40cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10bcb19d45af37e8a58129b939b86f21"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1Alignment.html">Alignment</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a10bcb19d45af37e8a58129b939b86f21">to_alignment</a> (const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;trav, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph)</td></tr>
<tr class="memdesc:a10bcb19d45af37e8a58129b939b86f21"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a snarl traversal into an alignment.  <a href="namespacevg.html#a10bcb19d45af37e8a58129b939b86f21">More...</a><br /></td></tr>
<tr class="separator:a10bcb19d45af37e8a58129b939b86f21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82a83d7c54d733abee06d328f91ef5ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a82a83d7c54d733abee06d328f91ef5ee">transfer_boundary_info</a> (const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;from, <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;to)</td></tr>
<tr class="memdesc:a82a83d7c54d733abee06d328f91ef5ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the boundary Visits from one <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes.">Snarl</a> into another.  <a href="namespacevg.html#a82a83d7c54d733abee06d328f91ef5ee">More...</a><br /></td></tr>
<tr class="separator:a82a83d7c54d733abee06d328f91ef5ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c04918053577c402e4f2cab61abd754"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2c04918053577c402e4f2cab61abd754">to_node_traversal</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph)</td></tr>
<tr class="separator:a2c04918053577c402e4f2cab61abd754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae64d7810e64af7119f1b1b3a2d08d797"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae64d7810e64af7119f1b1b3a2d08d797">to_rev_node_traversal</a> (const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;visit, <a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph)</td></tr>
<tr class="separator:ae64d7810e64af7119f1b1b3a2d08d797"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a0d273871a7d0feea0e9f0b1901931"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a61a0d273871a7d0feea0e9f0b1901931">from_hit</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;hit_pos, const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;mem, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> &amp;scorer)</td></tr>
<tr class="separator:a61a0d273871a7d0feea0e9f0b1901931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e61398cd459bb9ba3a1ced205491712"><td class="memItemLeft" align="right" valign="top">tuple&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, int64_t, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9e61398cd459bb9ba3a1ced205491712">trimmed_end</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln, int64_t len, bool from_end, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> &amp;aligner)</td></tr>
<tr class="separator:a9e61398cd459bb9ba3a1ced205491712"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8d0345d2d7cea79ffdca38d33ed0c7f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab8d0345d2d7cea79ffdca38d33ed0c7f">trim_path</a> (<a class="el" href="classvg_1_1path__t.html">path_t</a> *path, bool from_left, int64_t mapping_idx, int64_t edit_idx, int64_t base_idx)</td></tr>
<tr class="separator:ab8d0345d2d7cea79ffdca38d33ed0c7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee945465384e60bdda619684ffca2ece"><td class="memItemLeft" align="right" valign="top">pair&lt; pair&lt; <a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t &gt;, pair&lt; <a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aee945465384e60bdda619684ffca2ece">split_splice_segment</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;splice_segment, const tuple&lt; int64_t, int64_t, int64_t &gt; &amp;left_trace, const tuple&lt; int64_t, int64_t, int64_t &gt; &amp;right_trace, int64_t splice_junction_idx, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> &amp;scorer, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph)</td></tr>
<tr class="separator:aee945465384e60bdda619684ffca2ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5b37106006a0286045cd12f9159ac245"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5b37106006a0286045cd12f9159ac245">fuse_spliced_alignments</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&amp;left_mp_aln, <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&amp;right_mp_aln, int64_t left_bridge_point, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;splice_segment, int64_t splice_junction_idx, int32_t splice_score, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> &amp;scorer, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph)</td></tr>
<tr class="separator:a5b37106006a0286045cd12f9159ac245"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6eef175773ce8532826ba78eee0cece5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6eef175773ce8532826ba78eee0cece5">median</a> (std::vector&lt; int &gt; &amp;v)</td></tr>
<tr class="separator:a6eef175773ce8532826ba78eee0cece5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a614c672ed69c280b699a278ce0f34ade"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a614c672ed69c280b699a278ce0f34ade">wellford_update</a> (size_t &amp;count, double &amp;mean, double &amp;M2, double new_val)</td></tr>
<tr class="separator:a614c672ed69c280b699a278ce0f34ade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b96cd801bc780d426db346f80ab2172"><td class="memItemLeft" align="right" valign="top">pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4b96cd801bc780d426db346f80ab2172">wellford_mean_var</a> (size_t count, double mean, double M2, bool sample_variance)</td></tr>
<tr class="separator:a4b96cd801bc780d426db346f80ab2172"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afea3e6d4a8ac9b486d1a2b9b89eadd2f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afea3e6d4a8ac9b486d1a2b9b89eadd2f">Phi</a> (double x)</td></tr>
<tr class="memdesc:afea3e6d4a8ac9b486d1a2b9b89eadd2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">The standard normal cumulative distribution function.  <a href="namespacevg.html#afea3e6d4a8ac9b486d1a2b9b89eadd2f">More...</a><br /></td></tr>
<tr class="separator:afea3e6d4a8ac9b486d1a2b9b89eadd2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ae7976a3a19fe08c4b2bce4b3f3c00f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4ae7976a3a19fe08c4b2bce4b3f3c00f">Phi_inv</a> (double quantile)</td></tr>
<tr class="memdesc:a4ae7976a3a19fe08c4b2bce4b3f3c00f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inverse CDF of a standard normal distribution. Must have 0 &lt; quantile &lt; 1.  <a href="namespacevg.html#a4ae7976a3a19fe08c4b2bce4b3f3c00f">More...</a><br /></td></tr>
<tr class="separator:a4ae7976a3a19fe08c4b2bce4b3f3c00f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6b7d44806f0d50d79f7de39800495d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afe6b7d44806f0d50d79f7de39800495d">lognormal_pdf</a> (double x, double mu, double sigma)</td></tr>
<tr class="memdesc:afe6b7d44806f0d50d79f7de39800495d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Probability density function or log-normal distribution.  <a href="namespacevg.html#afe6b7d44806f0d50d79f7de39800495d">More...</a><br /></td></tr>
<tr class="separator:afe6b7d44806f0d50d79f7de39800495d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad477b45059373004136e69022e802e0b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad477b45059373004136e69022e802e0b">slope</a> (const std::vector&lt; double &gt; &amp;x, const std::vector&lt; double &gt; &amp;y)</td></tr>
<tr class="separator:ad477b45059373004136e69022e802e0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fa3b08acc22f29ea5d940317f6948ab"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9fa3b08acc22f29ea5d940317f6948ab">fit_zipf</a> (const vector&lt; double &gt; &amp;y)</td></tr>
<tr class="separator:a9fa3b08acc22f29ea5d940317f6948ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79672e0d9b7e8abdb60ec0f181eec6f0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a79672e0d9b7e8abdb60ec0f181eec6f0">fit_fixed_shape_max_exponential</a> (const vector&lt; double &gt; &amp;x, double shape, double tolerance=1e-8)</td></tr>
<tr class="memdesc:a79672e0d9b7e8abdb60ec0f181eec6f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MLE rate parameter for the distribution of (shape) iid exponential RVs.  <a href="namespacevg.html#a79672e0d9b7e8abdb60ec0f181eec6f0">More...</a><br /></td></tr>
<tr class="separator:a79672e0d9b7e8abdb60ec0f181eec6f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b47bdda079acc49d455953a91db12bd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4b47bdda079acc49d455953a91db12bd">fit_fixed_rate_max_exponential</a> (const vector&lt; double &gt; &amp;x, double rate, double tolerance=1e-8)</td></tr>
<tr class="memdesc:a4b47bdda079acc49d455953a91db12bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MLE estimate for the number of iid exponential RVs the data are maxima of.  <a href="namespacevg.html#a4b47bdda079acc49d455953a91db12bd">More...</a><br /></td></tr>
<tr class="separator:a4b47bdda079acc49d455953a91db12bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aafca6820103f98f205de4774a9d35f09"><td class="memItemLeft" align="right" valign="top">pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aafca6820103f98f205de4774a9d35f09">fit_max_exponential</a> (const vector&lt; double &gt; &amp;x, double tolerance=1e-8)</td></tr>
<tr class="memdesc:aafca6820103f98f205de4774a9d35f09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the MLE rate and shape parameters of a max exponential.  <a href="namespacevg.html#aafca6820103f98f205de4774a9d35f09">More...</a><br /></td></tr>
<tr class="separator:aafca6820103f98f205de4774a9d35f09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617472d242ff7aad1126a6b70e70a7a8"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a617472d242ff7aad1126a6b70e70a7a8">max_exponential_log_likelihood</a> (const vector&lt; double &gt; &amp;x, double rate, double shape, double location=0.0)</td></tr>
<tr class="memdesc:a617472d242ff7aad1126a6b70e70a7a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">The log likelihood of a max exponential with the given parameters on the given data.  <a href="namespacevg.html#a617472d242ff7aad1126a6b70e70a7a8">More...</a><br /></td></tr>
<tr class="separator:a617472d242ff7aad1126a6b70e70a7a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa64cff8c9c4b3c3baefb49c57614643d"><td class="memItemLeft" align="right" valign="top">pair&lt; double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa64cff8c9c4b3c3baefb49c57614643d">fit_weibull</a> (const vector&lt; double &gt; &amp;x)</td></tr>
<tr class="memdesc:aa64cff8c9c4b3c3baefb49c57614643d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an estimate of the rate and shape parameters of a Weibull distribution.  <a href="namespacevg.html#aa64cff8c9c4b3c3baefb49c57614643d">More...</a><br /></td></tr>
<tr class="separator:aa64cff8c9c4b3c3baefb49c57614643d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9f14b8e66ba0c5c28961e8da4aba4b6"><td class="memItemLeft" align="right" valign="top">tuple&lt; double, double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad9f14b8e66ba0c5c28961e8da4aba4b6">fit_offset_weibull</a> (const vector&lt; double &gt; &amp;x, double tolerance=1e-8)</td></tr>
<tr class="memdesc:ad9f14b8e66ba0c5c28961e8da4aba4b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns an estimate of the rate, shape, and location (minimum value) of a 3-parameter Weibull distribution.  <a href="namespacevg.html#ad9f14b8e66ba0c5c28961e8da4aba4b6">More...</a><br /></td></tr>
<tr class="separator:ad9f14b8e66ba0c5c28961e8da4aba4b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad93405cf370e6d92396691fc3320be1c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad93405cf370e6d92396691fc3320be1c">weibull_log_likelihood</a> (const vector&lt; double &gt; &amp;x, double scale, double shape, double location=0.0)</td></tr>
<tr class="memdesc:ad93405cf370e6d92396691fc3320be1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the log likelihood of some data generated by a Weibull distribution.  <a href="namespacevg.html#ad93405cf370e6d92396691fc3320be1c">More...</a><br /></td></tr>
<tr class="separator:ad93405cf370e6d92396691fc3320be1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a314ff925fad534d112e4531617e408fa"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a314ff925fad534d112e4531617e408fa">golden_section_search</a> (const function&lt; double(double)&gt; &amp;f, double x_min, double x_max, double tolerance=1e-8)</td></tr>
<tr class="memdesc:a314ff925fad534d112e4531617e408fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a local maximum of a function within an interval.  <a href="namespacevg.html#a314ff925fad534d112e4531617e408fa">More...</a><br /></td></tr>
<tr class="separator:a314ff925fad534d112e4531617e408fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab713ebc6e2988cc2c959be14bfa01200"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab713ebc6e2988cc2c959be14bfa01200">phred_to_prob</a> (uint8_t phred)</td></tr>
<tr class="memdesc:ab713ebc6e2988cc2c959be14bfa01200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert 8-bit Phred quality score to probability of wrongness, using a lookup table.  <a href="namespacevg.html#ab713ebc6e2988cc2c959be14bfa01200">More...</a><br /></td></tr>
<tr class="separator:ab713ebc6e2988cc2c959be14bfa01200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a6ab3a0f45f6ab7b38320db7cc14583"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9a6ab3a0f45f6ab7b38320db7cc14583">phred_for_at_least_one</a> (size_t p, size_t n)</td></tr>
<tr class="separator:a9a6ab3a0f45f6ab7b38320db7cc14583"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae46397f9d9aa9ac06a48b4ff30da7087"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae46397f9d9aa9ac06a48b4ff30da7087">prob_for_at_least_one</a> (size_t p, size_t n)</td></tr>
<tr class="separator:ae46397f9d9aa9ac06a48b4ff30da7087"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1409ac23ce33abd463dcd46093079023"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1409ac23ce33abd463dcd46093079023">transpose</a> (const vector&lt; vector&lt; double &gt;&gt; &amp;A)</td></tr>
<tr class="memdesc:a1409ac23ce33abd463dcd46093079023"><td class="mdescLeft">&#160;</td><td class="mdescRight">A shitty set of linear algebra functions.  <a href="namespacevg.html#a1409ac23ce33abd463dcd46093079023">More...</a><br /></td></tr>
<tr class="separator:a1409ac23ce33abd463dcd46093079023"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a02d66ca193142fb4825a62b300d60697"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a02d66ca193142fb4825a62b300d60697">matrix_multiply</a> (const vector&lt; vector&lt; double &gt;&gt; &amp;A, const vector&lt; vector&lt; double &gt;&gt; &amp;B)</td></tr>
<tr class="separator:a02d66ca193142fb4825a62b300d60697"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a1927488f1b7b82758828d5a53ca845"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9a1927488f1b7b82758828d5a53ca845">matrix_multiply</a> (const vector&lt; vector&lt; double &gt;&gt; &amp;A, const vector&lt; double &gt; &amp;b)</td></tr>
<tr class="separator:a9a1927488f1b7b82758828d5a53ca845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7effc13e3f877e676d65d9164a44b4a6"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; double &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7effc13e3f877e676d65d9164a44b4a6">matrix_invert</a> (const vector&lt; vector&lt; double &gt;&gt; &amp;A)</td></tr>
<tr class="separator:a7effc13e3f877e676d65d9164a44b4a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab16fbb8659a66f16f2004fcc3e8f9db"><td class="memItemLeft" align="right" valign="top">vector&lt; double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aab16fbb8659a66f16f2004fcc3e8f9db">regress</a> (const vector&lt; vector&lt; double &gt;&gt; &amp;X, vector&lt; double &gt; &amp;y)</td></tr>
<tr class="memdesc:aab16fbb8659a66f16f2004fcc3e8f9db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the coefficients of a regression (does not automatically compute constant)  <a href="namespacevg.html#aab16fbb8659a66f16f2004fcc3e8f9db">More...</a><br /></td></tr>
<tr class="separator:aab16fbb8659a66f16f2004fcc3e8f9db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11df8bd14dab3c0cfb7ecfa377a362f5"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a11df8bd14dab3c0cfb7ecfa377a362f5"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a11df8bd14dab3c0cfb7ecfa377a362f5">stdev</a> (const T &amp;v)</td></tr>
<tr class="separator:a11df8bd14dab3c0cfb7ecfa377a362f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8afe82a05092bbf4bc31c8ead079fe3"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:ae8afe82a05092bbf4bc31c8ead079fe3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1SummaryStatistics.html">SummaryStatistics</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae8afe82a05092bbf4bc31c8ead079fe3">summary_statistics</a> (const std::map&lt; Number, size_t &gt; &amp;values)</td></tr>
<tr class="memdesc:ae8afe82a05092bbf4bc31c8ead079fe3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns summary statistics for a multiset of numbers.  <a href="namespacevg.html#ae8afe82a05092bbf4bc31c8ead079fe3">More...</a><br /></td></tr>
<tr class="separator:ae8afe82a05092bbf4bc31c8ead079fe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d4ce16064ad3986381aeead6afe317f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0d4ce16064ad3986381aeead6afe317f">add_log</a> (double log_x, double log_y)</td></tr>
<tr class="separator:a0d4ce16064ad3986381aeead6afe317f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33c8f5153ad0766df2c72bbec623aa19"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a33c8f5153ad0766df2c72bbec623aa19">subtract_log</a> (double log_x, double log_y)</td></tr>
<tr class="separator:a33c8f5153ad0766df2c72bbec623aa19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a664ec3301c226596ad971b97a8e1fa65"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a664ec3301c226596ad971b97a8e1fa65">ln_to_log10</a> (double ln)</td></tr>
<tr class="separator:a664ec3301c226596ad971b97a8e1fa65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48d9ec9295afc7457506af4ddaf44217"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a48d9ec9295afc7457506af4ddaf44217">log10_to_ln</a> (double l10)</td></tr>
<tr class="separator:a48d9ec9295afc7457506af4ddaf44217"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16b2b6e110a2f72a871c309b888b013c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a16b2b6e110a2f72a871c309b888b013c">log10_add_one</a> (double x)</td></tr>
<tr class="separator:a16b2b6e110a2f72a871c309b888b013c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3f3c75ff3775f447d5dabbdb4e540dc"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab3f3c75ff3775f447d5dabbdb4e540dc">add_log10</a> (double i, double j)</td></tr>
<tr class="separator:ab3f3c75ff3775f447d5dabbdb4e540dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae825181ee40a5f0d5087fc657db9a7db"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae825181ee40a5f0d5087fc657db9a7db"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae825181ee40a5f0d5087fc657db9a7db">normal_pdf</a> (T x, T m=0.0, T s=1.0)</td></tr>
<tr class="separator:ae825181ee40a5f0d5087fc657db9a7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a476a2102f4f5aa82c06be87780ae6d42"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a476a2102f4f5aa82c06be87780ae6d42">prob_to_logprob</a> (double prob)</td></tr>
<tr class="memdesc:a476a2102f4f5aa82c06be87780ae6d42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a probability to a natural log probability.  <a href="namespacevg.html#a476a2102f4f5aa82c06be87780ae6d42">More...</a><br /></td></tr>
<tr class="separator:a476a2102f4f5aa82c06be87780ae6d42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea77a4ed92d78c48a08fce58cf319c4d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aea77a4ed92d78c48a08fce58cf319c4d">logprob_to_prob</a> (double logprob)</td></tr>
<tr class="memdesc:aea77a4ed92d78c48a08fce58cf319c4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert natural log probability to a probability.  <a href="namespacevg.html#aea77a4ed92d78c48a08fce58cf319c4d">More...</a><br /></td></tr>
<tr class="separator:aea77a4ed92d78c48a08fce58cf319c4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64b25a99232585c5e76baf01d1ef5520"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a64b25a99232585c5e76baf01d1ef5520">logprob_add</a> (double logprob1, double logprob2)</td></tr>
<tr class="separator:a64b25a99232585c5e76baf01d1ef5520"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1056422cd0697f2bbdcf8a085486793a"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1056422cd0697f2bbdcf8a085486793a">logprob_invert</a> (double logprob)</td></tr>
<tr class="memdesc:a1056422cd0697f2bbdcf8a085486793a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invert a logprob, and get the probability of its opposite.  <a href="namespacevg.html#a1056422cd0697f2bbdcf8a085486793a">More...</a><br /></td></tr>
<tr class="separator:a1056422cd0697f2bbdcf8a085486793a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afba77c5a550d5dd72f8cf7438f600676"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afba77c5a550d5dd72f8cf7438f600676">phred_to_prob</a> (double phred)</td></tr>
<tr class="memdesc:afba77c5a550d5dd72f8cf7438f600676"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert floating point Phred quality score to probability of wrongness.  <a href="namespacevg.html#afba77c5a550d5dd72f8cf7438f600676">More...</a><br /></td></tr>
<tr class="separator:afba77c5a550d5dd72f8cf7438f600676"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb81881c0a3b7cf276097d8142ddb312"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acb81881c0a3b7cf276097d8142ddb312">prob_to_phred</a> (double prob)</td></tr>
<tr class="memdesc:acb81881c0a3b7cf276097d8142ddb312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert probability of wrongness to integer Phred quality score.  <a href="namespacevg.html#acb81881c0a3b7cf276097d8142ddb312">More...</a><br /></td></tr>
<tr class="separator:acb81881c0a3b7cf276097d8142ddb312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35b531c82b765cd54702665668a98448"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a35b531c82b765cd54702665668a98448">phred_to_logprob</a> (int phred)</td></tr>
<tr class="memdesc:a35b531c82b765cd54702665668a98448"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a Phred quality score directly to a natural log probability of wrongness.  <a href="namespacevg.html#a35b531c82b765cd54702665668a98448">More...</a><br /></td></tr>
<tr class="separator:a35b531c82b765cd54702665668a98448"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66d295b4b0f83393ce621b44d88680a6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a66d295b4b0f83393ce621b44d88680a6">logprob_to_phred</a> (double logprob)</td></tr>
<tr class="memdesc:a66d295b4b0f83393ce621b44d88680a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert a natural log probability of wrongness directly to a Phred quality score.  <a href="namespacevg.html#a66d295b4b0f83393ce621b44d88680a6">More...</a><br /></td></tr>
<tr class="separator:a66d295b4b0f83393ce621b44d88680a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f8a1a81a5402187152a97ca6293b4f1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0f8a1a81a5402187152a97ca6293b4f1">logprob_geometric_mean</a> (double lnprob1, double lnprob2)</td></tr>
<tr class="memdesc:a0f8a1a81a5402187152a97ca6293b4f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the geometric mean of two logprobs.  <a href="namespacevg.html#a0f8a1a81a5402187152a97ca6293b4f1">More...</a><br /></td></tr>
<tr class="separator:a0f8a1a81a5402187152a97ca6293b4f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04edc3daae77e9d3813a97da0f473def"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a04edc3daae77e9d3813a97da0f473def">phred_geometric_mean</a> (double phred1, double phred2)</td></tr>
<tr class="memdesc:a04edc3daae77e9d3813a97da0f473def"><td class="mdescLeft">&#160;</td><td class="mdescRight">Take the geometric mean of two phred-encoded probabilities.  <a href="namespacevg.html#a04edc3daae77e9d3813a97da0f473def">More...</a><br /></td></tr>
<tr class="separator:a04edc3daae77e9d3813a97da0f473def"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a211ba38329cdc76a7ad0b64bbb227bfd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a211ba38329cdc76a7ad0b64bbb227bfd">phred_add</a> (double phred1, double phred2)</td></tr>
<tr class="separator:a211ba38329cdc76a7ad0b64bbb227bfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93d81b5193ecfc9600990bd427337adf"><td class="memTemplParams" colspan="2">template&lt;typename Collection &gt; </td></tr>
<tr class="memitem:a93d81b5193ecfc9600990bd427337adf"><td class="memTemplItemLeft" align="right" valign="top">Collection::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a93d81b5193ecfc9600990bd427337adf">logprob_sum</a> (const Collection &amp;collection)</td></tr>
<tr class="separator:a93d81b5193ecfc9600990bd427337adf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaeddefa307b95defd68c8a2022db732c"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:aaeddefa307b95defd68c8a2022db732c"><td class="memTemplItemLeft" align="right" valign="top">std::iterator_traits&lt; Iterator &gt;::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#aaeddefa307b95defd68c8a2022db732c">phred_sum</a> (const Iterator &amp;begin_it, const Iterator &amp;end_it)</td></tr>
<tr class="separator:aaeddefa307b95defd68c8a2022db732c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78072e330ae86c9ef80aeeb84f89e8f"><td class="memTemplParams" colspan="2">template&lt;typename Collection &gt; </td></tr>
<tr class="memitem:ad78072e330ae86c9ef80aeeb84f89e8f"><td class="memTemplItemLeft" align="right" valign="top">Collection::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad78072e330ae86c9ef80aeeb84f89e8f">phred_sum</a> (const Collection &amp;collection)</td></tr>
<tr class="separator:ad78072e330ae86c9ef80aeeb84f89e8f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82dc203eaecb442a26d8f1a3db773dda"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a82dc203eaecb442a26d8f1a3db773dda">max_exponential_cdf</a> (double x, double rate, double shape, double location=0.0)</td></tr>
<tr class="memdesc:a82dc203eaecb442a26d8f1a3db773dda"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the CDF of a max exponential with the given parameters.  <a href="namespacevg.html#a82dc203eaecb442a26d8f1a3db773dda">More...</a><br /></td></tr>
<tr class="separator:a82dc203eaecb442a26d8f1a3db773dda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a100efe5dfc5bfe434b53416f93d2a0e1"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a100efe5dfc5bfe434b53416f93d2a0e1">weibull_cdf</a> (double x, double scale, double shape, double location=0.0)</td></tr>
<tr class="memdesc:a100efe5dfc5bfe434b53416f93d2a0e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return the CDF of a max exponential with the given parameters.  <a href="namespacevg.html#a100efe5dfc5bfe434b53416f93d2a0e1">More...</a><br /></td></tr>
<tr class="separator:a100efe5dfc5bfe434b53416f93d2a0e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05748ab256c93e2393252aa8ebbdde3d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a05748ab256c93e2393252aa8ebbdde3d">gamma_ln</a> (<a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> x)</td></tr>
<tr class="separator:a05748ab256c93e2393252aa8ebbdde3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54a32f7feb38c9f86d7796f0b4f1dac7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a54a32f7feb38c9f86d7796f0b4f1dac7">factorial_ln</a> (int n)</td></tr>
<tr class="separator:a54a32f7feb38c9f86d7796f0b4f1dac7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a7a8c98d80a9daacbc72386bc6ad00c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3a7a8c98d80a9daacbc72386bc6ad00c">pow_ln</a> (<a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> m, int n)</td></tr>
<tr class="separator:a3a7a8c98d80a9daacbc72386bc6ad00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf777e701e331bb422d91135a13408d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abf777e701e331bb422d91135a13408d2">choose_ln</a> (int n, int k)</td></tr>
<tr class="separator:abf777e701e331bb422d91135a13408d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f09f05f7894863e9cd852c63266078"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a15f09f05f7894863e9cd852c63266078">multinomial_choose_ln</a> (int n, vector&lt; int &gt; k)</td></tr>
<tr class="separator:a15f09f05f7894863e9cd852c63266078"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9238b15cc78a87f27c335fc1e3627a62"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9238b15cc78a87f27c335fc1e3627a62">poisson_prob_ln</a> (int observed, <a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> expected)</td></tr>
<tr class="separator:a9238b15cc78a87f27c335fc1e3627a62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d69cf9a7d7e6272960fcb9f0a0a00c"><td class="memTemplParams" colspan="2">template&lt;typename ProbIn &gt; </td></tr>
<tr class="memitem:af4d69cf9a7d7e6272960fcb9f0a0a00c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#af4d69cf9a7d7e6272960fcb9f0a0a00c">multinomial_sampling_prob_ln</a> (const vector&lt; ProbIn &gt; &amp;probs, const vector&lt; int &gt; &amp;obs)</td></tr>
<tr class="separator:af4d69cf9a7d7e6272960fcb9f0a0a00c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a038ccb26c0c9c0a87601edc7b8b5df70"><td class="memTemplParams" colspan="2">template&lt;typename ProbIn &gt; </td></tr>
<tr class="memitem:a038ccb26c0c9c0a87601edc7b8b5df70"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a038ccb26c0c9c0a87601edc7b8b5df70">binomial_cmf_ln</a> (ProbIn success_logprob, size_t trials, size_t successes)</td></tr>
<tr class="separator:a038ccb26c0c9c0a87601edc7b8b5df70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae923ee7bdb53f33511c95f66a9c2773a"><td class="memTemplParams" colspan="2">template&lt;typename ProbIn &gt; </td></tr>
<tr class="memitem:ae923ee7bdb53f33511c95f66a9c2773a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae923ee7bdb53f33511c95f66a9c2773a">geometric_sampling_prob_ln</a> (ProbIn success_logprob, size_t trials)</td></tr>
<tr class="separator:ae923ee7bdb53f33511c95f66a9c2773a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0df0c35a951519aa4a74bf098a253516"><td class="memTemplParams" colspan="2">template&lt;typename Iter &gt; </td></tr>
<tr class="memitem:a0df0c35a951519aa4a74bf098a253516"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0df0c35a951519aa4a74bf098a253516">advance_split</a> (Iter start, Iter end)</td></tr>
<tr class="separator:a0df0c35a951519aa4a74bf098a253516"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a074fcebfeb68fc970b5b2a0db3722f01"><td class="memTemplParams" colspan="2">template&lt;typename ProbIn &gt; </td></tr>
<tr class="memitem:a074fcebfeb68fc970b5b2a0db3722f01"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a074fcebfeb68fc970b5b2a0db3722f01">multinomial_censored_sampling_prob_ln</a> (const vector&lt; ProbIn &gt; &amp;probs, const unordered_map&lt; vector&lt; bool &gt;, int &gt; &amp;obs)</td></tr>
<tr class="separator:a074fcebfeb68fc970b5b2a0db3722f01"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d4b5d91539506f52c32664fc1c0ddd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a59d4b5d91539506f52c32664fc1c0ddd">ewens_af_prob_ln</a> (const vector&lt; int &gt; &amp;a, <a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> theta)</td></tr>
<tr class="separator:a59d4b5d91539506f52c32664fc1c0ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5fc02ee1a5713060cd5f4b33e2eaaab"><td class="memItemLeft" align="right" valign="top">auto&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac5fc02ee1a5713060cd5f4b33e2eaaab">operator&lt;&lt;</a> (ostream &amp;out, const <a class="el" href="classvg_1_1BitString.html">BitString</a> &amp;bs)</td></tr>
<tr class="memdesc:ac5fc02ee1a5713060cd5f4b33e2eaaab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow BitStrings to be printed for debugging.  <a href="namespacevg.html#ac5fc02ee1a5713060cd5f4b33e2eaaab">More...</a><br /></td></tr>
<tr class="separator:ac5fc02ee1a5713060cd5f4b33e2eaaab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ace94ff076945069d22aa548b6e0bf6"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6ace94ff076945069d22aa548b6e0bf6">operator==</a> (const <a class="el" href="structvg_1_1Exon.html">Exon</a> &amp;lhs, const <a class="el" href="structvg_1_1Exon.html">Exon</a> &amp;rhs)</td></tr>
<tr class="separator:a6ace94ff076945069d22aa548b6e0bf6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22cb5c700c1dee4fec8d3af77057ea2a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a22cb5c700c1dee4fec8d3af77057ea2a">operator!=</a> (const <a class="el" href="structvg_1_1Exon.html">Exon</a> &amp;lhs, const <a class="el" href="structvg_1_1Exon.html">Exon</a> &amp;rhs)</td></tr>
<tr class="separator:a22cb5c700c1dee4fec8d3af77057ea2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad29d63c9b09132ab0457b3d28ea704ff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad29d63c9b09132ab0457b3d28ea704ff">operator&lt;</a> (const <a class="el" href="structvg_1_1Exon.html">Exon</a> &amp;lhs, const <a class="el" href="structvg_1_1Exon.html">Exon</a> &amp;rhs)</td></tr>
<tr class="separator:ad29d63c9b09132ab0457b3d28ea704ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace8e1de0bfe604d8da5537fd86e251ee"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ace8e1de0bfe604d8da5537fd86e251ee">operator==</a> (const <a class="el" href="structvg_1_1Transcript.html">Transcript</a> &amp;lhs, const <a class="el" href="structvg_1_1Transcript.html">Transcript</a> &amp;rhs)</td></tr>
<tr class="separator:ace8e1de0bfe604d8da5537fd86e251ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f594795be32cb04b7baf0ef71ad77b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4f594795be32cb04b7baf0ef71ad77b0">operator!=</a> (const <a class="el" href="structvg_1_1Transcript.html">Transcript</a> &amp;lhs, const <a class="el" href="structvg_1_1Transcript.html">Transcript</a> &amp;rhs)</td></tr>
<tr class="separator:a4f594795be32cb04b7baf0ef71ad77b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3728100975bea667f2f60fdc1df2dd1"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad3728100975bea667f2f60fdc1df2dd1">operator&lt;</a> (const <a class="el" href="structvg_1_1Transcript.html">Transcript</a> &amp;lhs, const <a class="el" href="structvg_1_1Transcript.html">Transcript</a> &amp;rhs)</td></tr>
<tr class="separator:ad3728100975bea667f2f60fdc1df2dd1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e2505b73c51b9659c94950d2f283eec"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8e2505b73c51b9659c94950d2f283eec">operator==</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;lhs, const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;rhs)</td></tr>
<tr class="separator:a8e2505b73c51b9659c94950d2f283eec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a581944f1e71285f8c4887c2f5ce1467f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a581944f1e71285f8c4887c2f5ce1467f">operator!=</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;lhs, const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;rhs)</td></tr>
<tr class="separator:a581944f1e71285f8c4887c2f5ce1467f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e719e28c0d3f7d6dfa354824220211"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a92e719e28c0d3f7d6dfa354824220211">operator==</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;lhs, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;rhs)</td></tr>
<tr class="separator:a92e719e28c0d3f7d6dfa354824220211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67115fb742d1bf6d7e4e489fda99b78e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a67115fb742d1bf6d7e4e489fda99b78e">operator!=</a> (const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;lhs, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;rhs)</td></tr>
<tr class="separator:a67115fb742d1bf6d7e4e489fda99b78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47c7102baf9a07b2c701e9937d53351f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a47c7102baf9a07b2c701e9937d53351f">sort_pair_by_second</a> (const pair&lt; uint32_t, uint32_t &gt; &amp;lhs, const pair&lt; uint32_t, uint32_t &gt; &amp;rhs)</td></tr>
<tr class="separator:a47c7102baf9a07b2c701e9937d53351f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaddbcf35ad2ff899bf2ae0caf901f778"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aaddbcf35ad2ff899bf2ae0caf901f778">sort_transcript_paths_by_name</a> (const <a class="el" href="structvg_1_1CompletedTranscriptPath.html">CompletedTranscriptPath</a> &amp;lhs, const <a class="el" href="structvg_1_1CompletedTranscriptPath.html">CompletedTranscriptPath</a> &amp;rhs)</td></tr>
<tr class="separator:aaddbcf35ad2ff899bf2ae0caf901f778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdaa29c218d5d55e76fe4ab168f7a14b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acdaa29c218d5d55e76fe4ab168f7a14b">mapping_to_handle</a> (const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mapping, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph)</td></tr>
<tr class="separator:acdaa29c218d5d55e76fe4ab168f7a14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52292dfd3869a811170f7c5c0d9da564"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a52292dfd3869a811170f7c5c0d9da564">is_match</a> (const <a class="el" href="structvg_1_1Translation.html">Translation</a> &amp;translation)</td></tr>
<tr class="separator:a52292dfd3869a811170f7c5c0d9da564"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d85d380ba4b936ac8a715a72062866c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1d85d380ba4b936ac8a715a72062866c">make_pos_t</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, bool <a class="el" href="namespacevg.html#aac725dd44bc5a8f540554d4b1882c1fe">is_rev</a>, <a class="el" href="namespacevg.html#afe223f2c7890c76de5e00b43ceb37add">offset_t</a> off)</td></tr>
<tr class="memdesc:a1d85d380ba4b936ac8a715a72062866c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a pos_t from a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a> ID, an orientation flag, and an offset along that strand of the node.  <a href="namespacevg.html#a1d85d380ba4b936ac8a715a72062866c">More...</a><br /></td></tr>
<tr class="separator:a1d85d380ba4b936ac8a715a72062866c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f6602b7e7a46c19819c8f362147b315"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a> (const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;pos)</td></tr>
<tr class="memdesc:a9f6602b7e7a46c19819c8f362147b315"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extract the id of the node a pos_t is on.  <a href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">More...</a><br /></td></tr>
<tr class="separator:a9f6602b7e7a46c19819c8f362147b315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac725dd44bc5a8f540554d4b1882c1fe"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aac725dd44bc5a8f540554d4b1882c1fe">is_rev</a> (const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;pos)</td></tr>
<tr class="memdesc:aac725dd44bc5a8f540554d4b1882c1fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a pos_t is on the reverse strand of its node.  <a href="namespacevg.html#aac725dd44bc5a8f540554d4b1882c1fe">More...</a><br /></td></tr>
<tr class="separator:aac725dd44bc5a8f540554d4b1882c1fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad48a54a3ddd5e6ffd8e3e6296fb9c037"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afe223f2c7890c76de5e00b43ceb37add">offset_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad48a54a3ddd5e6ffd8e3e6296fb9c037">offset</a> (const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;pos)</td></tr>
<tr class="memdesc:ad48a54a3ddd5e6ffd8e3e6296fb9c037"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the offset along the selected strand of the node from a pos_t.  <a href="namespacevg.html#ad48a54a3ddd5e6ffd8e3e6296fb9c037">More...</a><br /></td></tr>
<tr class="separator:ad48a54a3ddd5e6ffd8e3e6296fb9c037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae4370b5cb4b42e8556b0fbc793fbdfc0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae4370b5cb4b42e8556b0fbc793fbdfc0">get_id</a> (<a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;pos)</td></tr>
<tr class="memdesc:ae4370b5cb4b42e8556b0fbc793fbdfc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a> ID of a pos_t.  <a href="namespacevg.html#ae4370b5cb4b42e8556b0fbc793fbdfc0">More...</a><br /></td></tr>
<tr class="separator:ae4370b5cb4b42e8556b0fbc793fbdfc0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1919abd090eae3a01120e0859d434ed9"><td class="memItemLeft" align="right" valign="top">bool &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1919abd090eae3a01120e0859d434ed9">get_is_rev</a> (<a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;pos)</td></tr>
<tr class="memdesc:a1919abd090eae3a01120e0859d434ed9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the reverse flag of a pos_t.  <a href="namespacevg.html#a1919abd090eae3a01120e0859d434ed9">More...</a><br /></td></tr>
<tr class="separator:a1919abd090eae3a01120e0859d434ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af826519a2b2e0cf58394e35d7ab7b84c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afe223f2c7890c76de5e00b43ceb37add">offset_t</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af826519a2b2e0cf58394e35d7ab7b84c">get_offset</a> (<a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;pos)</td></tr>
<tr class="memdesc:af826519a2b2e0cf58394e35d7ab7b84c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a reference to the offset field of a pos_t, which counts along the selected strand of the node.  <a href="namespacevg.html#af826519a2b2e0cf58394e35d7ab7b84c">More...</a><br /></td></tr>
<tr class="separator:af826519a2b2e0cf58394e35d7ab7b84c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3620df68e5af61a8eb660e4a4838ea06"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a3620df68e5af61a8eb660e4a4838ea06">is_empty</a> (const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;pos)</td></tr>
<tr class="memdesc:a3620df68e5af61a8eb660e4a4838ea06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a pos_t is unset.  <a href="namespacevg.html#a3620df68e5af61a8eb660e4a4838ea06">More...</a><br /></td></tr>
<tr class="separator:a3620df68e5af61a8eb660e4a4838ea06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0576520eed494787a895b6ce862e1f0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ad0576520eed494787a895b6ce862e1f0">empty_pos_t</a> ()</td></tr>
<tr class="memdesc:ad0576520eed494787a895b6ce862e1f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an unset pos_t.  <a href="namespacevg.html#ad0576520eed494787a895b6ce862e1f0">More...</a><br /></td></tr>
<tr class="separator:ad0576520eed494787a895b6ce862e1f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac52fd5878b0be1d53de644eea3458663"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac52fd5878b0be1d53de644eea3458663">reverse</a> (const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;pos, size_t node_length)</td></tr>
<tr class="separator:ac52fd5878b0be1d53de644eea3458663"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2f3762e2a8a852c7608d71f030e0345"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae2f3762e2a8a852c7608d71f030e0345">reverse_base_pos</a> (const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;pos, size_t node_length)</td></tr>
<tr class="memdesc:ae2f3762e2a8a852c7608d71f030e0345"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reverse a pos_t and get a pos_t at the same <b>base</b>, going the other direction.  <a href="namespacevg.html#ae2f3762e2a8a852c7608d71f030e0345">More...</a><br /></td></tr>
<tr class="separator:ae2f3762e2a8a852c7608d71f030e0345"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19349c6c73bac7da9651ee91c4272156"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a19349c6c73bac7da9651ee91c4272156">operator&lt;&lt;</a> (std::ostream &amp;out, const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;pos)</td></tr>
<tr class="memdesc:a19349c6c73bac7da9651ee91c4272156"><td class="mdescLeft">&#160;</td><td class="mdescRight">Print a pos_t to a stream.  <a href="namespacevg.html#a19349c6c73bac7da9651ee91c4272156">More...</a><br /></td></tr>
<tr class="separator:a19349c6c73bac7da9651ee91c4272156"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa65de7dea52585f07bee6ae7f762eb95"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa65de7dea52585f07bee6ae7f762eb95">reverse_complement</a> (const char &amp;c)</td></tr>
<tr class="separator:aa65de7dea52585f07bee6ae7f762eb95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a30732a1a1e8d20d6eaaaeafecc8a50a7"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a30732a1a1e8d20d6eaaaeafecc8a50a7">reverse_complement</a> (const string &amp;seq)</td></tr>
<tr class="separator:a30732a1a1e8d20d6eaaaeafecc8a50a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6353d47c867f1b4cc7053d82aef42f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae6353d47c867f1b4cc7053d82aef42f4">reverse_complement_in_place</a> (string &amp;seq)</td></tr>
<tr class="separator:ae6353d47c867f1b4cc7053d82aef42f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6f7955b97d8537da2133a47f37f462"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abe6f7955b97d8537da2133a47f37f462">is_all_n</a> (const string &amp;seq)</td></tr>
<tr class="separator:abe6f7955b97d8537da2133a47f37f462"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8f8da6eb179ba0199fc2fdfe676fde7"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af8f8da6eb179ba0199fc2fdfe676fde7">get_fraction_of_ns</a> (const string &amp;seq)</td></tr>
<tr class="separator:af8f8da6eb179ba0199fc2fdfe676fde7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade988dd38efaa705be15ba17500fe219"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ade988dd38efaa705be15ba17500fe219">get_thread_count</a> (void)</td></tr>
<tr class="separator:ade988dd38efaa705be15ba17500fe219"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfe23dc452245bf901fee2ed698afe7d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acfe23dc452245bf901fee2ed698afe7d">choose_good_thread_count</a> ()</td></tr>
<tr class="separator:acfe23dc452245bf901fee2ed698afe7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2577b9163299f775898c17bcd3f72d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acb2577b9163299f775898c17bcd3f72d">split_delims</a> (const std::string &amp;s, const std::string &amp;delims, std::vector&lt; std::string &gt; &amp;elems, size_t max_cuts)</td></tr>
<tr class="separator:acb2577b9163299f775898c17bcd3f72d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a335fce1edcad06f9840edcfad2c53e34"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a335fce1edcad06f9840edcfad2c53e34">split_delims</a> (const std::string &amp;s, const std::string &amp;delims, size_t max_cuts)</td></tr>
<tr class="separator:a335fce1edcad06f9840edcfad2c53e34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b58d5d004a85a09906301781567970a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7b58d5d004a85a09906301781567970a">starts_with</a> (const std::string &amp;value, const std::string &amp;prefix)</td></tr>
<tr class="memdesc:a7b58d5d004a85a09906301781567970a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if a string starts with another string.  <a href="namespacevg.html#a7b58d5d004a85a09906301781567970a">More...</a><br /></td></tr>
<tr class="separator:a7b58d5d004a85a09906301781567970a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0cada7d579d914675f53490e0488ab53"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0cada7d579d914675f53490e0488ab53">sha1sum</a> (const std::string &amp;data)</td></tr>
<tr class="separator:a0cada7d579d914675f53490e0488ab53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6821cd887e206752c50c1a7be764d1f5"><td class="memItemLeft" align="right" valign="top">const std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6821cd887e206752c50c1a7be764d1f5">sha1head</a> (const std::string &amp;data, size_t head)</td></tr>
<tr class="separator:a6821cd887e206752c50c1a7be764d1f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57f111dda471f40192704110bae04a0f"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a57f111dda471f40192704110bae04a0f">wrap_text</a> (const string &amp;str, size_t width)</td></tr>
<tr class="separator:a57f111dda471f40192704110bae04a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af051490e6e94b4c476695610472cdf5b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af051490e6e94b4c476695610472cdf5b">is_number</a> (const std::string &amp;s)</td></tr>
<tr class="separator:af051490e6e94b4c476695610472cdf5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92c923774a6526b7bfc7f06ae4ae7a18"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a92c923774a6526b7bfc7f06ae4ae7a18">isATGC</a> (const char &amp;b)</td></tr>
<tr class="memdesc:a92c923774a6526b7bfc7f06ae4ae7a18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a character is an uppercase A, C, G, or T, and false otherwise.  <a href="namespacevg.html#a92c923774a6526b7bfc7f06ae4ae7a18">More...</a><br /></td></tr>
<tr class="separator:a92c923774a6526b7bfc7f06ae4ae7a18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a1786f1e7e453c4b76b319ba101782d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7a1786f1e7e453c4b76b319ba101782d">allATGC</a> (const string &amp;s)</td></tr>
<tr class="separator:a7a1786f1e7e453c4b76b319ba101782d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae24bea33b666a03a0065a10a60d64e9d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae24bea33b666a03a0065a10a60d64e9d">allATGCN</a> (const string &amp;s)</td></tr>
<tr class="separator:ae24bea33b666a03a0065a10a60d64e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a453b457823e1ddf916ebf298befb4512"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a453b457823e1ddf916ebf298befb4512">nonATGCNtoN</a> (const string &amp;s)</td></tr>
<tr class="separator:a453b457823e1ddf916ebf298befb4512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb243c35d883121f8645815571b7a55f"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afb243c35d883121f8645815571b7a55f">allAmbiguousToN</a> (const string &amp;s)</td></tr>
<tr class="separator:afb243c35d883121f8645815571b7a55f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00a949105ae94b18ca72452a442b8ddb"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a00a949105ae94b18ca72452a442b8ddb">toUppercase</a> (const string &amp;s)</td></tr>
<tr class="separator:a00a949105ae94b18ca72452a442b8ddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcf3d4a70f85f067842ccf34a82a4a46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#adcf3d4a70f85f067842ccf34a82a4a46">toUppercaseInPlace</a> (string &amp;s)</td></tr>
<tr class="separator:adcf3d4a70f85f067842ccf34a82a4a46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a239160a6fee7d0af8914c4ebc7275c78"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a239160a6fee7d0af8914c4ebc7275c78">write_fasta_sequence</a> (const std::string &amp;name, const std::string &amp;sequence, ostream &amp;os, size_t width)</td></tr>
<tr class="separator:a239160a6fee7d0af8914c4ebc7275c78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9fc5855bb49062ce72e56c805e1545a"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae9fc5855bb49062ce72e56c805e1545a">get_or_make_variant_id</a> (const vcflib::Variant &amp;variant)</td></tr>
<tr class="separator:ae9fc5855bb49062ce72e56c805e1545a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa74ef603900cf05ce35dbab813d21deb"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa74ef603900cf05ce35dbab813d21deb">make_variant_id</a> (const vcflib::Variant &amp;variant)</td></tr>
<tr class="separator:aa74ef603900cf05ce35dbab813d21deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a931d9271de88fc786030fdd0ab4bf534"><td class="memItemLeft" align="right" valign="top">vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a931d9271de88fc786030fdd0ab4bf534">range_vector</a> (size_t begin, size_t end)</td></tr>
<tr class="memdesc:a931d9271de88fc786030fdd0ab4bf534"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector containing positive integer values in [begin, end)  <a href="namespacevg.html#a931d9271de88fc786030fdd0ab4bf534">More...</a><br /></td></tr>
<tr class="separator:a931d9271de88fc786030fdd0ab4bf534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9c563a243faef4e5357eca9c7c8500"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5e9c563a243faef4e5357eca9c7c8500">stack_permutations</a> (const std::vector&lt; size_t &gt; &amp;bottom, const std::vector&lt; size_t &gt; &amp;top)</td></tr>
<tr class="memdesc:a5e9c563a243faef4e5357eca9c7c8500"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply one permutation on top of another. Retutn the combined permutation.  <a href="namespacevg.html#a5e9c563a243faef4e5357eca9c7c8500">More...</a><br /></td></tr>
<tr class="separator:a5e9c563a243faef4e5357eca9c7c8500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c950dca7cd25a5ce9846be2a6b93e13"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7c950dca7cd25a5ce9846be2a6b93e13">have_input_file</a> (int &amp;optind, int argc, char **argv)</td></tr>
<tr class="memdesc:a7c950dca7cd25a5ce9846be2a6b93e13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if there's a command line argument (i.e. input file name) waiting to be processed.  <a href="namespacevg.html#a7c950dca7cd25a5ce9846be2a6b93e13">More...</a><br /></td></tr>
<tr class="separator:a7c950dca7cd25a5ce9846be2a6b93e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1b8b686ef6eca09515be1abe566c013"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab1b8b686ef6eca09515be1abe566c013">get_input_file</a> (int &amp;optind, int argc, char **argv, function&lt; void(istream &amp;)&gt; callback)</td></tr>
<tr class="separator:ab1b8b686ef6eca09515be1abe566c013"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5026b599b1094a6c8e157f23b204b09b"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a5026b599b1094a6c8e157f23b204b09b">get_input_file_name</a> (int &amp;optind, int argc, char **argv, bool test_open)</td></tr>
<tr class="separator:a5026b599b1094a6c8e157f23b204b09b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae2a0425675c4a85289b230eef2c985b8"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae2a0425675c4a85289b230eef2c985b8">get_output_file_name</a> (int &amp;optind, int argc, char **argv)</td></tr>
<tr class="separator:ae2a0425675c4a85289b230eef2c985b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09969fef23098c7729a2f190cecb4694"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a09969fef23098c7729a2f190cecb4694">get_input_file</a> (const string &amp;file_name, function&lt; void(istream &amp;)&gt; callback)</td></tr>
<tr class="separator:a09969fef23098c7729a2f190cecb4694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a984d142cea24f43a1025bf7bb7b48a53"><td class="memItemLeft" align="right" valign="top">pair&lt; string, string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a984d142cea24f43a1025bf7bb7b48a53">split_ext</a> (const string &amp;filename)</td></tr>
<tr class="memdesc:a984d142cea24f43a1025bf7bb7b48a53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Split off the extension from a filename and return both parts.  <a href="namespacevg.html#a984d142cea24f43a1025bf7bb7b48a53">More...</a><br /></td></tr>
<tr class="separator:a984d142cea24f43a1025bf7bb7b48a53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abebdd1477a436020f3d3f8368d825054"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abebdd1477a436020f3d3f8368d825054">file_exists</a> (const string &amp;filename)</td></tr>
<tr class="separator:abebdd1477a436020f3d3f8368d825054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9e16eec9e4a4120718eba7d5711a7df"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae9e16eec9e4a4120718eba7d5711a7df">create_ref_allele</a> (vcflib::Variant &amp;variant, const std::string &amp;allele)</td></tr>
<tr class="separator:ae9e16eec9e4a4120718eba7d5711a7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6391a10ec421fbb6c487f491bd978ef6"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a6391a10ec421fbb6c487f491bd978ef6">add_alt_allele</a> (vcflib::Variant &amp;variant, const std::string &amp;allele)</td></tr>
<tr class="separator:a6391a10ec421fbb6c487f491bd978ef6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca4239af1a9e3eb1283f78bf5cc1411a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aca4239af1a9e3eb1283f78bf5cc1411a">integer_power</a> (uint64_t base, uint64_t exponent)</td></tr>
<tr class="memdesc:aca4239af1a9e3eb1283f78bf5cc1411a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes base^exponent in log(exponent) time.  <a href="namespacevg.html#aca4239af1a9e3eb1283f78bf5cc1411a">More...</a><br /></td></tr>
<tr class="separator:aca4239af1a9e3eb1283f78bf5cc1411a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc8f8791be2575164e6070e1cef39b4e"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abc8f8791be2575164e6070e1cef39b4e">modular_exponent</a> (uint64_t base, uint64_t exponent, uint64_t modulus)</td></tr>
<tr class="separator:abc8f8791be2575164e6070e1cef39b4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4012afd56ccb35387121c71c2119e244"><td class="memItemLeft" align="right" valign="top">default_random_engine&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4012afd56ccb35387121c71c2119e244">random_sequence_gen</a> (102)</td></tr>
<tr class="separator:a4012afd56ccb35387121c71c2119e244"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80fc8c8920c7ec53cfee81dc2fce852"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab80fc8c8920c7ec53cfee81dc2fce852">random_sequence</a> (size_t length)</td></tr>
<tr class="memdesc:ab80fc8c8920c7ec53cfee81dc2fce852"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a uniformly random DNA sequence of the given length.  <a href="namespacevg.html#ab80fc8c8920c7ec53cfee81dc2fce852">More...</a><br /></td></tr>
<tr class="separator:ab80fc8c8920c7ec53cfee81dc2fce852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1924855da445b625609837c0920af7b2"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1924855da445b625609837c0920af7b2">pseudo_random_sequence</a> (size_t length, uint64_t seed)</td></tr>
<tr class="memdesc:a1924855da445b625609837c0920af7b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a uniformly random DNA sequence sequence deterministically from a seed.  <a href="namespacevg.html#a1924855da445b625609837c0920af7b2">More...</a><br /></td></tr>
<tr class="separator:a1924855da445b625609837c0920af7b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab169ac1e2fc6ba662eebc1ede1ffe157"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab169ac1e2fc6ba662eebc1ede1ffe157">replace_in_string</a> (string subject, const string &amp;search, const string &amp;replace)</td></tr>
<tr class="separator:ab169ac1e2fc6ba662eebc1ede1ffe157"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba15a613567689d941f30a5a17c6ead"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2ba15a613567689d941f30a5a17c6ead">percent_url_encode</a> (const string &amp;seq)</td></tr>
<tr class="memdesc:a2ba15a613567689d941f30a5a17c6ead"><td class="mdescLeft">&#160;</td><td class="mdescRight">Escape "%" to "%25".  <a href="namespacevg.html#a2ba15a613567689d941f30a5a17c6ead">More...</a><br /></td></tr>
<tr class="separator:a2ba15a613567689d941f30a5a17c6ead"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b5e48235129c3583b5b3942ff4d44d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a73b5e48235129c3583b5b3942ff4d44d">deterministic_flip</a> (<a class="el" href="classvg_1_1LazyRNG.html">LazyRNG</a> &amp;rng)</td></tr>
<tr class="memdesc:a73b5e48235129c3583b5b3942ff4d44d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Flip a coin with 50% probability against the given RNG.  <a href="namespacevg.html#a73b5e48235129c3583b5b3942ff4d44d">More...</a><br /></td></tr>
<tr class="separator:a73b5e48235129c3583b5b3942ff4d44d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86d5f690fe272c74949e080aca561467"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a86d5f690fe272c74949e080aca561467">overlay_node_translations</a> (const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;over, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;under)</td></tr>
<tr class="memdesc:a86d5f690fe272c74949e080aca561467"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose the translations from two graph operations, both of which involved oriented transformations.  <a href="namespacevg.html#a86d5f690fe272c74949e080aca561467">More...</a><br /></td></tr>
<tr class="separator:a86d5f690fe272c74949e080aca561467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7816225a17a671ff849a79f064770ebb"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7816225a17a671ff849a79f064770ebb">overlay_node_translations</a> (const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;over, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;under)</td></tr>
<tr class="memdesc:a7816225a17a671ff849a79f064770ebb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose the translations from two graph operations, the first of which involved oriented transformations.  <a href="namespacevg.html#a7816225a17a671ff849a79f064770ebb">More...</a><br /></td></tr>
<tr class="separator:a7816225a17a671ff849a79f064770ebb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af224cfdc27efec675771ba4cc5143a3f"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#af224cfdc27efec675771ba4cc5143a3f">overlay_node_translations</a> (const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;over, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;under)</td></tr>
<tr class="memdesc:af224cfdc27efec675771ba4cc5143a3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose the translations from two graph operations, the second of which involved oriented transformations.  <a href="namespacevg.html#af224cfdc27efec675771ba4cc5143a3f">More...</a><br /></td></tr>
<tr class="separator:af224cfdc27efec675771ba4cc5143a3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae996017b379b1178d5e588b96a7c7f3f"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae996017b379b1178d5e588b96a7c7f3f">overlay_node_translations</a> (const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;over, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;under)</td></tr>
<tr class="memdesc:ae996017b379b1178d5e588b96a7c7f3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compose the translations from two graph operations, neither of which involved oriented transformations.  <a href="namespacevg.html#ae996017b379b1178d5e588b96a7c7f3f">More...</a><br /></td></tr>
<tr class="separator:ae996017b379b1178d5e588b96a7c7f3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd328fd8abb43338a3ae9e0a3b0be1f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1dd328fd8abb43338a3ae9e0a3b0be1f"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1dd328fd8abb43338a3ae9e0a3b0be1f">parse</a> (const string &amp;arg, double &amp;dest)</td></tr>
<tr class="separator:a1dd328fd8abb43338a3ae9e0a3b0be1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1de4a1752e875116c767ec49a8e2961"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa1de4a1752e875116c767ec49a8e2961"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa1de4a1752e875116c767ec49a8e2961">parse</a> (const string &amp;arg, std::regex &amp;dest)</td></tr>
<tr class="separator:aa1de4a1752e875116c767ec49a8e2961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4a3393960dd54c941e9d7c317923c2e"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aa4a3393960dd54c941e9d7c317923c2e"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa4a3393960dd54c941e9d7c317923c2e">parse</a> (const string &amp;arg, <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;dest)</td></tr>
<tr class="separator:aa4a3393960dd54c941e9d7c317923c2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97c44463adc7ddcc77ac9664692a62b8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a97c44463adc7ddcc77ac9664692a62b8">is_number</a> (const string &amp;s)</td></tr>
<tr class="separator:a97c44463adc7ddcc77ac9664692a62b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace99283a6b34f0891dc0b49f0cd60eea"><td class="memTemplParams" colspan="2">template&lt;typename T , typename V &gt; </td></tr>
<tr class="memitem:ace99283a6b34f0891dc0b49f0cd60eea"><td class="memTemplItemLeft" align="right" valign="top">set&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ace99283a6b34f0891dc0b49f0cd60eea">map_keys_to_set</a> (const map&lt; T, V &gt; &amp;m)</td></tr>
<tr class="separator:ace99283a6b34f0891dc0b49f0cd60eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f5da8e25414026729f0c4d09243f6d"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ac7f5da8e25414026729f0c4d09243f6d"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ac7f5da8e25414026729f0c4d09243f6d">pmax</a> (const std::vector&lt; T &gt; &amp;a, const std::vector&lt; T &gt; &amp;b)</td></tr>
<tr class="separator:ac7f5da8e25414026729f0c4d09243f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec4813274fc2af3d83679e128fdeb32f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aec4813274fc2af3d83679e128fdeb32f"><td class="memTemplItemLeft" align="right" valign="top">vector&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#aec4813274fc2af3d83679e128fdeb32f">vpmax</a> (const std::vector&lt; std::vector&lt; T &gt;&gt; &amp;vv)</td></tr>
<tr class="separator:aec4813274fc2af3d83679e128fdeb32f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa70726366aa31b20debdcac41c89490c"><td class="memTemplParams" colspan="2">template&lt;typename Collection &gt; </td></tr>
<tr class="memitem:aa70726366aa31b20debdcac41c89490c"><td class="memTemplItemLeft" align="right" valign="top">Collection::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa70726366aa31b20debdcac41c89490c">sum</a> (const Collection &amp;collection)</td></tr>
<tr class="separator:aa70726366aa31b20debdcac41c89490c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4833086451a8b97af4709aa6c7385177"><td class="memTemplParams" colspan="2">template&lt;template&lt; class T, class A=std::allocator&lt; T &gt;&gt; class Container, typename Input , typename Output &gt; </td></tr>
<tr class="memitem:a4833086451a8b97af4709aa6c7385177"><td class="memTemplItemLeft" align="right" valign="top">Container&lt; Output &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a4833086451a8b97af4709aa6c7385177">map_over</a> (const Container&lt; Input &gt; &amp;in, const std::function&lt; Output(const Input &amp;)&gt; &amp;lambda)</td></tr>
<tr class="separator:a4833086451a8b97af4709aa6c7385177"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6a210206858f806b345f8eb5c2c292a"><td class="memTemplParams" colspan="2">template&lt;template&lt; class T, class A=std::allocator&lt; T &gt;&gt; class Container, typename Item &gt; </td></tr>
<tr class="memitem:ae6a210206858f806b345f8eb5c2c292a"><td class="memTemplItemLeft" align="right" valign="top">Container&lt; const Item * &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae6a210206858f806b345f8eb5c2c292a">pointerfy</a> (const Container&lt; Item &gt; &amp;in)</td></tr>
<tr class="separator:ae6a210206858f806b345f8eb5c2c292a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64380ba1816d3fd97847a6dc6b2665d8"><td class="memTemplParams" colspan="2">template&lt;typename Item &gt; </td></tr>
<tr class="memitem:a64380ba1816d3fd97847a6dc6b2665d8"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; Item &gt;::const_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a64380ba1816d3fd97847a6dc6b2665d8">operator+</a> (typename <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; Item &gt;::const_iterator::difference_type a, const typename <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; Item &gt;::const_iterator &amp;b)</td></tr>
<tr class="memdesc:a64380ba1816d3fd97847a6dc6b2665d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow <a class="el" href="structvg_1_1VectorView.html">VectorView</a> iterators to be added to numbers.  <a href="namespacevg.html#a64380ba1816d3fd97847a6dc6b2665d8">More...</a><br /></td></tr>
<tr class="separator:a64380ba1816d3fd97847a6dc6b2665d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39adca1737de5d28d007d95b809deb7f"><td class="memItemLeft" align="right" valign="top">vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a39adca1737de5d28d007d95b809deb7f">range_vector</a> (size_t end)</td></tr>
<tr class="memdesc:a39adca1737de5d28d007d95b809deb7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Vector containing positive integer values in [0, end)  <a href="namespacevg.html#a39adca1737de5d28d007d95b809deb7f">More...</a><br /></td></tr>
<tr class="separator:a39adca1737de5d28d007d95b809deb7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae031408254f8c4031ba0b632f5456059"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ae031408254f8c4031ba0b632f5456059"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae031408254f8c4031ba0b632f5456059">sort_permutation</a> (const Iterator &amp;begin, const Iterator &amp;end, const std::function&lt; bool(const typename Iterator::value_type &amp;, const typename Iterator::value_type &amp;)&gt; &amp;comparator)</td></tr>
<tr class="memdesc:ae031408254f8c4031ba0b632f5456059"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index permutation that sorts the given items with the given comparator instead of &lt;.  <a href="namespacevg.html#ae031408254f8c4031ba0b632f5456059">More...</a><br /></td></tr>
<tr class="separator:ae031408254f8c4031ba0b632f5456059"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab03fad9d3c71a090606afbe1ef22ce71"><td class="memTemplParams" colspan="2">template&lt;typename Iterator &gt; </td></tr>
<tr class="memitem:ab03fad9d3c71a090606afbe1ef22ce71"><td class="memTemplItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ab03fad9d3c71a090606afbe1ef22ce71">sort_permutation</a> (const Iterator &amp;begin, const Iterator &amp;end)</td></tr>
<tr class="memdesc:ab03fad9d3c71a090606afbe1ef22ce71"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the index permutation that sorts the given items ascending using &lt;.  <a href="namespacevg.html#ab03fad9d3c71a090606afbe1ef22ce71">More...</a><br /></td></tr>
<tr class="separator:ab03fad9d3c71a090606afbe1ef22ce71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7c32d1e90ec006624a7ee03655f3c35"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa7c32d1e90ec006624a7ee03655f3c35">integer_power</a> (size_t x, size_t power)</td></tr>
<tr class="separator:aa7c32d1e90ec006624a7ee03655f3c35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a2c2b828b3943b33f2b0b12f756ed9a"><td class="memTemplParams" colspan="2">template&lt;class RandomIt &gt; </td></tr>
<tr class="memitem:a2a2c2b828b3943b33f2b0b12f756ed9a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2a2c2b828b3943b33f2b0b12f756ed9a">deterministic_shuffle</a> (RandomIt begin, RandomIt end, <a class="el" href="classvg_1_1LazyRNG.html">LazyRNG</a> &amp;rng)</td></tr>
<tr class="separator:a2a2c2b828b3943b33f2b0b12f756ed9a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f573d1f1f474086cbe0a8933fe29988"><td class="memTemplParams" colspan="2">template&lt;typename Number &gt; </td></tr>
<tr class="memitem:a1f573d1f1f474086cbe0a8933fe29988"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1f573d1f1f474086cbe0a8933fe29988">deterministic_beats</a> (const Number &amp;a, const Number &amp;b, <a class="el" href="classvg_1_1LazyRNG.html">LazyRNG</a> &amp;rng)</td></tr>
<tr class="memdesc:a1f573d1f1f474086cbe0a8933fe29988"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if a is larger than b, or else equal to b and wins a coin flip.  <a href="namespacevg.html#a1f573d1f1f474086cbe0a8933fe29988">More...</a><br /></td></tr>
<tr class="separator:a1f573d1f1f474086cbe0a8933fe29988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc312d814d6a06a4a5159c7943675bbe"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#acc312d814d6a06a4a5159c7943675bbe">make_shuffle_seed</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln)</td></tr>
<tr class="memdesc:acc312d814d6a06a4a5159c7943675bbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make seeds for Alignments based on their sequences.  <a href="namespacevg.html#acc312d814d6a06a4a5159c7943675bbe">More...</a><br /></td></tr>
<tr class="separator:acc312d814d6a06a4a5159c7943675bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ec8fc79a1f84c6ef4a02c9d7c7a2850"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a2ec8fc79a1f84c6ef4a02c9d7c7a2850"><td class="memTemplItemLeft" align="right" valign="top">string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2ec8fc79a1f84c6ef4a02c9d7c7a2850">make_shuffle_seed</a> (const T *ptr)</td></tr>
<tr class="memdesc:a2ec8fc79a1f84c6ef4a02c9d7c7a2850"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make seeds for pointers to things we can make seeds for.  <a href="namespacevg.html#a2ec8fc79a1f84c6ef4a02c9d7c7a2850">More...</a><br /></td></tr>
<tr class="separator:a2ec8fc79a1f84c6ef4a02c9d7c7a2850"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ebc20fd2965b1932e27958dd0c602c"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a04ebc20fd2965b1932e27958dd0c602c"><td class="memTemplItemLeft" align="right" valign="top">string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a04ebc20fd2965b1932e27958dd0c602c">make_shuffle_seed</a> (const pair&lt; T1, T2 &gt; &amp;p)</td></tr>
<tr class="memdesc:a04ebc20fd2965b1932e27958dd0c602c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make seeds for pairs of things we can make seeds for.  <a href="namespacevg.html#a04ebc20fd2965b1932e27958dd0c602c">More...</a><br /></td></tr>
<tr class="separator:a04ebc20fd2965b1932e27958dd0c602c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae74e428a09df726b5c2f4998b9d0a442"><td class="memTemplParams" colspan="2">template&lt;class RandomIt &gt; </td></tr>
<tr class="memitem:ae74e428a09df726b5c2f4998b9d0a442"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae74e428a09df726b5c2f4998b9d0a442">deterministic_shuffle</a> (RandomIt begin, RandomIt end)</td></tr>
<tr class="memdesc:ae74e428a09df726b5c2f4998b9d0a442"><td class="mdescLeft">&#160;</td><td class="mdescRight">Do a deterministic shuffle with automatic seed determination.  <a href="namespacevg.html#ae74e428a09df726b5c2f4998b9d0a442">More...</a><br /></td></tr>
<tr class="separator:ae74e428a09df726b5c2f4998b9d0a442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe3de0ca79c815a4eaf63df34805f6d0"><td class="memTemplParams" colspan="2">template&lt;class RandomIt , class Compare &gt; </td></tr>
<tr class="memitem:afe3de0ca79c815a4eaf63df34805f6d0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#afe3de0ca79c815a4eaf63df34805f6d0">sort_shuffling_ties</a> (RandomIt begin, RandomIt end, Compare comp, <a class="el" href="classvg_1_1LazyRNG.html">LazyRNG</a> &amp;rng)</td></tr>
<tr class="separator:afe3de0ca79c815a4eaf63df34805f6d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa071bccfee3a9078930f2c385e8dda20"><td class="memTemplParams" colspan="2">template&lt;class RandomIt , class Compare &gt; </td></tr>
<tr class="memitem:aa071bccfee3a9078930f2c385e8dda20"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa071bccfee3a9078930f2c385e8dda20">sort_shuffling_ties</a> (RandomIt begin, RandomIt end, Compare comp)</td></tr>
<tr class="separator:aa071bccfee3a9078930f2c385e8dda20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8873caafc22d22b52e0f6f3f164f6dc8"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:a8873caafc22d22b52e0f6f3f164f6dc8"><td class="memTemplItemLeft" align="right" valign="top">Result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8873caafc22d22b52e0f6f3f164f6dc8">parse</a> (const string &amp;arg)</td></tr>
<tr class="separator:a8873caafc22d22b52e0f6f3f164f6dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c5c364797f623025b67b9aff0657112"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:a8c5c364797f623025b67b9aff0657112"><td class="memTemplItemLeft" align="right" valign="top">Result&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8c5c364797f623025b67b9aff0657112">parse</a> (const char *arg)</td></tr>
<tr class="separator:a8c5c364797f623025b67b9aff0657112"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627f5ad6fe6f1e6b4cc23ac97dfca4b8"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:a627f5ad6fe6f1e6b4cc23ac97dfca4b8"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a627f5ad6fe6f1e6b4cc23ac97dfca4b8">parse</a> (const string &amp;arg, Result &amp;dest)</td></tr>
<tr class="separator:a627f5ad6fe6f1e6b4cc23ac97dfca4b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd6368e7395f1d90c4e3be1a7293d0a"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:a2cd6368e7395f1d90c4e3be1a7293d0a"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a2cd6368e7395f1d90c4e3be1a7293d0a">parse</a> (const string &amp;arg, typename enable_if&lt; sizeof(Result)&lt;=sizeof(long long) &amp;&amp;is_integral&lt; Result &gt;::value &amp;&amp;is_signed&lt; Result &gt;::value, Result &gt;::type &amp;dest)</td></tr>
<tr class="separator:a2cd6368e7395f1d90c4e3be1a7293d0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d3374c888c7c37f1de8370e151af7f9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a7d3374c888c7c37f1de8370e151af7f9">genotype_svs</a> (<a class="el" href="classvg_1_1VG.html">VG</a> *graph, string gamfile, string refpath)</td></tr>
<tr class="separator:a7d3374c888c7c37f1de8370e151af7f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96096594534e59d12b7a2cff3c400ef0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a96096594534e59d12b7a2cff3c400ef0">variant_recall</a> (<a class="el" href="classvg_1_1VG.html">VG</a> *graph, vcflib::VariantCallFile *vars, FastaReference *ref_genome, vector&lt; FastaReference * &gt; insertions, string gamfile)</td></tr>
<tr class="separator:a96096594534e59d12b7a2cff3c400ef0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8bc1d89bbcee041956e59895ed605ca3"><td class="memItemLeft" align="right" valign="top">tuple&lt; double, double, double &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a8bc1d89bbcee041956e59895ed605ca3">hash_to_rgb</a> (const string &amp;str, double min_sum)</td></tr>
<tr class="separator:a8bc1d89bbcee041956e59895ed605ca3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38d35bca25e8a6d5fe10f603cb9048c3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a38d35bca25e8a6d5fe10f603cb9048c3">wang_hash_64</a> (size_t key)</td></tr>
<tr class="separator:a38d35bca25e8a6d5fe10f603cb9048c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1384531a1c8d8387bdd04961590bdf93"><td class="memTemplParams" colspan="2">template&lt;typename Result &gt; </td></tr>
<tr class="memitem:a1384531a1c8d8387bdd04961590bdf93"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacevg.html#a1384531a1c8d8387bdd04961590bdf93">parse</a> (const string &amp;arg, typename enable_if&lt; <a class="el" href="structvg_1_1is__instantiation__of.html">is_instantiation_of</a>&lt; Result, <a class="el" href="structvg_1_1Range.html">Range</a> &gt;::value, Result &gt;::type &amp;dest)</td></tr>
<tr class="memdesc:a1384531a1c8d8387bdd04961590bdf93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse a range as start[:end[:step]].  <a href="namespacevg.html#a1384531a1c8d8387bdd04961590bdf93">More...</a><br /></td></tr>
<tr class="separator:a1384531a1c8d8387bdd04961590bdf93"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ade7204b42260155b9a98a6d18c24a0b7"><td class="memItemLeft" align="right" valign="top">const char *const&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ade7204b42260155b9a98a6d18c24a0b7">BAM_DNA_LOOKUP</a> = &quot;=ACMGRSVTWYHKDBN&quot;</td></tr>
<tr class="separator:ade7204b42260155b9a98a6d18c24a0b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe7fae89b379b5411189ac0ac74b2dd4"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#afe7fae89b379b5411189ac0ac74b2dd4">var</a> = &quot;VG_FULL_TRACEBACK&quot;</td></tr>
<tr class="separator:afe7fae89b379b5411189ac0ac74b2dd4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd1798abb6fcee86ab5b0539fb764eb2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#abd1798abb6fcee86ab5b0539fb764eb2">fullTrace</a> = false</td></tr>
<tr class="separator:abd1798abb6fcee86ab5b0539fb764eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae77436235694e5e661c74799ab326d0b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#ae77436235694e5e661c74799ab326d0b">ISSUE_URL</a> = &quot;https://github.com/vgteam/vg/issues/new/choose&quot;</td></tr>
<tr class="separator:ae77436235694e5e661c74799ab326d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb1b2d0c77858355b8bfbbe4406f0931"><td class="memItemLeft" align="right" valign="top">thread_local std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aeb1b2d0c77858355b8bfbbe4406f0931">stored_crash_context</a></td></tr>
<tr class="separator:aeb1b2d0c77858355b8bfbbe4406f0931"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32104605c22b25e9ec17d69fbc61a4b"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvg_1_1read__alignment__index__t.html">read_alignment_index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#aa32104605c22b25e9ec17d69fbc61a4b">NO_READ_INDEX</a> = {std::numeric_limits&lt;size_t&gt;::infinity(), std::numeric_limits&lt;size_t&gt;::infinity()}</td></tr>
<tr class="memdesc:aa32104605c22b25e9ec17d69fbc61a4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an unset index.  <a href="namespacevg.html#aa32104605c22b25e9ec17d69fbc61a4b">More...</a><br /></td></tr>
<tr class="separator:aa32104605c22b25e9ec17d69fbc61a4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0fc209aaa8c7c17499d70452d2816f44"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="structvg_1_1alignment__index__t.html">alignment_index_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacevg.html#a0fc209aaa8c7c17499d70452d2816f44">NO_INDEX</a> {std::numeric_limits&lt;size_t&gt;::max(), std::numeric_limits&lt;size_t&gt;::max(), std::numeric_limits&lt;bool&gt;::max()}</td></tr>
<tr class="memdesc:a0fc209aaa8c7c17499d70452d2816f44"><td class="mdescLeft">&#160;</td><td class="mdescRight">Represents an unset index.  <a href="namespacevg.html#a0fc209aaa8c7c17499d70452d2816f44">More...</a><br /></td></tr>
<tr class="separator:a0fc209aaa8c7c17499d70452d2816f44"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a4ab10687f0a0cca11ecfd062d9bb0a07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab10687f0a0cca11ecfd062d9bb0a07">&#9670;&nbsp;</a></span>benchtime</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#a4ab10687f0a0cca11ecfd062d9bb0a07">vg::benchtime</a> = typedef chrono::nanoseconds</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>We define a duration type for expressing benchmark times in. </p>

</div>
</div>
<a id="aceea01d66677e39af71921f1bb1911f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aceea01d66677e39af71921f1bb1911f0">&#9670;&nbsp;</a></span>Chain</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">vg::Chain</a> = typedef vector&lt;pair&lt;const <a class="el" href="structvg_1_1Snarl.html">Snarl</a>*, bool&gt; &gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Snarls are defined at the Protobuf level, but here is how we define chains as real objects.</p>
<p>A chain is a sequence of Snarls, in either normal (false) or reverse (true) orientation.</p>
<p>The <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> is going to have one official copy of each chain stored, and it will give you a pointer to it on demand. </p>

</div>
</div>
<a id="aa6df851edf21daea75fc6dc1dd81a78f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6df851edf21daea75fc6dc1dd81a78f">&#9670;&nbsp;</a></span>DeletableHandleGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">vg::DeletableHandleGraph</a> = typedef <a class="el" href="classhandlegraph_1_1DeletableHandleGraph.html">handlegraph::DeletableHandleGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3de8fe5f38b1730a36af4ad9c4258963"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3de8fe5f38b1730a36af4ad9c4258963">&#9670;&nbsp;</a></span>edge_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#a3de8fe5f38b1730a36af4ad9c4258963">vg::edge_t</a> = typedef <a class="el" href="namespacehandlegraph.html#a91452647367df9cfc96454c0cd07ce7b">handlegraph::edge_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7a29090bbc6b842c2362f9da44a4a57c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a29090bbc6b842c2362f9da44a4a57c">&#9670;&nbsp;</a></span>EdgeMapping</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::map&lt;<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, std::vector&lt;<a class="el" href="structvg_1_1Edge.html">Edge</a>*&gt; &gt; <a class="el" href="namespacevg.html#a7a29090bbc6b842c2362f9da44a4a57c">vg::EdgeMapping</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ae488d495e344881cbcf599ebdd2355"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae488d495e344881cbcf599ebdd2355">&#9670;&nbsp;</a></span>exon_nodes_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef vector&lt;gbwt::node_type&gt; <a class="el" href="namespacevg.html#a8ae488d495e344881cbcf599ebdd2355">vg::exon_nodes_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b677be2f409ffcbefd5d9f6149c80c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b677be2f409ffcbefd5d9f6149c80c1">&#9670;&nbsp;</a></span>GAMIndex</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#a9b677be2f409ffcbefd5d9f6149c80c1">vg::GAMIndex</a> = typedef <a class="el" href="classvg_1_1StreamIndex.html">StreamIndex</a>&lt;<a class="el" href="structvg_1_1Alignment.html">Alignment</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Define a GAM index as a stream index over a stream of Alignments. </p>

</div>
</div>
<a id="a6c00bf57d75db83e41ac19a88882c043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c00bf57d75db83e41ac19a88882c043">&#9670;&nbsp;</a></span>GAMSorter</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#a6c00bf57d75db83e41ac19a88882c043">vg::GAMSorter</a> = typedef <a class="el" href="classvg_1_1StreamSorter.html">StreamSorter</a>&lt;<a class="el" href="structvg_1_1Alignment.html">Alignment</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7143bc6d4008d03bc4a0ac4d4ba26948"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7143bc6d4008d03bc4a0ac4d4ba26948">&#9670;&nbsp;</a></span>Handle2Component</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unordered_map&lt;<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, int&gt; <a class="el" href="namespacevg.html#a7143bc6d4008d03bc4a0ac4d4ba26948">vg::Handle2Component</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaed4a2b7bc668cf2e076733ee26e036a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaed4a2b7bc668cf2e076733ee26e036a">&#9670;&nbsp;</a></span>handle_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structhandlegraph_1_1handle__t.html">vg::handle_t</a> = typedef <a class="el" href="structhandlegraph_1_1handle__t.html">handlegraph::handle_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad5781c55c25f1446e1fc74c72c051c62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5781c55c25f1446e1fc74c72c051c62">&#9670;&nbsp;</a></span>HandleGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classhandlegraph_1_1HandleGraph.html">vg::HandleGraph</a> = typedef <a class="el" href="classhandlegraph_1_1HandleGraph.html">handlegraph::HandleGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0942a662fe36dad76d2d0e310ec66e3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0942a662fe36dad76d2d0e310ec66e3f">&#9670;&nbsp;</a></span>HandleSet</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unordered_set&lt;<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&gt; <a class="el" href="namespacevg.html#a0942a662fe36dad76d2d0e310ec66e3f">vg::HandleSet</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afaa15fd8bdfd688d48561e1b12aee821"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afaa15fd8bdfd688d48561e1b12aee821">&#9670;&nbsp;</a></span>id_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">handlegraph::nid_t</a> <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">vg::id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a> ID. ID type is a 64-bit signed int. </p>

</div>
</div>
<a id="a96bc10f0ba77bc672e88a9f7d6e126b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96bc10f0ba77bc672e88a9f7d6e126b6">&#9670;&nbsp;</a></span>IndexGroup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#a96bc10f0ba77bc672e88a9f7d6e126b6">vg::IndexGroup</a> = typedef set&lt;<a class="el" href="namespacevg.html#a7027e98a84fa4b0fa42f72bf4a1d862f">IndexName</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A group of indexes that can be made simultaneously </p>

</div>
</div>
<a id="a7027e98a84fa4b0fa42f72bf4a1d862f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7027e98a84fa4b0fa42f72bf4a1d862f">&#9670;&nbsp;</a></span>IndexName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#a7027e98a84fa4b0fa42f72bf4a1d862f">vg::IndexName</a> = typedef string</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A unique identifier for an Index </p>

</div>
</div>
<a id="a293aa7465cc63a2581914d6a85a0e4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a293aa7465cc63a2581914d6a85a0e4b8">&#9670;&nbsp;</a></span>MutableHandleGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">vg::MutableHandleGraph</a> = typedef <a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">handlegraph::MutableHandleGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2f0cc7bac7a4f92b2b523357f8940aa5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f0cc7bac7a4f92b2b523357f8940aa5">&#9670;&nbsp;</a></span>MutablePathDeletableHandleGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html">vg::MutablePathDeletableHandleGraph</a> = typedef <a class="el" href="classhandlegraph_1_1MutablePathDeletableHandleGraph.html">handlegraph::MutablePathDeletableHandleGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a24350c08e6d69244e6930f41fee00e1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24350c08e6d69244e6930f41fee00e1f">&#9670;&nbsp;</a></span>MutablePathHandleGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html">vg::MutablePathHandleGraph</a> = typedef <a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html">handlegraph::MutablePathHandleGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2f83c48d4ecdcfd8f2604f10e863aea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2f83c48d4ecdcfd8f2604f10e863aea">&#9670;&nbsp;</a></span>MutablePathMutableHandleGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">vg::MutablePathMutableHandleGraph</a> = typedef <a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">handlegraph::MutablePathMutableHandleGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c7b4f84e5a75aee3d3abf4b65b0000f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c7b4f84e5a75aee3d3abf4b65b0000f">&#9670;&nbsp;</a></span>NamedNodeBackTranslation</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">vg::NamedNodeBackTranslation</a> = typedef <a class="el" href="classhandlegraph_1_1NamedNodeBackTranslation.html">handlegraph::NamedNodeBackTranslation</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a26f660292f00451f15d1c95d9b8c6ffb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26f660292f00451f15d1c95d9b8c6ffb">&#9670;&nbsp;</a></span>nid_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">vg::nid_t</a> = typedef <a class="el" href="namespacehandlegraph.html#a93c2889b752934c4b2488b37cbdd278b">handlegraph::nid_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe223f2c7890c76de5e00b43ceb37add"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe223f2c7890c76de5e00b43ceb37add">&#9670;&nbsp;</a></span>offset_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef size_t <a class="el" href="namespacevg.html#afe223f2c7890c76de5e00b43ceb37add">vg::offset_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents an offset along the sequence of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a>. Offsets are size_t. </p>

</div>
</div>
<a id="acf54b55d1c1d16a3d64f1bae268a58af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf54b55d1c1d16a3d64f1bae268a58af">&#9670;&nbsp;</a></span>oriented_node_range_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#acf54b55d1c1d16a3d64f1bae268a58af">vg::oriented_node_range_t</a> = typedef <a class="el" href="namespacehandlegraph.html#aa9a6ea7613d52c42947d4faa2a189bba">handlegraph::oriented_node_range_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1aa2d026eb3edc0c692e19e5a493feef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1aa2d026eb3edc0c692e19e5a493feef">&#9670;&nbsp;</a></span>pareto_point</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::pair&lt;uint32_t, int32_t&gt; <a class="el" href="namespacevg.html#a1aa2d026eb3edc0c692e19e5a493feef">vg::pareto_point</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaf7aeec04909c1aac0ad991764d48e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf7aeec04909c1aac0ad991764d48e24">&#9670;&nbsp;</a></span>path_handle_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structhandlegraph_1_1path__handle__t.html">vg::path_handle_t</a> = typedef <a class="el" href="structhandlegraph_1_1path__handle__t.html">handlegraph::path_handle_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abeb2636bd0db3101259ef6803cb4e591"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb2636bd0db3101259ef6803cb4e591">&#9670;&nbsp;</a></span>PathHandleGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">vg::PathHandleGraph</a> = typedef <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">handlegraph::PathHandleGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5f7f6692a7600f1fa62428255c5bb61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f7f6692a7600f1fa62428255c5bb61">&#9670;&nbsp;</a></span>PathMetadata</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classhandlegraph_1_1PathMetadata.html">vg::PathMetadata</a> = typedef <a class="el" href="classhandlegraph_1_1PathMetadata.html">handlegraph::PathMetadata</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2481be7fa8c46933b9b99108e4c797b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2481be7fa8c46933b9b99108e4c797b3">&#9670;&nbsp;</a></span>PathPositionHandleGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">vg::PathPositionHandleGraph</a> = typedef <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">handlegraph::PathPositionHandleGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15c1e75e93ab89aacd0eb7e1f0299724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15c1e75e93ab89aacd0eb7e1f0299724">&#9670;&nbsp;</a></span>PathSense</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacehandlegraph.html#ab3d3683c53bb48b8af63a6d94497271c">vg::PathSense</a> = typedef <a class="el" href="namespacehandlegraph.html#ab3d3683c53bb48b8af63a6d94497271c">handlegraph::PathSense</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8232142f432c4dd8e7cfe96e1f50e039"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8232142f432c4dd8e7cfe96e1f50e039">&#9670;&nbsp;</a></span>pos_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::tuple&lt;<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool, <a class="el" href="namespacevg.html#afe223f2c7890c76de5e00b43ceb37add">offset_t</a>&gt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">vg::pos_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Represents an oriented position on a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a>. <a class="el" href="structvg_1_1Position.html">Position</a> type: id, direction, offset. Offset is counted as for as prorobuf <a class="el" href="structvg_1_1Position.html">Position</a>, from the node's first base on the forward strand, and from its last base on the reverse strand. </p>

</div>
</div>
<a id="a215e44b59d26cf0745f02218dfd902a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a215e44b59d26cf0745f02218dfd902a2">&#9670;&nbsp;</a></span>RankedHandleGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classhandlegraph_1_1RankedHandleGraph.html">vg::RankedHandleGraph</a> = typedef <a class="el" href="classhandlegraph_1_1RankedHandleGraph.html">handlegraph::RankedHandleGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7392de2ef03532b2ec3461ebb178c75a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7392de2ef03532b2ec3461ebb178c75a">&#9670;&nbsp;</a></span>real_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">vg::real_t</a> = typedef long double</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ff09b399af11722aeee121ae6f4fd9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff09b399af11722aeee121ae6f4fd9b">&#9670;&nbsp;</a></span>RecipeFunc</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#a1ff09b399af11722aeee121ae6f4fd9b">vg::RecipeFunc</a> = typedef function&lt;vector&lt;vector&lt;string&gt; &gt;(const vector&lt;const <a class="el" href="classvg_1_1IndexFile.html">IndexFile</a>*&gt;&amp;, const <a class="el" href="classvg_1_1IndexingPlan.html">IndexingPlan</a>*, <a class="el" href="classvg_1_1AliasGraph.html">AliasGraph</a>&amp;, const <a class="el" href="namespacevg.html#a96bc10f0ba77bc672e88a9f7d6e126b6">IndexGroup</a>&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Is a recipe to create the files (returned by name) associated with some index, from a series of input indexes, given the plan it is being generated for and the index being generated. </p>

</div>
</div>
<a id="a6119d0b9707c042b0c2cde5d77b670cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6119d0b9707c042b0c2cde5d77b670cb">&#9670;&nbsp;</a></span>RecipeName</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#a6119d0b9707c042b0c2cde5d77b670cb">vg::RecipeName</a> = typedef pair&lt;<a class="el" href="namespacevg.html#a96bc10f0ba77bc672e88a9f7d6e126b6">IndexGroup</a>, size_t&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Names a recipe in the collection of registered recipes. </p>

</div>
</div>
<a id="a7378a177b4ed2e7be87e02a9bfcb7d4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7378a177b4ed2e7be87e02a9bfcb7d4e">&#9670;&nbsp;</a></span>SerializableHandleGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classhandlegraph_1_1SerializableHandleGraph.html">vg::SerializableHandleGraph</a> = typedef <a class="el" href="classhandlegraph_1_1SerializableHandleGraph.html">handlegraph::SerializableHandleGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a40b137bbd07d198ca2b77962eeeaf7c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40b137bbd07d198ca2b77962eeeaf7c8">&#9670;&nbsp;</a></span>step_handle_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="structhandlegraph_1_1step__handle__t.html">vg::step_handle_t</a> = typedef <a class="el" href="structhandlegraph_1_1step__handle__t.html">handlegraph::step_handle_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae28b502adf2ce7302acbb3138280f06c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae28b502adf2ce7302acbb3138280f06c">&#9670;&nbsp;</a></span>subrange_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#ae28b502adf2ce7302acbb3138280f06c">vg::subrange_t</a> = typedef <a class="el" href="namespacehandlegraph.html#a097e656b1ffb02a80c0b530b1987984a">handlegraph::subrange_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5c7b3ebb9ad8d6c01a0c54668b102c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c7b3ebb9ad8d6c01a0c54668b102c26">&#9670;&nbsp;</a></span>thread_ids_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef vector&lt;gbwt::size_type&gt; <a class="el" href="namespacevg.html#a5c7b3ebb9ad8d6c01a0c54668b102c26">vg::thread_ids_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31b8b476fb46de6667b26514b7b24fd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31b8b476fb46de6667b26514b7b24fd2">&#9670;&nbsp;</a></span>thread_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacevg.html#a31b8b476fb46de6667b26514b7b24fd2">vg::thread_t</a> = typedef vector&lt;gbwt::node_type&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a449aa64ac606119e59f71cecb8a3b218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449aa64ac606119e59f71cecb8a3b218">&#9670;&nbsp;</a></span>VectorizableHandleGraph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classhandlegraph_1_1VectorizableHandleGraph.html">vg::VectorizableHandleGraph</a> = typedef <a class="el" href="classhandlegraph_1_1VectorizableHandleGraph.html">handlegraph::VectorizableHandleGraph</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a43fe994695e911cc22e05195e327f5b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43fe994695e911cc22e05195e327f5b5">&#9670;&nbsp;</a></span>alignment_emitter_flags_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacevg.html#a43fe994695e911cc22e05195e327f5b5">vg::alignment_emitter_flags_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flag enum for controlling the behavior of alignment emitters behind <a class="el" href="namespacevg.html#aa95de659d860fc90fda95df414c89baf">get_alignment_emitter()</a>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a43fe994695e911cc22e05195e327f5b5a77d3ea80cba8f3d89e573bf723ea7f4f"></a>ALIGNMENT_EMITTER_FLAG_NONE&#160;</td><td class="fielddoc"><p>Value for no flags set. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43fe994695e911cc22e05195e327f5b5a311ead9579740c16ac55d9eaff3953e0"></a>ALIGNMENT_EMITTER_FLAG_HTS_RAW&#160;</td><td class="fielddoc"><p>Skip surjection, and expect pre-surjected alignments. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43fe994695e911cc22e05195e327f5b5a3388a03ab2e5b8dec8d422db673b00b3"></a>ALIGNMENT_EMITTER_FLAG_HTS_SPLICED&#160;</td><td class="fielddoc"><p>Use splicing-aware conversion to HTSlib formats: alignments are spliced at known splice sites (i.e. edges in the graph), so form spliced CIGAR strings </p>
</td></tr>
<tr><td class="fieldname"><a id="a43fe994695e911cc22e05195e327f5b5ad2539e657e6f87051e9f12489f9bb557"></a>ALIGNMENT_EMITTER_FLAG_HTS_PRUNE_SUSPICIOUS_ANCHORS&#160;</td><td class="fielddoc"><p>When surjecting, discard low-complexity anchors and realign more freely against the target path. </p>
</td></tr>
<tr><td class="fieldname"><a id="a43fe994695e911cc22e05195e327f5b5a3ea893f3dade371704d31df4070e95fd"></a>ALIGNMENT_EMITTER_FLAG_VG_USE_SEGMENT_NAMES&#160;</td><td class="fielddoc"><p>Emit graph alignments in named segment (i.e. GFA space) instead of numerical node ID space. </p>
</td></tr>
</table>

</div>
</div>
<a id="ae8af508a4586e2447fdbf2a30a213b39"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8af508a4586e2447fdbf2a30a213b39">&#9670;&nbsp;</a></span>MappingQualityMethod</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39">vg::MappingQualityMethod</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae8af508a4586e2447fdbf2a30a213b39a9ab31888ec6c2da1a29c051c49f2d5ea"></a>Approx&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae8af508a4586e2447fdbf2a30a213b39a71ab21548d5ec730cee91982aa78275e"></a>Exact&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae8af508a4586e2447fdbf2a30a213b39a0f1da9e8a7bb929e940b4fa8be187340"></a>Adaptive&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ae8af508a4586e2447fdbf2a30a213b39aa676d6ce23c4076e354ffb65936c03d1"></a>None&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ac47f059d08b97304ea21d00dfc19cd97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac47f059d08b97304ea21d00dfc19cd97">&#9670;&nbsp;</a></span>SnarlType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacevg.html#ac47f059d08b97304ea21d00dfc19cd97">vg::SnarlType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enumeration of the classifications of snarls. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac47f059d08b97304ea21d00dfc19cd97a7db3292851220acc20f75deebe0924ff"></a>UNCLASSIFIED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac47f059d08b97304ea21d00dfc19cd97aea6b4b85aa567a940c7434df2fcb56fb"></a>ULTRABUBBLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac47f059d08b97304ea21d00dfc19cd97a0e62c0ff8521d5960a5cc819a7bf7230"></a>UNARY&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a6391a10ec421fbb6c487f491bd978ef6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6391a10ec421fbb6c487f491bd978ef6">&#9670;&nbsp;</a></span>add_alt_allele()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::add_alt_allele </td>
          <td>(</td>
          <td class="paramtype">vcflib::Variant &amp;&#160;</td>
          <td class="paramname"><em>variant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>allele</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a new alt allele to a vcflib Variant, since apaprently there's no method for that already.</p>
<p>If that allele already exists in the variant, does not add it again.</p>
<p>Retuerns the allele number (0, 1, 2, etc.) corresponding to the given allele string in the given variant. </p>

</div>
</div>
<a id="a9e91a5d33d2da100b1173bc336ea90ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e91a5d33d2da100b1173bc336ea90ff">&#9670;&nbsp;</a></span>add_descendants_to_subgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::add_descendants_to_subgraph </td>
          <td>(</td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>parent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2303a00d9cf0d35e243dc6de7574471"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2303a00d9cf0d35e243dc6de7574471">&#9670;&nbsp;</a></span>add_edges_only()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::add_edges_only </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;, bool, bool)&gt;&#160;</td>
          <td class="paramname"><em>iterate_gam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_mapq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_bp_coverage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add edges between consecutive mappings that aren't already in the graph note: offsets are completely ignored (a simplifying assumption designed to help with SV genotpying with pack/call as edge packing works similarly)</p>
<p>No existing nodes or edges are modified, and no nodes are added, just edges So the output graph will be id-space compatible, and any GAM/GAF will continue to be valid for it. <br  />
 </p>

</div>
</div>
<a id="a0d4ce16064ad3986381aeead6afe317f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d4ce16064ad3986381aeead6afe317f">&#9670;&nbsp;</a></span>add_log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::add_log </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>log_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>log_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab3f3c75ff3775f447d5dabbdb4e540dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3f3c75ff3775f447d5dabbdb4e540dc">&#9670;&nbsp;</a></span>add_log10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::add_log10 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>j</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the log of the sum of two log10-transformed values without taking them out of log space. </p>

</div>
</div>
<a id="a4b080c96a3681c4bd64f38eb05acd31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b080c96a3681c4bd64f38eb05acd31b">&#9670;&nbsp;</a></span>add_nodes_and_edges() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::add_nodes_and_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; pair&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, string &gt;, vector&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>added_seqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>added_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig_node_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>dangling</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_node_size</em> = <code>1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a path on nodes that may or may not exist, and a map from start position in the old graph to a node in the current graph, add all the new sequence and edges required by the path. The given path must not contain adjacent perfect match edits in the same mapping, or any deletions on the start or end of mappings (the removal of which can be accomplished with the <a class="el" href="namespacevg.html#a486054f13a4dc43e37c0f0131f6a51ad">Path::simplify()</a> function).</p>
<p>Outputs (and caches for subsequent calls) novel node runs in added_seqs, and <a class="el" href="classvg_1_1Paths.html">Paths</a> describing where novel nodes translate back to in the original graph in added_nodes. Also needs a map of the original sizes of nodes deleted from the original graph, for reverse complementing. If dangling is nonempty, left edges of nodes created for initial inserts will connect to the specified sides. At the end, dangling is populated with the side corresponding to the last edit in the path.</p>
<p>Returns a fully embedded version of the path, after all node insertions, divisions, and translations. </p>

</div>
</div>
<a id="a3aa7eee80c4c79f0f863d10687714c74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa7eee80c4c79f0f863d10687714c74">&#9670;&nbsp;</a></span>add_nodes_and_edges() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::add_nodes_and_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; pair&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, string &gt;, vector&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>added_seqs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>added_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig_node_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_node_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This version doesn't require a set of dangling sides to populate <br  />
 </p>

</div>
</div>
<a id="a4043431a579c18af5497acef2f414710"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4043431a579c18af5497acef2f414710">&#9670;&nbsp;</a></span>add_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::add_path </td>
          <td>(</td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gbwt::size_type&#160;</td>
          <td class="paramname"><em>path_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gbwt::GBWTBuilder &amp;&#160;</td>
          <td class="paramname"><em>builder</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7ac200a1dbeaf55eb41bebbfd2ce4bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac200a1dbeaf55eb41bebbfd2ce4bdf">&#9670;&nbsp;</a></span>add_path_to_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> vg::add_path_to_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html">MutablePathHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a path to the graph. This is like <a class="el" href="classvg_1_1VG.html#a2519c3b939f48bca226e6fdea4c91f9d">VG::extend</a>, and expects a path with no edits, and for all the nodes and edges in the path to exist exactly in the graph </p>

</div>
</div>
<a id="afe2d6096dfe672a486e44df018c713c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe2d6096dfe672a486e44df018c713c2">&#9670;&nbsp;</a></span>add_thread_edges_to_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::add_thread_edges_to_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a31b8b476fb46de6667b26514b7b24fd2">thread_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2adfa9e81b2553fefdd5e1d6b24c7a77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2adfa9e81b2553fefdd5e1d6b24c7a77">&#9670;&nbsp;</a></span>add_thread_nodes_to_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::add_thread_nodes_to_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a31b8b476fb46de6667b26514b7b24fd2">thread_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a948a49f6716e35c8da05e84497dc01e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a948a49f6716e35c8da05e84497dc01e4">&#9670;&nbsp;</a></span>addArbitraryTelomerePair()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::addArbitraryTelomerePair </td>
          <td>(</td>
          <td class="paramtype">vector&lt; stCactusEdgeEnd * &gt;&#160;</td>
          <td class="paramname"><em>ends</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stList *&#160;</td>
          <td class="paramname"><em>telomeres</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds an arbitrary pair of telomeres in a Cactus graph, which are are either a pair of bridge edge ends or a pair of chain edge ends, oriented such that they form a pair of boundaries.</p>
<p>Mostly copied from the pinchesAndCacti unit tests. </p>

</div>
</div>
<a id="a92de94b4571057762bb3152de1376e51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92de94b4571057762bb3152de1376e51">&#9670;&nbsp;</a></span>adjacent_mappings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::adjacent_mappings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0df0c35a951519aa4a74bf098a253516"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df0c35a951519aa4a74bf098a253516">&#9670;&nbsp;</a></span>advance_split()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::advance_split </td>
          <td>(</td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Iter&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a split of items across a certain number of categories, as ints between the two given bidirectional iterators, advance to the next split and return true. If there is no next split, leave the collection unchanged and return false. </p>

</div>
</div>
<a id="a3b337b4ea1b6ad514093ce1b9d44b598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b337b4ea1b6ad514093ce1b9d44b598">&#9670;&nbsp;</a></span>aligned_interval()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; int64_t, int64_t &gt; vg::aligned_interval </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The indexes on the read sequence of the portion of the read that is aligned outside of soft clips. </p>

</div>
</div>
<a id="aa63fccb24f075243da0ba145eb8d6aca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa63fccb24f075243da0ba145eb8d6aca">&#9670;&nbsp;</a></span>alignment_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::alignment_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acdc3ca4569facd77e26c78ba583e4f0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdc3ca4569facd77e26c78ba583e4f0a">&#9670;&nbsp;</a></span>alignment_ends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::alignment_ends </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae4defc9906e81731eab06f8acaa28369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4defc9906e81731eab06f8acaa28369">&#9670;&nbsp;</a></span>alignment_from_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::alignment_from_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abcf3c5c3332d721a86740ef23fb9e6e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcf3c5c3332d721a86740ef23fb9e6e2">&#9670;&nbsp;</a></span>alignment_from_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::alignment_from_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02344193099beceed3ee60119c63fa1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02344193099beceed3ee60119c63fa1f">&#9670;&nbsp;</a></span>alignment_is_valid()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1AlignmentValidity.html">AlignmentValidity</a> vg::alignment_is_valid </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>hgraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check to make sure edits on the alignment's path don't assume incorrect node lengths or ids. Result can be used like a bool or inspected for further details. Does not log anything itself about bad alignments. </p>

</div>
</div>
<a id="a15b82cc5c99cc3e8f78229ac971ec9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15b82cc5c99cc3e8f78229ac971ec9c3">&#9670;&nbsp;</a></span>alignment_middle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::alignment_middle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a4413a5d745c8fdc6339efdcd13310c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a4413a5d745c8fdc6339efdcd13310c">&#9670;&nbsp;</a></span>alignment_quality_per_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, int &gt; vg::alignment_quality_per_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ad13bf14c3488a2d7a86931831ce25d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad13bf14c3488a2d7a86931831ce25d">&#9670;&nbsp;</a></span>alignment_refpos_to_path_offsets()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; string,vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; vg::alignment_refpos_to_path_offsets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return the path offsets as cached in the alignment </p>

</div>
</div>
<a id="a6c45c724ede7f4892b24ad654d68fbef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c45c724ede7f4892b24ad654d68fbef">&#9670;&nbsp;</a></span>alignment_set_distance_to_correct() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::alignment_set_distance_to_correct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; string, string &gt; *&#160;</td>
          <td class="paramname"><em>translation</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Annotate the first alignment with its minimum distance to the second in their annotated paths. If translation is set, replace path names in aln using that mapping, if they are found in it. </p>

</div>
</div>
<a id="ab7c6a6b96f1c4c2ca04b0b6df8f384b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7c6a6b96f1c4c2ca04b0b6df8f384b3">&#9670;&nbsp;</a></span>alignment_set_distance_to_correct() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::alignment_set_distance_to_correct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; string, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>base_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; string, string &gt; *&#160;</td>
          <td class="paramname"><em>translation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c59e7d46046fad0d349a3c747ffd6b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c59e7d46046fad0d349a3c747ffd6b3">&#9670;&nbsp;</a></span>alignment_set_distance_to_correct() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::alignment_set_distance_to_correct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; string, vector&lt; pair&lt; size_t, bool &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>base_offsets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; string, string &gt; *&#160;</td>
          <td class="paramname"><em>translation</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab7f897cb4a7bbbd40edcb938cdbd4e7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f897cb4a7bbbd40edcb938cdbd4e7c">&#9670;&nbsp;</a></span>alignment_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::alignment_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d064f9483fe862fe937abc9e7474e57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d064f9483fe862fe937abc9e7474e57">&#9670;&nbsp;</a></span>alignment_to_bam() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bam1_t * vg::alignment_to_bam </td>
          <td>(</td>
          <td class="paramtype">bam_hdr_t *&#160;</td>
          <td class="paramname"><em>bam_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>refseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>refpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>refrev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; int, char &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cigar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an unpaired <a class="el" href="structvg_1_1Alignment.html">Alignment</a> to a BAM record. If the alignment is unmapped, refpos must be -1. Otherwise, refpos must be the position on the reference sequence to which the alignment is aligned. Similarly, refseq must be the sequence aligned to, or "" if unaligned.</p>
<p>Remember to clean up with bam_destroy1(b); </p>

</div>
</div>
<a id="a1b59157d021eca5f39da96ca23f33f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b59157d021eca5f39da96ca23f33f08">&#9670;&nbsp;</a></span>alignment_to_bam() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bam1_t * vg::alignment_to_bam </td>
          <td>(</td>
          <td class="paramtype">bam_hdr_t *&#160;</td>
          <td class="paramname"><em>bam_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>refseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>refpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>refrev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; int, char &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cigar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>mateseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>matepos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>materev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tlen_max</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a paired <a class="el" href="structvg_1_1Alignment.html">Alignment</a> to a BAM record. If the alignment is unmapped, refpos must be -1. Otherwise, refpos must be the position on the reference sequence to which the alignment is aligned. Similarly, refseq must be the sequence aligned to, or "" if unaligned. The mateseq and matepos fields must be set similarly for the mate. Note that mateseq must not be "=". If tlen_max is given, it is a limit on the magnitude of tlen to consider the read properly paired.</p>
<p>Remember to clean up with bam_destroy1(b); </p>

</div>
</div>
<a id="a815420ed5a7dce52d484c346271fbd71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a815420ed5a7dce52d484c346271fbd71">&#9670;&nbsp;</a></span>alignment_to_bam_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bam1_t* vg::alignment_to_bam_internal </td>
          <td>(</td>
          <td class="paramtype">bam_hdr_t *&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>refseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>refpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>refrev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; int, char &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cigar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>mateseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>matepos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>materev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tlen_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a38cb960f8c643934d65c03f0cc85442c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38cb960f8c643934d65c03f0cc85442c">&#9670;&nbsp;</a></span>alignment_to_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::alignment_to_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afec7360276d2d875f4368057d528572a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afec7360276d2d875f4368057d528572a">&#9670;&nbsp;</a></span>alignment_to_sam() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::alignment_to_sam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>refseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>refpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>refrev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; int, char &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cigar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert an unpaired <a class="el" href="structvg_1_1Alignment.html">Alignment</a> to a SAM record. If the alignment is unmapped, refpos must be -1. Otherwise, refpos must be the position on the reference sequence to which the alignment is aligned. Similarly, refseq must be the sequence aligned to, or "" if unaligned. </p>

</div>
</div>
<a id="a8d06ec05d079a41bf301a4f5f93b635b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d06ec05d079a41bf301a4f5f93b635b">&#9670;&nbsp;</a></span>alignment_to_sam() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::alignment_to_sam </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>refseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>refpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>refrev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; int, char &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cigar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>mateseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>matepos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>materev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tlen_max</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a paired <a class="el" href="structvg_1_1Alignment.html">Alignment</a> to a SAM record. If the alignment is unmapped, refpos must be -1. Otherwise, refpos must be the position on the reference sequence to which the alignment is aligned. Similarly, refseq must be the sequence aligned to, or "" if unaligned. The mateseq and matepos fields must be set similarly for the mate. Note that mateseq must not be "=". If tlen_max is given, it is a limit on the magnitude of tlen to consider the read properly paired. </p>

</div>
</div>
<a id="af0471358e141f59c271b38dd64854371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0471358e141f59c271b38dd64854371">&#9670;&nbsp;</a></span>alignment_to_sam_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::alignment_to_sam_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>refseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>refpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>refrev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; int, char &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cigar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>mateseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>matepos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>materev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tlen_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb243c35d883121f8645815571b7a55f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb243c35d883121f8645815571b7a55f">&#9670;&nbsp;</a></span>allAmbiguousToN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::allAmbiguousToN </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert known IUPAC ambiguity codes (which we don't support) to N (which we do), while leaving any other garbage to trigger validation checks later. </p>

</div>
</div>
<a id="a7a1786f1e7e453c4b76b319ba101782d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a1786f1e7e453c4b76b319ba101782d">&#9670;&nbsp;</a></span>allATGC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::allATGC </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae24bea33b666a03a0065a10a60d64e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae24bea33b666a03a0065a10a60d64e9d">&#9670;&nbsp;</a></span>allATGCN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::allATGCN </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b46a0183527dc1713f3ab30ef85b185"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b46a0183527dc1713f3ab30ef85b185">&#9670;&nbsp;</a></span>allele_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::allele_to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>allele</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Turn the given path into an allele. Drops the first and last mappings and looks up the sequences for the nodes of the others. </p>

</div>
</div>
<a id="a083d5edb5192697a269a3e5b8815bccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083d5edb5192697a269a3e5b8815bccd">&#9670;&nbsp;</a></span>append_cigar_operation()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::append_cigar_operation </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>operation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, char &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cigar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add a CIGAR operation to a vector representing the parsed CIGAR string.</p>
<p>Coalesces adjacent operations of the same type. Coalesces runs of inserts and deletes into a signle delete followed by a single insert. </p>

</div>
</div>
<a id="ac93525ce8a55a9394025efe575468488"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac93525ce8a55a9394025efe575468488">&#9670;&nbsp;</a></span>append_multipath_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::append_multipath_alignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to_append</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add the subpaths of one multipath alignment onto another. </p>

</div>
</div>
<a id="a75a663b07489d2aba3f800943eeb0eaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75a663b07489d2aba3f800943eeb0eaf">&#9670;&nbsp;</a></span>append_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> &amp; vg::append_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append the second path onto the end of the first, without combining mappings or simplifying. Modifies and returns a reference to the first path. </p>

</div>
</div>
<a id="a745a31f5e7853868dbf903f33a986480"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a745a31f5e7853868dbf903f33a986480">&#9670;&nbsp;</a></span>approx_gbwt_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::approx_gbwt_memory </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>vcf_filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d0300b12116a047d137e134eebe2e1d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0300b12116a047d137e134eebe2e1d">&#9670;&nbsp;</a></span>approx_graph_load_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::approx_graph_load_memory </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>graph_filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4a16cd88bceed4db044decd94211833d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a16cd88bceed4db044decd94211833d">&#9670;&nbsp;</a></span>approx_graph_memory() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::approx_graph_memory </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>fasta_filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>vcf_filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa588389795ea8613480df1c7eeeafaf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa588389795ea8613480df1c7eeeafaf8">&#9670;&nbsp;</a></span>approx_graph_memory() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::approx_graph_memory </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>gfa_filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d3cceb7b721a218a1be1c948138526a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d3cceb7b721a218a1be1c948138526a">&#9670;&nbsp;</a></span>approx_graph_memory() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::approx_graph_memory </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fasta_filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>vcf_filenames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a665fe802cdb44d2dba6052fc9063513d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a665fe802cdb44d2dba6052fc9063513d">&#9670;&nbsp;</a></span>approx_num_vars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::approx_num_vars </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>vcf_filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ad955989dbbd240c02052d94a9214e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ad955989dbbd240c02052d94a9214e2">&#9670;&nbsp;</a></span>augment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::augment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>gam_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>aln_format</em> = <code>&quot;GAM&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; *&#160;</td>
          <td class="paramname"><em>out_translation</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>gam_out_path</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>embed_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>break_at_ends</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_soft_clips</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>filter_out_of_graph_alignments</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_baseq</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_mapq</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1Packer.html">Packer</a> *&#160;</td>
          <td class="paramname"><em>packer</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_bp_coverage</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_frac_n</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>edges_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Edit the graph to include all the sequence and edges added by the given paths. Can handle paths that visit nodes in any orientation. Note that this method sorts the graph and rebuilds the path index, so it should not be called in a loop.</p>
<p>if gam_path is "-", then stdin used if gam_out_path is "-", then stdout used If gam_out_path is not empty, the paths will be modified to reflect their embedding in the modified graph and written to the path. aln_format used to toggle between GAM and GAF If out_translation is not null, a list of translations, one per node existing after the edit, describing how each new or conserved node is embedded in the old graph. if embed_paths is true, then the augmented alignemnents will be saved as embededed paths in the graph in order to add it back to the graph. If break_at_ends is true, nodes will be broken at the ends of paths that start/end woth perfect matches, so the paths can be added to the vg graph's paths object. If soft_clip is true, soft clips will be removed from the input paths before processing, and the dangling ends won't end up in the graph If filter_out_of_graph_alignments is true, some extra time will be taken to check if all nodes in the alignment are in the graph. If they aren't, then it will be ignored If an edit sequence's avg base quality is less than min_baseq it will be ignored (considered a match) If an alignment's mapping quality is less than min_mapq it is ignored A packer is required for all non-mapq filters If a breakpoint has less than min_bp_coverage it is not included in the graph Edits with more than max_frac_n N content will be ignored </p>

</div>
</div>
<a id="a10c4a321eb33280d58a3ddaf97f52ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10c4a321eb33280d58a3ddaf97f52ed2">&#9670;&nbsp;</a></span>augment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::augment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_vector</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>aln_format</em> = <code>&quot;GAM&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; *&#160;</td>
          <td class="paramname"><em>out_translation</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>gam_out_path</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>embed_paths</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>break_at_ends</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_soft_clips</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>filter_out_of_graph_alignments</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_baseq</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_mapq</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1Packer.html">Packer</a> *&#160;</td>
          <td class="paramname"><em>packer</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_bp_coverage</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_frac_n</em> = <code>1.</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>edges_only</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Like above, but operates on a vector of Alignments, instead of a file (Note: It is best to use file interface to stream large numbers of alignments to save memory) </p>

</div>
</div>
<a id="a5be4fdda1799c2f6876f2ac4937da349"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5be4fdda1799c2f6876f2ac4937da349">&#9670;&nbsp;</a></span>augment_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::augment_impl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;, bool, bool)&gt;&#160;</td>
          <td class="paramname"><em>iterate_gam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>aln_format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; *&#160;</td>
          <td class="paramname"><em>out_translations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>gam_out_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>embed_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>break_at_ends</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>remove_softclips</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>filter_out_of_graph_alignments</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_baseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_mapq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1Packer.html">Packer</a> *&#160;</td>
          <td class="paramname"><em>packer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_bp_coverage</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_frac_n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>edges_only</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic version used to implement the above three methods. <br  />
 </p>

</div>
</div>
<a id="ab7caa49b187d9fc25833daa572cdf770"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7caa49b187d9fc25833daa572cdf770">&#9670;&nbsp;</a></span>balanced_kmers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const vector&lt; string &gt; vg::balanced_kmers </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>kmer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7211eb89509ce3ca625333936c08ec9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7211eb89509ce3ca625333936c08ec9b">&#9670;&nbsp;</a></span>balanced_stride()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const int vg::balanced_stride </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>read_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kmer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>stride</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f8705957c0972a6b4778efb5036c6aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8705957c0972a6b4778efb5036c6aa">&#9670;&nbsp;</a></span>bam_to_alignment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::bam_to_alignment </td>
          <td>(</td>
          <td class="paramtype">const bam1_t *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; string, string &gt; &amp;&#160;</td>
          <td class="paramname"><em>rg_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; int, <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tid_path_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a461b5385c79e073ab10d8fe860ff9428"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a461b5385c79e073ab10d8fe860ff9428">&#9670;&nbsp;</a></span>bam_to_alignment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::bam_to_alignment </td>
          <td>(</td>
          <td class="paramtype">const bam1_t *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; string, string &gt; &amp;&#160;</td>
          <td class="paramname"><em>rg_sample</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; int, <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tid_path_handle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bam_hdr_t *&#160;</td>
          <td class="paramname"><em>bh</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a71046fb34dc43f0a3e102e1394ce8697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71046fb34dc43f0a3e102e1394ce8697">&#9670;&nbsp;</a></span>benchmark_control()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::benchmark_control </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The benchmark control function, designed to take some amount of time that might vary with CPU load. </p>

</div>
</div>
<a id="a038ccb26c0c9c0a87601edc7b8b5df70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a038ccb26c0c9c0a87601edc7b8b5df70">&#9670;&nbsp;</a></span>binomial_cmf_ln()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ProbIn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::binomial_cmf_ln </td>
          <td>(</td>
          <td class="paramtype">ProbIn&#160;</td>
          <td class="paramname"><em>success_logprob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>trials</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>successes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the probability of having the given number of successes or fewer in the given number of trials, with the given success probability. Returns the resulting log probability. </p>

</div>
</div>
<a id="a34b89433618346e971606020965b10ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b89433618346e971606020965b10ed">&#9670;&nbsp;</a></span>build_gcsa_lcp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::build_gcsa_lcp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gcsa::GCSA *&amp;&#160;</td>
          <td class="paramname"><em>gcsa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gcsa::LCPArray *&amp;&#160;</td>
          <td class="paramname"><em>lcp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kmer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>doubling_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>base_file_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adf53e86632a6d1d4b54370e6d948d08c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf53e86632a6d1d4b54370e6d948d08c">&#9670;&nbsp;</a></span>cactus_to_vg()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> vg::cactus_to_vg </td>
          <td>(</td>
          <td class="paramtype">stCactusGraph *&#160;</td>
          <td class="paramname"><em>cactus_graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4d05bc207717708d48e1da09f83eec6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4d05bc207717708d48e1da09f83eec6">&#9670;&nbsp;</a></span>cactusify()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a> vg::cactusify </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a74563bc5f9f3268b9a933688ad1a5edb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74563bc5f9f3268b9a933688ad1a5edb">&#9670;&nbsp;</a></span>canonical_orientation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1PhaseUnfolder.html#a402b0f84990279594bfbb1cd71ffd8e5">PhaseUnfolder::path_type</a> vg::canonical_orientation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1PhaseUnfolder.html#a402b0f84990279594bfbb1cd71ffd8e5">PhaseUnfolder::path_type</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>from_border</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>to_border</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3b14246f4fe83e3fbdadb1ba838faeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3b14246f4fe83e3fbdadb1ba838faeb">&#9670;&nbsp;</a></span>chain_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a> vg::chain_begin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We define free functions for getting iterators forward and backward through chains. </p>

</div>
</div>
<a id="aefacc656d2c444dfd6e0e445218265cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefacc656d2c444dfd6e0e445218265cc">&#9670;&nbsp;</a></span>chain_begin_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a> vg::chain_begin_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;&#160;</td>
          <td class="paramname"><em>chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>start_snarl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>snarl_orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We also define a function for getting the <a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a> (forward or reverse complement) for a chain starting with a given snarl in the given inward orientation. Only works for bounding snarls of the chain. </p>

</div>
</div>
<a id="a0612d7af2f7366ff81c89824f43a5865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0612d7af2f7366ff81c89824f43a5865">&#9670;&nbsp;</a></span>chain_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a> vg::chain_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0627b5d536b881a355d8b419b6f329c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0627b5d536b881a355d8b419b6f329c6">&#9670;&nbsp;</a></span>chain_end_from()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a> vg::chain_end_from </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;&#160;</td>
          <td class="paramname"><em>chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>start_snarl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>snarl_orientation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>And the end iterator for the chain (forward or reverse complement) viewed from a given snarl in the given inward orientation. Only works for bounding snarls of the chain, and should be the <em>same</em> bounding snarl as was used for chain_begin_from. </p>

</div>
</div>
<a id="aa24387fbb4606765c23a280316bfcb65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24387fbb4606765c23a280316bfcb65">&#9670;&nbsp;</a></span>chain_rbegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a> vg::chain_rbegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7aed054b974860f2cc4d5be4b7615de0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aed054b974860f2cc4d5be4b7615de0">&#9670;&nbsp;</a></span>chain_rcbegin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a> vg::chain_rcbegin </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We also define some reverse complement iterators, which go from right to left through the chains, but give us the reverse view. For ecample, if all the snarls are oriented forward in the chain, we will iterate through the snarls in reverse order, with each individual snarl also reversed. </p>

</div>
</div>
<a id="ae1369d5e29159750fd14482f73421660"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1369d5e29159750fd14482f73421660">&#9670;&nbsp;</a></span>chain_rcend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a> vg::chain_rcend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c65134c67609a001a61291b22337f8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c65134c67609a001a61291b22337f8d">&#9670;&nbsp;</a></span>chain_rend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ChainIterator.html">ChainIterator</a> vg::chain_rend </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acfe23dc452245bf901fee2ed698afe7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfe23dc452245bf901fee2ed698afe7d">&#9670;&nbsp;</a></span>choose_good_thread_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::choose_good_thread_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Decide on and apply a sensible OMP thread count. Pay attention to OMP_NUM_THREADS if set, the "hardware concurrency", and container limit information that may be available in /proc. </p>

</div>
</div>
<a id="abf777e701e331bb422d91135a13408d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf777e701e331bb422d91135a13408d2">&#9670;&nbsp;</a></span>choose_ln()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::choose_ln </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of ways to select k items from a collection of n distinguishable items, ignoring order. Returns the natural log of the (integer) result. </p>

</div>
</div>
<a id="a43ac2d1903fa51a20a2366a865f5f0a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43ac2d1903fa51a20a2366a865f5f0a4">&#9670;&nbsp;</a></span>cigar_against_path() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; int, char &gt; &gt; vg::cigar_against_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on_reverse_strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>path_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>softclip_suppress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a CIGAR from the given <a class="el" href="structvg_1_1Alignment.html">Alignment</a>. If softclip_suppress is nonzero, suppress softclips up to that length. This will necessitate adjusting pos, which is why it is passed by reference. </p>

</div>
</div>
<a id="aaa223d83f7bc78267d7c7a522c909231"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa223d83f7bc78267d7c7a522c909231">&#9670;&nbsp;</a></span>cigar_against_path() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; int, char &gt; &gt; vg::cigar_against_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>path_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_splice_length</em> = <code>numeric_limits&lt;&#160;int64_t&#160;&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Convert a surjected multipath alignment into a CIGAR sequence against a path. Splicing will be allowed at connections and at any silent deletions of path sequence. Surjected multipath alignment graph must consist of a single non-branching path </p>

</div>
</div>
<a id="a598379872a84d4be8ff74df6242abf10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a598379872a84d4be8ff74df6242abf10">&#9670;&nbsp;</a></span>cigar_mapping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::cigar_mapping </td>
          <td>(</td>
          <td class="paramtype">const bam1_t *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81755bb87928f81a864e4a752973bd69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81755bb87928f81a864e4a752973bd69">&#9670;&nbsp;</a></span>cigar_mapping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::cigar_mapping </td>
          <td>(</td>
          <td class="paramtype">const bam1_t *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> *&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a022b99db4260a7fd77a248bf27c50041"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a022b99db4260a7fd77a248bf27c50041">&#9670;&nbsp;</a></span>cigar_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::cigar_string </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; pair&lt; int, char &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cigar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0406641335bb841c51b0c103219a29da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0406641335bb841c51b0c103219a29da">&#9670;&nbsp;</a></span>clear_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::clear_alignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Clear all of the field associated with the alignment. </p>

</div>
</div>
<a id="ae414970cfc37049b4dc9b308d9ed5f59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae414970cfc37049b4dc9b308d9ed5f59">&#9670;&nbsp;</a></span>clear_annotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Annotated &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::clear_annotation </td>
          <td>(</td>
          <td class="paramtype">Annotated &amp;&#160;</td>
          <td class="paramname"><em>annotated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the annotation with the given name. </p>

</div>
</div>
<a id="ad970d2836c53996c21e5c5d9d3e0a6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad970d2836c53996c21e5c5d9d3e0a6d8">&#9670;&nbsp;</a></span>clear_annotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Annotated &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::clear_annotation </td>
          <td>(</td>
          <td class="paramtype">Annotated *&#160;</td>
          <td class="paramname"><em>annotated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clear the annotation with the given name. </p>

</div>
</div>
<a id="af64359d12f27f1035ce70e4ff1622f9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64359d12f27f1035ce70e4ff1622f9c">&#9670;&nbsp;</a></span>clear_crash_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::clear_crash_context </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User code should call this when it wants to clear context for a failure in its thread. </p>

</div>
</div>
<a id="afca0783176bbca00f50e9c8f4b53515c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afca0783176bbca00f50e9c8f4b53515c">&#9670;&nbsp;</a></span>clip_contained_low_depth_nodes_and_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::clip_contained_low_depth_nodes_and_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>pp_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Region.html">Region</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_fragment_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Or on contained snarls </p>

</div>
</div>
<a id="affb16bab122c9abe8aa4282992b8fe12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affb16bab122c9abe8aa4282992b8fe12">&#9670;&nbsp;</a></span>clip_contained_snarls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::clip_contained_snarls </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>pp_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Region.html">Region</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_fragment_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_nodes_shallow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_edges_shallow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_avg_degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_reflen_prop</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_reflen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>out_bed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If a given bed region spans a snarl (overlaps its end nodes, and forms a traversal) then clip out all other nodes (ie nodes that don't lie on the traversal)</p>
<p>IMPORTANT: for any given snarl, the first region that contains it is used. <br  />
</p>
<p>Update: now accepts some snarl complexity thresholds to ignore simple enough snarls </p>

</div>
</div>
<a id="afc1766ad15ac6853f074a743d19873fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1766ad15ac6853f074a743d19873fc">&#9670;&nbsp;</a></span>clip_contained_stubs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::clip_contained_stubs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>pp_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Region.html">Region</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_fragment_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f58b3aa775dcde39a1d511a9d838b97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f58b3aa775dcde39a1d511a9d838b97">&#9670;&nbsp;</a></span>clip_deletion_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::clip_deletion_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_deletion</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>context_steps</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_fragment_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>clip out deletion edges </p>

</div>
</div>
<a id="aeaa0f9143fd06ff6948f2b548e4dde12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaa0f9143fd06ff6948f2b548e4dde12">&#9670;&nbsp;</a></span>clip_low_depth_nodes_and_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::clip_low_depth_nodes_and_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_fragment_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run above function on graph </p>

</div>
</div>
<a id="a1c4eb49afa34726115d01e380372669a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c4eb49afa34726115d01e380372669a">&#9670;&nbsp;</a></span>clip_low_depth_nodes_and_edges_generic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::clip_low_depth_nodes_and_edges_generic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(function&lt; void(<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, const <a class="el" href="structvg_1_1Region.html">Region</a> *)&gt;)&gt;&#160;</td>
          <td class="paramname"><em>iterate_handles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(function&lt; void(<a class="el" href="namespacevg.html#a3de8fe5f38b1730a36af4ad9c4258963">edge_t</a>, const <a class="el" href="structvg_1_1Region.html">Region</a> *)&gt;)&gt;&#160;</td>
          <td class="paramname"><em>iterate_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_fragment_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clip out nodes that don't pass depth threshold (depth &lt; min_depth). <br  />
 "depth" is the number of paths that step on the node. Nodes on path with given prefix ignored (todo: should really switch to regex or something) iterate_handles is a hack to generalize this function to whole graphs or snarls </p>

</div>
</div>
<a id="ae596e7d9757cad372b5aaeb5e8a5146e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae596e7d9757cad372b5aaeb5e8a5146e">&#9670;&nbsp;</a></span>clip_stubs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::clip_stubs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_fragment_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>clip out stubs </p>

</div>
</div>
<a id="aba796b34b1f89333758ff6cb4271f708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba796b34b1f89333758ff6cb4271f708">&#9670;&nbsp;</a></span>clip_stubs_generic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::clip_stubs_generic </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(function&lt; void(<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, const <a class="el" href="structvg_1_1Region.html">Region</a> *)&gt;)&gt;&#160;</td>
          <td class="paramname"><em>iterate_handles</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; bool(<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>)&gt;&#160;</td>
          <td class="paramname"><em>handle_in_range</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_prefixes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_fragment_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>verbose</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe3e65f9aafb5ab9ce5455cc72fa0b56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3e65f9aafb5ab9ce5455cc72fa0b56">&#9670;&nbsp;</a></span>cluster_cover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; string::const_iterator &gt; vg::cluster_cover </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3380e0f81fc879601afe493949814a4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3380e0f81fc879601afe493949814a4d">&#9670;&nbsp;</a></span>cluster_coverage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::cluster_coverage </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af6c60d6eb4cafd02a45384cf71a12bfe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6c60d6eb4cafd02a45384cf71a12bfe">&#9670;&nbsp;</a></span>cluster_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &gt; vg::cluster_nodes </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9f1bd05c1d67c074797eded33151e88"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9f1bd05c1d67c074797eded33151e88">&#9670;&nbsp;</a></span>cluster_subgraph_containing()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdsg::HashGraph vg::cluster_subgraph_containing </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">vg::MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>return a containing subgraph connecting the mems </p>

</div>
</div>
<a id="ac20a47954c6352afbd98da5b7d4f2d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac20a47954c6352afbd98da5b7d4f2d95">&#9670;&nbsp;</a></span>cluster_subgraph_walk()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bdsg::HashGraph vg::cluster_subgraph_walk </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">vg::MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>expansion</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>return a subgraph for a cluster of MEMs from the given alignment use walking to get the hits </p>

</div>
</div>
<a id="a9d8947e51da3156529e12ae131c25a47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d8947e51da3156529e12ae131c25a47">&#9670;&nbsp;</a></span>clusters_overlap_in_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::clusters_overlap_in_graph </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af67eb440256877ac857d6649052d7db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af67eb440256877ac857d6649052d7db1">&#9670;&nbsp;</a></span>clusters_overlap_in_read()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::clusters_overlap_in_read </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a50260b7d42777dd7f352a5ba40ac655e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50260b7d42777dd7f352a5ba40ac655e">&#9670;&nbsp;</a></span>clusters_overlap_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::clusters_overlap_length </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>cluster2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a04bb552d73f5ed9ca37d1227acacee4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bb552d73f5ed9ca37d1227acacee4a">&#9670;&nbsp;</a></span>compose_short_path_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vg::compose_short_path_name </td>
          <td>(</td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>gbwt_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gbwt::size_type&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a short version of a string representation of a thread name stored in GBWT metadata, made of just the sample and contig and haplotype. NOTE: id is a gbwt path id, not a gbwt sequence id. </p>

</div>
</div>
<a id="ad3824b96906cc229f270166a06a7a625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3824b96906cc229f270166a06a7a625">&#9670;&nbsp;</a></span>compute_template_lengths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; int32_t, int32_t &gt; vg::compute_template_lengths </td>
          <td>(</td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; int, char &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cigar1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int64_t &amp;&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; int, char &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cigar2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Work out the TLEN values for two reads. The magnitude is the distance between the outermost aligned bases, and the sign is positive for the leftmost read and negative for the rightmost. </p>

</div>
</div>
<a id="a8fc7225da088d27cd1201422ba011f51"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fc7225da088d27cd1201422ba011f51">&#9670;&nbsp;</a></span>concat_mappings()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> vg::concat_mappings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trim_internal_deletions</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac7d43d119d665bda802489b3309e0bce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7d43d119d665bda802489b3309e0bce">&#9670;&nbsp;</a></span>concat_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::concat_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a68859b86cb7465d17ca9cb68553a8e4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68859b86cb7465d17ca9cb68553a8e4c">&#9670;&nbsp;</a></span>connected_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; int64_t &gt; &gt; vg::connected_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a vector whose elements are vectors with the indexes of the <a class="el" href="classvg_1_1subpath__t.html">subpath_t</a>'s in each connected component. An unmapped <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> with no subpaths produces an empty vector. </p>

</div>
</div>
<a id="a37c256d47f5d50349766d6f8085b017f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37c256d47f5d50349766d6f8085b017f">&#9670;&nbsp;</a></span>connected_comps_do()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::connected_comps_do </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>on_new_component</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(size_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>on_new_node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b7416f4636f53c22bcb1fab81d63de8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b7416f4636f53c22bcb1fab81d63de8">&#9670;&nbsp;</a></span>construct_graph_from_nodes_and_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::construct_graph_from_nodes_and_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">set&lt; pair&lt; int, int &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f65013661cfc322222585843c30773a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f65013661cfc322222585843c30773a">&#9670;&nbsp;</a></span>contains_connection()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::contains_connection </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if any subpath has a connection adjacency. </p>

</div>
</div>
<a id="accfb6f4fc450e420c5b147cff9e6ae31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accfb6f4fc450e420c5b147cff9e6ae31">&#9670;&nbsp;</a></span>contains_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::contains_match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>read_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>match_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the multipath alignment contains a match of a given length starting at the graph and read position </p>

</div>
</div>
<a id="a5674e45f23020370046d49c674fd691f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5674e45f23020370046d49c674fd691f">&#9670;&nbsp;</a></span>convert() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::convert </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;&#160;</td>
          <td class="paramname"><em>r</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7b1ca8b13ad1732d0679723bb206f18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7b1ca8b13ad1732d0679723bb206f18">&#9670;&nbsp;</a></span>convert() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string vg::convert </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>r</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a256962a964ea02f3d4ec54c5c48d72a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a256962a964ea02f3d4ec54c5c48d72a8">&#9670;&nbsp;</a></span>convert_alignment_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::convert_alignment_char </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f29020dbd628bd21a9a039ee718b29b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f29020dbd628bd21a9a039ee718b29b">&#9670;&nbsp;</a></span>convert_multipath_alignment_char()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::convert_multipath_alignment_char </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="add9a4cf274b29df3caf222d0360805f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add9a4cf274b29df3caf222d0360805f3">&#9670;&nbsp;</a></span>convert_Ts_to_Us() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::convert_Ts_to_Us </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces any T's in the sequence or the <a class="el" href="structvg_1_1Path.html">Path</a> with U's. </p>

</div>
</div>
<a id="a92c7d384c096b813501b23730e308796"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c7d384c096b813501b23730e308796">&#9670;&nbsp;</a></span>convert_Ts_to_Us() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::convert_Ts_to_Us </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all T's in the sequence and the aligned <a class="el" href="classvg_1_1Paths.html">Paths</a> with U's. </p>

</div>
</div>
<a id="abdc8589575aed95e82c0bb70828ab036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdc8589575aed95e82c0bb70828ab036">&#9670;&nbsp;</a></span>convert_Us_to_Ts() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::convert_Us_to_Ts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces any U's in the sequence or the <a class="el" href="structvg_1_1Path.html">Path</a> with T's. </p>

</div>
</div>
<a id="a5a6e3cc99aac92404ec33126dbbd9192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a6e3cc99aac92404ec33126dbbd9192">&#9670;&nbsp;</a></span>convert_Us_to_Ts() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::convert_Us_to_Ts </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replaces all U's in the sequence and the aligned <a class="el" href="classvg_1_1Paths.html">Paths</a> with T's. </p>

</div>
</div>
<a id="a1c2f1e37da37dda61d25e9d8bb6552d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c2f1e37da37dda61d25e9d8bb6552d6">&#9670;&nbsp;</a></span>copy_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::copy_file </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>from_fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>to_fp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab2237df8adff809619083730f10d0e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2237df8adff809619083730f10d0e2e">&#9670;&nbsp;</a></span>copy_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::copy_metadata </td>
          <td>(</td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; gbwt::size_type &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>jobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>job_order</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a84d3002d98148b82b4f395c7b625b892"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d3002d98148b82b4f395c7b625b892">&#9670;&nbsp;</a></span>corresponding_from_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::corresponding_from_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>to_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9dffafa4fdd05242ff4b73f5aafedd95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9dffafa4fdd05242ff4b73f5aafedd95">&#9670;&nbsp;</a></span>corresponding_length_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::corresponding_length_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>given_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_from_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fa02fa34866aee06ca1e3cead896b8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa02fa34866aee06ca1e3cead896b8d">&#9670;&nbsp;</a></span>corresponding_to_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::corresponding_to_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>from_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0ca4eebd30887a3625fb8561c3d240d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ca4eebd30887a3625fb8561c3d240d8">&#9670;&nbsp;</a></span>crash_unless_impl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::crash_unless_impl </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>condition</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>condition_string</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>file</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>function</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>crash_unless calls into this function for a real implementation. </p>

</div>
</div>
<a id="ae9e16eec9e4a4120718eba7d5711a7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9e16eec9e4a4120718eba7d5711a7df">&#9670;&nbsp;</a></span>create_ref_allele()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::create_ref_allele </td>
          <td>(</td>
          <td class="paramtype">vcflib::Variant &amp;&#160;</td>
          <td class="paramname"><em>variant</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>allele</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the reference allele for an empty vcflib Variant, since apaprently there's no method for that already. Must be called before any alt alleles are added. </p>

</div>
</div>
<a id="a4f45a0764dcd0711bb37067151c78d6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f45a0764dcd0711bb37067151c78d6a">&#9670;&nbsp;</a></span>cut_mapping() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structvg_1_1Mapping.html">Mapping</a>, <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &gt; vg::cut_mapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a86cd2447c52bf50d938b0142bf98dc57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86cd2447c52bf50d938b0142bf98dc57">&#9670;&nbsp;</a></span>cut_mapping() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structvg_1_1Mapping.html">Mapping</a>, <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &gt; vg::cut_mapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1cb07d52156c2d1a3e13c566bf629760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cb07d52156c2d1a3e13c566bf629760">&#9670;&nbsp;</a></span>cut_mapping() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a>, <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt; vg::cut_mapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af98f355163fd3a01d1d23c978fa1dbd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af98f355163fd3a01d1d23c978fa1dbd3">&#9670;&nbsp;</a></span>cut_mapping() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a>, <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt; vg::cut_mapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e9091c8bf2f73d219522420a705dc1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9091c8bf2f73d219522420a705dc1f">&#9670;&nbsp;</a></span>cut_mapping_offset() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structvg_1_1Mapping.html">Mapping</a>, <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &gt; vg::cut_mapping_offset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a455dd0d543b21690c3e71e67ff45e57d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455dd0d543b21690c3e71e67ff45e57d">&#9670;&nbsp;</a></span>cut_mapping_offset() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a>, <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &gt; vg::cut_mapping_offset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0456e049dd685a689886372f4b0a354d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0456e049dd685a689886372f4b0a354d">&#9670;&nbsp;</a></span>cut_path() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structvg_1_1Path.html">Path</a>, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; vg::cut_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1dbdbb650e0a076cd3890c2a74515260"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dbdbb650e0a076cd3890c2a74515260">&#9670;&nbsp;</a></span>cut_path() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="structvg_1_1Path.html">Path</a>, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; vg::cut_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae72a83063f59506e0fcd76304b85d842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae72a83063f59506e0fcd76304b85d842">&#9670;&nbsp;</a></span>debug_string() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::debug_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1connection__t.html">connection_t</a> &amp;&#160;</td>
          <td class="paramname"><em>connection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a51469d56a6d4e55660c15af135c92b46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51469d56a6d4e55660c15af135c92b46">&#9670;&nbsp;</a></span>debug_string() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::debug_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1edit__t.html">edit_t</a> &amp;&#160;</td>
          <td class="paramname"><em>edit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3a723cb7c4957a689cb7de6812237dea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a723cb7c4957a689cb7de6812237dea">&#9670;&nbsp;</a></span>debug_string() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::debug_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a11592884d28d3865ea95f76232e2fed4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11592884d28d3865ea95f76232e2fed4">&#9670;&nbsp;</a></span>debug_string() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::debug_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1path__mapping__t.html">path_mapping_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a472702e0931449cfaa10a337d7119d63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a472702e0931449cfaa10a337d7119d63">&#9670;&nbsp;</a></span>debug_string() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::debug_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a99864b7ad9781d2c41c424ae69187e2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99864b7ad9781d2c41c424ae69187e2e">&#9670;&nbsp;</a></span>debug_string() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::debug_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1position__t.html">position_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8401a5ba093820ee017f9db390058087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8401a5ba093820ee017f9db390058087">&#9670;&nbsp;</a></span>debug_string() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::debug_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1subpath__t.html">subpath_t</a> &amp;&#160;</td>
          <td class="paramname"><em>subpath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90fe8f4de1196dd902ac05f7567b9b7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90fe8f4de1196dd902ac05f7567b9b7b">&#9670;&nbsp;</a></span>decompose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::decompose </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>ref_positions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, <a class="el" href="structvg_1_1Edit.html">Edit</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab273ea17c855b1b0a32fc4e98405519e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab273ea17c855b1b0a32fc4e98405519e">&#9670;&nbsp;</a></span>delete_nodes_and_chop_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::delete_nodes_and_chop_paths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathMutableHandleGraph.html">MutablePathMutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes_to_delete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; <a class="el" href="namespacevg.html#a3de8fe5f38b1730a36af4ad9c4258963">edge_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>edges_to_delete</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>min_fragment_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; string, size_t &gt; *&#160;</td>
          <td class="paramname"><em>fragments_per_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa3eeb1e344417323232103c7e38747f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa3eeb1e344417323232103c7e38747f">&#9670;&nbsp;</a></span>determine_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::determine_flag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>refseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>refpos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>refrev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>mateseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>matepos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>materev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tlen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paired</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int32_t&#160;</td>
          <td class="paramname"><em>tlen_max</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the SAM bit-coded flag for alignment with. </p>

</div>
</div>
<a id="a1f573d1f1f474086cbe0a8933fe29988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f573d1f1f474086cbe0a8933fe29988">&#9670;&nbsp;</a></span>deterministic_beats()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::deterministic_beats </td>
          <td>(</td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Number &amp;&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1LazyRNG.html">LazyRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if a is larger than b, or else equal to b and wins a coin flip. </p>

</div>
</div>
<a id="a73b5e48235129c3583b5b3942ff4d44d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b5e48235129c3583b5b3942ff4d44d">&#9670;&nbsp;</a></span>deterministic_flip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::deterministic_flip </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1LazyRNG.html">LazyRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>rng</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flip a coin with 50% probability against the given RNG. </p>

</div>
</div>
<a id="ae74e428a09df726b5c2f4998b9d0a442"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae74e428a09df726b5c2f4998b9d0a442">&#9670;&nbsp;</a></span>deterministic_shuffle() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::deterministic_shuffle </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Do a deterministic shuffle with automatic seed determination. </p>

</div>
</div>
<a id="a2a2c2b828b3943b33f2b0b12f756ed9a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a2c2b828b3943b33f2b0b12f756ed9a">&#9670;&nbsp;</a></span>deterministic_shuffle() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomIt &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::deterministic_shuffle </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1LazyRNG.html">LazyRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a pair of random access iterators defining a range, deterministically shuffle the contents of the range based on the given RNG. Allows one RNG from deterministic_start() to be used for multiple shuffles. </p>

</div>
</div>
<a id="ad3b0a534daaa4c4eb7204b139fbbe3b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3b0a534daaa4c4eb7204b139fbbe3b7">&#9670;&nbsp;</a></span>divergence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::divergence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a104aaf42bb3f44518626b9417a4db2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a104aaf42bb3f44518626b9417a4db2d5">&#9670;&nbsp;</a></span>each_approx_graph_memory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;int64_t&gt; vg::each_approx_graph_memory </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>fasta_filenames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>vcf_filenames</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2610da8a8fbe723e13519d79ac2d0afe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2610da8a8fbe723e13519d79ac2d0afe">&#9670;&nbsp;</a></span>edit_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::edit_count </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abfba7a19cbb794cd210116be91c62d96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfba7a19cbb794cd210116be91c62d96">&#9670;&nbsp;</a></span>edits_are_compatible()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::edits_are_compatible </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if two edits could be combined into one (assuming adjacency). </p>

</div>
</div>
<a id="a40556998a17c0f59c8ecc682af3a99a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40556998a17c0f59c8ecc682af3a99a3">&#9670;&nbsp;</a></span>emit_stacktrace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::emit_stacktrace </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signalNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">siginfo_t *&#160;</td>
          <td class="paramname"><em>signalInfo</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>signalContext</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Emit a stack trace when something bad happens. Add as a signal handler with sigaction. </p>

</div>
</div>
<a id="a8811548042613f9e65545d1ed377643e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8811548042613f9e65545d1ed377643e">&#9670;&nbsp;</a></span>empty_gbwtgraph_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::empty_gbwtgraph_handle </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns an empty GBWTGraph handle corresponding to the GBWT endmarker. </p>

</div>
</div>
<a id="ad0576520eed494787a895b6ce862e1f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0576520eed494787a895b6ce862e1f0">&#9670;&nbsp;</a></span>empty_pos_t()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> vg::empty_pos_t </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an unset pos_t. </p>

</div>
</div>
<a id="a1f4461f901aba4b67353768ee25e23d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4461f901aba4b67353768ee25e23d7">&#9670;&nbsp;</a></span>enable_crash_handling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::enable_crash_handling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Main should call this to turn on our stack tracing support. </p>

</div>
</div>
<a id="aa25419c15b3dcae6b217f893c243c487"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa25419c15b3dcae6b217f893c243c487">&#9670;&nbsp;</a></span>encode_chars()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gcsa::byte_type vg::encode_chars </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; char &gt; &amp;&#160;</td>
          <td class="paramname"><em>chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gcsa::Alphabet &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Encode the chars into the gcsa2 byte. </p>

</div>
</div>
<a id="acab8d2ef076a0e866c7849aace290124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acab8d2ef076a0e866c7849aace290124">&#9670;&nbsp;</a></span>end_backward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::end_backward </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the last snarl in the given chain is backward relative to the chain. </p>

</div>
</div>
<a id="a35bec7a1758e5eb88a359da78174d8d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35bec7a1758e5eb88a359da78174d8d9">&#9670;&nbsp;</a></span>ensure_breakpoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; vg::ensure_breakpoints </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, set&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breakpoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Take a map from node ID to a set of offsets at which new nodes should start (which may include 0 and 1-past-the-end, which should be ignored), break the specified nodes at those positions. Returns a map from old node start position to new node pointer in the graph. Note that the caller will have to crear and rebuild path rank data.</p>
<p>Returns a map from old node start position to new node. This map contains some entries pointing to null, for positions past the ends of original nodes. It also maps from positions on either strand of the old node to the same new node pointer; the new node's forward strand is always the same as the old node's forward strand. </p>

</div>
</div>
<a id="a77c1cb6069f865239d0365b55649bc8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77c1cb6069f865239d0365b55649bc8a">&#9670;&nbsp;</a></span>entropy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::entropy </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>st</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3165438256db24864e88601839197df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3165438256db24864e88601839197df">&#9670;&nbsp;</a></span>entropy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::entropy </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>st</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59d4b5d91539506f52c32664fc1c0ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d4b5d91539506f52c32664fc1c0ddd">&#9670;&nbsp;</a></span>ewens_af_prob_ln()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::ewens_af_prob_ln </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td>
          <td class="paramname"><em>theta</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac302dd262b1fc457d0711c914a216aef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac302dd262b1fc457d0711c914a216aef">&#9670;&nbsp;</a></span>execute_in_fork()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::execute_in_fork </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>exec</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a491e9c11712ae965b8c6745ab33aba21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a491e9c11712ae965b8c6745ab33aba21">&#9670;&nbsp;</a></span>extend_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp; vg::extend_alignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afcc55b3037b4e078c4268f08dda7cf4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcc55b3037b4e078c4268f08dda7cf4b">&#9670;&nbsp;</a></span>extend_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> &amp; vg::extend_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d1c00a44e9aeb5c4294edd60fcbaa61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d1c00a44e9aeb5c4294edd60fcbaa61">&#9670;&nbsp;</a></span>extract_as_gbwt_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gbwt::vector_type vg::extract_as_gbwt_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Extract a path as a GBWT path. If the path does not exist, it is treated as empty. </p>

</div>
</div>
<a id="a768828fcd9f2ecf7661e7d873f23bc58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a768828fcd9f2ecf7661e7d873f23bc58">&#9670;&nbsp;</a></span>extract_gbwt_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::extract_gbwt_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>gbwt_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gbwt::size_type&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract a GBWT thread as a path in the given graph. NOTE: id is a gbwt path id, not a gbwt sequence id. </p>

</div>
</div>
<a id="aa381cdc7f966379fc7cc9ea11257f632"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa381cdc7f966379fc7cc9ea11257f632">&#9670;&nbsp;</a></span>extract_path_metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; vector&lt; pair&lt; string, int64_t &gt; &gt;, unordered_map&lt; string, int64_t &gt; &gt; vg::extract_path_metadata </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; tuple&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, size_t, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subpath_support</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a list of path handles and size info (from get_sequence_dictionary), return two things: 1) names and lengths of all of base paths in order. 2) a mapping of path names to length (reflects paths in the graph including subpaths)</p>
<p>If subpath_support is set to false, there won't be a distinction. </p>

</div>
</div>
<a id="a2b9703408d4c7160e8d9e83303c4d1c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b9703408d4c7160e8d9e83303c4d1c7">&#9670;&nbsp;</a></span>extract_sub_multipath_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::extract_sub_multipath_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>subpath_indexes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>sub_multipath_aln</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Extract the <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> consisting of the Subpaths with the given indexes into a new <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> object </p>

</div>
</div>
<a id="a54a32f7feb38c9f86d7796f0b4f1dac7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54a32f7feb38c9f86d7796f0b4f1dac7">&#9670;&nbsp;</a></span>factorial_ln()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::factorial_ln </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the natural log of the factorial of the given integer. TODO: replace with a cache or giant lookup table from Freebayes. </p>

</div>
</div>
<a id="a99b58aa1a0c067044f1fcbf97627e390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99b58aa1a0c067044f1fcbf97627e390">&#9670;&nbsp;</a></span>fastq_for_each()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::fastq_for_each </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a50976b47c0b2b13fb095a0ef92b3b027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50976b47c0b2b13fb095a0ef92b3b027">&#9670;&nbsp;</a></span>fastq_paired_interleaved_for_each()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::fastq_paired_interleaved_for_each </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ade9b61525b8a059f3cb0c131e1c0a93c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade9b61525b8a059f3cb0c131e1c0a93c">&#9670;&nbsp;</a></span>fastq_paired_interleaved_for_each_parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::fastq_paired_interleaved_for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>batch_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="affe4f02b57454f05982949fe74467ac6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#affe4f02b57454f05982949fe74467ac6">&#9670;&nbsp;</a></span>fastq_paired_interleaved_for_each_parallel_after_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::fastq_paired_interleaved_for_each_parallel_after_wait </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; bool(void)&gt;&#160;</td>
          <td class="paramname"><em>single_threaded_until_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>batch_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aedcdef25c312dba95a599ff9c1b44b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedcdef25c312dba95a599ff9c1b44b50">&#9670;&nbsp;</a></span>fastq_paired_two_files_for_each()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::fastq_paired_two_files_for_each </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>file1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>file2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac13b99e544cff2a419dfa9d64a03d210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac13b99e544cff2a419dfa9d64a03d210">&#9670;&nbsp;</a></span>fastq_paired_two_files_for_each_parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::fastq_paired_two_files_for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>file1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>file2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>batch_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af70ee85be3dab6bf495cb73163bc2379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af70ee85be3dab6bf495cb73163bc2379">&#9670;&nbsp;</a></span>fastq_paired_two_files_for_each_parallel_after_wait()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::fastq_paired_two_files_for_each_parallel_after_wait </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>file1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>file2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; bool(void)&gt;&#160;</td>
          <td class="paramname"><em>single_threaded_until_true</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>batch_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a581952a0bdf921e9388ace316dbe3a63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581952a0bdf921e9388ace316dbe3a63">&#9670;&nbsp;</a></span>fastq_unpaired_for_each()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::fastq_unpaired_for_each </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9be9503a9e2519d984303added3fa549"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9be9503a9e2519d984303added3fa549">&#9670;&nbsp;</a></span>fastq_unpaired_for_each_parallel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::fastq_unpaired_for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>batch_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abebdd1477a436020f3d3f8368d825054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abebdd1477a436020f3d3f8368d825054">&#9670;&nbsp;</a></span>file_exists()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::file_exists </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Determine if a file exists. Only works for files readable by the current user. </p>

</div>
</div>
<a id="ac146be1a4fdd34ea5731dfa640e21aab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac146be1a4fdd34ea5731dfa640e21aab">&#9670;&nbsp;</a></span>fill_in_distance_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::fill_in_distance_index </td>
          <td>(</td>
          <td class="paramtype">SnarlDistanceIndex *&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1HandleGraphSnarlFinder.html">HandleGraphSnarlFinder</a> *&#160;</td>
          <td class="paramname"><em>snarl_finder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5ddba9dd6dcb384cbbea06c535e00d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ddba9dd6dcb384cbbea06c535e00d6d">&#9670;&nbsp;</a></span>filter_breakpoints_by_coverage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, set&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &gt; &gt; vg::filter_breakpoints_by_coverage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;&#160;</td>
          <td class="paramname"><em>packed_breakpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_bp_coverage</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Filters the breakpoints by coverage, and converts them back from the <a class="el" href="classvg_1_1Packer.html">Packer</a> to the STL map expected by following methods </p>

</div>
</div>
<a id="ad435098725ff21d822052abee009d2bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad435098725ff21d822052abee009d2bd">&#9670;&nbsp;</a></span>final_position() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> vg::final_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28e15d36e2ee202f8a194cca31d91d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28e15d36e2ee202f8a194cca31d91d65">&#9670;&nbsp;</a></span>final_position() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> vg::final_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac80bc94af296d0a543d983eae79afac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac80bc94af296d0a543d983eae79afac0">&#9670;&nbsp;</a></span>find_breakpoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::find_breakpoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, set&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breakpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>break_ends</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>base_quals</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_baseq</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_frac_n</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find all the points at which a <a class="el" href="structvg_1_1Path.html">Path</a> enters or leaves nodes in the graph. Adds them to the given map by node ID of sets of bases in the node that will need to become the starts of new nodes.</p>
<p>If break_ends is true, emits breakpoints at the ends of the path, even if it starts/ends with perfect matches. Find all the points at which a <a class="el" href="structvg_1_1Path.html">Path</a> enters or leaves nodes in the graph. Adds them to the given map by node ID of sets of bases in the node that will need to become the starts of new nodes.</p>
<p>If break_ends is true, emits breakpoints at the ends of the path, even if it starts/ends with perfect matches. </p>

</div>
</div>
<a id="afdd5134ae715117de1b7ba9283fa8651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afdd5134ae715117de1b7ba9283fa8651">&#9670;&nbsp;</a></span>find_kmer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt;<a class="el" href="structvg_1_1Haplotypes_1_1Subchain.html#a13b4b76384742f4ee127b52faff37aa6">Haplotypes::Subchain::kmer_type</a>, size_t&gt;::iterator vg::find_kmer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="structvg_1_1Haplotypes_1_1Subchain.html#a13b4b76384742f4ee127b52faff37aa6">Haplotypes::Subchain::kmer_type</a>, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Haplotypes_1_1Subchain.html#a13b4b76384742f4ee127b52faff37aa6">Haplotypes::Subchain::kmer_type</a>&#160;</td>
          <td class="paramname"><em>kmer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a050aedf4b2e047e04f31a6e8b7ad55ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050aedf4b2e047e04f31a6e8b7ad55ce">&#9670;&nbsp;</a></span>find_mismatches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::find_mismatches </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gbwtgraph::CachedGBWTGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a808481f23dac7bc58c339cf36a9a0aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a808481f23dac7bc58c339cf36a9a0aaf">&#9670;&nbsp;</a></span>find_packed_breakpoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::find_packed_breakpoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1Packer.html">Packer</a> &amp;&#160;</td>
          <td class="paramname"><em>packed_breakpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>break_ends</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>base_quals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_baseq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_frac_n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Like "find_breakpoints", but store in packed structure (better for large gams and enables coverage filter) </p>

</div>
</div>
<a id="ac2fee40d55dfda86b1e0cc2f2500b280"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2fee40d55dfda86b1e0cc2f2500b280">&#9670;&nbsp;</a></span>finish_gbwt_constuction()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::finish_gbwt_constuction </td>
          <td>(</td>
          <td class="paramtype">gbwt::GBWTBuilder &amp;&#160;</td>
          <td class="paramname"><em>builder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>sample_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>contig_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>haplotype_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>print_metadata</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Finish GBWT construction and optionally print the metadata. </p>

</div>
</div>
<a id="ada7557d06abd0fca3d66f9ca73fe81db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7557d06abd0fca3d66f9ca73fe81db">&#9670;&nbsp;</a></span>first_path_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::first_path_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b47bdda079acc49d455953a91db12bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b47bdda079acc49d455953a91db12bd">&#9670;&nbsp;</a></span>fit_fixed_rate_max_exponential()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::fit_fixed_rate_max_exponential </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MLE estimate for the number of iid exponential RVs the data are maxima of. </p>

</div>
</div>
<a id="a79672e0d9b7e8abdb60ec0f181eec6f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79672e0d9b7e8abdb60ec0f181eec6f0">&#9670;&nbsp;</a></span>fit_fixed_shape_max_exponential()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::fit_fixed_shape_max_exponential </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MLE rate parameter for the distribution of (shape) iid exponential RVs. </p>

</div>
</div>
<a id="aafca6820103f98f205de4774a9d35f09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aafca6820103f98f205de4774a9d35f09">&#9670;&nbsp;</a></span>fit_max_exponential()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; double, double &gt; vg::fit_max_exponential </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the MLE rate and shape parameters of a max exponential. </p>

</div>
</div>
<a id="ad9f14b8e66ba0c5c28961e8da4aba4b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9f14b8e66ba0c5c28961e8da4aba4b6">&#9670;&nbsp;</a></span>fit_offset_weibull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple&lt; double, double, double &gt; vg::fit_offset_weibull </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an estimate of the rate, shape, and location (minimum value) of a 3-parameter Weibull distribution. </p>

</div>
</div>
<a id="aa64cff8c9c4b3c3baefb49c57614643d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa64cff8c9c4b3c3baefb49c57614643d">&#9670;&nbsp;</a></span>fit_weibull()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; double, double &gt; vg::fit_weibull </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns an estimate of the rate and shape parameters of a Weibull distribution. </p>

</div>
</div>
<a id="a9fa3b08acc22f29ea5d940317f6948ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa3b08acc22f29ea5d940317f6948ab">&#9670;&nbsp;</a></span>fit_zipf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::fit_zipf </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8a651561299e3236ec62af61d509112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8a651561299e3236ec62af61d509112">&#9670;&nbsp;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> vg::flip </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>to_flip</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flip the orientations of a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele.">Support</a>. </p>

</div>
</div>
<a id="a89c2bb28b708cb4acf67eabfaa4b0168"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89c2bb28b708cb4acf67eabfaa4b0168">&#9670;&nbsp;</a></span>flip_doubly_reversed_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::flip_doubly_reversed_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>clean up doubly-reversed edges </p>

</div>
</div>
<a id="a1f4eaa1a100e433af698e794afa8857b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f4eaa1a100e433af698e794afa8857b">&#9670;&nbsp;</a></span>flip_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::flip_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; size_t(int64_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f0eee097c87cbab2bc44f096b463d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f0eee097c87cbab2bc44f096b463d8b">&#9670;&nbsp;</a></span>for_each_basic_annotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Annotated &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::for_each_basic_annotation </td>
          <td>(</td>
          <td class="paramtype">const Annotated &amp;&#160;</td>
          <td class="paramname"><em>annotated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const string &amp;)&gt;&#160;</td>
          <td class="paramname"><em>null_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const string &amp;, double)&gt;&#160;</td>
          <td class="paramname"><em>double_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const string &amp;, bool)&gt;&#160;</td>
          <td class="paramname"><em>bool_lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const string &amp;, const string &amp;)&gt;&#160;</td>
          <td class="paramname"><em>string_lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Apply a lambda to all annotations, except for Struct and ListValue annotations (which cannot be easily typed without exposing ugly Protobuf internals </p>

</div>
</div>
<a id="ab3d4de4fa2fda6bfcd6eaa77080c67ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3d4de4fa2fda6bfcd6eaa77080c67ad">&#9670;&nbsp;</a></span>for_each_kmer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::for_each_kmer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const <a class="el" href="structvg_1_1kmer__t.html">kmer_t</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>head_id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>tail_id</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">atomic&lt; int &gt; *&#160;</td>
          <td class="paramname"><em>stop_flag</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over all the kmers in the graph, running lambda on each If the stop flag is included, stop execution if it ever evaluates to true </p>

</div>
</div>
<a id="a3ae70effc22331b3e4667ed48808602c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ae70effc22331b3e4667ed48808602c">&#9670;&nbsp;</a></span>format_multiplier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::format_multiplier </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e9c975d7bec4a22a46b72736915ceb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e9c975d7bec4a22a46b72736915ceb1">&#9670;&nbsp;</a></span>forwardize_breakpoints()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, set&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &gt; &gt; vg::forwardize_breakpoints </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, set&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>breakpoints</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Flips the breakpoints onto the forward strand. </p>

</div>
</div>
<a id="ae968813905d72a9d49a1822b390cbe5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae968813905d72a9d49a1822b390cbe5d">&#9670;&nbsp;</a></span>from_handle_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::from_handle_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a61a0d273871a7d0feea0e9f0b1901931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a0d273871a7d0feea0e9f0b1901931">&#9670;&nbsp;</a></span>from_hit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> vg::from_hit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>hit_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> &amp;&#160;</td>
          <td class="paramname"><em>scorer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a83d1f079508a3ee8a2705773109a5a8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83d1f079508a3ee8a2705773109a5a8e">&#9670;&nbsp;</a></span>from_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::from_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59b4e98d0d99a9b58b56f0946f49b1ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b4e98d0d99a9b58b56f0946f49b1ab">&#9670;&nbsp;</a></span>from_length_after_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::from_length_after_pos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a21d316f0ae049289cacab5117678d6ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21d316f0ae049289cacab5117678d6ab">&#9670;&nbsp;</a></span>from_length_before_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::from_length_before_pos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0eaa4d69a029a84c1d3028745c84bc4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0eaa4d69a029a84c1d3028745c84bc4c">&#9670;&nbsp;</a></span>from_path_handle_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::from_path_handle_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b8b4c6f298818989d39189d631980a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b8b4c6f298818989d39189d631980a8">&#9670;&nbsp;</a></span>from_proto_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::from_proto_edit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;&#160;</td>
          <td class="paramname"><em>proto_edit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1edit__t.html">edit_t</a> &amp;&#160;</td>
          <td class="paramname"><em>edit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1e6878ce34057ea3c8e8c0deacc1726b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e6878ce34057ea3c8e8c0deacc1726b">&#9670;&nbsp;</a></span>from_proto_mapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::from_proto_mapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>proto_mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1path__mapping__t.html">path_mapping_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8630566250dfefc57ec84cbf6c22c3e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8630566250dfefc57ec84cbf6c22c3e2">&#9670;&nbsp;</a></span>from_proto_multipath_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::from_proto_multipath_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>proto_multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a protobuf <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> to an STL-based <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a>. </p>

</div>
</div>
<a id="a01ce1f20da22c85b09e4bae9bf9a3d1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01ce1f20da22c85b09e4bae9bf9a3d1f">&#9670;&nbsp;</a></span>from_proto_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::from_proto_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>proto_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae7d3ba6e34f59b610d86a84d0d6c32d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d3ba6e34f59b610d86a84d0d6c32d1">&#9670;&nbsp;</a></span>from_proto_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::from_proto_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1position__t.html">position_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5b37106006a0286045cd12f9159ac245"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b37106006a0286045cd12f9159ac245">&#9670;&nbsp;</a></span>fuse_spliced_alignments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&amp; vg::fuse_spliced_alignments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>left_mp_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>right_mp_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>left_bridge_point</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>splice_segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>splice_junction_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>splice_score</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> &amp;&#160;</td>
          <td class="paramname"><em>scorer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05748ab256c93e2393252aa8ebbdde3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05748ab256c93e2393252aa8ebbdde3d">&#9670;&nbsp;</a></span>gamma_ln()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::gamma_ln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Calculate the natural log of the gamma function of the given argument. </p>

</div>
</div>
<a id="ada6300e45d21f1171c5ff2b71f4d173b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada6300e45d21f1171c5ff2b71f4d173b">&#9670;&nbsp;</a></span>gbwt_node_width()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gbwt::size_type vg::gbwt_node_width </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Determine the node width in bits for the GBWT nodes based on the given graph. </p>

</div>
</div>
<a id="a28c93b1c4a71fadf62fc2582cc8f0ed2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28c93b1c4a71fadf62fc2582cc8f0ed2">&#9670;&nbsp;</a></span>gbwt_to_handle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::gbwt_to_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gbwt::node_type&#160;</td>
          <td class="paramname"><em>node</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert gbwt::node_type to handle_t. </p>

</div>
</div>
<a id="ae7b5f995eb3e1e824cc4e7db99c81042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7b5f995eb3e1e824cc4e7db99c81042">&#9670;&nbsp;</a></span>gbwt_to_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> vg::gbwt_to_pos </td>
          <td>(</td>
          <td class="paramtype">gbwt::node_type&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert gbwt::node_type and an offset as size_t to pos_t. </p>

</div>
</div>
<a id="a3240e7b9bf787fb218d6324389ea234e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3240e7b9bf787fb218d6324389ea234e">&#9670;&nbsp;</a></span>gcsa_nodes_to_positions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &gt; vg::gcsa_nodes_to_positions </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; gcsa::node_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>nodes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a117021c748aad14cfa190bbd2452405d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a117021c748aad14cfa190bbd2452405d">&#9670;&nbsp;</a></span>generate_haplotype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vg::generate_haplotype </td>
          <td>(</td>
          <td class="paramtype">gbwt::edge_type&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gbwtgraph::GBWTGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d3374c888c7c37f1de8370e151af7f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d3374c888c7c37f1de8370e151af7f9">&#9670;&nbsp;</a></span>genotype_svs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::genotype_svs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>gamfile</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>refpath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Takes a graph and two GAMs, one tumor and one normal Locates existing variation supported by the tumor and annotate it with a path Then overlay the normal sample Use a depthmap of snarltraversal transforms, one for tumor, one for normal which we can use to count the normal and tumor alleles void somatic_genotyper(VG* graph, string tumorgam, string normalgam);</p>
<p>Do smart augment, maintaining a depth map for tumor/normal perfect matches and then editing in all of the SV reads (after normalization) with a T/N_ prefix Then, get our Snarls count reads supporting each and genotype void somatic_caller_genotyper(VG* graph, string tumorgam, string normalgam); </p>

</div>
</div>
<a id="ae923ee7bdb53f33511c95f66a9c2773a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae923ee7bdb53f33511c95f66a9c2773a">&#9670;&nbsp;</a></span>geometric_sampling_prob_ln()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ProbIn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::geometric_sampling_prob_ln </td>
          <td>(</td>
          <td class="paramtype">ProbIn&#160;</td>
          <td class="paramname"><em>success_logprob</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>trials</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the log probability for sampling the given value from a geometric distribution with the given success log probability. The geometric distribution is the distribution of the number of trials, with a given success probability, required to observe a single success. </p>

</div>
</div>
<a id="aa95de659d860fc90fda95df414c89baf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa95de659d860fc90fda95df414c89baf">&#9670;&nbsp;</a></span>get_alignment_emitter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unique_ptr&lt; <a class="el" href="classvg_1_1io_1_1AlignmentEmitter.html">AlignmentEmitter</a> &gt; vg::get_alignment_emitter </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; tuple&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, size_t, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_threads</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em> = <code><a class="el" href="namespacevg.html#a43fe994695e911cc22e05195e327f5b5a77d3ea80cba8f3d89e573bf723ea7f4f">ALIGNMENT_EMITTER_FLAG_NONE</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an AlignmentEmitter that can emit to the given file (or "-") in the given format. When writing HTSlib formats (SAM, BAM, CRAM), paths should contain the paths in the linear reference in sequence dictionary order (see get_sequence_dictionary), and a PathPositionHandleGraph must be provided. When writing GAF, a HandleGraph must be provided for obtaining node lengths and sequences. Other formats do not need a graph.</p>
<p>flags is an ORed together set of flags from alignment_emitter_flags_t.</p>
<p>Automatically applies per-thread buffering, but needs to know how many OMP threads will be in use. </p>

</div>
</div>
<a id="a1c9f371af54160a44a44afd80c6cf71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c9f371af54160a44a44afd80c6cf71a">&#9670;&nbsp;</a></span>get_annotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AnnotationType , typename Annotated &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AnnotationType vg::get_annotation </td>
          <td>(</td>
          <td class="paramtype">Annotated *&#160;</td>
          <td class="paramname"><em>annotated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the annotation with the given name and return it. If not present, returns the Protobuf default value for the annotation type. The value may be a primitive type or an entire Protobuf object. It is undefined behavior to read a value out into a different type than it was stored with. </p>

</div>
</div>
<a id="a1fda752e24eaed100f6c30904d2ca3e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fda752e24eaed100f6c30904d2ca3e1">&#9670;&nbsp;</a></span>get_annotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AnnotationType , typename Annotated &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">AnnotationType vg::get_annotation </td>
          <td>(</td>
          <td class="paramtype">const Annotated &amp;&#160;</td>
          <td class="paramname"><em>annotated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the annotation with the given name and return it. If not present, returns the Protobuf default value for the annotation type. The value may be a primitive type or an entire Protobuf object. It is undefined behavior to read a value out into a different type than it was stored with. </p>

</div>
</div>
<a id="a680a465e72fbddeed584f27a6c3f7b27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680a465e72fbddeed584f27a6c3f7b27">&#9670;&nbsp;</a></span>get_avg_baseq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::get_avg_baseq </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;&#160;</td>
          <td class="paramname"><em>edit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>base_quals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>position_in_read</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the average base quality of an edit. If the edit has no sequence or there are no base_quals given, then double_max is returned. <br  />
 </p>

</div>
</div>
<a id="ab35317ee2bc53165662dd776516f341d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab35317ee2bc53165662dd776516f341d">&#9670;&nbsp;</a></span>get_best_gbwtgraph_gfa_parsing_parameters()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gbwtgraph::GFAParsingParameters vg::get_best_gbwtgraph_gfa_parsing_parameters </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the best configuration to use for the GBWTGraph library GFA parser, to best matcch the behavior of vg's GFA parser. </p>

</div>
</div>
<a id="a8cd30aaebcab130194ac375f23e6f098"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cd30aaebcab130194ac375f23e6f098">&#9670;&nbsp;</a></span>get_current_vmem_kb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::get_current_vmem_kb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the current virtual memory size, in kb, or 0 if unsupported. </p>

</div>
</div>
<a id="af76e8a5e74f67093a40ed5f2cd15ff28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af76e8a5e74f67093a40ed5f2cd15ff28">&#9670;&nbsp;</a></span>get_end_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Visit.html">Visit</a> vg::get_end_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the outward-facing end <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> for a chain. </p>

</div>
</div>
<a id="a53098c7c826c3d8d2aab804ba5500fd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53098c7c826c3d8d2aab804ba5500fd5">&#9670;&nbsp;</a></span>get_file_size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::get_file_size </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af8f8da6eb179ba0199fc2fdfe676fde7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8f8da6eb179ba0199fc2fdfe676fde7">&#9670;&nbsp;</a></span>get_fraction_of_ns()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::get_fraction_of_ns </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of Ns as a fraction of the total sequence length (or 0 if the sequence is empty) </p>

</div>
</div>
<a id="a571047c58b73b78d02a767c3ab6ec222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a571047c58b73b78d02a767c3ab6ec222">&#9670;&nbsp;</a></span>get_gbwt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gbwt::GBWT vg::get_gbwt </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; gbwt::vector_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>paths</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transform the paths into a GBWT index. Primarily for testing. </p>

</div>
</div>
<a id="ae4370b5cb4b42e8556b0fbc793fbdfc0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4370b5cb4b42e8556b0fbc793fbdfc0">&#9670;&nbsp;</a></span>get_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&amp; vg::get_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a> ID of a pos_t. </p>

</div>
</div>
<a id="a09969fef23098c7729a2f190cecb4694"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09969fef23098c7729a2f190cecb4694">&#9670;&nbsp;</a></span>get_input_file() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::get_input_file </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>file_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(istream &amp;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a callback with an istream&amp; to an open file. Handles "-" as a filename as indicating standard input. The reference passed is guaranteed to be valid only until the callback returns. </p>

</div>
</div>
<a id="ab1b8b686ef6eca09515be1abe566c013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1b8b686ef6eca09515be1abe566c013">&#9670;&nbsp;</a></span>get_input_file() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::get_input_file </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>optind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(istream &amp;)&gt;&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a callback with an istream&amp; to an open file if a file name argument is present after the parsed options, or print an error message and exit if one is not. Handles "-" as a filename as indicating standard input. The reference passed is guaranteed to be valid only until the callback returns. Bumps up optind to the next argument if a filename is found.</p>
<p>Warning: If you're reading a HandleGraph via <a class="el" href="classvg_1_1io_1_1VPKG.html#affd67a72df658a50228c6cae7efe7753">VPKG::load_one</a> (as is the pattern in vg) it is best to use <a class="el" href="namespacevg.html#a5026b599b1094a6c8e157f23b204b09b">get_input_file_name()</a> below instead, and run load_one on that. This allows better GFA support because it allows memmapping the file directly </p>

</div>
</div>
<a id="a5026b599b1094a6c8e157f23b204b09b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5026b599b1094a6c8e157f23b204b09b">&#9670;&nbsp;</a></span>get_input_file_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::get_input_file_name </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>optind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>test_open</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse out the name of an input file (i.e. the next positional argument), or throw an error. File name must be nonempty, but may be "-" or may not exist. </p>

</div>
</div>
<a id="a1919abd090eae3a01120e0859d434ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1919abd090eae3a01120e0859d434ed9">&#9670;&nbsp;</a></span>get_is_rev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool&amp; vg::get_is_rev </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the reverse flag of a pos_t. </p>

</div>
</div>
<a id="a546b60e87f7fc326074f6dcf2cdd0659"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a546b60e87f7fc326074f6dcf2cdd0659">&#9670;&nbsp;</a></span>get_max_rss_kb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::get_max_rss_kb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the max RSS usage ever, in kb, or 0 if unsupported. </p>

</div>
</div>
<a id="a917d8892f93a31e2d8c3161de264fea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a917d8892f93a31e2d8c3161de264fea1">&#9670;&nbsp;</a></span>get_max_vmem_kb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::get_max_vmem_kb </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the max virtual memory size ever, in kb, or 0 if unsupported. </p>

</div>
</div>
<a id="a13a0b0f632813ff45251135b2b4510c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a0b0f632813ff45251135b2b4510c0">&#9670;&nbsp;</a></span>get_minimizer_distances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1MIPayloadValues.html">MIPayloadValues</a> vg::get_minimizer_distances </td>
          <td>(</td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4f91415350a5b07bb4b4f90dd531658d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f91415350a5b07bb4b4f90dd531658d">&#9670;&nbsp;</a></span>get_next_alignment_from_fastq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::get_next_alignment_from_fastq </td>
          <td>(</td>
          <td class="paramtype">gzFile&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6e9fd0ae285f5f9dd8605c9f5343e071"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e9fd0ae285f5f9dd8605c9f5343e071">&#9670;&nbsp;</a></span>get_next_alignment_pair_from_fastqs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::get_next_alignment_pair_from_fastqs </td>
          <td>(</td>
          <td class="paramtype">gzFile&#160;</td>
          <td class="paramname"><em>fp1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gzFile&#160;</td>
          <td class="paramname"><em>fp2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>mate1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>mate2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afb9108ffcadb902a9d82ca882919a38c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb9108ffcadb902a9d82ca882919a38c">&#9670;&nbsp;</a></span>get_next_interleaved_alignment_pair_from_fastq()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::get_next_interleaved_alignment_pair_from_fastq </td>
          <td>(</td>
          <td class="paramtype">gzFile&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>mate1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>mate2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe9d79548464e7842327275008447299"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe9d79548464e7842327275008447299">&#9670;&nbsp;</a></span>get_num_samples()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::get_num_samples </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>vcf_filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af826519a2b2e0cf58394e35d7ab7b84c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af826519a2b2e0cf58394e35d7ab7b84c">&#9670;&nbsp;</a></span>get_offset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afe223f2c7890c76de5e00b43ceb37add">offset_t</a>&amp; vg::get_offset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a reference to the offset field of a pos_t, which counts along the selected strand of the node. </p>

</div>
</div>
<a id="ae9fc5855bb49062ce72e56c805e1545a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9fc5855bb49062ce72e56c805e1545a">&#9670;&nbsp;</a></span>get_or_make_variant_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::get_or_make_variant_id </td>
          <td>(</td>
          <td class="paramtype">const vcflib::Variant &amp;&#160;</td>
          <td class="paramname"><em>variant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2a0425675c4a85289b230eef2c985b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2a0425675c4a85289b230eef2c985b8">&#9670;&nbsp;</a></span>get_output_file_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::get_output_file_name </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>optind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse out the name of an output file (i.e. the next positional argument), or throw an error. File name must be nonempty. </p>

</div>
</div>
<a id="a162ed4c8f358ca4c33ab05a27f8349cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a162ed4c8f358ca4c33ab05a27f8349cb">&#9670;&nbsp;</a></span>get_path() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&gt; vg::get_path </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gbwt::node_type&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d972910bf64084a1ee50ca4350c5b59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d972910bf64084a1ee50ca4350c5b59">&#9670;&nbsp;</a></span>get_path() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&gt; vg::get_path </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a66796444cb3b92c35ebeddbb7a9bc6bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66796444cb3b92c35ebeddbb7a9bc6bf">&#9670;&nbsp;</a></span>get_path() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&gt; vg::get_path </td>
          <td>(</td>
          <td class="paramtype">gbwt::node_type&#160;</td>
          <td class="paramname"><em>reverse_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa5fc35eee866d216357a5818cd1fb927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5fc35eee866d216357a5818cd1fb927">&#9670;&nbsp;</a></span>get_path() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&gt; vg::get_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>second</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9fb67697fd1e49bcb389a735ba9fa8f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fb67697fd1e49bcb389a735ba9fa8f2">&#9670;&nbsp;</a></span>get_proc_status_value()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::get_proc_status_value </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the string value for a field in /proc/self/status by name, or "" if unsupported or not found. </p>

</div>
</div>
<a id="a2e23f130325e05c894696771e50f2636"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e23f130325e05c894696771e50f2636">&#9670;&nbsp;</a></span>get_sequence_dictionary()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; tuple&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, size_t, size_t &gt; &gt; vg::get_sequence_dictionary </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_names</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Produce a list of path handles in a fixed order, suitable for use with get_alignment_emitter_with_surjection(), by parsing a file. The file may be an HTSlib-style "sequence dictionary" (consisting of SAM @SQ header lines), or a plain list of sequence names (which do not start with "@SQ"). If the file is not openable or contains no entries, reports an error and quits.</p>
<p>If path_names has entries, they are treated as path names that supplement those in the file, if any.</p>
<p>If the filename is itself an empty string, and no path names are passed, then all reference-sense paths from the graph will be collected in arbitrary order. If there are none, all non-alt-allele generic sense paths from the graph will be collected in arbitrary order.</p>
<p>TODO: Be able to generate the autosomes human-sort, X, Y, MT order typical of references.</p>
<p>The tuple is &lt;path, path length in graph, base path length&gt; For a subpath (ie chr1[1000-10000]) the base path length would be that of chr1 This information needs to come from the user in order to be correct, but if it's not specified, it'll be guessed from the graph </p>

</div>
</div>
<a id="afa918cf29c1c8238d88f2bbc94b6abef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa918cf29c1c8238d88f2bbc94b6abef">&#9670;&nbsp;</a></span>get_start_of()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Visit.html">Visit</a> vg::get_start_of </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the inward-facing start <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> for a chain. </p>

</div>
</div>
<a id="ade988dd38efaa705be15ba17500fe219"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade988dd38efaa705be15ba17500fe219">&#9670;&nbsp;</a></span>get_thread_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::get_thread_count </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return the number of threads that OMP will produce for a parallel section. TODO: Assumes that this is the same for every parallel section. </p>

</div>
</div>
<a id="a871d5cdd29e1806636314021d0b6d451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a871d5cdd29e1806636314021d0b6d451">&#9670;&nbsp;</a></span>get_traversal_of_snarl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> vg::get_traversal_of_snarl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *&#160;</td>
          <td class="paramname"><em>snarl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td>
          <td class="paramname"><em>manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Given a path (which may run either direction through a snarl, or not touch the ends at all), collect a list of NodeTraversals in order for the part of the path that is inside the snarl, in the same orientation as the path. </p>

</div>
</div>
<a id="af601021f7ec2c0b0d7404030ee7271c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af601021f7ec2c0b0d7404030ee7271c9">&#9670;&nbsp;</a></span>getReachableBridges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::getReachableBridges </td>
          <td>(</td>
          <td class="paramtype">stCactusEdgeEnd *&#160;</td>
          <td class="paramname"><em>edgeEnd1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stList *&#160;</td>
          <td class="paramname"><em>bridgeEnds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the bridge ends that form boundary pairs with edgeEnd1. Duplicated from the pinchesAndCacti tests. </p>

</div>
</div>
<a id="a2dc613a63afb3f23851c96494006630d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc613a63afb3f23851c96494006630d">&#9670;&nbsp;</a></span>getReachableBridges2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::getReachableBridges2 </td>
          <td>(</td>
          <td class="paramtype">stCactusEdgeEnd *&#160;</td>
          <td class="paramname"><em>edgeEnd1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stHash *&#160;</td>
          <td class="paramname"><em>bridgeEndsToBridgeNodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">stList *&#160;</td>
          <td class="paramname"><em>bridgeEnds</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the bridge ends that form boundary pairs with edgeEnd1, using the given getBridgeEdgeEndsToBridgeNodes hash map. Duplicated from the pinchesAndCacti tests. </p>

</div>
</div>
<a id="a314ff925fad534d112e4531617e408fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a314ff925fad534d112e4531617e408fa">&#9670;&nbsp;</a></span>golden_section_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::golden_section_search </td>
          <td>(</td>
          <td class="paramtype">const function&lt; double(double)&gt; &amp;&#160;</td>
          <td class="paramname"><em>f</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_min</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x_max</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a local maximum of a function within an interval. </p>

</div>
</div>
<a id="ad8c4a075bb9301c8050d89ed8e6a33b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8c4a075bb9301c8050d89ed8e6a33b9">&#9670;&nbsp;</a></span>graph_to_gfa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::graph_to_gfa </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>rgfa_paths</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rgfa_pline</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_w_lines</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Export the given <a class="el" href="classvg_1_1VG.html">VG</a> graph to the given GFA file. Express paths mentioned in rgfa_paths as rGFA. If rgfa_pline is set, also express them as dedicated lines. If use_w_lines is set, reference and haplotype paths will use W lines instead of P lines. </p>

</div>
</div>
<a id="a536dfd4326c17ad4d072d2c9021e4b7c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a536dfd4326c17ad4d072d2c9021e4b7c">&#9670;&nbsp;</a></span>handle_full_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::handle_full_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>overlap_threshold</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3d4e7ee3d7394e2318e874dc98dd8320"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4e7ee3d7394e2318e874dc98dd8320">&#9670;&nbsp;</a></span>handle_graph_to_cactus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; stCactusGraph *, stList * &gt; vg::handle_graph_to_cactus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; string &gt; &amp;&#160;</td>
          <td class="paramname"><em>hint_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>single_component</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1fa5cc80bff735a8803aa9f564c29994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fa5cc80bff735a8803aa9f564c29994">&#9670;&nbsp;</a></span>handle_to_gbwt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gbwt::node_type vg::handle_to_gbwt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert handle_t to gbwt::node_type. </p>

</div>
</div>
<a id="ab5a2adbf9370dc37be337d927341f9db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5a2adbf9370dc37be337d927341f9db">&#9670;&nbsp;</a></span>haplotype_consistent_alignments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::haplotype_consistent_alignments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhaplo_1_1ScoreProvider.html">haplo::ScoreProvider</a> &amp;&#160;</td>
          <td class="paramname"><em>score_provider</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>soft_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>hard_count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>optimal_first</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds all alignments consistent with haplotypes available by incremental search with the given haplotype score provider. Pads to a certain count with haplotype-inconsistent alignments that are population-scorable (i.e. use only edges used by some haplotype in the index), and then with unscorable alignments if scorable ones are unavailable. This may result in an empty vector.</p>
<p>Output Alignments may not be unique. The input <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> may have exponentially many ways to spell the same <a class="el" href="structvg_1_1Alignment.html">Alignment</a>, and we will look at all of them. We also may have duplicates of the optimal alignment if we are asked to produce it unconsitionally.</p>
<p>Note: Assumes that each subpath's <a class="el" href="structvg_1_1Path.html">Path</a> object uses one <a class="el" href="structvg_1_1Mapping.html">Mapping</a> per node and that start subpaths have been identified</p>
<p>Args: multipath_aln multipath alignment to find optimal paths through score_provider a <a class="el" href="classhaplo_1_1ScoreProvider.html">haplo::ScoreProvider</a> that supports incremental search over its haplotype database (such as a GBWTScoreProvider) soft_count maximum number of haplotype-inconsistent alignments to pad to hard_count maximum number of alignments, including haplotype-consistent (0 if no limit) optimal_first always compute and return first the optimal alignment, even if not haplotype-consistent </p>

</div>
</div>
<a id="a34f4e73b242fa5b34d30ecc4da496835"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34f4e73b242fa5b34d30ecc4da496835">&#9670;&nbsp;</a></span>has_annotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Annotated &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::has_annotation </td>
          <td>(</td>
          <td class="paramtype">const Annotated &amp;&#160;</td>
          <td class="paramname"><em>annotated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if the Protobuf object has an annotation with this name. </p>

</div>
</div>
<a id="a1b545f6474c6e528176031149a8bc570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b545f6474c6e528176031149a8bc570">&#9670;&nbsp;</a></span>has_inversion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::has_inversion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if we find an edge that may specify an inversion </p>

</div>
</div>
<a id="a94f469aebb2be5b0028c337108d253fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f469aebb2be5b0028c337108d253fb">&#9670;&nbsp;</a></span>hash_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string vg::hash_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8bc1d89bbcee041956e59895ed605ca3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bc1d89bbcee041956e59895ed605ca3">&#9670;&nbsp;</a></span>hash_to_rgb()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple&lt; double, double, double &gt; vg::hash_to_rgb </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_sum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c950dca7cd25a5ce9846be2a6b93e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c950dca7cd25a5ce9846be2a6b93e13">&#9670;&nbsp;</a></span>have_input_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::have_input_file </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>optind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>argc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char **&#160;</td>
          <td class="paramname"><em>argv</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if there's a command line argument (i.e. input file name) waiting to be processed. </p>

</div>
</div>
<a id="a0676eec9e08d9589fe286cabdd16ffb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0676eec9e08d9589fe286cabdd16ffb3">&#9670;&nbsp;</a></span>hts_file_header()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bam_hdr_t * vg::hts_file_header </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>header</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7abb14966c1c20cff85c5744a47de0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7abb14966c1c20cff85c5744a47de0e">&#9670;&nbsp;</a></span>hts_for_each() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::hts_for_each </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f1e53242cb6ccf3d567c73c0895c4ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f1e53242cb6ccf3d567c73c0895c4ca">&#9670;&nbsp;</a></span>hts_for_each() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::hts_for_each </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a59c6c494c2e7663fb14e40c978b4f9e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59c6c494c2e7663fb14e40c978b4f9e5">&#9670;&nbsp;</a></span>hts_for_each_parallel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::hts_for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c0d37c85747f2bce6ba3356a813524a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c0d37c85747f2bce6ba3356a813524a">&#9670;&nbsp;</a></span>hts_for_each_parallel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::hts_for_each_parallel </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;)&gt;&#160;</td>
          <td class="paramname"><em>lambda</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc01af3a6e386a06a2971c17a0e6d1b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc01af3a6e386a06a2971c17a0e6d1b1">&#9670;&nbsp;</a></span>hts_string_header() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bam_hdr_t * vg::hts_string_header </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; string, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; string, string &gt; &amp;&#160;</td>
          <td class="paramname"><em>rg_sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aeb8cd62602cb90541b2270a79aed7595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb8cd62602cb90541b2270a79aed7595">&#9670;&nbsp;</a></span>hts_string_header() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bam_hdr_t * vg::hts_string_header </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; string, int64_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>path_order_and_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; string, string &gt; &amp;&#160;</td>
          <td class="paramname"><em>rg_sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9f6602b7e7a46c19819c8f362147b315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f6602b7e7a46c19819c8f362147b315">&#9670;&nbsp;</a></span>id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::id </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract the id of the node a pos_t is on. </p>

</div>
</div>
<a id="a0844cc3c2da56dfed0e9436d7f0dd7de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0844cc3c2da56dfed0e9436d7f0dd7de">&#9670;&nbsp;</a></span>identify_start_subpaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::identify_start_subpaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the start subpaths (i.e. the source nodes of the multipath DAG) and stores them in the 'start' field of the <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> </p>

</div>
</div>
<a id="ab3c5c7a407962a8c735c1d533cc0b186"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3c5c7a407962a8c735c1d533cc0b186">&#9670;&nbsp;</a></span>identity()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::identity </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a62239efefb85e451fcec6519644186d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a62239efefb85e451fcec6519644186d1">&#9670;&nbsp;</a></span>in_place_subvector()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Element &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::in_place_subvector </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; Element &gt; &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>head</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>tail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9fa6175557c33cd572b8726222cf6547"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fa6175557c33cd572b8726222cf6547">&#9670;&nbsp;</a></span>increment_node_mapping_ids()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a>&amp; vg::increment_node_mapping_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>inc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd31d3a8dc67801f147d0ba1b0059c3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd31d3a8dc67801f147d0ba1b0059c3f">&#9670;&nbsp;</a></span>initial_position() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> vg::initial_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5273bbd5e5d0f9bbf639c19c962a58dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5273bbd5e5d0f9bbf639c19c962a58dd">&#9670;&nbsp;</a></span>initial_position() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> vg::initial_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9bf4a7dd2a81bb5b873127156a2dfb33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bf4a7dd2a81bb5b873127156a2dfb33">&#9670;&nbsp;</a></span>insert_gbwt_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vg::insert_gbwt_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutablePathHandleGraph.html">MutablePathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>gbwt_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gbwt::size_type&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>path_name</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Insert a GBWT thread into the graph and return its name. Returns an empty string on failure. If a path name is specified and not empty, that name will be used for the inserted path. NOTE: id is a gbwt path id, not a gbwt sequence id. </p>

</div>
</div>
<a id="aa7c32d1e90ec006624a7ee03655f3c35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa7c32d1e90ec006624a7ee03655f3c35">&#9670;&nbsp;</a></span>integer_power() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::integer_power </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>power</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aca4239af1a9e3eb1283f78bf5cc1411a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca4239af1a9e3eb1283f78bf5cc1411a">&#9670;&nbsp;</a></span>integer_power() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::integer_power </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>exponent</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes base^exponent in log(exponent) time. </p>

</div>
</div>
<a id="a9467900ec651b93d47190413208cdf6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9467900ec651b93d47190413208cdf6f">&#9670;&nbsp;</a></span>interval_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::interval_length </td>
          <td>(</td>
          <td class="paramtype">std::pair&lt; size_t, size_t &gt;&#160;</td>
          <td class="paramname"><em>interval</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe6f7955b97d8537da2133a47f37f462"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6f7955b97d8537da2133a47f37f462">&#9670;&nbsp;</a></span>is_all_n()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::is_all_n </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return True if the given string is entirely Ns of either case, and false otherwise. </p>

</div>
</div>
<a id="a3620df68e5af61a8eb660e4a4838ea06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3620df68e5af61a8eb660e4a4838ea06">&#9670;&nbsp;</a></span>is_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::is_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if a pos_t is unset. </p>

</div>
</div>
<a id="a8f065676bdbe54b44e45961d7d40d8a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f065676bdbe54b44e45961d7d40d8a5">&#9670;&nbsp;</a></span>is_gzipped()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::is_gzipped </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5570a5685bef6eee6ac2697920ebc6c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5570a5685bef6eee6ac2697920ebc6c0">&#9670;&nbsp;</a></span>is_id_sortable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::is_id_sortable </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>returns true if the graph is id-sortable (no reverse links) </p>

</div>
</div>
<a id="a52292dfd3869a811170f7c5c0d9da564"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52292dfd3869a811170f7c5c0d9da564">&#9670;&nbsp;</a></span>is_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::is_match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Translation.html">Translation</a> &amp;&#160;</td>
          <td class="paramname"><em>translation</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af051490e6e94b4c476695610472cdf5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af051490e6e94b4c476695610472cdf5b">&#9670;&nbsp;</a></span>is_number() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::is_number </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a97c44463adc7ddcc77ac9664692a62b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97c44463adc7ddcc77ac9664692a62b8">&#9670;&nbsp;</a></span>is_number() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::is_number </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac725dd44bc5a8f540554d4b1882c1fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac725dd44bc5a8f540554d4b1882c1fe">&#9670;&nbsp;</a></span>is_rev()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::is_rev </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if a pos_t is on the reverse strand of its node. </p>

</div>
</div>
<a id="a92c923774a6526b7bfc7f06ae4ae7a18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92c923774a6526b7bfc7f06ae4ae7a18">&#9670;&nbsp;</a></span>isATGC()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::isATGC </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if a character is an uppercase A, C, G, or T, and false otherwise. </p>

</div>
</div>
<a id="ae8290bb0f46f4410bd8d19a9214f42d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8290bb0f46f4410bd8d19a9214f42d9">&#9670;&nbsp;</a></span>kff_bytes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::kff_bytes </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the number of bytes required for a kmer in KFF format. </p>

</div>
</div>
<a id="a508b66314d777de73b671860cc1ba66f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a508b66314d777de73b671860cc1ba66f">&#9670;&nbsp;</a></span>kff_decode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vg::kff_decode </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>kmer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>decoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Decodes a kmer in KFF format according to the given encoding. </p>

</div>
</div>
<a id="adbd931ab5e8c6d8549262292b5fd1bdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbd931ab5e8c6d8549262292b5fd1bdb">&#9670;&nbsp;</a></span>kff_decode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::kff_decode </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>byte</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>decoding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad8ec52a5e105f9ff5dc0ee6a882f11ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8ec52a5e105f9ff5dc0ee6a882f11ef">&#9670;&nbsp;</a></span>kff_encode() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint8_t &gt; vg::kff_encode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>kmer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Encodes a kmer in KFF format according to the given encoding. Non-ACGT characters are encoded as 0s. </p>

</div>
</div>
<a id="a703f0e894fc3faab71d1f56963a1b1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703f0e894fc3faab71d1f56963a1b1f2">&#9670;&nbsp;</a></span>kff_encode() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t vg::kff_encode </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>kmer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a971fa4f581aa13c4d3a29728485a496a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a971fa4f581aa13c4d3a29728485a496a">&#9670;&nbsp;</a></span>kff_get()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t vg::kff_get </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>kmer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afff8c68e07248aa6b304c3b9f45f8e4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afff8c68e07248aa6b304c3b9f45f8e4b">&#9670;&nbsp;</a></span>kff_invert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vg::kff_invert </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>encoding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverts the KFF encoding into a packed -&gt; char table. </p>

</div>
</div>
<a id="ab293dcf09c223de43976346c70763cd8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab293dcf09c223de43976346c70763cd8">&#9670;&nbsp;</a></span>kff_is_trivial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::kff_is_trivial </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>encoding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns <code>true</code> if the encoding is trivial (0, 1, 2, 3). </p>

</div>
</div>
<a id="ac3021a605be981221a7454ed41329abb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3021a605be981221a7454ed41329abb">&#9670;&nbsp;</a></span>kff_parse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::kff_parse </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parses a big-endian integer from KFF data. </p>

</div>
</div>
<a id="ab6b770ea79c9b74e89ecff6f5e347bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b770ea79c9b74e89ecff6f5e347bf6">&#9670;&nbsp;</a></span>kff_recode() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gbwtgraph::Key64::value_type vg::kff_recode </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>kmer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1kff__recoding__t.html">kff_recoding_t</a>&#160;</td>
          <td class="paramname"><em>recoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recodes a KFF kmer in the minimizer index format according to the given encoding. Will fail silently if <code>k</code> is too large or <code>recoding</code> is not from <code><a class="el" href="namespacevg.html#a1429f1c00018d575e753609329896f31" title="Returns a recoding for the given encoding.">kff_recoding()</a></code>. </p>

</div>
</div>
<a id="a92ba361b3ec6a01bac17e71af08d2223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ba361b3ec6a01bac17e71af08d2223">&#9670;&nbsp;</a></span>kff_recode() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; gbwtgraph::Key64::value_type &gt; vg::kff_recode </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>kmers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1kff__recoding__t.html">kff_recoding_t</a>&#160;</td>
          <td class="paramname"><em>recoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recodes <code>n</code> KFF kmers in the minimizer index format according to the given encoding. Will fail silently if <code>k</code> is too large or <code>recoding</code> is not from <code><a class="el" href="namespacevg.html#a1429f1c00018d575e753609329896f31" title="Returns a recoding for the given encoding.">kff_recoding()</a></code>. </p>

</div>
</div>
<a id="acc31374a96e3cd653324ab57eb9714ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc31374a96e3cd653324ab57eb9714ff">&#9670;&nbsp;</a></span>kff_recode() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint8_t &gt; vg::kff_recode </td>
          <td>(</td>
          <td class="paramtype">gbwtgraph::Key64::value_type&#160;</td>
          <td class="paramname"><em>kmer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Recodes a kmer from a minimizer index in KFF format according to the given encoding. </p>

</div>
</div>
<a id="a1d573b735cb520c77d373fe1231fb94d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d573b735cb520c77d373fe1231fb94d">&#9670;&nbsp;</a></span>kff_recode() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t vg::kff_recode </td>
          <td>(</td>
          <td class="paramtype">gbwtgraph::Key64::value_type&#160;</td>
          <td class="paramname"><em>kmer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>chars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad52eac0801905a9d5f2ba805f1387213"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad52eac0801905a9d5f2ba805f1387213">&#9670;&nbsp;</a></span>kff_recode_trivial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gbwtgraph::Key64::value_type vg::kff_recode_trivial </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>kmer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Recodes a KFF kmer in the minimizer index format, assuming that the encoding is the same. Will fail silently if <code>k</code> or <code>bytes</code> is too large. </p>

</div>
</div>
<a id="a1429f1c00018d575e753609329896f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1429f1c00018d575e753609329896f31">&#9670;&nbsp;</a></span>kff_recoding()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1kff__recoding__t.html">kff_recoding_t</a> vg::kff_recoding </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>encoding</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a recoding for the given encoding. </p>

</div>
</div>
<a id="a213d22fbc9d8056efb8082e529ab0f22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a213d22fbc9d8056efb8082e529ab0f22">&#9670;&nbsp;</a></span>kff_reverse_complement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; uint8_t &gt; vg::kff_reverse_complement </td>
          <td>(</td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>kmer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const uint8_t *&#160;</td>
          <td class="paramname"><em>encoding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the reverse complement of a KFF kmer. </p>

</div>
</div>
<a id="ad78d3175e64e6a9c019275b5b3e17fe5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78d3175e64e6a9c019275b5b3e17fe5">&#9670;&nbsp;</a></span>kff_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::kff_set </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; uint8_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>kmer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a661fc17618ee9ff7bd9d469c74c63369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a661fc17618ee9ff7bd9d469c74c63369">&#9670;&nbsp;</a></span>kmer_to_gcsa_kmers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::kmer_to_gcsa_kmers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1kmer__t.html">kmer_t</a> &amp;&#160;</td>
          <td class="paramname"><em>kmer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gcsa::Alphabet &amp;&#160;</td>
          <td class="paramname"><em>alpha</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(const gcsa::KMer &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the <a class="el" href="structvg_1_1kmer__t.html">kmer_t</a> to a set of gcsa2 binary kmers which are exposed via a callback. </p>

</div>
</div>
<a id="a4f32c345e847a3627afcee659116730c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f32c345e847a3627afcee659116730c">&#9670;&nbsp;</a></span>kmp_search()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::kmp_search </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>text</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>text_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pattern_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>prefix_suffix_table</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa1c1e5b8ce9f9607976913317102d6dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1c1e5b8ce9f9607976913317102d6dc">&#9670;&nbsp;</a></span>last_path_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::last_path_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abe3c447c811f77c28669a36c4d3376b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe3c447c811f77c28669a36c4d3376b9">&#9670;&nbsp;</a></span>list_haplotypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; vector&lt; gbwt::node_type &gt;, gbwt::SearchState &gt; &gt; vg::list_haplotypes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>gbwt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; bool(const vector&lt; gbwt::node_type &gt; &amp;)&gt;&#160;</td>
          <td class="paramname"><em>stop_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a664ec3301c226596ad971b97a8e1fa65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a664ec3301c226596ad971b97a8e1fa65">&#9670;&nbsp;</a></span>ln_to_log10()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::ln_to_log10 </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>ln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a number ln to the same number log 10. </p>

</div>
</div>
<a id="a5197b188ae631a5adcd9689a18138042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5197b188ae631a5adcd9689a18138042">&#9670;&nbsp;</a></span>load_gbwt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::load_gbwt </td>
          <td>(</td>
          <td class="paramtype">gbwt::DynamicGBWT &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a dynamic GBWT from the file. </p>

</div>
</div>
<a id="af077c13bde9c0e8f5ee88d7000a0803e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af077c13bde9c0e8f5ee88d7000a0803e">&#9670;&nbsp;</a></span>load_gbwt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::load_gbwt </td>
          <td>(</td>
          <td class="paramtype">gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a compressed GBWT from the file. </p>

</div>
</div>
<a id="af83417b41cb483c6cad692b718c2bc02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83417b41cb483c6cad692b718c2bc02">&#9670;&nbsp;</a></span>load_gbwtgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::load_gbwtgraph </td>
          <td>(</td>
          <td class="paramtype">gbwtgraph::GBWTGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load GBWTGraph from the file. NOTE: Call <code>graph.set_gbwt()</code> afterwards with the appropriate GBWT index. </p>

</div>
</div>
<a id="a142177e721683d3e4d428f6cb8f22981"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a142177e721683d3e4d428f6cb8f22981">&#9670;&nbsp;</a></span>load_gbz() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::load_gbz </td>
          <td>(</td>
          <td class="paramtype">gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gbwtgraph::GBWTGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load GBWT and GBWTGraph from the GBZ file. </p>

</div>
</div>
<a id="a7f775d6f61207052e3c157e5ad6cfcf0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7f775d6f61207052e3c157e5ad6cfcf0">&#9670;&nbsp;</a></span>load_gbz() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::load_gbz </td>
          <td>(</td>
          <td class="paramtype">gbwtgraph::GBZ &amp;&#160;</td>
          <td class="paramname"><em>gbz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load GBZ from the file. </p>

</div>
</div>
<a id="a1bd12c27c337a889da2db07d54d2e1d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd12c27c337a889da2db07d54d2e1d6">&#9670;&nbsp;</a></span>load_gbz() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::load_gbz </td>
          <td>(</td>
          <td class="paramtype">gbwtgraph::GBZ &amp;&#160;</td>
          <td class="paramname"><em>gbz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>gbwt_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>graph_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load GBZ from separate GBWT / GBWTGraph files. </p>

</div>
</div>
<a id="afb0e46d1a71de77dddab10d147ac0538"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb0e46d1a71de77dddab10d147ac0538">&#9670;&nbsp;</a></span>load_gcsa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::load_gcsa </td>
          <td>(</td>
          <td class="paramtype">gcsa::GCSA &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load GCSA from the file. </p>

</div>
</div>
<a id="a0679feb8bafbf4be20c4bffa633223c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0679feb8bafbf4be20c4bffa633223c6">&#9670;&nbsp;</a></span>load_lcp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::load_lcp </td>
          <td>(</td>
          <td class="paramtype">gcsa::LCPArray &amp;&#160;</td>
          <td class="paramname"><em>lcp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load LCP array from the file. </p>

</div>
</div>
<a id="a649b144d7ce85a247af73055577c4d91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a649b144d7ce85a247af73055577c4d91">&#9670;&nbsp;</a></span>load_minimizer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::load_minimizer </td>
          <td>(</td>
          <td class="paramtype">gbwtgraph::DefaultMinimizerIndex &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load a minimizer index from the file. </p>

</div>
</div>
<a id="a4ab05fd111751cbf31c3a6a5189a76ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ab05fd111751cbf31c3a6a5189a76ff">&#9670;&nbsp;</a></span>load_r_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::load_r_index </td>
          <td>(</td>
          <td class="paramtype">gbwt::FastLocate &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load an r-index from the file. </p>

</div>
</div>
<a id="a0b717077a15106d70c8ce4cc035ca890"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b717077a15106d70c8ce4cc035ca890">&#9670;&nbsp;</a></span>load_translation_back_map() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, std::pair&lt; std::string, size_t &gt; &gt; vg::load_translation_back_map </td>
          <td>(</td>
          <td class="paramtype">const gbwtgraph::GBWTGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a backwards mapping of chopped node to original segment position (id,offset pair) </p>
<p>Return a backwards mapping of chopped node to original segment position (id,offset pair) (mimicking logic and interface from function of same name in <a class="el" href="gbwt__helper_8cpp.html">gbwt_helper.cpp</a>) </p>

</div>
</div>
<a id="a3cde90cbb8b1fc46d2b830bf87dba997"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cde90cbb8b1fc46d2b830bf87dba997">&#9670;&nbsp;</a></span>load_translation_back_map() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, pair&lt; string, size_t &gt; &gt; vg::load_translation_back_map </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ifstream &amp;&#160;</td>
          <td class="paramname"><em>input_stream</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a translation file (created with vg gbwt &ndash;translation) and return a backwards mapping of chopped node to original segment position (id,offset pair) NOTE: hopefully this is just a short-term hack, and we get a general interface baked into the handlegraphs themselves </p>

</div>
</div>
<a id="a709e93bb1c0dbdcdbc928960e42688ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a709e93bb1c0dbdcdbc928960e42688ec">&#9670;&nbsp;</a></span>load_translation_map() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unordered_map&lt; std::string, std::vector&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &gt; vg::load_translation_map </td>
          <td>(</td>
          <td class="paramtype">const gbwtgraph::GBWTGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a mapping of the original segment ids to a list of chopped node ids. </p>
<p>Return a mapping of the original segment ids to a list of chopped node ids (mimicking logic and interface from function of same name in <a class="el" href="gbwt__helper_8cpp.html">gbwt_helper.cpp</a>) </p>

</div>
</div>
<a id="a11a634196a7420547646dc30d2c57b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11a634196a7420547646dc30d2c57b18">&#9670;&nbsp;</a></span>load_translation_map() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; string, vector&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &gt; vg::load_translation_map </td>
          <td>(</td>
          <td class="paramtype">ifstream &amp;&#160;</td>
          <td class="paramname"><em>input_stream</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load a translation file (created with vg gbwt &ndash;translation) and return a mapping original segment ids to a list of chopped node ids </p>

</div>
</div>
<a id="a16b2b6e110a2f72a871c309b888b013c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b2b6e110a2f72a871c309b888b013c">&#9670;&nbsp;</a></span>log10_add_one()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::log10_add_one </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Given the log10 of a value, retunr the log10 of (that value plus one). </p>

</div>
</div>
<a id="a48d9ec9295afc7457506af4ddaf44217"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48d9ec9295afc7457506af4ddaf44217">&#9670;&nbsp;</a></span>log10_to_ln()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::log10_to_ln </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>l10</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Convert a number log 10 to the same number ln. </p>

</div>
</div>
<a id="afe6b7d44806f0d50d79f7de39800495d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6b7d44806f0d50d79f7de39800495d">&#9670;&nbsp;</a></span>lognormal_pdf()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::lognormal_pdf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mu</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Probability density function or log-normal distribution. </p>

</div>
</div>
<a id="a64b25a99232585c5e76baf01d1ef5520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64b25a99232585c5e76baf01d1ef5520">&#9670;&nbsp;</a></span>logprob_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::logprob_add </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>logprob1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>logprob2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add two probabilities (expressed as logprobs) together and return the result as a logprob. </p>

</div>
</div>
<a id="a0f8a1a81a5402187152a97ca6293b4f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f8a1a81a5402187152a97ca6293b4f1">&#9670;&nbsp;</a></span>logprob_geometric_mean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::logprob_geometric_mean </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lnprob1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lnprob2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take the geometric mean of two logprobs. </p>

</div>
</div>
<a id="a1056422cd0697f2bbdcf8a085486793a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1056422cd0697f2bbdcf8a085486793a">&#9670;&nbsp;</a></span>logprob_invert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::logprob_invert </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>logprob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invert a logprob, and get the probability of its opposite. </p>

</div>
</div>
<a id="a93d81b5193ecfc9600990bd427337adf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93d81b5193ecfc9600990bd427337adf">&#9670;&nbsp;</a></span>logprob_sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Collection::value_type vg::logprob_sum </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the sum of the values in a collection, where the values are log probabilities and the result is the log of the total probability. Items must be convertible to/from doubles for math. </p>

</div>
</div>
<a id="a66d295b4b0f83393ce621b44d88680a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66d295b4b0f83393ce621b44d88680a6">&#9670;&nbsp;</a></span>logprob_to_phred()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::logprob_to_phred </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>logprob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a natural log probability of wrongness directly to a Phred quality score. </p>

</div>
</div>
<a id="aea77a4ed92d78c48a08fce58cf319c4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea77a4ed92d78c48a08fce58cf319c4d">&#9670;&nbsp;</a></span>logprob_to_prob()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::logprob_to_prob </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>logprob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert natural log probability to a probability. </p>

</div>
</div>
<a id="a2d9f0a2379194fb00d706e90d373b378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9f0a2379194fb00d706e90d373b378">&#9670;&nbsp;</a></span>make_pos_t() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> vg::make_pos_t </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a <a class="el" href="structvg_1_1Position.html">Position</a> to a (much smaller) pos_t. </p>

</div>
</div>
<a id="a1b348dcfac955a7030a3721f436e7d5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b348dcfac955a7030a3721f436e7d5d">&#9670;&nbsp;</a></span>make_pos_t() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> vg::make_pos_t </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1position__t.html">position_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afc066dab7543192bf782959ef160f2d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc066dab7543192bf782959ef160f2d4">&#9670;&nbsp;</a></span>make_pos_t() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> vg::make_pos_t </td>
          <td>(</td>
          <td class="paramtype">gcsa::node_type&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a pos_t from a gcsa node. </p>

</div>
</div>
<a id="a1d85d380ba4b936ac8a715a72062866c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d85d380ba4b936ac8a715a72062866c">&#9670;&nbsp;</a></span>make_pos_t() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> vg::make_pos_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afe223f2c7890c76de5e00b43ceb37add">offset_t</a>&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a pos_t from a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a> ID, an orientation flag, and an offset along that strand of the node. </p>

</div>
</div>
<a id="a6247de8deb27aaabf2bc0d6fc755f693"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6247de8deb27aaabf2bc0d6fc755f693">&#9670;&nbsp;</a></span>make_position() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::make_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert a pos_t to a <a class="el" href="structvg_1_1Position.html">Position</a>. </p>

</div>
</div>
<a id="a4cdd9b08b7b6d6e15d00536554f3ca56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cdd9b08b7b6d6e15d00536554f3ca56">&#9670;&nbsp;</a></span>make_position() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::make_position </td>
          <td>(</td>
          <td class="paramtype">gcsa::node_type&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a <a class="el" href="structvg_1_1Position.html">Position</a> from a gcsa node. </p>

</div>
</div>
<a id="ac6af3d55800703f7534ca07a84450580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6af3d55800703f7534ca07a84450580">&#9670;&nbsp;</a></span>make_position() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::make_position </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afe223f2c7890c76de5e00b43ceb37add">offset_t</a>&#160;</td>
          <td class="paramname"><em>off</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a <a class="el" href="structvg_1_1Position.html">Position</a> from a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a> ID, an orientation flag, and an offset along that strand of the node. </p>

</div>
</div>
<a id="a3ff1638bd636bb4b9746545dc261aea1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ff1638bd636bb4b9746545dc261aea1">&#9670;&nbsp;</a></span>make_prefix_suffix_table()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; size_t &gt; vg::make_prefix_suffix_table </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>pattern</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc312d814d6a06a4a5159c7943675bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc312d814d6a06a4a5159c7943675bbe">&#9670;&nbsp;</a></span>make_shuffle_seed() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::make_shuffle_seed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make seeds for Alignments based on their sequences. </p>

</div>
</div>
<a id="aeca2b8e2d5730b1d5b94c1d3861757d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeca2b8e2d5730b1d5b94c1d3861757d7">&#9670;&nbsp;</a></span>make_shuffle_seed() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::make_shuffle_seed </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Define seed generation for shuffling multipath alignments. </p>

</div>
</div>
<a id="a04ebc20fd2965b1932e27958dd0c602c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04ebc20fd2965b1932e27958dd0c602c">&#9670;&nbsp;</a></span>make_shuffle_seed() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T1 , typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::make_shuffle_seed </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; T1, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make seeds for pairs of things we can make seeds for. </p>

</div>
</div>
<a id="a2ec8fc79a1f84c6ef4a02c9d7c7a2850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ec8fc79a1f84c6ef4a02c9d7c7a2850">&#9670;&nbsp;</a></span>make_shuffle_seed() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::make_shuffle_seed </td>
          <td>(</td>
          <td class="paramtype">const T *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make seeds for pointers to things we can make seeds for. </p>

</div>
</div>
<a id="a1c0ae5cc687e77bb7cee28e975a005b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c0ae5cc687e77bb7cee28e975a005b3">&#9670;&nbsp;</a></span>make_support()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> vg::make_support </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>forward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>TBD Create a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele.">Support</a> for the given forward and reverse coverage and quality. </p>

</div>
</div>
<a id="a7eec172f798f421f4d059e5c51d6d9ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eec172f798f421f4d059e5c51d6d9ce">&#9670;&nbsp;</a></span>make_temporary_distance_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">SnarlDistanceIndex::TemporaryDistanceIndex vg::make_temporary_distance_index </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1HandleGraphSnarlFinder.html">HandleGraphSnarlFinder</a> *&#160;</td>
          <td class="paramname"><em>snarl_finder</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a028aa842a68b6993a37a82c7645e0633"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a028aa842a68b6993a37a82c7645e0633">&#9670;&nbsp;</a></span>make_translation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Translation.html">Translation</a> &gt; vg::make_translation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="structvg_1_1Path.html">Path</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>added_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig_node_sizes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Produce a graph <a class="el" href="structvg_1_1Translation.html">Translation</a> object from information about the editing process. </p>

</div>
</div>
<a id="aa74ef603900cf05ce35dbab813d21deb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa74ef603900cf05ce35dbab813d21deb">&#9670;&nbsp;</a></span>make_variant_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::make_variant_id </td>
          <td>(</td>
          <td class="paramtype">const vcflib::Variant &amp;&#160;</td>
          <td class="paramname"><em>variant</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace99283a6b34f0891dc0b49f0cd60eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace99283a6b34f0891dc0b49f0cd60eea">&#9670;&nbsp;</a></span>map_keys_to_set()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename V &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">set&lt;T&gt; vg::map_keys_to_set </td>
          <td>(</td>
          <td class="paramtype">const map&lt; T, V &gt; &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4833086451a8b97af4709aa6c7385177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4833086451a8b97af4709aa6c7385177">&#9670;&nbsp;</a></span>map_over()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class T, class A=std::allocator&lt; T &gt;&gt; class Container, typename Input , typename Output &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&lt;Output&gt; vg::map_over </td>
          <td>(</td>
          <td class="paramtype">const Container&lt; Input &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; Output(const Input &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We have a transforming map function that we can chain. </p>

</div>
</div>
<a id="ad2e7730a993652e18d80ca77dac73713"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad2e7730a993652e18d80ca77dac73713">&#9670;&nbsp;</a></span>mapping_against_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::mapping_against_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bam1_t *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on_reverse_strand</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Translate the CIGAR in the given BAM record into mappings in the given <a class="el" href="structvg_1_1Alignment.html">Alignment</a> against the given path in the given graph. </p>

</div>
</div>
<a id="a27af27aefacd2822744823bee4fe9366"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27af27aefacd2822744823bee4fe9366">&#9670;&nbsp;</a></span>mapping_cigar() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::mapping_cigar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, char &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>cigar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a814bb77cffb64c258d06bbc9a79252d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a814bb77cffb64c258d06bbc9a79252d9">&#9670;&nbsp;</a></span>mapping_cigar() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::mapping_cigar </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, char &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cigar</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afeef6a4c023183ead5725398b14d443c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afeef6a4c023183ead5725398b14d443c">&#9670;&nbsp;</a></span>mapping_ends_in_deletion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::mapping_ends_in_deletion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2aa77c6d4db628d13488c0bd82538ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2aa77c6d4db628d13488c0bd82538ed">&#9670;&nbsp;</a></span>mapping_from_length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::mapping_from_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a151a868062bd12ac34b9aea68dc8d4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a151a868062bd12ac34b9aea68dc8d4f0">&#9670;&nbsp;</a></span>mapping_from_length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::mapping_from_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1path__mapping__t.html">path_mapping_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a78ea8a2cf04759a3cfecbe4bf3e926c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78ea8a2cf04759a3cfecbe4bf3e926c2">&#9670;&nbsp;</a></span>mapping_is_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::mapping_is_match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8ba5042b838f859a078cf014f1a0871"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8ba5042b838f859a078cf014f1a0871">&#9670;&nbsp;</a></span>mapping_is_simple_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::mapping_is_simple_match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d10b5bc5677fdb0ae164f79848bb1bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d10b5bc5677fdb0ae164f79848bb1bb">&#9670;&nbsp;</a></span>mapping_is_total_deletion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::mapping_is_total_deletion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac23702705b681eacdfd1b3bcbc5254b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac23702705b681eacdfd1b3bcbc5254b5">&#9670;&nbsp;</a></span>mapping_sequence() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string vg::mapping_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2b648cd1a51584623d6618565d3ca9c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b648cd1a51584623d6618565d3ca9c6">&#9670;&nbsp;</a></span>mapping_sequence() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string vg::mapping_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>node_seq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa377b3e776e312c717aedec842216f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa377b3e776e312c717aedec842216f48">&#9670;&nbsp;</a></span>mapping_starts_in_deletion()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::mapping_starts_in_deletion </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad993b1f289a57f3413b85840984b459c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad993b1f289a57f3413b85840984b459c">&#9670;&nbsp;</a></span>mapping_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::mapping_string </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ace1a7180fda8bb98abba24fb19183e9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace1a7180fda8bb98abba24fb19183e9d">&#9670;&nbsp;</a></span>mapping_to_gbwt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gbwt::node_type vg::mapping_to_gbwt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert <a class="el" href="structvg_1_1Mapping.html">Mapping</a> to gbwt::node_type. </p>

</div>
</div>
<a id="acdaa29c218d5d55e76fe4ab168f7a14b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdaa29c218d5d55e76fe4ab168f7a14b">&#9670;&nbsp;</a></span>mapping_to_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> vg::mapping_to_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9ef1ccef545dfc30f9123eba61267b4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ef1ccef545dfc30f9123eba61267b4a">&#9670;&nbsp;</a></span>mapping_to_length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::mapping_to_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3f709a91987a7d669b3974fa00aa8ecd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f709a91987a7d669b3974fa00aa8ecd">&#9670;&nbsp;</a></span>mapping_to_length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::mapping_to_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1path__mapping__t.html">path_mapping_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af26a23818c9426d77ef25b07bbaaf605"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af26a23818c9426d77ef25b07bbaaf605">&#9670;&nbsp;</a></span>mappings_equivalent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::mappings_equivalent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a242b97c26d74e9fc05ad16c31b21dcca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a242b97c26d74e9fc05ad16c31b21dcca">&#9670;&nbsp;</a></span>maps_to_node()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::maps_to_node </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3495eb8e73ceeece9957079280edc921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3495eb8e73ceeece9957079280edc921">&#9670;&nbsp;</a></span>match_backward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::match_backward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &amp;&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gbwtgraph::view_type&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mismatch_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abcb300141666ec86856482f6a59cec4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcb300141666ec86856482f6a59cec4c">&#9670;&nbsp;</a></span>match_forward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::match_forward </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &amp;&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gbwtgraph::view_type&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mismatch_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b1defb1ef0b163389ff84745294d1d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1defb1ef0b163389ff84745294d1d0">&#9670;&nbsp;</a></span>match_initial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::match_initial </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &amp;&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gbwtgraph::view_type&#160;</td>
          <td class="paramname"><em>target</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7effc13e3f877e676d65d9164a44b4a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7effc13e3f877e676d65d9164a44b4a6">&#9670;&nbsp;</a></span>matrix_invert()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; double &gt; &gt; vg::matrix_invert </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9a1927488f1b7b82758828d5a53ca845"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a1927488f1b7b82758828d5a53ca845">&#9670;&nbsp;</a></span>matrix_multiply() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; vg::matrix_multiply </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a02d66ca193142fb4825a62b300d60697"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a02d66ca193142fb4825a62b300d60697">&#9670;&nbsp;</a></span>matrix_multiply() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; double &gt; &gt; vg::matrix_multiply </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>B</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82dc203eaecb442a26d8f1a3db773dda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82dc203eaecb442a26d8f1a3db773dda">&#9670;&nbsp;</a></span>max_exponential_cdf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::max_exponential_cdf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>location</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the CDF of a max exponential with the given parameters. </p>

</div>
</div>
<a id="a617472d242ff7aad1126a6b70e70a7a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617472d242ff7aad1126a6b70e70a7a8">&#9670;&nbsp;</a></span>max_exponential_log_likelihood()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::max_exponential_log_likelihood </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rate</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The log likelihood of a max exponential with the given parameters on the given data. </p>

</div>
</div>
<a id="a004ed92d4db665ce8ec4e527f150a7c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a004ed92d4db665ce8ec4e527f150a7c4">&#9670;&nbsp;</a></span>maximum_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::maximum_distance </td>
          <td>(</td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6eef175773ce8532826ba78eee0cece5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eef175773ce8532826ba78eee0cece5">&#9670;&nbsp;</a></span>median()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::median </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1678438e6011469b88ddf3b54023013"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1678438e6011469b88ddf3b54023013">&#9670;&nbsp;</a></span>mem_min_oriented_distances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; int64_t, int64_t &gt; vg::mem_min_oriented_distances </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa65ea58e40ea30264407f9fdbce2a83d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65ea58e40ea30264407f9fdbce2a83d">&#9670;&nbsp;</a></span>mem_node_start_positions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; gcsa::node_type, size_t &gt; &gt; vg::mem_node_start_positions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MaximalExactMatch.html">vg::MaximalExactMatch</a> &amp;&#160;</td>
          <td class="paramname"><em>mem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get the handles that a mem covers </p>

</div>
</div>
<a id="aa412de4741b61d2a8b863f50f31209e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa412de4741b61d2a8b863f50f31209e0">&#9670;&nbsp;</a></span>mems_overlap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::mems_overlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;&#160;</td>
          <td class="paramname"><em>mem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;&#160;</td>
          <td class="paramname"><em>mem2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af5d04132733b3487e3dab20729645850"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5d04132733b3487e3dab20729645850">&#9670;&nbsp;</a></span>mems_overlap_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::mems_overlap_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;&#160;</td>
          <td class="paramname"><em>mem1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;&#160;</td>
          <td class="paramname"><em>mem2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0bec9992b4441128754ac4ed1a330e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0bec9992b4441128754ac4ed1a330e8">&#9670;&nbsp;</a></span>mems_to_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const string vg::mems_to_json </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30a83a9e127a0c7d75118dc14a8985f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30a83a9e127a0c7d75118dc14a8985f6">&#9670;&nbsp;</a></span>merge_adjacent_edits() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> vg::merge_adjacent_edits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge adjacent edits of the same type. </p>

</div>
</div>
<a id="a2c9985bf70965bd36bb54f910ab74e3b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c9985bf70965bd36bb54f910ab74e3b">&#9670;&nbsp;</a></span>merge_adjacent_edits() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::merge_adjacent_edits </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge adjacent edits of the same type. </p>

</div>
</div>
<a id="a9d71527a132d7e6bf364d2108b269e09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d71527a132d7e6bf364d2108b269e09">&#9670;&nbsp;</a></span>merge_alignments() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::merge_alignments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>a1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>a2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>debug</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa2d2a5d955cff1e7a99369055ebe75d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2d2a5d955cff1e7a99369055ebe75d">&#9670;&nbsp;</a></span>merge_alignments() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::merge_alignments </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a20ebf02d59df03f906550e695a1aa00d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20ebf02d59df03f906550e695a1aa00d">&#9670;&nbsp;</a></span>merge_edits_in_place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::merge_edits_in_place </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;&#160;</td>
          <td class="paramname"><em>e</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Glom the second edit into the first, assuming adjacency. </p>

</div>
</div>
<a id="a86fd22ae591c4923588d20b9b5c52e43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86fd22ae591c4923588d20b9b5c52e43">&#9670;&nbsp;</a></span>merge_non_branching_subpaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::merge_non_branching_subpaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>prohibited_merges</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merges non-branching paths in a multipath alignment in place Does not assume topological order among subpaths </p>

</div>
</div>
<a id="aa539af4f481d4e955ede26ee85c320c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa539af4f481d4e955ede26ee85c320c5">&#9670;&nbsp;</a></span>mergeNodeObjects()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* vg::mergeNodeObjects </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7848d492a243a93f37b1ac52a541a96a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7848d492a243a93f37b1ac52a541a96a">&#9670;&nbsp;</a></span>middle_signature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::middle_signature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af64c67658563ff567bc0b103ef1d8af4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af64c67658563ff567bc0b103ef1d8af4">&#9670;&nbsp;</a></span>middle_signature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; string, string &gt; vg::middle_signature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a973bf2647d54324bc63c323a0aa29a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a973bf2647d54324bc63c323a0aa29a35">&#9670;&nbsp;</a></span>min_oriented_distances()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; int64_t, int64_t &gt; vg::min_oriented_distances </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_offsets1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>, vector&lt; pair&lt; size_t, bool &gt; &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_offsets2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find the min distance in the path offsets where the path orientation is the same and different. </p>

</div>
</div>
<a id="ae4b8625853b4a17f731c9fbd5a040fd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae4b8625853b4a17f731c9fbd5a040fd7">&#9670;&nbsp;</a></span>minimizer_reverse_complement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gbwtgraph::Key64::value_type vg::minimizer_reverse_complement </td>
          <td>(</td>
          <td class="paramtype">gbwtgraph::Key64::value_type&#160;</td>
          <td class="paramname"><em>kmer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the reverse complement of a minimizer index kmer. </p>

</div>
</div>
<a id="abcbcd550b51078ae43f2b1d87941e1a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abcbcd550b51078ae43f2b1d87941e1a0">&#9670;&nbsp;</a></span>minimum_distance()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::minimum_distance </td>
          <td>(</td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>unoriented_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc8f8791be2575164e6070e1cef39b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc8f8791be2575164e6070e1cef39b4e">&#9670;&nbsp;</a></span>modular_exponent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::modular_exponent </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>base</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>exponent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>modulus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Computes base^exponent mod modulus in log(exponent) time without requiring more than 64 bits to represent exponentiated number </p>

</div>
</div>
<a id="a074fcebfeb68fc970b5b2a0db3722f01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a074fcebfeb68fc970b5b2a0db3722f01">&#9670;&nbsp;</a></span>multinomial_censored_sampling_prob_ln()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ProbIn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::multinomial_censored_sampling_prob_ln </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; ProbIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>probs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; vector&lt; bool &gt;, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>obs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the log probability for sampling any actual set of category counts that is consistent with the constraints specified by obs, using the per-category probabilities defined in probs.</p>
<p>Obs maps from a vector of per-category flags (called a "class") to a number of items that might be in any of the flagged categories.</p>
<p>For example, if there are two equally likely categories, and one item flagged as potentially from either category, the probability of sampling a set of category counts consistent with that constraint is 1. If instead there are three equally likely categories, and one item flagged as potentially from two of the three but not the third, the probability of sampling a set of category counts consistent with that constraint is 2/3. </p>

</div>
</div>
<a id="a15f09f05f7894863e9cd852c63266078"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f09f05f7894863e9cd852c63266078">&#9670;&nbsp;</a></span>multinomial_choose_ln()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::multinomial_choose_ln </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt;&#160;</td>
          <td class="paramname"><em>k</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the number of ways to select k_1, k_2, ... k_i items into i buckets from a collection of n distinguishable items, ignoring order. All of the items have to go into the buckets, so all k_i must sum to n. To compute choose you have to call this function with a 2-element vector, to represent the chosen and not-chosen buckets. Returns the natural log of the (integer) result.</p>
<p>TODO: Turns out we don't actually need this for the ambiguous multinomial after all. </p>

</div>
</div>
<a id="af4d69cf9a7d7e6272960fcb9f0a0a00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d69cf9a7d7e6272960fcb9f0a0a00c">&#9670;&nbsp;</a></span>multinomial_sampling_prob_ln()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ProbIn &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::multinomial_sampling_prob_ln </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; ProbIn &gt; &amp;&#160;</td>
          <td class="paramname"><em>probs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>obs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the probability for sampling the counts in obs from a set of categories weighted by the probabilities in probs. Works for both double and real_t probabilities. Also works for binomials. </p>

</div>
</div>
<a id="a434e32ac84fd027508a6506e80107331"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a434e32ac84fd027508a6506e80107331">&#9670;&nbsp;</a></span>node_end()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> vg::node_end </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce the end <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a>. </p>

</div>
</div>
<a id="a30f5b0dc3732e48a6d9b8d1c895cd8d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f5b0dc3732e48a6d9b8d1c895cd8d1">&#9670;&nbsp;</a></span>node_start()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> vg::node_start </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Produce the start <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a>. </p>

</div>
</div>
<a id="a3ec2e2ef9679291d966bc348a47c3537"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ec2e2ef9679291d966bc348a47c3537">&#9670;&nbsp;</a></span>non_match_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::non_match_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae838e7d89edc59dd87747238cee49b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae838e7d89edc59dd87747238cee49b49">&#9670;&nbsp;</a></span>non_match_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::non_match_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a453b457823e1ddf916ebf298befb4512"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a453b457823e1ddf916ebf298befb4512">&#9670;&nbsp;</a></span>nonATGCNtoN()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::nonATGCNtoN </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae825181ee40a5f0d5087fc657db9a7db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae825181ee40a5f0d5087fc657db9a7db">&#9670;&nbsp;</a></span>normal_pdf()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">T vg::normal_pdf </td>
          <td>(</td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>m</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T&#160;</td>
          <td class="paramname"><em>s</em> = <code>1.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa0c54720b2b1007ae540dc70b5b8024"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa0c54720b2b1007ae540dc70b5b8024">&#9670;&nbsp;</a></span>normalize_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::normalize_alignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge adjacent edits of the same type and convert all N matches to mismatches. </p>

</div>
</div>
<a id="a1ac45a06bc04f88ba6c2321d7af304c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ac45a06bc04f88ba6c2321d7af304c6">&#9670;&nbsp;</a></span>num_connected_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::num_connected_components </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the number of connected components in the multipath alignment. </p>

</div>
</div>
<a id="ad48a54a3ddd5e6ffd8e3e6296fb9c037"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad48a54a3ddd5e6ffd8e3e6296fb9c037">&#9670;&nbsp;</a></span>offset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afe223f2c7890c76de5e00b43ceb37add">offset_t</a> vg::offset </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the offset along the selected strand of the node from a pos_t. </p>

</div>
</div>
<a id="a22cb5c700c1dee4fec8d3af77057ea2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22cb5c700c1dee4fec8d3af77057ea2a">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Exon.html">Exon</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Exon.html">Exon</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a581944f1e71285f8c4887c2f5ce1467f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a581944f1e71285f8c4887c2f5ce1467f">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a67115fb742d1bf6d7e4e489fda99b78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67115fb742d1bf6d7e4e489fda99b78e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a654eca8448629e42ae87cadd893ee10e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a654eca8448629e42ae87cadd893ee10e">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Two Snarls are unequal if they are not equal. </p>

</div>
</div>
<a id="a24e1e38ea29c615b2c5f5cd8dbaeeb2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24e1e38ea29c615b2c5f5cd8dbaeeb2a">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Two SnarlTraversals are unequal if they are not equal. </p>

</div>
</div>
<a id="a4f594795be32cb04b7baf0ef71ad77b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f594795be32cb04b7baf0ef71ad77b0">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Transcript.html">Transcript</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Transcript.html">Transcript</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abb6063b76b70947010198b46c053b578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb6063b76b70947010198b46c053b578">&#9670;&nbsp;</a></span>operator!=() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator!= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Two Visits are unequal if they are not equal. </p>

</div>
</div>
<a id="a10844a7c14d7ff54051bad20c75d012e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10844a7c14d7ff54051bad20c75d012e">&#9670;&nbsp;</a></span>operator*() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> vg::operator* </td>
          <td>(</td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>support</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele.">Support</a> by a factor, the other way </p>

</div>
</div>
<a id="a84dfc966c7511b05c234d215e3b6aec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84dfc966c7511b05c234d215e3b6aec7">&#9670;&nbsp;</a></span>operator*() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> vg::operator* </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele.">Support</a> by a factor. </p>

</div>
</div>
<a id="abe7831ba6fe294e8be36fa0359a63848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe7831ba6fe294e8be36fa0359a63848">&#9670;&nbsp;</a></span>operator*=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a>&amp; vg::operator*= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Scale a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele.">Support</a> by a factor, in place. </p>

</div>
</div>
<a id="a27dd5c8f7c6d984a396665cbab5eba01"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27dd5c8f7c6d984a396665cbab5eba01">&#9670;&nbsp;</a></span>operator+() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> vg::operator+ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>one</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add two <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele.">Support</a> values together, accounting for strand. </p>

</div>
</div>
<a id="a64380ba1816d3fd97847a6dc6b2665d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64380ba1816d3fd97847a6dc6b2665d8">&#9670;&nbsp;</a></span>operator+() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Item &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt;Item&gt;::const_iterator vg::operator+ </td>
          <td>(</td>
          <td class="paramtype">typename <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; Item &gt;::const_iterator::difference_type&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const typename <a class="el" href="structvg_1_1VectorView.html">VectorView</a>&lt; Item &gt;::const_iterator &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow <a class="el" href="structvg_1_1VectorView.html">VectorView</a> iterators to be added to numbers. </p>

</div>
</div>
<a id="a4f550213560bfa3c3ad8446478be24d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f550213560bfa3c3ad8446478be24d8">&#9670;&nbsp;</a></span>operator+=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> &amp; vg::operator+= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>one</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add in a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele.">Support</a> to another. </p>

</div>
</div>
<a id="a5a9eefddbec41755309a378fb150071c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a9eefddbec41755309a378fb150071c">&#9670;&nbsp;</a></span>operator/()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> vg::operator/ </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele.">Support</a> by a factor. </p>

</div>
</div>
<a id="a1807752a0b6b83fd5952d36cc64b758d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1807752a0b6b83fd5952d36cc64b758d">&#9670;&nbsp;</a></span>operator/=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scalar &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a>&amp; vg::operator/= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>support</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Scalar &amp;&#160;</td>
          <td class="paramname"><em>scale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Divide a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele.">Support</a> by a factor, in place. </p>

</div>
</div>
<a id="ad29d63c9b09132ab0457b3d28ea704ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad29d63c9b09132ab0457b3d28ea704ff">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Exon.html">Exon</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Exon.html">Exon</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac476fcc21a47f34d00b4a449b28c686b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac476fcc21a47f34d00b4a449b28c686b">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fd908e60f72bd98dcba364a16ab7190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fd908e60f72bd98dcba364a16ab7190">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes.">Snarl</a> is less than another <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes.">Snarl</a> if its type is smaller, or its start <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> is smaller, or its end <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> is smaller, or its parent is smaller. </p>

</div>
</div>
<a id="aea87c61d2cc1d5acf1af1d2d351bdb75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea87c61d2cc1d5acf1af1d2d351bdb75">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A SnalTraversal is less than another if it is a traversal of a smaller <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes.">Snarl</a>, or if its list of Visits has a smaller <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> first, or if its list of Visits is shorter. </p>

</div>
</div>
<a id="ab554a977204c1f756bd0e2738a797447"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab554a977204c1f756bd0e2738a797447">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele.">Support</a> less-than, based on total coverage. </p>

</div>
</div>
<a id="ad3728100975bea667f2f60fdc1df2dd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3728100975bea667f2f60fdc1df2dd1">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Transcript.html">Transcript</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Transcript.html">Transcript</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d2e2066b3b4534b62cde6e4423efd81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2e2066b3b4534b62cde6e4423efd81">&#9670;&nbsp;</a></span>operator&lt;() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator&lt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> is less than another <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> if it represents a traversal of a smaller node, or it represents a traversal of a smaller snarl, or it represents a traversal of the same node or snarl forward instead of backward. </p>

</div>
</div>
<a id="a35d8d71a9d6d51760cc7354910d029e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35d8d71a9d6d51760cc7354910d029e9">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[1/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Counts.html">Counts</a> &amp;&#160;</td>
          <td class="paramname"><em>counts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7cc9c4d4d792e1e7f38c2c6009207706"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cc9c4d4d792e1e7f38c2c6009207706">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[2/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1BenchmarkResult.html">BenchmarkResult</a> &amp;&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Benchmark results can be output to streams </p>

</div>
</div>
<a id="ac5fc02ee1a5713060cd5f4b33e2eaaab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5fc02ee1a5713060cd5f4b33e2eaaab">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[3/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1BitString.html">BitString</a> &amp;&#160;</td>
          <td class="paramname"><em>bs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> -&gt;  ostream &amp;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow BitStrings to be printed for debugging. </p>

</div>
</div>
<a id="a0e459d4a7dda13edf5b79ea8996cfd82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e459d4a7dda13edf5b79ea8996cfd82">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[4/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1kmer__t.html">kmer_t</a> &amp;&#160;</td>
          <td class="paramname"><em>kmer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Print a <a class="el" href="structvg_1_1kmer__t.html">kmer_t</a> to a stream. </p>

</div>
</div>
<a id="af0a4b11db620d43a7e20886d5563e5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a4b11db620d43a7e20886d5563e5b8">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[5/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;&#160;</td>
          <td class="paramname"><em>mem</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9b4bea48392e7bb9e745b3b04e5bf223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b4bea48392e7bb9e745b3b04e5bf223">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[6/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &amp;&#160;</td>
          <td class="paramname"><em>nodeside</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> to a stream. </p>

</div>
</div>
<a id="ad1bdeb550c6f5fa632ad61454321e001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1bdeb550c6f5fa632ad61454321e001">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[7/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ostream&amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>nodetraversal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print the given <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>. </p>

</div>
</div>
<a id="ae0744fdee12e0f4136de643a91c15f77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0744fdee12e0f4136de643a91c15f77">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[8/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes.">Snarl</a> can be printed. </p>

</div>
</div>
<a id="ab38d6991537581f9ce3f4c549f966a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab38d6991537581f9ce3f4c549f966a33">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[9/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>visit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> can be printed. </p>

</div>
</div>
<a id="a81357f8477c9ed2c3839489e0ada1ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81357f8477c9ed2c3839489e0ada1ced">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[10/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1mapping__t.html">mapping_t</a>&#160;</td>
          <td class="paramname"><em>mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow a <a class="el" href="classvg_1_1mapping__t.html">mapping_t</a> to be printed, for debugging purposes. </p>

</div>
</div>
<a id="a141fbf9c40f389909c5c46132ab6c615"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a141fbf9c40f389909c5c46132ab6c615">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[11/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>support</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Allow printing a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele.">Support</a>. </p>

</div>
</div>
<a id="a3caa19999a88016c7aedf3fefb8ca69c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3caa19999a88016c7aedf3fefb8ca69c">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[12/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Funnel.html#a23e7fd0c49df53dd8a9e25934fe06c85">Funnel::State</a> &amp;&#160;</td>
          <td class="paramname"><em>state</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a19349c6c73bac7da9651ee91c4272156"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19349c6c73bac7da9651ee91c4272156">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[13/15]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Print a pos_t to a stream. </p>

</div>
</div>
<a id="a1fbb5dfd532a055d9e8251d2dcab3e58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fbb5dfd532a055d9e8251d2dcab3e58">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[14/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1WFAAlignment.html#a1ce899c26978ebac4bc7a31623809eeb">WFAAlignment::Edit</a> &amp;&#160;</td>
          <td class="paramname"><em>edit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Allow printing an <a class="el" href="structvg_1_1Edit.html">Edit</a>. </p>

</div>
</div>
<a id="a1e7a5fc9017560cc1b505641cc4ef6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1e7a5fc9017560cc1b505641cc4ef6d0">&#9670;&nbsp;</a></span>operator&lt;&lt;() <span class="overload">[15/15]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; vg::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1PathBranch.html">PathBranch</a>&#160;</td>
          <td class="paramname"><em>branch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6ace94ff076945069d22aa548b6e0bf6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6ace94ff076945069d22aa548b6e0bf6">&#9670;&nbsp;</a></span>operator==() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Exon.html">Exon</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Exon.html">Exon</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8e2505b73c51b9659c94950d2f283eec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2505b73c51b9659c94950d2f283eec">&#9670;&nbsp;</a></span>operator==() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af94d73312bfd787493e87d207398d73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af94d73312bfd787493e87d207398d73a">&#9670;&nbsp;</a></span>operator==() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;&#160;</td>
          <td class="paramname"><em>m1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;&#160;</td>
          <td class="paramname"><em>m2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a92e719e28c0d3f7d6dfa354824220211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e719e28c0d3f7d6dfa354824220211">&#9670;&nbsp;</a></span>operator==() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a387ff1f8cefcf4feb705b0f1225d16c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a387ff1f8cefcf4feb705b0f1225d16c7">&#9670;&nbsp;</a></span>operator==() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Two Snarls are equal if their types are equal and their bounding Visits are equal and their parents are equal. </p>

</div>
</div>
<a id="a845213e6efb7204868c05afcae9c926f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a845213e6efb7204868c05afcae9c926f">&#9670;&nbsp;</a></span>operator==() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Two SnarlTraversals are equal if their snarls are equal and they have the same number of visits and all their visits are equal. </p>

</div>
</div>
<a id="ace8e1de0bfe604d8da5537fd86e251ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace8e1de0bfe604d8da5537fd86e251ee">&#9670;&nbsp;</a></span>operator==() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Transcript.html">Transcript</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Transcript.html">Transcript</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a87b890a4bc73725bbea08984d7510df4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b890a4bc73725bbea08984d7510df4">&#9670;&nbsp;</a></span>operator==() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Two Visits are equal if they represent the same traversal of the same <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a> or <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes.">Snarl</a>. </p>

</div>
</div>
<a id="a955d56fb4c95213de77c1fcce44c77b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a955d56fb4c95213de77c1fcce44c77b8">&#9670;&nbsp;</a></span>operator&gt;()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::operator&gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele.">Support</a> greater-than, based on total coverage. </p>

</div>
</div>
<a id="a4e3c0f0d0f60a6a6ef1c301b63e9a21e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4e3c0f0d0f60a6a6ef1c301b63e9a21e">&#9670;&nbsp;</a></span>optimal_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::optimal_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subpath_global</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the highest scoring alignment contained in the <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> in an <a class="el" href="structvg_1_1Alignment.html">Alignment</a></p>
<p>Note: Assumes that each subpath's <a class="el" href="structvg_1_1Path.html">Path</a> object uses one <a class="el" href="structvg_1_1Mapping.html">Mapping</a> per node and that start subpaths have been identified</p>
<p>Args: multipath_aln multipath alignment to find optimal path through aln_out empty alignment to store optimal alignment in (data will be overwritten if not empty) subpath_global if true, only allows alignments that source subpath to sink subpath in the multipath DAG, else allows any start and end subpath </p>

</div>
</div>
<a id="a3caee9d564f3a803a6ad69642269c5b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3caee9d564f3a803a6ad69642269c5b6">&#9670;&nbsp;</a></span>optimal_alignment_internal()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::optimal_alignment_internal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> *&#160;</td>
          <td class="paramname"><em>aln_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subpath_global</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad3548ef9766130a155ba65420c0e7c0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3548ef9766130a155ba65420c0e7c0e">&#9670;&nbsp;</a></span>optimal_alignment_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::optimal_alignment_score </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subpath_global</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the score of the highest scoring alignment contained in the <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a></p>
<p>Note: Assumes that each subpath's <a class="el" href="structvg_1_1Path.html">Path</a> object uses one <a class="el" href="structvg_1_1Mapping.html">Mapping</a> per node and that start subpaths have been identified</p>
<p>Args: multipath_aln multipath alignment to find optimal score in subpath_global if true, only allows alignments that source subpath to sink subpath in the multipath DAG, else allows any start and end subpath </p>

</div>
</div>
<a id="ada4d6b6771c5d7e5b2367b18ca8f76f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada4d6b6771c5d7e5b2367b18ca8f76f3">&#9670;&nbsp;</a></span>optimal_alignments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::optimal_alignments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the top k highest-scoring alignments contained in the <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a>. Note that some or all of these may be duplicate Alignments, which were spelled out by tracebacks through different sequences of subpaths that shared alignment material.</p>
<p>If the best alignment is no alignment (i.e. the read is unmapped), returns an empty vector.</p>
<p>Note: Assumes that each subpath's <a class="el" href="structvg_1_1Path.html">Path</a> object uses one <a class="el" href="structvg_1_1Mapping.html">Mapping</a> per node and that start subpaths have been identified</p>
<p>Args: multipath_aln multipath alignment to find optimal paths through count maximum number of top alignments to return </p>

</div>
</div>
<a id="af711577f7d293ffc1c8002c868081bb1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af711577f7d293ffc1c8002c868081bb1">&#9670;&nbsp;</a></span>optimal_alignments_with_disjoint_subpaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::optimal_alignments_with_disjoint_subpaths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds k or fewer top-scoring alignments using only distinct subpaths. Asymmetrical: the optimal alignment for each end subpath is found, greedily, subject to the constraint, but the other subpaths are first-come first-serve. Also, distinct subpaths may not guarantee distinct actual alignments, so alignments may need deduplication.</p>
<p>If the best alignment is no alignment (i.e. the read is unmapped), returns an empty vector.</p>
<p>Note: Assumes that each subpath's <a class="el" href="structvg_1_1Path.html">Path</a> object uses one <a class="el" href="structvg_1_1Mapping.html">Mapping</a> per node and that start subpaths have been identified</p>
<p>Args: multipath_aln multipath alignment to find optimal paths through count maximum number of top alignments to return </p>

</div>
</div>
<a id="a134ccba76916d6d94e59581932f1b595"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134ccba76916d6d94e59581932f1b595">&#9670;&nbsp;</a></span>output_graph_with_embedded_paths() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::output_graph_with_embedded_paths </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>subgraph_ostream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a31b8b476fb46de6667b26514b7b24fd2">thread_t</a>, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>haplotype_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>json</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae62ff63e415416fd298c6f59c8f2da47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae62ff63e415416fd298c6f59c8f2da47">&#9670;&nbsp;</a></span>output_graph_with_embedded_paths() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> vg::output_graph_with_embedded_paths </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a31b8b476fb46de6667b26514b7b24fd2">thread_t</a>, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>haplotype_list</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae2d79bdac899f70214959ef92dbbad2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2d79bdac899f70214959ef92dbbad2f">&#9670;&nbsp;</a></span>output_haplotype_counts()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::output_haplotype_counts </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>annotation_ostream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="namespacevg.html#a31b8b476fb46de6667b26514b7b24fd2">thread_t</a>, int &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>haplotype_list</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaac70d8b120ca61591561cba307dcc1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac70d8b120ca61591561cba307dcc1b">&#9670;&nbsp;</a></span>overlap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::overlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae996017b379b1178d5e588b96a7c7f3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae996017b379b1178d5e588b96a7c7f3f">&#9670;&nbsp;</a></span>overlay_node_translations() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; vg::overlay_node_translations </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>over</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>under</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose the translations from two graph operations, neither of which involved oriented transformations. </p>

</div>
</div>
<a id="a7816225a17a671ff849a79f064770ebb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7816225a17a671ff849a79f064770ebb">&#9670;&nbsp;</a></span>overlay_node_translations() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt; &gt; vg::overlay_node_translations </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>over</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>under</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose the translations from two graph operations, the first of which involved oriented transformations. </p>

</div>
</div>
<a id="af224cfdc27efec675771ba4cc5143a3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af224cfdc27efec675771ba4cc5143a3f">&#9670;&nbsp;</a></span>overlay_node_translations() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt; &gt; vg::overlay_node_translations </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>over</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>under</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose the translations from two graph operations, the second of which involved oriented transformations. </p>

</div>
</div>
<a id="a86d5f690fe272c74949e080aca561467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86d5f690fe272c74949e080aca561467">&#9670;&nbsp;</a></span>overlay_node_translations() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt; &gt; vg::overlay_node_translations </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>over</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>under</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compose the translations from two graph operations, both of which involved oriented transformations. </p>

</div>
</div>
<a id="a8c5c364797f623025b67b9aff0657112"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c5c364797f623025b67b9aff0657112">&#9670;&nbsp;</a></span>parse() <span class="overload">[1/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Result vg::parse </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse a command-line argument C string. Exits with an error if the string does not contain exactly an item of the appropriate type. </p>

</div>
</div>
<a id="a8873caafc22d22b52e0f6f3f164f6dc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8873caafc22d22b52e0f6f3f164f6dc8">&#9670;&nbsp;</a></span>parse() <span class="overload">[2/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Result vg::parse </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse a command-line argument string. Exits with an error if the string does not contain exactly an item of the appropriate type. </p>

</div>
</div>
<a id="a1dd328fd8abb43338a3ae9e0a3b0be1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd328fd8abb43338a3ae9e0a3b0be1f">&#9670;&nbsp;</a></span>parse() <span class="overload">[3/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::parse </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4a3393960dd54c941e9d7c317923c2e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4a3393960dd54c941e9d7c317923c2e">&#9670;&nbsp;</a></span>parse() <span class="overload">[4/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::parse </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a627f5ad6fe6f1e6b4cc23ac97dfca4b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627f5ad6fe6f1e6b4cc23ac97dfca4b8">&#9670;&nbsp;</a></span>parse() <span class="overload">[5/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::parse </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Result &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse the appropriate type from the string to the destination value. Return true if parsing is successful and false (or throw something) otherwise. </p>

</div>
</div>
<a id="aa1de4a1752e875116c767ec49a8e2961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1de4a1752e875116c767ec49a8e2961">&#9670;&nbsp;</a></span>parse() <span class="overload">[6/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::parse </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::regex &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1384531a1c8d8387bdd04961590bdf93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1384531a1c8d8387bdd04961590bdf93">&#9670;&nbsp;</a></span>parse() <span class="overload">[7/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::parse </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">typename enable_if&lt; <a class="el" href="structvg_1_1is__instantiation__of.html">is_instantiation_of</a>&lt; Result, <a class="el" href="structvg_1_1Range.html">Range</a> &gt;::value, Result &gt;::type &amp;&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Parse a range as start[:end[:step]]. </p>

</div>
</div>
<a id="a2cd6368e7395f1d90c4e3be1a7293d0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd6368e7395f1d90c4e3be1a7293d0a">&#9670;&nbsp;</a></span>parse() <span class="overload">[8/8]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Result &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::parse </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>arg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8fd1e3436d98304996aaecece048cb45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fd1e3436d98304996aaecece048cb45">&#9670;&nbsp;</a></span>parse_bed_regions() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::parse_bed_regions </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>bed_path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Region.html">Region</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; string &gt; *&#160;</td>
          <td class="paramname"><em>out_names</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a736f4c7b5d03a7efe78315b4c5490f15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a736f4c7b5d03a7efe78315b4c5490f15">&#9670;&nbsp;</a></span>parse_bed_regions() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::parse_bed_regions </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>bedstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; *&#160;</td>
          <td class="paramname"><em>out_alignments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Parse regions from the given BED file into Alignments in a vector. Reads the optional name, is_reverse, and score fields if present, and populates the relevant <a class="el" href="structvg_1_1Alignment.html">Alignment</a> fields. Skips and warns about malformed or illegal BED records. </p>

</div>
</div>
<a id="a55cc20d96f38b54c590af4f3f3ac2498"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55cc20d96f38b54c590af4f3f3ac2498">&#9670;&nbsp;</a></span>parse_gff_regions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::parse_gff_regions </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>gffstream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; *&#160;</td>
          <td class="paramname"><em>out_alignments</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a253257615743a1cfb948b749be7700e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a253257615743a1cfb948b749be7700e2">&#9670;&nbsp;</a></span>parse_region() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::parse_region </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>target</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af0a3beb8908adf7a6e4d641243937830"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0a3beb8908adf7a6e4d641243937830">&#9670;&nbsp;</a></span>parse_region() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::parse_region </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>region</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Region.html">Region</a> &amp;&#160;</td>
          <td class="paramname"><em>out_region</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a637c855dffc0296c6575ae8a4cac6b43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637c855dffc0296c6575ae8a4cac6b43">&#9670;&nbsp;</a></span>parse_rg_sample_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::parse_rg_sample_map </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>hts_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, string &gt; &amp;&#160;</td>
          <td class="paramname"><em>rg_sample</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Populate a mapping from read group to sample name, given the text BAM header. </p>

</div>
</div>
<a id="abc66619671bdc564023a9b3259558785"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc66619671bdc564023a9b3259558785">&#9670;&nbsp;</a></span>parse_tid_path_handle_map()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::parse_tid_path_handle_map </td>
          <td>(</td>
          <td class="paramtype">const bam_hdr_t *&#160;</td>
          <td class="paramname"><em>hts_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; int, <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>tid_path_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Populate a mapping from target ID number to path handle in the given graph, given a parsed BAM header. The graph may be null. Missing target paths in the graph produce no warning or error and no map entry. </p>

</div>
</div>
<a id="a8bcecf9fe02b7f50dd5e72e40dcd98e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bcecf9fe02b7f50dd5e72e40dcd98e1">&#9670;&nbsp;</a></span>parseGenotypes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; vg::parseGenotypes </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>vcf_line</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_samples</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a802baeeacfe4ee75781afabac562588b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a802baeeacfe4ee75781afabac562588b">&#9670;&nbsp;</a></span>partition_gbwt_sequences()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;std::vector&lt;gbwt::size_type&gt; &gt; vg::partition_gbwt_sequences </td>
          <td>(</td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>gbwt_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_to_job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>num_jobs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af505a96db454fbd06e026f11cb6fbfba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af505a96db454fbd06e026f11cb6fbfba">&#9670;&nbsp;</a></span>path_end_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::path_end_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1524b7b1b7e67c048c0c5e88b204de08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1524b7b1b7e67c048c0c5e88b204de08">&#9670;&nbsp;</a></span>path_from_length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::path_from_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae87f325eb11aaf966e6d77d99be40c54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae87f325eb11aaf966e6d77d99be40c54">&#9670;&nbsp;</a></span>path_from_length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::path_from_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3aef5ee16ad883f8defeaa0f52fc342c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aef5ee16ad883f8defeaa0f52fc342c">&#9670;&nbsp;</a></span>path_from_node_traversals()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::path_from_node_traversals </td>
          <td>(</td>
          <td class="paramtype">const list&lt; <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>traversals</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a864fe6e3e163b18e84db0783f9a2e17d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a864fe6e3e163b18e84db0783f9a2e17d">&#9670;&nbsp;</a></span>path_from_path_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::path_from_path_handle </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a>&#160;</td>
          <td class="paramname"><em>path_handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab0f225fb74f28ea09c6c8917ec14db73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f225fb74f28ea09c6c8917ec14db73">&#9670;&nbsp;</a></span>path_from_thread_t()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::path_from_thread_t </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a31b8b476fb46de6667b26514b7b24fd2">thread_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43c4a438edc31c7b0d2aa0731c522e8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c4a438edc31c7b0d2aa0731c522e8a">&#9670;&nbsp;</a></span>path_is_simple_match()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::path_is_simple_match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6bdd8e00dd9f63a0d9049ffe3461d47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6bdd8e00dd9f63a0d9049ffe3461d47">&#9670;&nbsp;</a></span>path_node() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">vg::id_t</a> vg::path_node </td>
          <td>(</td>
          <td class="paramtype">const gbwt::vector_type &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3bd8aa63fec8b9f6c3ed5808689975e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bd8aa63fec8b9f6c3ed5808689975e6">&#9670;&nbsp;</a></span>path_node() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">vg::id_t</a> vg::path_node </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">vg::id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72aa312e964fab8a03b93ec897f355ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72aa312e964fab8a03b93ec897f355ec">&#9670;&nbsp;</a></span>path_predecessors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gbwt::vector_type vg::path_predecessors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find all predecessor nodes of the path, ignoring self-loops. If the path does not exist, it is treated as empty. </p>

</div>
</div>
<a id="aa0439b7fcf30da565152d9800ff4473d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0439b7fcf30da565152d9800ff4473d">&#9670;&nbsp;</a></span>path_reverse() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::path_reverse </td>
          <td>(</td>
          <td class="paramtype">const gbwt::vector_type &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae8fcec2fbe4151075a0b33bc6a0dd145"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8fcec2fbe4151075a0b33bc6a0dd145">&#9670;&nbsp;</a></span>path_reverse() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::path_reverse </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">vg::id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>i</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aad7dc3b95a62cfd99b5fa6377c1a9545"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad7dc3b95a62cfd99b5fa6377c1a9545">&#9670;&nbsp;</a></span>path_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::path_sequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0c911ba34849a4afd407812fe6373579"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c911ba34849a4afd407812fe6373579">&#9670;&nbsp;</a></span>path_size() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::path_size </td>
          <td>(</td>
          <td class="paramtype">const gbwt::vector_type &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aae876005c9e34df70bdc9e2e97776121"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae876005c9e34df70bdc9e2e97776121">&#9670;&nbsp;</a></span>path_size() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::path_size </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">vg::id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c3b1708b878655d0f6a50a2ba589bf9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c3b1708b878655d0f6a50a2ba589bf9">&#9670;&nbsp;</a></span>path_start_position()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::path_start_position </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a529e3aef69e8c01934184726b7937c37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a529e3aef69e8c01934184726b7937c37">&#9670;&nbsp;</a></span>path_to_gbwt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gbwt::vector_type vg::path_to_gbwt </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert <a class="el" href="structvg_1_1Path.html">Path</a> to a GBWT path. </p>

</div>
</div>
<a id="a48108a0abc0fdfc187437d174f88e590"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a48108a0abc0fdfc187437d174f88e590">&#9670;&nbsp;</a></span>path_to_length() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::path_to_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a16b3cfa2fc1c70ce96f7ebc695c8766d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16b3cfa2fc1c70ce96f7ebc695c8766d">&#9670;&nbsp;</a></span>path_to_length() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::path_to_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbe0993e79f4ef7bb4b37456b0b08402"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbe0993e79f4ef7bb4b37456b0b08402">&#9670;&nbsp;</a></span>path_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::path_to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Path.html">Path</a>&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b5ffc03255d72f1901a7b1ce34c058a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b5ffc03255d72f1901a7b1ce34c058a">&#9670;&nbsp;</a></span>paths_from_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classvg_1_1Paths.html">Paths</a> vg::paths_from_graph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2ba15a613567689d941f30a5a17c6ead"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba15a613567689d941f30a5a17c6ead">&#9670;&nbsp;</a></span>percent_url_encode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::percent_url_encode </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Escape "%" to "%25". </p>

</div>
</div>
<a id="afea3e6d4a8ac9b486d1a2b9b89eadd2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afea3e6d4a8ac9b486d1a2b9b89eadd2f">&#9670;&nbsp;</a></span>Phi()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::Phi </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The standard normal cumulative distribution function. </p>

</div>
</div>
<a id="a4ae7976a3a19fe08c4b2bce4b3f3c00f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ae7976a3a19fe08c4b2bce4b3f3c00f">&#9670;&nbsp;</a></span>Phi_inv()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::Phi_inv </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Inverse CDF of a standard normal distribution. Must have 0 &lt; quantile &lt; 1. </p>

</div>
</div>
<a id="a211ba38329cdc76a7ad0b64bbb227bfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a211ba38329cdc76a7ad0b64bbb227bfd">&#9670;&nbsp;</a></span>phred_add()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::phred_add </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>phred1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>phred2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Add two probabilities (expressed as phred scores) together and return the result as a phred score. </p>

</div>
</div>
<a id="a9a6ab3a0f45f6ab7b38320db7cc14583"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a6ab3a0f45f6ab7b38320db7cc14583">&#9670;&nbsp;</a></span>phred_for_at_least_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::phred_for_at_least_one </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assume that we have n independent random events that occur with probability p each (p is interpreted as a real number between 0 at 0 and 1 at its maximum value). Return an approximate probability for at least one event occurring as a phred score.</p>
<p>n must be &lt;= MAX_AT_LEAST_ONE_EVENTS. </p>
<p>Assume that we have n &lt;= MAX_AT_LEAST_ONE_EVENTS independent events with probability p each. Let x be the AT_LEAST_ONE_PRECISION most significant bits of p. Then</p>
<p>phred_at_least_one[(n &lt;&lt; AT_LEAST_ONE_PRECISION) + x]</p>
<p>is an approximate phred score of at least one event occurring.</p>
<p>We exploit the magical thread-safety of static local initialization to fill this in exactly once when needed.</p>

</div>
</div>
<a id="a04edc3daae77e9d3813a97da0f473def"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04edc3daae77e9d3813a97da0f473def">&#9670;&nbsp;</a></span>phred_geometric_mean()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::phred_geometric_mean </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>phred1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>phred2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Take the geometric mean of two phred-encoded probabilities. </p>

</div>
</div>
<a id="ad78072e330ae86c9ef80aeeb84f89e8f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78072e330ae86c9ef80aeeb84f89e8f">&#9670;&nbsp;</a></span>phred_sum() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Collection::value_type vg::phred_sum </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the sum of the values in a collection, where the values are Phred scores and the result is the Phred score of the total probability. Items must be convertible to/from doubles for math. </p>

</div>
</div>
<a id="aaeddefa307b95defd68c8a2022db732c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaeddefa307b95defd68c8a2022db732c">&#9670;&nbsp;</a></span>phred_sum() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::iterator_traits&lt;Iterator&gt;::value_type vg::phred_sum </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>begin_it</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>end_it</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the sum of the values in a collection, represented by an iterator range, where the values are Phred scores and the result is the Phred score of the total probability. Items must be convertible to/from doubles for math. </p>

</div>
</div>
<a id="a35b531c82b765cd54702665668a98448"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35b531c82b765cd54702665668a98448">&#9670;&nbsp;</a></span>phred_to_logprob()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::phred_to_logprob </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>phred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a Phred quality score directly to a natural log probability of wrongness. </p>

</div>
</div>
<a id="afba77c5a550d5dd72f8cf7438f600676"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afba77c5a550d5dd72f8cf7438f600676">&#9670;&nbsp;</a></span>phred_to_prob() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::phred_to_prob </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>phred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert floating point Phred quality score to probability of wrongness. </p>

</div>
</div>
<a id="ab713ebc6e2988cc2c959be14bfa01200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab713ebc6e2988cc2c959be14bfa01200">&#9670;&nbsp;</a></span>phred_to_prob() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::phred_to_prob </td>
          <td>(</td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>phred</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert 8-bit Phred quality score to probability of wrongness, using a lookup table. </p>

</div>
</div>
<a id="ac7f5da8e25414026729f0c4d09243f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f5da8e25414026729f0c4d09243f6d">&#9670;&nbsp;</a></span>pmax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;T&gt; vg::pmax </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6a210206858f806b345f8eb5c2c292a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a210206858f806b345f8eb5c2c292a">&#9670;&nbsp;</a></span>pointerfy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;template&lt; class T, class A=std::allocator&lt; T &gt;&gt; class Container, typename Item &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Container&lt;const Item*&gt; vg::pointerfy </td>
          <td>(</td>
          <td class="paramtype">const Container&lt; Item &gt; &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We have a wrapper of that to turn a container reference into a container of pointers. </p>

</div>
</div>
<a id="a9238b15cc78a87f27c335fc1e3627a62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9238b15cc78a87f27c335fc1e3627a62">&#9670;&nbsp;</a></span>poisson_prob_ln()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::poisson_prob_ln </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>observed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td>
          <td class="paramname"><em>expected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Compute the log probability of a Poisson-distributed process: observed events in an interval where expected events happen on average. </p>

</div>
</div>
<a id="a191bf7b238ea717afbf8118df0afa999"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a191bf7b238ea717afbf8118df0afa999">&#9670;&nbsp;</a></span>populate_path_from_traceback()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename TracebackIterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::populate_path_from_traceback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathProblem.html">MultipathProblem</a> &amp;&#160;</td>
          <td class="paramname"><em>problem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TracebackIterator&#160;</td>
          <td class="paramname"><em>traceback_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">TracebackIterator&#160;</td>
          <td class="paramname"><em>traceback_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Path.html">Path</a> *&#160;</td>
          <td class="paramname"><em>output</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We define this helper to turn tracebacks through a DP problem into <a class="el" href="classvg_1_1Paths.html">Paths</a> that we can put in an <a class="el" href="structvg_1_1Alignment.html">Alignment</a>. We use iterators to the start and past-the-end of the traceback (in some kind of list of int64_t subpath indexes) to define it. </p>

</div>
</div>
<a id="a909f1da1c571aa4c8a82b2e48ac915b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a909f1da1c571aa4c8a82b2e48ac915b2">&#9670;&nbsp;</a></span>populate_snarl_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::populate_snarl_index </td>
          <td>(</td>
          <td class="paramtype">SnarlDistanceIndex::TemporaryDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>temp_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pair&lt; SnarlDistanceIndex::temp_record_t, size_t &gt;&#160;</td>
          <td class="paramname"><em>snarl_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Record the distance</p>
<p>Add the next node to the priority queue</p>
<p>Check the minimum length of the snarl passing through this node</p>

</div>
</div>
<a id="ae1296fd4e352a120122d4be0a0007819"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1296fd4e352a120122d4be0a0007819">&#9670;&nbsp;</a></span>pos_to_gbwt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gbwt::node_type vg::pos_to_gbwt </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extract gbwt::node_type from pos_t. </p>

</div>
</div>
<a id="a9a33db744c41ff651da5dacda9578712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9a33db744c41ff651da5dacda9578712">&#9670;&nbsp;</a></span>position_at()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> vg::position_at </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph_ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>path_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>path_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>We have a helper function to convert path positions and orientations to pos_t values.</p>
<p>We have a utility function for turning positions along paths, with orientations, into pos_ts. Remember that pos_t counts offset from the start of the reoriented node, while here we count offset from the beginning of the forward version of the path. </p>

</div>
</div>
<a id="a3a7a8c98d80a9daacbc72386bc6ad00c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7a8c98d80a9daacbc72386bc6ad00c">&#9670;&nbsp;</a></span>pow_ln()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a> vg::pow_ln </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a7392de2ef03532b2ec3461ebb178c75a">real_t</a>&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Raise a log probability to a power </p>

</div>
</div>
<a id="a65ac31e5878660a97207b6ade1418c81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ac31e5878660a97207b6ade1418c81">&#9670;&nbsp;</a></span>preflight_check()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::preflight_check </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run a preflight check to make sure that the system is usable for this build of vg. Aborts with a helpful message if this is not the case. We make sure to build it for a lowest-common-denominator architecture. </p>

</div>
</div>
<a id="a348af3d255543b4880fc1240e8ef442f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a348af3d255543b4880fc1240e8ef442f">&#9670;&nbsp;</a></span>present_kmers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::present_kmers </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; <a class="el" href="classvg_1_1HaplotypePartitioner.html#a2780337120cfec8463356829af22aa97">HaplotypePartitioner::kmer_type</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sequences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::pair&lt; <a class="el" href="classvg_1_1HaplotypePartitioner.html#a2780337120cfec8463356829af22aa97">HaplotypePartitioner::kmer_type</a>, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>all_kmers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">sdsl::bit_vector &amp;&#160;</td>
          <td class="paramname"><em>kmers_present</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8bf8f408b11966feb9695d4bb723dfac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8bf8f408b11966feb9695d4bb723dfac">&#9670;&nbsp;</a></span>printId()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Decoder &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::printId </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">vg::id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae46397f9d9aa9ac06a48b4ff30da7087"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae46397f9d9aa9ac06a48b4ff30da7087">&#9670;&nbsp;</a></span>prob_for_at_least_one()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::prob_for_at_least_one </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Assume that we have n independent random events that occur with probability p each (p is interpreted as a real number between 0 at 0 and 1 at its maximum value). Return an approximate probability for at least one event occurring as a raw probability.</p>
<p>n must be &lt;= MAX_AT_LEAST_ONE_EVENTS. </p>
<p>Assume that we have n &lt;= MAX_AT_LEAST_ONE_EVENTS independent events with probability p each. Let x be the AT_LEAST_ONE_PRECISION most significant bits of p. Then</p>
<p>prob_at_least_one[(n &lt;&lt; AT_LEAST_ONE_PRECISION) + x]</p>
<p>is an approximate probability of at least one event occurring.</p>
<p>We exploit the magical thread-safety of static local initialization to fill this in exactly once when needed.</p>

</div>
</div>
<a id="a476a2102f4f5aa82c06be87780ae6d42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a476a2102f4f5aa82c06be87780ae6d42">&#9670;&nbsp;</a></span>prob_to_logprob()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::prob_to_logprob </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>prob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a probability to a natural log probability. </p>

</div>
</div>
<a id="acb81881c0a3b7cf276097d8142ddb312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb81881c0a3b7cf276097d8142ddb312">&#9670;&nbsp;</a></span>prob_to_phred()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::prob_to_phred </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>prob</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert probability of wrongness to integer Phred quality score. </p>

</div>
</div>
<a id="a1924855da445b625609837c0920af7b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1924855da445b625609837c0920af7b2">&#9670;&nbsp;</a></span>pseudo_random_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::pseudo_random_sequence </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>seed</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a uniformly random DNA sequence sequence deterministically from a seed. </p>

</div>
</div>
<a id="acffe466a3ca83097eceac30a09b9a010"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acffe466a3ca83097eceac30a09b9a010">&#9670;&nbsp;</a></span>query_overlap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::query_overlap </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab80fc8c8920c7ec53cfee81dc2fce852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab80fc8c8920c7ec53cfee81dc2fce852">&#9670;&nbsp;</a></span>random_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::random_sequence </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a uniformly random DNA sequence of the given length. </p>

</div>
</div>
<a id="a4012afd56ccb35387121c71c2119e244"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4012afd56ccb35387121c71c2119e244">&#9670;&nbsp;</a></span>random_sequence_gen()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">default_random_engine vg::random_sequence_gen </td>
          <td>(</td>
          <td class="paramtype">102&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a931d9271de88fc786030fdd0ab4bf534"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a931d9271de88fc786030fdd0ab4bf534">&#9670;&nbsp;</a></span>range_vector() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; size_t &gt; vg::range_vector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Vector containing positive integer values in [begin, end) </p>

</div>
</div>
<a id="a39adca1737de5d28d007d95b809deb7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39adca1737de5d28d007d95b809deb7f">&#9670;&nbsp;</a></span>range_vector() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;size_t&gt; vg::range_vector </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>end</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Vector containing positive integer values in [0, end) </p>

</div>
</div>
<a id="a95d54bf0a30125f9ded043bb099cb25f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95d54bf0a30125f9ded043bb099cb25f">&#9670;&nbsp;</a></span>rebuild_gbwt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gbwt::GBWT vg::rebuild_gbwt </td>
          <td>(</td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>gbwt_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structvg_1_1RebuildJob.html">RebuildJob</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>jobs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::unordered_map&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_to_job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1RebuildParameters.html">RebuildParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Rebuild the GBWT by applying all provided mappings. Each mapping is a pair (original subpath, new subpath). If the original subpath is empty, the mapping is ignored. If there are multiple applicable mappings, the first one will be used.</p>
<p>The mappings will be applied in both orientations. The reverse mapping replaces the reverse of the original subpath with the reverse of the new subpath.</p>
<p>The first and the last node can be used as context. For example (aXb, aYb) can be interpreted as "replace X with Y in context a b". If both subpaths end with the same node, the cursor will point at that node after the mapping. Otherwise the cursor will be set past the original subpath.</p>
<p>NOTE: To avoid infinite loops, the cursor will proceed after a mapping of the type (a, Xa).</p>
<p>The process can be partitioned into multiple non-overlapping jobs, each of them corresponding to one or more weakly connected components in the graph. Multiple jobs can be run in parallel using 2 threads each, and the jobs will be started from the largest to the smallest.</p>
<p><code>node_to_job</code> maps each node identifier to the corresponding job identifier. Empty paths go to the first job, but this can be overridden by including <code>gbwt::ENDMARKER</code> in <code>node_to_job</code>.</p>
<p>NOTE: Threads may be reordered if there are multiple jobs. Old thread ids are no longer valid after rebuilding the GBWT. </p>

</div>
</div>
<a id="ade5b1e6daa5da7101533d444d3d8ff41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade5b1e6daa5da7101533d444d3d8ff41">&#9670;&nbsp;</a></span>rebuild_gbwt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gbwt::GBWT vg::rebuild_gbwt </td>
          <td>(</td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>gbwt_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; <a class="el" href="structvg_1_1RebuildJob.html#afdbb259fb3fc369a7824f6420b2043c0">RebuildJob::mapping_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mappings</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>As the general <code>rebuild_gbwt</code>, but always using a single job with default parameters. </p>

</div>
</div>
<a id="aec4970f98c4a004a1c07c1beaec524ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4970f98c4a004a1c07c1beaec524ae">&#9670;&nbsp;</a></span>rebuild_gbwt_job()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gbwt::GBWT vg::rebuild_gbwt_job </td>
          <td>(</td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>gbwt_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1RebuildJob.html">RebuildJob</a> &amp;&#160;</td>
          <td class="paramname"><em>job</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; gbwt::size_type &gt; &amp;&#160;</td>
          <td class="paramname"><em>sequences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1RebuildParameters.html">RebuildParameters</a> &amp;&#160;</td>
          <td class="paramname"><em>parameters</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aab16fbb8659a66f16f2004fcc3e8f9db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab16fbb8659a66f16f2004fcc3e8f9db">&#9670;&nbsp;</a></span>regress()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; double &gt; vg::regress </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>X</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the coefficients of a regression (does not automatically compute constant) </p>

</div>
</div>
<a id="add4d3a3d1917566a8df138c80b38e548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add4d3a3d1917566a8df138c80b38e548">&#9670;&nbsp;</a></span>remove_duplicate_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::remove_duplicate_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove duplicate edges </p>

</div>
</div>
<a id="a6dbe8468f2f2bcf8ceb859e6a0f8b4b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dbe8468f2f2bcf8ceb859e6a0f8b4b1">&#9670;&nbsp;</a></span>remove_duplicate_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::remove_duplicate_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove duplicate nodes </p>

</div>
</div>
<a id="aecd2e49750e94ed6f9de917dd9c72ac2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecd2e49750e94ed6f9de917dd9c72ac2">&#9670;&nbsp;</a></span>remove_duplicates() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::remove_duplicates </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove duplicate nodes and edges </p>

</div>
</div>
<a id="a5d00fa3c72ac473353496aab96965e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d00fa3c72ac473353496aab96965e60">&#9670;&nbsp;</a></span>remove_duplicates() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::remove_duplicates </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>result</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3fb034fcd6d50c2b84f40026b40f284"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3fb034fcd6d50c2b84f40026b40f284">&#9670;&nbsp;</a></span>remove_empty_alignment_sections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::remove_empty_alignment_sections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all edit, mappings, and subpaths that have no aligned bases, and introduces transitive edges to preserve connectivity through any completely removed subpaths </p>

</div>
</div>
<a id="a0ea49989e31a688e22265eb41291c0ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ea49989e31a688e22265eb41291c0ae">&#9670;&nbsp;</a></span>remove_low_scoring_sections()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::remove_low_scoring_sections </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>max_score_diff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all subpaths and edges whose optimal full length alignment is less than the given difference from the highest-scoring full length alignment </p>

</div>
</div>
<a id="a0b38f4f0d7e63b1f7f20d2dc985f88c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b38f4f0d7e63b1f7f20d2dc985f88c4">&#9670;&nbsp;</a></span>remove_orphan_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::remove_orphan_edges </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove edges that link to a node that is not in the graph </p>

</div>
</div>
<a id="ad5e16e94675197650b9d6edb9e7a9081"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5e16e94675197650b9d6edb9e7a9081">&#9670;&nbsp;</a></span>remove_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::remove_paths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(const string &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>paths_to_take</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::list&lt; <a class="el" href="structvg_1_1Path.html">Path</a> &gt; *&#160;</td>
          <td class="paramname"><em>matching</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab169ac1e2fc6ba662eebc1ede1ffe157"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab169ac1e2fc6ba662eebc1ede1ffe157">&#9670;&nbsp;</a></span>replace_in_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::replace_in_string </td>
          <td>(</td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>subject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>search</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>replace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a638a54aabac7956dae6fd882468a86fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a638a54aabac7956dae6fd882468a86fe">&#9670;&nbsp;</a></span>report_exception()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::report_exception </td>
          <td>(</td>
          <td class="paramtype">const std::exception &amp;&#160;</td>
          <td class="paramname"><em>ex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>User code should call this if it catches an exception it doesn't know what to do with. </p>

</div>
</div>
<a id="a785f128b2eeb9aa2a4ee5477e5b9942b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a785f128b2eeb9aa2a4ee5477e5b9942b">&#9670;&nbsp;</a></span>rev_comp_multipath_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::rev_comp_multipath_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(int64_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>rev_comp_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the reverse complement of a <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> in another <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a></p>
<p>Args: multipath_aln multipath alignment to reverse complement node_length a function that returns the length of a node sequence from its node ID rev_comp_out empty multipath alignment to store reverse complement in (some data may be overwritten if not empty) </p>

</div>
</div>
<a id="ab9aa92b68bb45684a3b751060508c709"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9aa92b68bb45684a3b751060508c709">&#9670;&nbsp;</a></span>rev_comp_multipath_alignment_in_place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::rev_comp_multipath_alignment_in_place </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> *&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(int64_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stores the reverse complement of a <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> in another <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a></p>
<p>Args: multipath_aln multipath alignment to reverse complement in place node_length a function that returns the length of a node sequence from its node ID </p>

</div>
</div>
<a id="a4d802144c81c58c86f814507e1f99e22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d802144c81c58c86f814507e1f99e22">&#9670;&nbsp;</a></span>rev_comp_subpath()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::rev_comp_subpath </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1subpath__t.html">subpath_t</a> &amp;&#160;</td>
          <td class="paramname"><em>subpath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(int64_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1subpath__t.html">subpath_t</a> &amp;&#160;</td>
          <td class="paramname"><em>rev_comp_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Stores the reverse complement of a <a class="el" href="structvg_1_1Subpath.html" title="A non-branching path of a MultipathAlignment.">Subpath</a> in another <a class="el" href="structvg_1_1Subpath.html" title="A non-branching path of a MultipathAlignment.">Subpath</a></p>
<p>note: this is not included in the header because reversing a subpath without going through the multipath alignment can break invariants related to the edge lists</p>
<p>Args: subpath subpath to reverse complement node_length a function that returns the length of a node sequence from its node ID rev_comp_out empty subpath to store reverse complement in (data will be overwritten if not empty) </p>

</div>
</div>
<a id="ac52fd5878b0be1d53de644eea3458663"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac52fd5878b0be1d53de644eea3458663">&#9670;&nbsp;</a></span>reverse() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> vg::reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reverse a pos_t and get a pos_t at the same <b>point between bases</b>, going the other direction. To get a pos_t to the same <em>base</em>, subtract 1 from the resulting offset or call <a class="el" href="namespacevg.html#ae2f3762e2a8a852c7608d71f030e0345" title="Reverse a pos_t and get a pos_t at the same base, going the other direction.">reverse_base_pos()</a>. </p>

</div>
</div>
<a id="a91adfc6327b5709dc73fcc7edbe5da57"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91adfc6327b5709dc73fcc7edbe5da57">&#9670;&nbsp;</a></span>reverse() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Position.html">Position</a> vg::reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reverse a <a class="el" href="structvg_1_1Position.html">Position</a> and get a <a class="el" href="structvg_1_1Position.html">Position</a> at the same <b>point between bases</b>, going the other direction. To get a <a class="el" href="structvg_1_1Position.html">Position</a> to the same <em>base</em>, subtract 1 from the resulting offset. </p>

</div>
</div>
<a id="a2e300d25fd8281f9453366f68b484196"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e300d25fd8281f9453366f68b484196">&#9670;&nbsp;</a></span>reverse() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Visit.html">Visit</a> vg::reverse </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>visit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the reversed version of a visit. </p>

</div>
</div>
<a id="ae2f3762e2a8a852c7608d71f030e0345"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae2f3762e2a8a852c7608d71f030e0345">&#9670;&nbsp;</a></span>reverse_base_pos()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> vg::reverse_base_pos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reverse a pos_t and get a pos_t at the same <b>base</b>, going the other direction. </p>

</div>
</div>
<a id="aa65de7dea52585f07bee6ae7f762eb95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa65de7dea52585f07bee6ae7f762eb95">&#9670;&nbsp;</a></span>reverse_complement() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">char vg::reverse_complement </td>
          <td>(</td>
          <td class="paramtype">const char &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30732a1a1e8d20d6eaaaeafecc8a50a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30732a1a1e8d20d6eaaaeafecc8a50a7">&#9670;&nbsp;</a></span>reverse_complement() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::reverse_complement </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98e512ed0fca2503ccc370435591a6c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98e512ed0fca2503ccc370435591a6c1">&#9670;&nbsp;</a></span>reverse_complement_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::reverse_complement_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab96610ffc81d6207e0b13f675296c234"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab96610ffc81d6207e0b13f675296c234">&#9670;&nbsp;</a></span>reverse_complement_alignment_in_place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::reverse_complement_alignment_in_place </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> *&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aed045b02277d7704e997cbede67c2662"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed045b02277d7704e997cbede67c2662">&#9670;&nbsp;</a></span>reverse_complement_alignments()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; vg::reverse_complement_alignments </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(int64_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae6353d47c867f1b4cc7053d82aef42f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6353d47c867f1b4cc7053d82aef42f4">&#9670;&nbsp;</a></span>reverse_complement_in_place()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::reverse_complement_in_place </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ce6fa1d8f3ba4f8f361fa77a6fd5261"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ce6fa1d8f3ba4f8f361fa77a6fd5261">&#9670;&nbsp;</a></span>reverse_complement_mapping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> vg::reverse_complement_mapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a798565f048dc7844739ea4913d950d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a798565f048dc7844739ea4913d950d31">&#9670;&nbsp;</a></span>reverse_complement_mapping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1path__mapping__t.html">path_mapping_t</a> vg::reverse_complement_mapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1path__mapping__t.html">path_mapping_t</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2dc9d6ee4403027eb5965aa6a71eb4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2dc9d6ee4403027eb5965aa6a71eb4e">&#9670;&nbsp;</a></span>reverse_complement_mapping_in_place() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::reverse_complement_mapping_in_place </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abc9bd04ab1099c6d9bd655a2accbe52e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc9bd04ab1099c6d9bd655a2accbe52e">&#9670;&nbsp;</a></span>reverse_complement_mapping_in_place() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::reverse_complement_mapping_in_place </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1path__mapping__t.html">path_mapping_t</a> *&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a463d9eaed29cd6d46a8e2afb645c8fda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a463d9eaed29cd6d46a8e2afb645c8fda">&#9670;&nbsp;</a></span>reverse_complement_path() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::reverse_complement_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3df9f25ec47163ccbfa328673bd28ab5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3df9f25ec47163ccbfa328673bd28ab5">&#9670;&nbsp;</a></span>reverse_complement_path() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1path__t.html">path_t</a> vg::reverse_complement_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af2941a3c80481d02c65d9d72bd835807"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2941a3c80481d02c65d9d72bd835807">&#9670;&nbsp;</a></span>reverse_complement_path_in_place() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::reverse_complement_path_in_place </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Path.html">Path</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0df8f9c5838119e79ee1f671cd823740"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0df8f9c5838119e79ee1f671cd823740">&#9670;&nbsp;</a></span>reverse_complement_path_in_place() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::reverse_complement_path_in_place </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1path__t.html">path_t</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; int64_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="added44ff3bb1c0ce606563a40923c513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#added44ff3bb1c0ce606563a40923c513">&#9670;&nbsp;</a></span>run_benchmark() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1BenchmarkResult.html">BenchmarkResult</a> vg::run_benchmark </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>setup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>under_test</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run a benchmark with a setup function. </p>

</div>
</div>
<a id="ac101c453ab2076d74f0324f73d174695"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac101c453ab2076d74f0324f73d174695">&#9670;&nbsp;</a></span>run_benchmark() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1BenchmarkResult.html">BenchmarkResult</a> vg::run_benchmark </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>iterations</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; void(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>under_test</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Run the given function the given number of times, interleaved with runs of the control function, and return a <a class="el" href="structvg_1_1BenchmarkResult.html">BenchmarkResult</a> describing its performance. </p>

</div>
</div>
<a id="ae57a78071537c87e2f0f57bfea18ba71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae57a78071537c87e2f0f57bfea18ba71">&#9670;&nbsp;</a></span>run_multipath_dp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple&lt;<a class="el" href="structvg_1_1MultipathProblem.html">MultipathProblem</a>, int64_t, int32_t&gt; vg::run_multipath_dp </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>subpath_global</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forward</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Internal helper function for running the dynamic programming problem represented by a multipath alignment. Returns the filled DP problem, the optimal ending subpath, or -1 if no subpath is optimal, and the optimal score, or 0 if no score is optimal. An option toggles whether the traceback should be global (a source to a sink in the multipath DAG) or local (starting and ending at any subpath) </p>

</div>
</div>
<a id="aaac16668663556af1aea74159a73d4ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaac16668663556af1aea74159a73d4ed">&#9670;&nbsp;</a></span>sa_to_da()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::sa_to_da </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; <a class="el" href="classvg_1_1HaplotypePartitioner.html#aa06fc618c54377342c05b7306b8dec72">HaplotypePartitioner::sequence_type</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>sequences</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gbwt::FastLocate &amp;&#160;</td>
          <td class="paramname"><em>r_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae37c6d66a01cef6f92707d367ebf4cdb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae37c6d66a01cef6f92707d367ebf4cdb">&#9670;&nbsp;</a></span>sam_flag()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::sam_flag </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>on_reverse_strand</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>paired</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8385d575383b7bae35726e90851a2795"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8385d575383b7bae35726e90851a2795">&#9670;&nbsp;</a></span>save_gbwt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::save_gbwt </td>
          <td>(</td>
          <td class="paramtype">const gbwt::DynamicGBWT &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a dynamic GBWT to the file. </p>

</div>
</div>
<a id="a790122d8b3f28068aaf09f1eb5b966a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a790122d8b3f28068aaf09f1eb5b966a9">&#9670;&nbsp;</a></span>save_gbwt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::save_gbwt </td>
          <td>(</td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a compressed GBWT to the file. </p>

</div>
</div>
<a id="aea7640260b1c70795335439f3d6c2eac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea7640260b1c70795335439f3d6c2eac">&#9670;&nbsp;</a></span>save_gbwtgraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::save_gbwtgraph </td>
          <td>(</td>
          <td class="paramtype">const gbwtgraph::GBWTGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save GBWTGraph to the file. </p>

</div>
</div>
<a id="a6beaace0e6d90b654dc9c382afb39ce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6beaace0e6d90b654dc9c382afb39ce0">&#9670;&nbsp;</a></span>save_gbz() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::save_gbz </td>
          <td>(</td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gbwtgraph::GBWTGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save GBWT and GBWTGraph to the GBZ file. </p>

</div>
</div>
<a id="a017e7cda40a98b4b044507ab78a34da9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a017e7cda40a98b4b044507ab78a34da9">&#9670;&nbsp;</a></span>save_gbz() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::save_gbz </td>
          <td>(</td>
          <td class="paramtype">const gbwtgraph::GBZ &amp;&#160;</td>
          <td class="paramname"><em>gbz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save GBZ to the file. </p>

</div>
</div>
<a id="af7669e457f62e6f197f3120086a091e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7669e457f62e6f197f3120086a091e2">&#9670;&nbsp;</a></span>save_gbz() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::save_gbz </td>
          <td>(</td>
          <td class="paramtype">const gbwtgraph::GBZ &amp;&#160;</td>
          <td class="paramname"><em>gbz</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>gbwt_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>graph_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save GBZ to separate GBWT / GBWTGraph files. </p>

</div>
</div>
<a id="aa2840fc8dbdb12c000769a3baa39b808"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2840fc8dbdb12c000769a3baa39b808">&#9670;&nbsp;</a></span>save_gcsa()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::save_gcsa </td>
          <td>(</td>
          <td class="paramtype">const gcsa::GCSA &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save GCSA to the file. </p>

</div>
</div>
<a id="a604f783fb59cb6c3e7fcc783a8286822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a604f783fb59cb6c3e7fcc783a8286822">&#9670;&nbsp;</a></span>save_lcp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::save_lcp </td>
          <td>(</td>
          <td class="paramtype">const gcsa::LCPArray &amp;&#160;</td>
          <td class="paramname"><em>lcp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save LCP array to the file. </p>

</div>
</div>
<a id="af7885143ca20185816afadc669813f12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7885143ca20185816afadc669813f12">&#9670;&nbsp;</a></span>save_minimizer()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::save_minimizer </td>
          <td>(</td>
          <td class="paramtype">const gbwtgraph::DefaultMinimizerIndex &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save a minimizer index to the file. </p>

</div>
</div>
<a id="a50d4b5eef7efd656daeb423af1f6a3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d4b5eef7efd656daeb423af1f6a3c6">&#9670;&nbsp;</a></span>save_r_index()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::save_r_index </td>
          <td>(</td>
          <td class="paramtype">const gbwt::FastLocate &amp;&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_progress</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save an r-index to the file. </p>

</div>
</div>
<a id="aea0e7a0965b967bed3ff54e6ff630f91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea0e7a0965b967bed3ff54e6ff630f91">&#9670;&nbsp;</a></span>score_gap()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::score_gap </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>gap_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>gap_open</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>gap_extension</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Score a gap with the given open and extension scores. </p>

</div>
</div>
<a id="aa9d71371be6972c8284b267d42fac754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9d71371be6972c8284b267d42fac754">&#9670;&nbsp;</a></span>search_multipath_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; tuple&lt; int64_t, int64_t, int64_t, int64_t &gt; &gt; vg::search_multipath_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>graph_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>seq_pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns all of the positions where a given sequence index occurs at a given graph graph position (if any), where positions are represented as tuples of (subpath index, mapping index, edit index, index within edit) </p>

</div>
</div>
<a id="a54bcd5d5fc5318bbdbe784f224b906bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54bcd5d5fc5318bbdbe784f224b906bd">&#9670;&nbsp;</a></span>set_annotation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AnnotationType , typename Annotated &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::set_annotation </td>
          <td>(</td>
          <td class="paramtype">Annotated &amp;&#160;</td>
          <td class="paramname"><em>annotated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnnotationType &amp;&#160;</td>
          <td class="paramname"><em>annotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the annotation with the given name to the given value. The value may be a primitive type or a vector of a primitive type. </p>

</div>
</div>
<a id="adea29af7b94ac90b1db0eacd908511c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adea29af7b94ac90b1db0eacd908511c0">&#9670;&nbsp;</a></span>set_annotation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename AnnotationType , typename Annotated &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::set_annotation </td>
          <td>(</td>
          <td class="paramtype">Annotated *&#160;</td>
          <td class="paramname"><em>annotated</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const AnnotationType &amp;&#160;</td>
          <td class="paramname"><em>annotation</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Set the annotation with the given name to the given value. The value may be a primitive type or a vector of a primitive type. </p>

</div>
</div>
<a id="ac801de9444375b2f131d3c21d125e83b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac801de9444375b2f131d3c21d125e83b">&#9670;&nbsp;</a></span>set_crash_context()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::set_crash_context </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>message</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User code should call this when it has context for a failure in its thread. </p>

</div>
</div>
<a id="a234b2ca417edb50a3c738991fcfc269a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a234b2ca417edb50a3c738991fcfc269a">&#9670;&nbsp;</a></span>set_intersection()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::set_intersection </td>
          <td>(</td>
          <td class="paramtype">const unordered_set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>set_1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_set&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>set_2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_set&lt; T &gt; *&#160;</td>
          <td class="paramname"><em>out_intersection</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3b05a1318d7be5ecf3547a3eca837618"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b05a1318d7be5ecf3547a3eca837618">&#9670;&nbsp;</a></span>set_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::set_score </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &amp;&#160;</td>
          <td class="paramname"><em>extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6821cd887e206752c50c1a7be764d1f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6821cd887e206752c50c1a7be764d1f5">&#9670;&nbsp;</a></span>sha1head()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string vg::sha1head </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>head</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0cada7d579d914675f53490e0488ab53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0cada7d579d914675f53490e0488ab53">&#9670;&nbsp;</a></span>sha1sum()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::string vg::sha1sum </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2616dde2763b947a15ac562fd631e688"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2616dde2763b947a15ac562fd631e688">&#9670;&nbsp;</a></span>signature() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::signature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a134fc6762c4b66dd4847078b0ddbfdd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a134fc6762c4b66dd4847078b0ddbfdd6">&#9670;&nbsp;</a></span>signature() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; string, string &gt; vg::signature </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a486054f13a4dc43e37c0f0131f6a51ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a486054f13a4dc43e37c0f0131f6a51ad">&#9670;&nbsp;</a></span>simplify() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::simplify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trim_internal_deletions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simplifies the <a class="el" href="structvg_1_1Path.html">Path</a> in the <a class="el" href="structvg_1_1Alignment.html">Alignment</a>. Note that this removes deletions at the start and end of Mappings, so code that handles simplified Alignments needs to handle offsets on internal Mappings. </p>

</div>
</div>
<a id="a9514446da89671007ae40e420c1297d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9514446da89671007ae40e420c1297d7">&#9670;&nbsp;</a></span>simplify() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> vg::simplify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trim_internal_deletions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge adjacent edits of the same type, strip leading and trailing deletion edits (while updating positions if necessary), and makes sure position is actually set. </p>

</div>
</div>
<a id="a86653c665afe3c8932f60cc39163e202"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86653c665afe3c8932f60cc39163e202">&#9670;&nbsp;</a></span>simplify() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::simplify </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trim_internal_deletions</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Simplify the path for addition as new material in the graph. Remove any mappings that are merely single deletions, merge adjacent edits of the same type, strip leading and trailing deletion edits on mappings, and make sure no mappings have missing positions. </p>

</div>
</div>
<a id="a553c3fcfd7de2e51f41a6f174c313947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a553c3fcfd7de2e51f41a6f174c313947">&#9670;&nbsp;</a></span>simplify_cigar()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::simplify_cigar </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; int, char &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>cigar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Merge runs of successive I/D operations into a single I and D, remove 0-length operations, and merge adjacent operations of the same type </p>

</div>
</div>
<a id="ad6a42e8ba843cd728b9f84738756b30e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6a42e8ba843cd728b9f84738756b30e">&#9670;&nbsp;</a></span>simplify_filtered_edits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::simplify_filtered_edits </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const map&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>node_translation</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>orig_node_sizes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>min_baseq</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_frac_n</em> = <code>1.</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove edits in our graph that don't correspond to breakpoints (ie were effectively filtered out due to insufficient coverage. This way, subsequent logic in add_nodes_and_edges can be run correctly. Returns true if at least one edit survived the filter. </p>

</div>
</div>
<a id="ad477b45059373004136e69022e802e0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad477b45059373004136e69022e802e0b">&#9670;&nbsp;</a></span>slope()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::slope </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a05d6d0388148a996d9423524fa4bcc91"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05d6d0388148a996d9423524fa4bcc91">&#9670;&nbsp;</a></span>softclip_end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::softclip_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa84e4c417206a9b3a910dfde0fec3857"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa84e4c417206a9b3a910dfde0fec3857">&#9670;&nbsp;</a></span>softclip_end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::softclip_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90f2af92a34fdf5fb4ddfee8f8880b48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f2af92a34fdf5fb4ddfee8f8880b48">&#9670;&nbsp;</a></span>softclip_start() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::softclip_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9fe66eebecbc5017b05c9044413b2b4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fe66eebecbc5017b05c9044413b2b4e">&#9670;&nbsp;</a></span>softclip_start() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::softclip_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a947760b26fa8669d55f2f420174a578c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a947760b26fa8669d55f2f420174a578c">&#9670;&nbsp;</a></span>softclip_trim()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::softclip_trim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af25c227066a422379ff06d81b5990865"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af25c227066a422379ff06d81b5990865">&#9670;&nbsp;</a></span>sort_by_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::sort_by_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>order the nodes and edges in the graph by id </p>

</div>
</div>
<a id="a984c1d2199f90f58677096772b870390"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984c1d2199f90f58677096772b870390">&#9670;&nbsp;</a></span>sort_by_id_dedup_and_clean()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::sort_by_id_dedup_and_clean </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>remove duplicates and sort by id </p>

</div>
</div>
<a id="a90cc117e3ac781c77cf8fdaa7802048b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90cc117e3ac781c77cf8fdaa7802048b">&#9670;&nbsp;</a></span>sort_edges_by_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::sort_edges_by_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>order the edges in the graph by id pairs </p>

</div>
</div>
<a id="afb37b16823e6e26cfd8571a1bb621651"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb37b16823e6e26cfd8571a1bb621651">&#9670;&nbsp;</a></span>sort_nodes_by_id()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::sort_nodes_by_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>order the nodes in the graph by id </p>

</div>
</div>
<a id="a47c7102baf9a07b2c701e9937d53351f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47c7102baf9a07b2c701e9937d53351f">&#9670;&nbsp;</a></span>sort_pair_by_second()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::sort_pair_by_second </td>
          <td>(</td>
          <td class="paramtype">const pair&lt; uint32_t, uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pair&lt; uint32_t, uint32_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab03fad9d3c71a090606afbe1ef22ce71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab03fad9d3c71a090606afbe1ef22ce71">&#9670;&nbsp;</a></span>sort_permutation() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; vg::sort_permutation </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index permutation that sorts the given items ascending using &lt;. </p>

</div>
</div>
<a id="ae031408254f8c4031ba0b632f5456059"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae031408254f8c4031ba0b632f5456059">&#9670;&nbsp;</a></span>sort_permutation() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;size_t&gt; vg::sort_permutation </td>
          <td>(</td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Iterator &amp;&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; bool(const typename Iterator::value_type &amp;, const typename Iterator::value_type &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>comparator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the index permutation that sorts the given items with the given comparator instead of &lt;. </p>

</div>
</div>
<a id="aa071bccfee3a9078930f2c385e8dda20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa071bccfee3a9078930f2c385e8dda20">&#9670;&nbsp;</a></span>sort_shuffling_ties() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomIt , class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::sort_shuffling_ties </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the items between the two given random-access iterators, as with std::sort. Deterministically shuffle the ties, if any, at the top end, using automatic seed determination as defined by a <a class="el" href="namespacevg.html#aeca2b8e2d5730b1d5b94c1d3861757d7" title="Define seed generation for shuffling multipath alignments.">make_shuffle_seed()</a> overload for the collection's item type. </p>

</div>
</div>
<a id="afe3de0ca79c815a4eaf63df34805f6d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe3de0ca79c815a4eaf63df34805f6d0">&#9670;&nbsp;</a></span>sort_shuffling_ties() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class RandomIt , class Compare &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::sort_shuffling_ties </td>
          <td>(</td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomIt&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Compare&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1LazyRNG.html">LazyRNG</a> &amp;&#160;</td>
          <td class="paramname"><em>rng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sort the items between the two given random-access iterators, as with std::sort. Deterministically shuffle the ties, if any, at the top end. </p>

</div>
</div>
<a id="aaddbcf35ad2ff899bf2ae0caf901f778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaddbcf35ad2ff899bf2ae0caf901f778">&#9670;&nbsp;</a></span>sort_transcript_paths_by_name()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::sort_transcript_paths_by_name </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1CompletedTranscriptPath.html">CompletedTranscriptPath</a> &amp;&#160;</td>
          <td class="paramname"><em>lhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1CompletedTranscriptPath.html">CompletedTranscriptPath</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a335fce1edcad06f9840edcfad2c53e34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a335fce1edcad06f9840edcfad2c53e34">&#9670;&nbsp;</a></span>split_delims() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; vg::split_delims </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_cuts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb2577b9163299f775898c17bcd3f72d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2577b9163299f775898c17bcd3f72d">&#9670;&nbsp;</a></span>split_delims() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; &amp; vg::split_delims </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>delims</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>elems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_cuts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a984d142cea24f43a1025bf7bb7b48a53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a984d142cea24f43a1025bf7bb7b48a53">&#9670;&nbsp;</a></span>split_ext()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; string, string &gt; vg::split_ext </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Split off the extension from a filename and return both parts. </p>

</div>
</div>
<a id="aee945465384e60bdda619684ffca2ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee945465384e60bdda619684ffca2ece">&#9670;&nbsp;</a></span>split_splice_segment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt;pair&lt;<a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t&gt;, pair&lt;<a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t&gt; &gt; vg::split_splice_segment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>splice_segment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tuple&lt; int64_t, int64_t, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>left_trace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const tuple&lt; int64_t, int64_t, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>right_trace</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>splice_junction_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> &amp;&#160;</td>
          <td class="paramname"><em>scorer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5e9c563a243faef4e5357eca9c7c8500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9c563a243faef4e5357eca9c7c8500">&#9670;&nbsp;</a></span>stack_permutations()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; vg::stack_permutations </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>bottom</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>top</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply one permutation on top of another. Retutn the combined permutation. </p>

</div>
</div>
<a id="a8d771862cc44504508267240462cb043"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d771862cc44504508267240462cb043">&#9670;&nbsp;</a></span>stacktrace_manually()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::stacktrace_manually </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>signalNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>ip</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void **&#160;</td>
          <td class="paramname"><em>bp</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a43f061abac718e0386965aa537398e74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43f061abac718e0386965aa537398e74">&#9670;&nbsp;</a></span>start_backward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::start_backward </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#aceea01d66677e39af71921f1bb1911f0">Chain</a> &amp;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Return true if the first snarl in the given chain is backward relative to the chain. </p>

</div>
</div>
<a id="a7b58d5d004a85a09906301781567970a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b58d5d004a85a09906301781567970a">&#9670;&nbsp;</a></span>starts_with()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::starts_with </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>prefix</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if a string starts with another string. </p>

</div>
</div>
<a id="a11df8bd14dab3c0cfb7ecfa377a362f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11df8bd14dab3c0cfb7ecfa377a362f5">&#9670;&nbsp;</a></span>stdev()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double vg::stdev </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adbe45b79675104ebc36691774d4124c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbe45b79675104ebc36691774d4124c4">&#9670;&nbsp;</a></span>strip_from_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::strip_from_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd6786ea9551b426f95fba325beff138"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6786ea9551b426f95fba325beff138">&#9670;&nbsp;</a></span>strip_from_start()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::strip_from_start </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>drop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab63c41956b73af429507b469108d1759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63c41956b73af429507b469108d1759">&#9670;&nbsp;</a></span>sub_overlaps_of_first_aln()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::sub_overlaps_of_first_aln </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">float&#160;</td>
          <td class="paramname"><em>overlap_fraction</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc960c295c1e3088dc8e71ab1af5c4d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc960c295c1e3088dc8e71ab1af5c4d6">&#9670;&nbsp;</a></span>subgraph_containing_path_snarls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::subgraph_containing_path_snarls </td>
          <td>(</td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aff8a7aca57dd525bc2def1369abae3fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff8a7aca57dd525bc2def1369abae3fe">&#9670;&nbsp;</a></span>subgraph_in_distance_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::subgraph_in_distance_range </td>
          <td>(</td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>super_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>look_forward</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a30f08b56f8c117103357ed4b8ebc08b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a30f08b56f8c117103357ed4b8ebc08b8">&#9670;&nbsp;</a></span>subgraph_in_distance_range_walk_across_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::subgraph_in_distance_range_walk_across_chain </td>
          <td>(</td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>super_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a>&#160;</td>
          <td class="paramname"><em>current_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>current_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>search_start_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1hash__set.html">hash_set</a>&lt; pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>seen_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>min_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>max_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>checked_loop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0312bffc43a4f4176aad1c37073b59df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0312bffc43a4f4176aad1c37073b59df">&#9670;&nbsp;</a></span>subgraph_in_distance_range_walk_graph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::subgraph_in_distance_range_walk_graph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>super_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unordered_set&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>subgraph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>, size_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>start_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1hash__set.html">hash_set</a>&lt; pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>seen_nodes</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pair&lt; <a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>, bool &gt; &amp;&#160;</td>
          <td class="paramname"><em>traversal_start</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Helper for subgraph_in_distance_range Given starting handles in the super graph and the distances to each handle (including the start position and </p>

</div>
</div>
<a id="ab1dcbe73351c8eaeea745f4b5191b8f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1dcbe73351c8eaeea745f4b5191b8f0">&#9670;&nbsp;</a></span>subpath_topological_order()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;size_t&gt; vg::subpath_topological_order </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>do_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return either the vector of topological order by index or the vector of indexes within the topological order. </p>

</div>
</div>
<a id="a33c8f5153ad0766df2c72bbec623aa19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33c8f5153ad0766df2c72bbec623aa19">&#9670;&nbsp;</a></span>subtract_log()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::subtract_log </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>log_x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>log_y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa70726366aa31b20debdcac41c89490c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa70726366aa31b20debdcac41c89490c">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Collection &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Collection::value_type vg::sum </td>
          <td>(</td>
          <td class="paramtype">const Collection &amp;&#160;</td>
          <td class="paramname"><em>collection</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Compute the sum of the values in a collection. Values must be default- constructable (like numbers are). </p>

</div>
</div>
<a id="ae8afe82a05092bbf4bc31c8ead079fe3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8afe82a05092bbf4bc31c8ead079fe3">&#9670;&nbsp;</a></span>summary_statistics()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Number &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1SummaryStatistics.html">SummaryStatistics</a> vg::summary_statistics </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; Number, size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns summary statistics for a multiset of numbers. </p>

</div>
</div>
<a id="ac3787b0a7fc02bbfe45dc5eb082d5779"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3787b0a7fc02bbfe45dc5eb082d5779">&#9670;&nbsp;</a></span>support_max()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> vg::support_max </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the maximum support of a pair of Supports, by taking the max in each orientation. </p>

</div>
</div>
<a id="a3c2ae4c37201ebbc6f6d4faaf27fe4de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c2ae4c37201ebbc6f6d4faaf27fe4de">&#9670;&nbsp;</a></span>support_min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Support.html">Support</a> vg::support_min </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the minimum support of a pair of Supports, by taking the min in each orientation. </p>

</div>
</div>
<a id="afc64443321ef5b17233dac0ca11e98ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc64443321ef5b17233dac0ca11e98ed">&#9670;&nbsp;</a></span>take_unique_minimizers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="classvg_1_1HaplotypePartitioner.html#a2780337120cfec8463356829af22aa97">HaplotypePartitioner::kmer_type</a>&gt; vg::take_unique_minimizers </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gbwtgraph::DefaultMinimizerIndex &amp;&#160;</td>
          <td class="paramname"><em>minimizer_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a08575acb0012ffaabd9859324e404562"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08575acb0012ffaabd9859324e404562">&#9670;&nbsp;</a></span>target_alignment() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::target_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make an <a class="el" href="structvg_1_1Alignment.html">Alignment</a> corresponding to a subregion of a stored path. Positions are 0-based, and pos2 is excluded. Respects path circularity, so pos2 &lt; pos1 is not a problem. If pos1 == pos2, returns an empty alignment. </p>

</div>
</div>
<a id="ac712c04180499746dab8cdc6c8795c56"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac712c04180499746dab8cdc6c8795c56">&#9670;&nbsp;</a></span>target_alignment() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::target_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1path__handle__t.html">path_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>feature</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>cigar_mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as above, but uses the given <a class="el" href="structvg_1_1Mapping.html">Mapping</a>, translated directly form a CIGAR string, as a source of edits. The edits are inserted into the generated <a class="el" href="structvg_1_1Alignment.html">Alignment</a>, cut as necessary to fit into the <a class="el" href="structvg_1_1Alignment.html">Alignment</a>'s Mappings. </p>

</div>
</div>
<a id="aa24cc1f72643cab5fa0dfcc551f61d50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa24cc1f72643cab5fa0dfcc551f61d50">&#9670;&nbsp;</a></span>thread_to_graph_spanned()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::thread_to_graph_spanned </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a31b8b476fb46de6667b26514b7b24fd2">thread_t</a> &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5813ee7997572d371f9ff7b45bbe4843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5813ee7997572d371f9ff7b45bbe4843">&#9670;&nbsp;</a></span>threads_for_contig()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; gbwt::size_type &gt; vg::threads_for_contig </td>
          <td>(</td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>gbwt_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>contig_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the list of thread ids / gbwt path ids for the given contig. </p>

</div>
</div>
<a id="a2d4b0a9961f932a8caccb1d0723fd171"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d4b0a9961f932a8caccb1d0723fd171">&#9670;&nbsp;</a></span>threads_for_sample()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; gbwt::size_type &gt; vg::threads_for_sample </td>
          <td>(</td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>gbwt_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sample_name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return the list of thread ids / gbwt path ids for the given sample. </p>

</div>
</div>
<a id="a10bcb19d45af37e8a58129b939b86f21"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10bcb19d45af37e8a58129b939b86f21">&#9670;&nbsp;</a></span>to_alignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::to_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>trav</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Convert a snarl traversal into an alignment. </p>

</div>
</div>
<a id="a1da5277daea16b80ffc4ab75175b1882"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1da5277daea16b80ffc4ab75175b1882">&#9670;&nbsp;</a></span>to_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a3de8fe5f38b1730a36af4ad9c4258963">edge_t</a> vg::to_edge </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>v1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>v2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make an edge_t from a pair of visits. </p>

</div>
</div>
<a id="a84d646b72482de0145745a64414ca5df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84d646b72482de0145745a64414ca5df">&#9670;&nbsp;</a></span>to_left_side()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> vg::to_left_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>visit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> to a node or snarl into a <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> for its left side. </p>

</div>
</div>
<a id="a5ed83dc32e575ae68b591d142eb38912"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ed83dc32e575ae68b591d142eb38912">&#9670;&nbsp;</a></span>to_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::to_length </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>m</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad47f373b3433b3190f9f1c0f5f17274d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad47f373b3433b3190f9f1c0f5f17274d">&#9670;&nbsp;</a></span>to_length_after_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::to_length_after_pos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa40f0cfd74a9eeaa7b6ffecbc0926a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa40f0cfd74a9eeaa7b6ffecbc0926a6d">&#9670;&nbsp;</a></span>to_length_before_pos()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::to_length_before_pos </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a128ffce6142542678bbbdc6e2e0b40cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a128ffce6142542678bbbdc6e2e0b40cd">&#9670;&nbsp;</a></span>to_mapping() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> vg::to_mapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>visit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>vg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> to a <a class="el" href="structvg_1_1Mapping.html">Mapping</a>. Throws an exception if the <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> is of a <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes.">Snarl</a> instead of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a>. Uses a graph to get node length. </p>

</div>
</div>
<a id="a28be7f9898d5ad6e075e25b81df512e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28be7f9898d5ad6e075e25b81df512e8">&#9670;&nbsp;</a></span>to_mapping() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> vg::to_mapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>visit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::function&lt; size_t(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> to a <a class="el" href="structvg_1_1Mapping.html">Mapping</a>. Throws an exception if the <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> is of a <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes.">Snarl</a> instead of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a>. Uses a function to get node length. </p>

</div>
</div>
<a id="a27656a1e271730b6a62263dc2af8055d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27656a1e271730b6a62263dc2af8055d">&#9670;&nbsp;</a></span>to_multipath_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::to_multipath_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="structvg_1_1Alignment.html">Alignment</a> into a <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> with one subpath and stores it in an object</p>
<p>Args: aln alignment to convert multipath_aln empty multipath alignment to store converted alignment in (data may be be overwritten if not empty) </p>

</div>
</div>
<a id="a5a2e772d69c9e45cbc1c1d1a9e6df842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a2e772d69c9e45cbc1c1d1a9e6df842">&#9670;&nbsp;</a></span>to_node_traversal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> vg::to_node_traversal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>visit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> to a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a>. Throws an exception if the <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> is of a <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes.">Snarl</a> instead of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a> </p>

</div>
</div>
<a id="a2c04918053577c402e4f2cab61abd754"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c04918053577c402e4f2cab61abd754">&#9670;&nbsp;</a></span>to_node_traversal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> vg::to_node_traversal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>visit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a84c5dd6c830450f9100b5e9c11522050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a84c5dd6c830450f9100b5e9c11522050">&#9670;&nbsp;</a></span>to_proto_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::to_proto_edit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1edit__t.html">edit_t</a> &amp;&#160;</td>
          <td class="paramname"><em>edit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;&#160;</td>
          <td class="paramname"><em>proto_edit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3da977cb90bf3ffd94166edb2fdb980a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3da977cb90bf3ffd94166edb2fdb980a">&#9670;&nbsp;</a></span>to_proto_mapping()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::to_proto_mapping </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1path__mapping__t.html">path_mapping_t</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>proto_mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f8f0e54cfa0c3279c18748c503ccbe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f8f0e54cfa0c3279c18748c503ccbe9">&#9670;&nbsp;</a></span>to_proto_multipath_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::to_proto_multipath_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>proto_multipath_aln_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert an STL-based <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> to a protobuf <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a>. </p>

</div>
</div>
<a id="a9473b834c584544cc90c819d6b5bb222"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9473b834c584544cc90c819d6b5bb222">&#9670;&nbsp;</a></span>to_proto_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::to_proto_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>proto_path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b4a5c32294bf49aa7f0a6d180cc2832"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b4a5c32294bf49aa7f0a6d180cc2832">&#9670;&nbsp;</a></span>to_rev_node_traversal() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> vg::to_rev_node_traversal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>visit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> to a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> in the opposite orientation. Throws an exception if the <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> is of a <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes.">Snarl</a> instead of a <a class="el" href="structvg_1_1Node.html" title="Nodes store sequence data.">Node</a> </p>

</div>
</div>
<a id="ae64d7810e64af7119f1b1b3a2d08d797"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae64d7810e64af7119f1b1b3a2d08d797">&#9670;&nbsp;</a></span>to_rev_node_traversal() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> vg::to_rev_node_traversal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>visit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7164ae8636d1ca7783d6202c8ce316ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7164ae8636d1ca7783d6202c8ce316ca">&#9670;&nbsp;</a></span>to_rev_visit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Visit.html">Visit</a> vg::to_rev_visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>node_traversal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> to a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> in the opposite orientation. </p>

</div>
</div>
<a id="a74fab09b3ae1d9f799742a31b5206a35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74fab09b3ae1d9f799742a31b5206a35">&#9670;&nbsp;</a></span>to_right_side()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> vg::to_right_side </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Visit.html">Visit</a> &amp;&#160;</td>
          <td class="paramname"><em>visit</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> to a node or snarl into a <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> for its right side. </p>

</div>
</div>
<a id="a75bc48248af00118bc7cdacc00e37db1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a75bc48248af00118bc7cdacc00e37db1">&#9670;&nbsp;</a></span>to_string() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a3de8fe5f38b1730a36af4ad9c4258963">edge_t</a>&#160;</td>
          <td class="paramname"><em>edge</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad7ec65dd3bb34f37cff811f49c1b9599"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ec65dd3bb34f37cff811f49c1b9599">&#9670;&nbsp;</a></span>to_string() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::to_string </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9aadb20454b27a0819f40006556ffe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9aadb20454b27a0819f40006556ffe6">&#9670;&nbsp;</a></span>to_string() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vg::to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a93282dbd7c3a7daaf92b75f77c28dc29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93282dbd7c3a7daaf92b75f77c28dc29">&#9670;&nbsp;</a></span>to_string_gbwtgraph() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vg::to_string_gbwtgraph </td>
          <td>(</td>
          <td class="paramtype">gbwt::node_type&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of a GBWTGraph node. </p>

</div>
</div>
<a id="adc47f14b546282cf0818ba47826a9110"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc47f14b546282cf0818ba47826a9110">&#9670;&nbsp;</a></span>to_string_gbwtgraph() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string vg::to_string_gbwtgraph </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a>&#160;</td>
          <td class="paramname"><em>handle</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string representation of a GBWTGraph handle. </p>

</div>
</div>
<a id="a420f2fd8ef6d04f1a34a08af2a3dee0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a420f2fd8ef6d04f1a34a08af2a3dee0e">&#9670;&nbsp;</a></span>to_vcf_genotype()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::to_vcf_genotype </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Genotype.html">Genotype</a> &amp;&#160;</td>
          <td class="paramname"><em>gt</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get a VCF-style 1/2, 1|2|3, etc. string from a <a class="el" href="structvg_1_1Genotype.html" title="Describes a genotype at a particular locus.">Genotype</a>. </p>

</div>
</div>
<a id="ae7d774bd39780563236dbf2badfc804b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae7d774bd39780563236dbf2badfc804b">&#9670;&nbsp;</a></span>to_visit() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Visit.html">Visit</a> vg::to_visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">handlegraph::HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1handle__t.html">handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>handle</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> from a handle in a HandleGraph. </p>

</div>
</div>
<a id="acd53873bb85623cbf5b797f09bf88dc4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd53873bb85623cbf5b797f09bf88dc4">&#9670;&nbsp;</a></span>to_visit() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Visit.html">Visit</a> vg::to_visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>make_full_node_match</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="structvg_1_1Mapping.html">Mapping</a> to a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a>. The mapping must represent a full node match. If make_full_node_match is true, the mapping will automatically be made a full node match during the conversion process. </p>

</div>
</div>
<a id="a827ce532cdbd4710e86a21ebd986e1cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a827ce532cdbd4710e86a21ebd986e1cc">&#9670;&nbsp;</a></span>to_visit() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Visit.html">Visit</a> vg::to_visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>node_traversal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="classvg_1_1NodeTraversal.html">NodeTraversal</a> to a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a>. </p>

</div>
</div>
<a id="a0a18238f71586af9b3eba2ba1dac2a6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a18238f71586af9b3eba2ba1dac2a6e">&#9670;&nbsp;</a></span>to_visit() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Visit.html">Visit</a> vg::to_visit </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> from a snarl to traverse. </p>

</div>
</div>
<a id="aa76433c3398610bc58b842f2a4b462c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa76433c3398610bc58b842f2a4b462c7">&#9670;&nbsp;</a></span>to_visit() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Visit.html">Visit</a> vg::to_visit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make a <a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> from a node ID and an orientation. </p>

</div>
</div>
<a id="a3ca9ccb5a2301ed1ce48f6334b3c4937"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ca9ccb5a2301ed1ce48f6334b3c4937">&#9670;&nbsp;</a></span>topologically_order_subpaths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::topologically_order_subpaths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Put subpaths in topological order (assumed to be true for other algorithms) </p>

</div>
</div>
<a id="a0a064dd8829b2100c6a38780311073f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a064dd8829b2100c6a38780311073f3">&#9670;&nbsp;</a></span>total()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::total </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Support.html">Support</a> &amp;&#160;</td>
          <td class="paramname"><em>support</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the total read support in a <a class="el" href="structvg_1_1Support.html" title="Aggregates information about the reads supporting an allele.">Support</a>. </p>

</div>
</div>
<a id="a00a949105ae94b18ca72452a442b8ddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00a949105ae94b18ca72452a442b8ddb">&#9670;&nbsp;</a></span>toUppercase()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::toUppercase </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adcf3d4a70f85f067842ccf34a82a4a46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcf3d4a70f85f067842ccf34a82a4a46">&#9670;&nbsp;</a></span>toUppercaseInPlace()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::toUppercaseInPlace </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2d9774c4df98285526a427ba54e970ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9774c4df98285526a427ba54e970ba">&#9670;&nbsp;</a></span>trace_haplotypes_and_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::trace_haplotypes_and_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathHandleGraph.html">PathHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>source</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gbwt::GBWT &amp;&#160;</td>
          <td class="paramname"><em>haplotype_database</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">vg::id_t</a>&#160;</td>
          <td class="paramname"><em>start_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>extend_distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1algorithms_1_1Graph.html">Graph</a> &amp;&#160;</td>
          <td class="paramname"><em>out_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">map&lt; string, int &gt; &amp;&#160;</td>
          <td class="paramname"><em>out_thread_frequencies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>expand_graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a83257be63a821ae991e1b332b62facd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83257be63a821ae991e1b332b62facd4">&#9670;&nbsp;</a></span>trace_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; tuple&lt; int64_t, int64_t, int64_t &gt;, vector&lt; tuple&lt; int64_t, int64_t, int64_t, int64_t &gt; &gt; &gt; vg::trace_path </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>subpath_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>mapping_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>edit_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>base_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>search_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>search_limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns a pair of (mapping, edit, base) and possibly multiple (subpath, mapping, edit, base),of the furthest position that can be traced through the multipath alignment along the pathstarting the indicated position in the multipath alignment. The path can be traced rightward starting at the beginning, or leftward starting. Search is limited to not passing a given mapping on the path. </p>

</div>
</div>
<a id="aa44c63a293d251b1bffbbeee59d2b7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa44c63a293d251b1bffbbeee59d2b7fe">&#9670;&nbsp;</a></span>transcript_file_nonempty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::transcript_file_nonempty </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>transcripts</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac0534767a787eae1a5f93444bf21b2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0534767a787eae1a5f93444bf21b2a1">&#9670;&nbsp;</a></span>transfer_between_proto_annotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProtoAlignment1 , class ProtoAlignment2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::transfer_between_proto_annotation </td>
          <td>(</td>
          <td class="paramtype">const ProtoAlignment1 &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProtoAlignment2 &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a82a83d7c54d733abee06d328f91ef5ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82a83d7c54d733abee06d328f91ef5ee">&#9670;&nbsp;</a></span>transfer_boundary_info()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::transfer_boundary_info </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Snarl.html">Snarl</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the boundary Visits from one <a class="el" href="structvg_1_1Snarl.html" title="Describes a subgraph that is connected to the rest of the graph by two nodes.">Snarl</a> into another. </p>

</div>
</div>
<a id="a57c3f88ce9f85ceae2d77c32fd9de04d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57c3f88ce9f85ceae2d77c32fd9de04d">&#9670;&nbsp;</a></span>transfer_from_proto_annotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProtoAlignment &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::transfer_from_proto_annotation </td>
          <td>(</td>
          <td class="paramtype">const ProtoAlignment &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0582a68dfa130c9f0a2bdaa1c7ac5ef5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0582a68dfa130c9f0a2bdaa1c7ac5ef5">&#9670;&nbsp;</a></span>transfer_proto_metadata() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::transfer_proto_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Transfer the annotations that are carried with the Protobuf formats but not the internal <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> (and which therefore get lost when using it as an intermediate format). </p>

</div>
</div>
<a id="ad6476e86221a660dda1fa85254e9436d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6476e86221a660dda1fa85254e9436d">&#9670;&nbsp;</a></span>transfer_proto_metadata() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::transfer_proto_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af48acb91edce241c75a9a4fd02745620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af48acb91edce241c75a9a4fd02745620">&#9670;&nbsp;</a></span>transfer_read_metadata() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::transfer_read_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a54b4f608ad692caffd8fce4df9a1e4ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a54b4f608ad692caffd8fce4df9a1e4ef">&#9670;&nbsp;</a></span>transfer_read_metadata() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::transfer_read_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>All functions of this form transfer:</p><ul>
<li>sequence</li>
<li>base quality</li>
<li>mapping quality</li>
<li>read annotations (including multiple encodings of secondary) </li>
</ul>

</div>
</div>
<a id="a2d8929c8f610705661da889830b0b7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d8929c8f610705661da889830b0b7b9">&#9670;&nbsp;</a></span>transfer_read_metadata() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::transfer_read_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad0995c3042ff642b9e8aeaa1727dccb5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad0995c3042ff642b9e8aeaa1727dccb5">&#9670;&nbsp;</a></span>transfer_read_metadata() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::transfer_read_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acac375591689f0066f6c723dc25fb834"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acac375591689f0066f6c723dc25fb834">&#9670;&nbsp;</a></span>transfer_read_metadata() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::transfer_read_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a195fc7fa6da6fecfa7e9fa31e5cf6f0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a195fc7fa6da6fecfa7e9fa31e5cf6f0c">&#9670;&nbsp;</a></span>transfer_read_metadata() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::transfer_read_metadata </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1MultipathAlignment.html">MultipathAlignment</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a90a76dfce70406755151cf45e6990848"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90a76dfce70406755151cf45e6990848">&#9670;&nbsp;</a></span>transfer_to_proto_annotation()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class ProtoAlignment &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::transfer_to_proto_annotation </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ProtoAlignment &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adbf827b04e42865ece378b51482df898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbf827b04e42865ece378b51482df898">&#9670;&nbsp;</a></span>transfer_uniform_metadata()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class Alignment1 , class Alignment2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void vg::transfer_uniform_metadata </td>
          <td>(</td>
          <td class="paramtype">const Alignment1 &amp;&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Alignment2 &amp;&#160;</td>
          <td class="paramname"><em>to</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4bc1837d8c1cca33ab223957402b70ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bc1837d8c1cca33ab223957402b70ba">&#9670;&nbsp;</a></span>translate_mems()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; vg::translate_mems </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af71770196fc31c2e3c9c2a83f3497177"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af71770196fc31c2e3c9c2a83f3497177">&#9670;&nbsp;</a></span>translate_node_ids() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::translate_node_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>translator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches the node ids in the path to the ones indicated by the translator. </p>

</div>
</div>
<a id="aa49e4506c94e5747c88805e39aa18090"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa49e4506c94e5747c88805e39aa18090">&#9670;&nbsp;</a></span>translate_node_ids() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::translate_node_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>translator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>cut_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>bases_removed</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_right</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Replaces the node IDs in the path with the ones indicated by the translator. Supports a single cut node in the source graph, where the given number of bases of the given node were removed from its left or right side when making the source graph from the destination graph. </p>

</div>
</div>
<a id="a322ec292675d4891ecc265e56a836db7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a322ec292675d4891ecc265e56a836db7">&#9670;&nbsp;</a></span>translate_node_ids() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::translate_node_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>translator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a98dcd16f2a4eae4c223a374dd2ab2da4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98dcd16f2a4eae4c223a374dd2ab2da4">&#9670;&nbsp;</a></span>translate_nodes()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::translate_nodes </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>ids</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::function&lt; size_t(int64_t)&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acb86c984b743e10c6ddaa57612ca3991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb86c984b743e10c6ddaa57612ca3991">&#9670;&nbsp;</a></span>translate_oriented_node_ids() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::translate_oriented_node_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>translator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches node ids and orientations in the path to the ones indicated by the translator. </p>

</div>
</div>
<a id="a2b0ba7a1d0cf7630b79d03ba0ab65c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b0ba7a1d0cf7630b79d03ba0ab65c53">&#9670;&nbsp;</a></span>translate_oriented_node_ids() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::translate_oriented_node_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>translator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Switches the node ids and orientations in the path to the ones indicated by the translator. </p>

</div>
</div>
<a id="abfebb6e72326ea81b2ed13b4c3b57885"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfebb6e72326ea81b2ed13b4c3b57885">&#9670;&nbsp;</a></span>translate_oriented_node_ids() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::translate_oriented_node_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>translator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a449dd4b0d7106c6ee7afceb4f7412d6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a449dd4b0d7106c6ee7afceb4f7412d6d">&#9670;&nbsp;</a></span>translate_oriented_node_ids() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::translate_oriented_node_ids </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>translator</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1409ac23ce33abd463dcd46093079023"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1409ac23ce33abd463dcd46093079023">&#9670;&nbsp;</a></span>transpose()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; double &gt; &gt; vg::transpose </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; vector&lt; double &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>A</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A shitty set of linear algebra functions. </p>

</div>
</div>
<a id="a94385b32246fc81a0a44ea1b47d994ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94385b32246fc81a0a44ea1b47d994ee">&#9670;&nbsp;</a></span>traversal_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::traversal_to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a <a class="el" href="structvg_1_1SnarlTraversal.html">SnarlTraversal</a> into the string it represents, including notes for nested child snarls. </p>

</div>
</div>
<a id="ad83da8607e104967dd51d9230f4b51bb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad83da8607e104967dd51d9230f4b51bb">&#9670;&nbsp;</a></span>trim_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> vg::trim_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Position.html">Position</a> &amp;&#160;</td>
          <td class="paramname"><em>pos2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a990f54fb0e09dc439dace1519aff5e9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a990f54fb0e09dc439dace1519aff5e9f">&#9670;&nbsp;</a></span>trim_hanging_ends()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1Path.html">Path</a> vg::trim_hanging_ends </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>p</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77211f457b4e1f61915d771faf06cda0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77211f457b4e1f61915d771faf06cda0">&#9670;&nbsp;</a></span>trim_mismatches()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::trim_mismatches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1GaplessExtension.html">GaplessExtension</a> &amp;&#160;</td>
          <td class="paramname"><em>extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const gbwtgraph::CachedGBWTGraph &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> &amp;&#160;</td>
          <td class="paramname"><em>aligner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8d0345d2d7cea79ffdca38d33ed0c7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8d0345d2d7cea79ffdca38d33ed0c7f">&#9670;&nbsp;</a></span>trim_path()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::trim_path </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1path__t.html">path_t</a> *&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>mapping_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>edit_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>base_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9e61398cd459bb9ba3a1ced205491712"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e61398cd459bb9ba3a1ced205491712">&#9670;&nbsp;</a></span>trimmed_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">tuple&lt; <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a>, int64_t, int32_t &gt; vg::trimmed_end </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> &amp;&#160;</td>
          <td class="paramname"><em>aligner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd966c42f332957a1b9317faa3d26407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd966c42f332957a1b9317faa3d26407">&#9670;&nbsp;</a></span>uses_Us()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::uses_Us </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns true if the alignment sequence contains any U's and false if the alignment sequence contains and T's. In the case that both T's and U's are included, responds according to whichever comes first. If the sequence contains neither U's nor T's, returns false. </p>

</div>
</div>
<a id="a026842b7758f60f2be6a474cf41d3fe1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a026842b7758f60f2be6a474cf41d3fe1">&#9670;&nbsp;</a></span>validate_multipath_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::validate_multipath_alignment </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>handle_graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Debugging function to check that multipath alignment meets the formalism's basic invariants. Returns true if multipath alignment is valid, else false. Does not validate alignment score. </p>

</div>
</div>
<a id="aca53457219a2ced000f439df5bd0d71f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca53457219a2ced000f439df5bd0d71f">&#9670;&nbsp;</a></span>value_cast() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::protobuf::Value vg::value_cast </td>
          <td>(</td>
          <td class="paramtype">const Container &amp;&#160;</td>
          <td class="paramname"><em>wrap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a76fc86953f8c080621c080cd35bc9ae0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76fc86953f8c080621c080cd35bc9ae0">&#9670;&nbsp;</a></span>value_cast() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T vg::value_cast </td>
          <td>(</td>
          <td class="paramtype">const google::protobuf::Value &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a Protobuf generic Value to any type. </p>

</div>
</div>
<a id="a12109d27c9801031e32a408e75af2bd1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12109d27c9801031e32a408e75af2bd1">&#9670;&nbsp;</a></span>value_cast() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Container &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Container vg::value_cast </td>
          <td>(</td>
          <td class="paramtype">const google::protobuf::Value &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast a Protobuf generic Value to any type. </p>

</div>
</div>
<a id="ac84a9621d5108f53976d51f1188e7214"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac84a9621d5108f53976d51f1188e7214">&#9670;&nbsp;</a></span>value_cast() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::protobuf::Value vg::value_cast </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>wrap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Cast any type to a generic Protobuf value. </p>

</div>
</div>
<a id="ab572dfa4b65db43984f1572d74a94036"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab572dfa4b65db43984f1572d74a94036">&#9670;&nbsp;</a></span>value_cast&lt; bool &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::protobuf::Value <a class="el" href="namespacevg.html#a76fc86953f8c080621c080cd35bc9ae0">vg::value_cast</a>&lt; bool &gt; </td>
          <td>(</td>
          <td class="paramtype">const bool &amp;&#160;</td>
          <td class="paramname"><em>wrap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac90d23f22ad3ec78da4e03dc011cabf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac90d23f22ad3ec78da4e03dc011cabf8">&#9670;&nbsp;</a></span>value_cast&lt; bool &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="namespacevg.html#a76fc86953f8c080621c080cd35bc9ae0">vg::value_cast</a>&lt; bool &gt; </td>
          <td>(</td>
          <td class="paramtype">const google::protobuf::Value &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac16fdb4078f95e252450a80a1e9e14f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac16fdb4078f95e252450a80a1e9e14f2">&#9670;&nbsp;</a></span>value_cast&lt; double &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::protobuf::Value <a class="el" href="namespacevg.html#a76fc86953f8c080621c080cd35bc9ae0">vg::value_cast</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">const double &amp;&#160;</td>
          <td class="paramname"><em>wrap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a13a0cc45e4277281efeedb821c1444f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13a0cc45e4277281efeedb821c1444f6">&#9670;&nbsp;</a></span>value_cast&lt; double &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double <a class="el" href="namespacevg.html#a76fc86953f8c080621c080cd35bc9ae0">vg::value_cast</a>&lt; double &gt; </td>
          <td>(</td>
          <td class="paramtype">const google::protobuf::Value &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad1ca627c13de536f96efbc08934edb62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1ca627c13de536f96efbc08934edb62">&#9670;&nbsp;</a></span>value_cast&lt; int &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::protobuf::Value <a class="el" href="namespacevg.html#a76fc86953f8c080621c080cd35bc9ae0">vg::value_cast</a>&lt; int &gt; </td>
          <td>(</td>
          <td class="paramtype">const int &amp;&#160;</td>
          <td class="paramname"><em>wrap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2a12578ee636d9d929a9c1205e7c8525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a12578ee636d9d929a9c1205e7c8525">&#9670;&nbsp;</a></span>value_cast&lt; size_t &gt;()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::protobuf::Value <a class="el" href="namespacevg.html#a76fc86953f8c080621c080cd35bc9ae0">vg::value_cast</a>&lt; size_t &gt; </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>wrap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a16575a017d153499fe4a0976e801be61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16575a017d153499fe4a0976e801be61">&#9670;&nbsp;</a></span>value_cast&lt; string &gt;() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="namespacevg.html#a76fc86953f8c080621c080cd35bc9ae0">vg::value_cast</a>&lt; string &gt; </td>
          <td>(</td>
          <td class="paramtype">const google::protobuf::Value &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a51e6a112ff1115272420d46ca4316f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e6a112ff1115272420d46ca4316f63">&#9670;&nbsp;</a></span>value_cast&lt; string &gt;() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">google::protobuf::Value <a class="el" href="namespacevg.html#a76fc86953f8c080621c080cd35bc9ae0">vg::value_cast</a>&lt; string &gt; </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>wrap</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a96096594534e59d12b7a2cff3c400ef0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96096594534e59d12b7a2cff3c400ef0">&#9670;&nbsp;</a></span>variant_recall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::variant_recall </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vcflib::VariantCallFile *&#160;</td>
          <td class="paramname"><em>vars</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">FastaReference *&#160;</td>
          <td class="paramname"><em>ref_genome</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; FastaReference * &gt;&#160;</td>
          <td class="paramname"><em>insertions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string&#160;</td>
          <td class="paramname"><em>gamfile</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>run with : vg genotype -L -V v.vcf -I i.fa -R ref.fa </p>

</div>
</div>
<a id="a691144860bc63559aaf088d2e052af62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691144860bc63559aaf088d2e052af62">&#9670;&nbsp;</a></span>vcf_contigs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;string&gt; vg::vcf_contigs </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3ed0a4f26673002b2081832a7602e9bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ed0a4f26673002b2081832a7602e9bd">&#9670;&nbsp;</a></span>verify_path()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class PathType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool vg::verify_path </td>
          <td>(</td>
          <td class="paramtype">const PathType &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhandlegraph_1_1MutableHandleGraph.html">MutableHandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>unfolded</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">vg::id_t</a>, std::vector&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">vg::id_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>reverse_mapping</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a411a023efbe439f069829603a2775673"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a411a023efbe439f069829603a2775673">&#9670;&nbsp;</a></span>view_multipath_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::view_multipath_alignment </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>handle_graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Send a formatted string representation of the <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> into the ostream. </p>

</div>
</div>
<a id="a716909fc23ddaab59e0d2bf89fdd1ae3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716909fc23ddaab59e0d2bf89fdd1ae3">&#9670;&nbsp;</a></span>view_multipath_alignment_as_dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::view_multipath_alignment_as_dot </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>show_graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts a <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> to a GraphViz Dot representation, output to the given ostream. </p>

</div>
</div>
<a id="ae3a49e3aea82c8e552e4cf9fd8396ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae3a49e3aea82c8e552e4cf9fd8396ad4">&#9670;&nbsp;</a></span>visit_contained_snarls()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::visit_contained_snarls </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1PathPositionHandleGraph.html">PathPositionHandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Region.html">Region</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>regions</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_endpoints</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">function&lt; void(const <a class="el" href="structvg_1_1Snarl.html">Snarl</a> *, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, <a class="el" href="structhandlegraph_1_1step__handle__t.html">step_handle_t</a>, int64_t, int64_t, bool, const <a class="el" href="structvg_1_1Region.html">Region</a> *)&gt;&#160;</td>
          <td class="paramname"><em>visit_fn</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="structvg_1_1Visit.html" title="Describes a step of a walk through a Snarl either on a node or through a child Snarl.">Visit</a> each snarl if it is fully contained in at least one region from the input set. Only the top-most snarl is visited. The parameters to visit_fn are: &lt;the snarl, start_step, end_step, steps_reversed, the containing input region&gt; </p>

</div>
</div>
<a id="aec4813274fc2af3d83679e128fdeb32f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec4813274fc2af3d83679e128fdeb32f">&#9670;&nbsp;</a></span>vpmax()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;T&gt; vg::vpmax </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::vector&lt; T &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>vv</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a38d35bca25e8a6d5fe10f603cb9048c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d35bca25e8a6d5fe10f603cb9048c3">&#9670;&nbsp;</a></span>wang_hash_64()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::wang_hash_64 </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Thomas Wang's integer hash function. In many implementations, std::hash is identity function for integers, which leads to performance issues. </p>

</div>
</div>
<a id="a100efe5dfc5bfe434b53416f93d2a0e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a100efe5dfc5bfe434b53416f93d2a0e1">&#9670;&nbsp;</a></span>weibull_cdf()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::weibull_cdf </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>location</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return the CDF of a max exponential with the given parameters. </p>

</div>
</div>
<a id="ad93405cf370e6d92396691fc3320be1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad93405cf370e6d92396691fc3320be1c">&#9670;&nbsp;</a></span>weibull_log_likelihood()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::weibull_log_likelihood </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; double &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>shape</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>location</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the log likelihood of some data generated by a Weibull distribution. </p>

</div>
</div>
<a id="a4b96cd801bc780d426db346f80ab2172"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b96cd801bc780d426db346f80ab2172">&#9670;&nbsp;</a></span>wellford_mean_var()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; double, double &gt; vg::wellford_mean_var </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>sample_variance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a614c672ed69c280b699a278ce0f34ade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a614c672ed69c280b699a278ce0f34ade">&#9670;&nbsp;</a></span>wellford_update()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::wellford_update </td>
          <td>(</td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>M2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>new_val</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d2cbe5fe5e1b8a33b7d707f7059b3c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d2cbe5fe5e1b8a33b7d707f7059b3c6">&#9670;&nbsp;</a></span>with_exception_handling()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::with_exception_handling </td>
          <td>(</td>
          <td class="paramtype">const std::function&lt; void(void)&gt; &amp;&#160;</td>
          <td class="paramname"><em>body</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>User code should call this to get all its exceptions handled. </p>

</div>
</div>
<a id="a8e2c6fbf0d030acabb7dd6b8d428e143"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e2c6fbf0d030acabb7dd6b8d428e143">&#9670;&nbsp;</a></span>worst_alignment_score()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int32_t vg::worst_alignment_score </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the score of the lowest-scoring source-to-sink alignment in the <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a>. Assumes that subpaths are topologically ordered and starts have been identified. </p>

</div>
</div>
<a id="a57f111dda471f40192704110bae04a0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57f111dda471f40192704110bae04a0f">&#9670;&nbsp;</a></span>wrap_text()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::wrap_text </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81c8bc6d3b973fd1a34c3457a9d2e401"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81c8bc6d3b973fd1a34c3457a9d2e401">&#9670;&nbsp;</a></span>write_alignment_to_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::write_alignment_to_file </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a239160a6fee7d0af8914c4ebc7275c78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a239160a6fee7d0af8914c4ebc7275c78">&#9670;&nbsp;</a></span>write_fasta_sequence()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::write_fasta_sequence </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>sequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>width</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d8c71ff9f77ddd4a366119e83122771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d8c71ff9f77ddd4a366119e83122771">&#9670;&nbsp;</a></span>write_gcsa_kmers()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::write_gcsa_kmers </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kmer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>head_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>tail_id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write GCSA2 formatted binary KMers to the given ostream. size_limit is the maximum size of the kmer file in bytes. When the function returns, size_limit is the size of the kmer file in bytes. </p>

</div>
</div>
<a id="a38d9326cbc013aed614bc052c8c224e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38d9326cbc013aed614bc052c8c224e6">&#9670;&nbsp;</a></span>write_gcsa_kmers_to_tmpfile()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">string vg::write_gcsa_kmers_to_tmpfile </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kmer_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t &amp;&#160;</td>
          <td class="paramname"><em>size_limit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>head_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>tail_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>base_file_name</em> = <code>&quot;vg-kmers-tmp-&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Open a tempfile and write the kmers to it. The calling context should remove it with <a class="el" href="namespacevg_1_1temp__file.html#a9885078330e16129fccc5fb6d8717ec5">temp_file::remove()</a>. In the case that the size limit is exceeded, throws a <a class="el" href="classvg_1_1SizeLimitExceededException.html">SizeLimitExceededException</a> and deletes the temp file. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ade7204b42260155b9a98a6d18c24a0b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade7204b42260155b9a98a6d18c24a0b7">&#9670;&nbsp;</a></span>BAM_DNA_LOOKUP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* const vg::BAM_DNA_LOOKUP = &quot;=ACMGRSVTWYHKDBN&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abd1798abb6fcee86ab5b0539fb764eb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd1798abb6fcee86ab5b0539fb764eb2">&#9670;&nbsp;</a></span>fullTrace</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::fullTrace = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae77436235694e5e661c74799ab326d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae77436235694e5e661c74799ab326d0b">&#9670;&nbsp;</a></span>ISSUE_URL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* vg::ISSUE_URL = &quot;https://github.com/vgteam/vg/issues/new/choose&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0fc209aaa8c7c17499d70452d2816f44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0fc209aaa8c7c17499d70452d2816f44">&#9670;&nbsp;</a></span>NO_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvg_1_1alignment__index__t.html">alignment_index_t</a> vg::NO_INDEX {std::numeric_limits&lt;size_t&gt;::max(), std::numeric_limits&lt;size_t&gt;::max(), std::numeric_limits&lt;bool&gt;::max()}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents an unset index. </p>

</div>
</div>
<a id="aa32104605c22b25e9ec17d69fbc61a4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32104605c22b25e9ec17d69fbc61a4b">&#9670;&nbsp;</a></span>NO_READ_INDEX</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="structvg_1_1read__alignment__index__t.html">read_alignment_index_t</a> vg::NO_READ_INDEX = {std::numeric_limits&lt;size_t&gt;::infinity(), std::numeric_limits&lt;size_t&gt;::infinity()}</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Represents an unset index. </p>

</div>
</div>
<a id="aeb1b2d0c77858355b8bfbbe4406f0931"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb1b2d0c77858355b8bfbbe4406f0931">&#9670;&nbsp;</a></span>stored_crash_context</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">thread_local std::string vg::stored_crash_context</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afe7fae89b379b5411189ac0ac74b2dd4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe7fae89b379b5411189ac0ac74b2dd4">&#9670;&nbsp;</a></span>var</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* vg::var = &quot;VG_FULL_TRACEBACK&quot;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
