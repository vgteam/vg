<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::Pileups Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1Pileups.html">Pileups</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="classvg_1_1Pileups-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::Pileups Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;pileup.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a81156712ca4dd691905d6d9884df1b55"><td class="memItemLeft" align="right" valign="top">typedef spp::sparse_hash_map&lt; int64_t, <a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> *, <a class="el" href="structvg_1_1wang__hash.html">wang_hash</a>&lt; int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a81156712ca4dd691905d6d9884df1b55">NodePileupHash</a></td></tr>
<tr class="separator:a81156712ca4dd691905d6d9884df1b55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78543be08ac7141b012fb89dd04d3c87"><td class="memItemLeft" align="right" valign="top">typedef spp::sparse_hash_map&lt; pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;, <a class="el" href="structvg_1_1EdgePileup.html">EdgePileup</a> *, <a class="el" href="structvg_1_1wang__hash.html">wang_hash</a>&lt; pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a78543be08ac7141b012fb89dd04d3c87">EdgePileupHash</a></td></tr>
<tr class="separator:a78543be08ac7141b012fb89dd04d3c87"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a981effb71b5d6778be516e8c7c3152ac"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a981effb71b5d6778be516e8c7c3152ac">Pileups</a> (<a class="el" href="classvg_1_1VG.html">VG</a> *graph, int min_quality=0, int max_mismatches=1, int window_size=0, int max_depth=1000, bool use_mapq=false, bool strict_edge_support=false)</td></tr>
<tr class="separator:a981effb71b5d6778be516e8c7c3152ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab088376228d3e9a55614d5a7abcccd10"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#ab088376228d3e9a55614d5a7abcccd10">Pileups</a> (const <a class="el" href="classvg_1_1Pileups.html">Pileups</a> &amp;other)</td></tr>
<tr class="memdesc:ab088376228d3e9a55614d5a7abcccd10"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy constructor  <a href="#ab088376228d3e9a55614d5a7abcccd10">More...</a><br /></td></tr>
<tr class="separator:ab088376228d3e9a55614d5a7abcccd10"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c6b10101fcba001719273dc82bb40dc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a2c6b10101fcba001719273dc82bb40dc">Pileups</a> (<a class="el" href="classvg_1_1Pileups.html">Pileups</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a2c6b10101fcba001719273dc82bb40dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">move constructor  <a href="#a2c6b10101fcba001719273dc82bb40dc">More...</a><br /></td></tr>
<tr class="separator:a2c6b10101fcba001719273dc82bb40dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b1652ee48a9da72594e35dde54f0233"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Pileups.html">Pileups</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a4b1652ee48a9da72594e35dde54f0233">operator=</a> (const <a class="el" href="classvg_1_1Pileups.html">Pileups</a> &amp;other)</td></tr>
<tr class="memdesc:a4b1652ee48a9da72594e35dde54f0233"><td class="mdescLeft">&#160;</td><td class="mdescRight">copy assignment operator  <a href="#a4b1652ee48a9da72594e35dde54f0233">More...</a><br /></td></tr>
<tr class="separator:a4b1652ee48a9da72594e35dde54f0233"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9406946c8ffa200537354d84b11c1691"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Pileups.html">Pileups</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a9406946c8ffa200537354d84b11c1691">operator=</a> (<a class="el" href="classvg_1_1Pileups.html">Pileups</a> &amp;&amp;other) noexcept</td></tr>
<tr class="memdesc:a9406946c8ffa200537354d84b11c1691"><td class="mdescLeft">&#160;</td><td class="mdescRight">move assignment operator  <a href="#a9406946c8ffa200537354d84b11c1691">More...</a><br /></td></tr>
<tr class="separator:a9406946c8ffa200537354d84b11c1691"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a534e99280eccd403f4b5ac6104d6cf80"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a534e99280eccd403f4b5ac6104d6cf80">~Pileups</a> ()</td></tr>
<tr class="memdesc:a534e99280eccd403f4b5ac6104d6cf80"><td class="mdescLeft">&#160;</td><td class="mdescRight">delete contents of table  <a href="#a534e99280eccd403f4b5ac6104d6cf80">More...</a><br /></td></tr>
<tr class="separator:a534e99280eccd403f4b5ac6104d6cf80"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd546a6dcbac62ab1a501ba61108c4e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a1bd546a6dcbac62ab1a501ba61108c4e">clear</a> ()</td></tr>
<tr class="separator:a1bd546a6dcbac62ab1a501ba61108c4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0db435edc597819efff5ba61258734cd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a0db435edc597819efff5ba61258734cd">to_json</a> (ostream &amp;out)</td></tr>
<tr class="memdesc:a0db435edc597819efff5ba61258734cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">write to JSON  <a href="#a0db435edc597819efff5ba61258734cd">More...</a><br /></td></tr>
<tr class="separator:a0db435edc597819efff5ba61258734cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64fcca5a4aaf0b24cbd91d55e30d4587"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a64fcca5a4aaf0b24cbd91d55e30d4587">load</a> (istream &amp;in)</td></tr>
<tr class="memdesc:a64fcca5a4aaf0b24cbd91d55e30d4587"><td class="mdescLeft">&#160;</td><td class="mdescRight">read from protobuf  <a href="#a64fcca5a4aaf0b24cbd91d55e30d4587">More...</a><br /></td></tr>
<tr class="separator:a64fcca5a4aaf0b24cbd91d55e30d4587"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0585c8203f4755615d50f863ee69e4ae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a0585c8203f4755615d50f863ee69e4ae">write</a> (ostream &amp;out, size_t buffer_size=5)</td></tr>
<tr class="memdesc:a0585c8203f4755615d50f863ee69e4ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">write to protobuf, with EOF marker  <a href="#a0585c8203f4755615d50f863ee69e4ae">More...</a><br /></td></tr>
<tr class="separator:a0585c8203f4755615d50f863ee69e4ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57d574b82b4b612858d03acac1926425"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a57d574b82b4b612858d03acac1926425">for_each_node_pileup</a> (const function&lt; void(<a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> &amp;)&gt; &amp;lambda)</td></tr>
<tr class="memdesc:a57d574b82b4b612858d03acac1926425"><td class="mdescLeft">&#160;</td><td class="mdescRight">apply function to each pileup in table  <a href="#a57d574b82b4b612858d03acac1926425">More...</a><br /></td></tr>
<tr class="separator:a57d574b82b4b612858d03acac1926425"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e8b9fee616eefe46c199e2a4ac0aeff"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a3e8b9fee616eefe46c199e2a4ac0aeff">get_node_pileup</a> (int64_t node_id)</td></tr>
<tr class="memdesc:a3e8b9fee616eefe46c199e2a4ac0aeff"><td class="mdescLeft">&#160;</td><td class="mdescRight">search hash table for node id  <a href="#a3e8b9fee616eefe46c199e2a4ac0aeff">More...</a><br /></td></tr>
<tr class="separator:a3e8b9fee616eefe46c199e2a4ac0aeff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cac5c176e990c44c2e6d76909a7f969"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a9cac5c176e990c44c2e6d76909a7f969">get_create_node_pileup</a> (const <a class="el" href="structvg_1_1Node.html">Node</a> *node)</td></tr>
<tr class="memdesc:a9cac5c176e990c44c2e6d76909a7f969"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pileup. if it's null, create a new one and insert it.  <a href="#a9cac5c176e990c44c2e6d76909a7f969">More...</a><br /></td></tr>
<tr class="separator:a9cac5c176e990c44c2e6d76909a7f969"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d01d77749a72567f5e4a945e52c83da"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a2d01d77749a72567f5e4a945e52c83da">for_each_edge_pileup</a> (const function&lt; void(<a class="el" href="structvg_1_1EdgePileup.html">EdgePileup</a> &amp;)&gt; &amp;lambda)</td></tr>
<tr class="separator:a2d01d77749a72567f5e4a945e52c83da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dc9a6e8a14d7848d92072a83e1b6669"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1EdgePileup.html">EdgePileup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a0dc9a6e8a14d7848d92072a83e1b6669">get_edge_pileup</a> (pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; sides)</td></tr>
<tr class="memdesc:a0dc9a6e8a14d7848d92072a83e1b6669"><td class="mdescLeft">&#160;</td><td class="mdescRight">search hash table for edge id  <a href="#a0dc9a6e8a14d7848d92072a83e1b6669">More...</a><br /></td></tr>
<tr class="separator:a0dc9a6e8a14d7848d92072a83e1b6669"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af23ee2221884522d902408671e3f843b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1EdgePileup.html">EdgePileup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#af23ee2221884522d902408671e3f843b">get_create_edge_pileup</a> (pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt; sides)</td></tr>
<tr class="memdesc:af23ee2221884522d902408671e3f843b"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pileup. if it's null, create a new one and insert it.  <a href="#af23ee2221884522d902408671e3f843b">More...</a><br /></td></tr>
<tr class="separator:af23ee2221884522d902408671e3f843b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61fb12878bae89e5d33eaef75f26d6a0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a61fb12878bae89e5d33eaef75f26d6a0">extend</a> (<a class="el" href="structvg_1_1Pileup.html">Pileup</a> &amp;pileup)</td></tr>
<tr class="separator:a61fb12878bae89e5d33eaef75f26d6a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af320f1f78612b1fe0f092a44c6191a45"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#af320f1f78612b1fe0f092a44c6191a45">insert_node_pileup</a> (<a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> *pileup)</td></tr>
<tr class="separator:af320f1f78612b1fe0f092a44c6191a45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56d273cfc5d5867e74efdf3b06e8653f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a56d273cfc5d5867e74efdf3b06e8653f">insert_edge_pileup</a> (<a class="el" href="structvg_1_1EdgePileup.html">EdgePileup</a> *edge_pileup)</td></tr>
<tr class="separator:a56d273cfc5d5867e74efdf3b06e8653f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40423fdfa7c0dea06ed60134de7857b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a40423fdfa7c0dea06ed60134de7857b9">compute_from_alignment</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment)</td></tr>
<tr class="memdesc:a40423fdfa7c0dea06ed60134de7857b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">create / update all pileups from a single alignment  <a href="#a40423fdfa7c0dea06ed60134de7857b9">More...</a><br /></td></tr>
<tr class="separator:a40423fdfa7c0dea06ed60134de7857b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e76b1bcd067e49623e2e3844ac67146"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a6e76b1bcd067e49623e2e3844ac67146">compute_from_edit</a> (<a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> &amp;pileup, int64_t &amp;node_offset, int64_t &amp;read_offset, const <a class="el" href="structvg_1_1Node.html">Node</a> &amp;node, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mapping, const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;edit, const <a class="el" href="structvg_1_1Edit.html">Edit</a> *next_edit, const vector&lt; int &gt; &amp;mismatch_counts, pair&lt; const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> *, int64_t &gt; &amp;last_match, pair&lt; const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> *, int64_t &gt; &amp;last_del, pair&lt; const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> *, int64_t &gt; &amp;open_del)</td></tr>
<tr class="separator:a6e76b1bcd067e49623e2e3844ac67146"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9ecef785061ece0f3da8994f7b3fd9c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#aa9ecef785061ece0f3da8994f7b3fd9c">pass_filter</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, int64_t read_offset, int64_t length, const vector&lt; int &gt; &amp;mismatches) const</td></tr>
<tr class="memdesc:aa9ecef785061ece0f3da8994f7b3fd9c"><td class="mdescLeft">&#160;</td><td class="mdescRight">check base quality as well as miss match filter  <a href="#aa9ecef785061ece0f3da8994f7b3fd9c">More...</a><br /></td></tr>
<tr class="separator:aa9ecef785061ece0f3da8994f7b3fd9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8b072ad1bd89a7b166e09aa385e7ee"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Pileups.html">Pileups</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a1b8b072ad1bd89a7b166e09aa385e7ee">merge</a> (<a class="el" href="classvg_1_1Pileups.html">Pileups</a> &amp;other)</td></tr>
<tr class="separator:a1b8b072ad1bd89a7b166e09aa385e7ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae04d22ed29096e3a2b12212e06e014f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#aae04d22ed29096e3a2b12212e06e014f">merge_base_pileups</a> (<a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> &amp;p1, <a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> &amp;p2)</td></tr>
<tr class="memdesc:aae04d22ed29096e3a2b12212e06e014f"><td class="mdescLeft">&#160;</td><td class="mdescRight">merge p2 into p1 and return 1. p2 is left an empty husk  <a href="#aae04d22ed29096e3a2b12212e06e014f">More...</a><br /></td></tr>
<tr class="separator:aae04d22ed29096e3a2b12212e06e014f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6c6de7ba4448d281536d9aaf3a1024a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#ad6c6de7ba4448d281536d9aaf3a1024a">merge_node_pileups</a> (<a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> &amp;p1, <a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> &amp;p2)</td></tr>
<tr class="memdesc:ad6c6de7ba4448d281536d9aaf3a1024a"><td class="mdescLeft">&#160;</td><td class="mdescRight">merge p2 into p1 and return 1. p2 is lef an empty husk  <a href="#ad6c6de7ba4448d281536d9aaf3a1024a">More...</a><br /></td></tr>
<tr class="separator:ad6c6de7ba4448d281536d9aaf3a1024a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb147fd284015205bd856b280ca0d58d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1EdgePileup.html">EdgePileup</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#abb147fd284015205bd856b280ca0d58d">merge_edge_pileups</a> (<a class="el" href="structvg_1_1EdgePileup.html">EdgePileup</a> &amp;p1, <a class="el" href="structvg_1_1EdgePileup.html">EdgePileup</a> &amp;p2)</td></tr>
<tr class="memdesc:abb147fd284015205bd856b280ca0d58d"><td class="mdescLeft">&#160;</td><td class="mdescRight">merge p2 into p1 and return 1. p2 is lef an empty husk  <a href="#abb147fd284015205bd856b280ca0d58d">More...</a><br /></td></tr>
<tr class="separator:abb147fd284015205bd856b280ca0d58d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31045fb78332c6e740d33bd14e0a2f63"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a31045fb78332c6e740d33bd14e0a2f63">combined_quality</a> (char base_quality, int map_quality) const</td></tr>
<tr class="memdesc:a31045fb78332c6e740d33bd14e0a2f63"><td class="mdescLeft">&#160;</td><td class="mdescRight">create combine map quality (optionally) with base quality  <a href="#a31045fb78332c6e740d33bd14e0a2f63">More...</a><br /></td></tr>
<tr class="separator:a31045fb78332c6e740d33bd14e0a2f63"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a9daae92b7e7954d755f834498d4934df"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a9daae92b7e7954d755f834498d4934df">count_mismatches</a> (<a class="el" href="classvg_1_1VG.html">VG</a> &amp;graph, const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;path, vector&lt; int &gt; &amp;mismatches, bool skipIndels=false)</td></tr>
<tr class="separator:a9daae92b7e7954d755f834498d4934df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a349f056902aa97c602945941b78570fa"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a349f056902aa97c602945941b78570fa">get_base_pileup</a> (<a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> &amp;np, int64_t <a class="el" href="namespacevg.html#a416939020600ce2996331c350f1fe68c">offset</a>)</td></tr>
<tr class="memdesc:a349f056902aa97c602945941b78570fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">get ith <a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> record  <a href="#a349f056902aa97c602945941b78570fa">More...</a><br /></td></tr>
<tr class="separator:a349f056902aa97c602945941b78570fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a627ffd6cd2e340f90b3c3d60011b137a"><td class="memItemLeft" align="right" valign="top">static const <a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a627ffd6cd2e340f90b3c3d60011b137a">get_base_pileup</a> (const <a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> &amp;np, int64_t <a class="el" href="namespacevg.html#a416939020600ce2996331c350f1fe68c">offset</a>)</td></tr>
<tr class="separator:a627ffd6cd2e340f90b3c3d60011b137a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9ea0eb777b7c9976598d4a13fb67d49"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#af9ea0eb777b7c9976598d4a13fb67d49">get_create_base_pileup</a> (<a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> &amp;np, int64_t <a class="el" href="namespacevg.html#a416939020600ce2996331c350f1fe68c">offset</a>)</td></tr>
<tr class="memdesc:af9ea0eb777b7c9976598d4a13fb67d49"><td class="mdescLeft">&#160;</td><td class="mdescRight">get ith <a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> record, create if doesn't exist  <a href="#af9ea0eb777b7c9976598d4a13fb67d49">More...</a><br /></td></tr>
<tr class="separator:af9ea0eb777b7c9976598d4a13fb67d49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45c8a726bf3d3abf2546bc69a9a233d3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a45c8a726bf3d3abf2546bc69a9a233d3">parse_base_offsets</a> (const <a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> &amp;bp, vector&lt; pair&lt; int64_t, int64_t &gt; &gt; &amp;offsets)</td></tr>
<tr class="separator:a45c8a726bf3d3abf2546bc69a9a233d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cfd8c66f4777b5997ac86511b63398a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a2cfd8c66f4777b5997ac86511b63398a">casify</a> (string &amp;seq, bool is_reverse)</td></tr>
<tr class="memdesc:a2cfd8c66f4777b5997ac86511b63398a"><td class="mdescLeft">&#160;</td><td class="mdescRight">transform case of every character in string  <a href="#a2cfd8c66f4777b5997ac86511b63398a">More...</a><br /></td></tr>
<tr class="separator:a2cfd8c66f4777b5997ac86511b63398a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1d327ef23fbc70883e9d70c931121ed"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#ab1d327ef23fbc70883e9d70c931121ed">make_match</a> (string &amp;seq, int64_t <a class="el" href="namespacevg.html#a83d1f079508a3ee8a2705773109a5a8e">from_length</a>, bool is_reverse)</td></tr>
<tr class="memdesc:ab1d327ef23fbc70883e9d70c931121ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">make the sam pileup style token  <a href="#ab1d327ef23fbc70883e9d70c931121ed">More...</a><br /></td></tr>
<tr class="separator:ab1d327ef23fbc70883e9d70c931121ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176af241b5113498330d9c3ed076adb3"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a176af241b5113498330d9c3ed076adb3">make_insert</a> (string &amp;seq, bool is_reverse)</td></tr>
<tr class="separator:a176af241b5113498330d9c3ed076adb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2917632822b6bce5084fc3bfc24965e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#ab2917632822b6bce5084fc3bfc24965e">make_delete</a> (string &amp;seq, bool is_reverse, const pair&lt; const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> *, int64_t &gt; &amp;last_match, const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;mapping, int64_t node_offset)</td></tr>
<tr class="separator:ab2917632822b6bce5084fc3bfc24965e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c6639579bc521c6ef81e33e20dfbb30"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a3c6639579bc521c6ef81e33e20dfbb30">make_delete</a> (string &amp;seq, bool is_reverse, int64_t from_id, int64_t from_offset, bool from_start, int64_t to_id, int64_t to_offset, bool to_end)</td></tr>
<tr class="separator:a3c6639579bc521c6ef81e33e20dfbb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe5b378ac99c223fe1780c5e27832e2"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#abfe5b378ac99c223fe1780c5e27832e2">parse_insert</a> (const string &amp;tok, int64_t &amp;len, string &amp;seq, bool &amp;is_reverse)</td></tr>
<tr class="separator:abfe5b378ac99c223fe1780c5e27832e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59bb8031b052a628b3d9100a7ba6d2dc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a59bb8031b052a628b3d9100a7ba6d2dc">parse_delete</a> (const string &amp;tok, bool &amp;is_reverse, int64_t &amp;from_id, int64_t &amp;from_offset, bool &amp;from_start, int64_t &amp;to_id, int64_t &amp;to_offset, bool &amp;to_end)</td></tr>
<tr class="separator:a59bb8031b052a628b3d9100a7ba6d2dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f998d4a10664dfe3367ca82fff85a19"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a2f998d4a10664dfe3367ca82fff85a19">base_equal</a> (char c1, char c2, bool is_reverse)</td></tr>
<tr class="separator:a2f998d4a10664dfe3367ca82fff85a19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa1e9892f26c161145aec4f0be3277527"><td class="memItemLeft" align="right" valign="top">static char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#aa1e9892f26c161145aec4f0be3277527">extract_match</a> (const <a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> &amp;bp, int64_t <a class="el" href="namespacevg.html#a416939020600ce2996331c350f1fe68c">offset</a>)</td></tr>
<tr class="memdesc:aa1e9892f26c161145aec4f0be3277527"><td class="mdescLeft">&#160;</td><td class="mdescRight">get a pileup value on forward strand  <a href="#aa1e9892f26c161145aec4f0be3277527">More...</a><br /></td></tr>
<tr class="separator:aa1e9892f26c161145aec4f0be3277527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abefbe50ce820bd0e5b93578b5782a07d"><td class="memItemLeft" align="right" valign="top">static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#abefbe50ce820bd0e5b93578b5782a07d">extract</a> (const <a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> &amp;bp, int64_t <a class="el" href="namespacevg.html#a416939020600ce2996331c350f1fe68c">offset</a>)</td></tr>
<tr class="memdesc:abefbe50ce820bd0e5b93578b5782a07d"><td class="mdescLeft">&#160;</td><td class="mdescRight">get arbitrary value from offset on forward strand  <a href="#abefbe50ce820bd0e5b93578b5782a07d">More...</a><br /></td></tr>
<tr class="separator:abefbe50ce820bd0e5b93578b5782a07d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a57532ec0e7dba81c24a0d37352a1e218"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1VG.html">VG</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a57532ec0e7dba81c24a0d37352a1e218">_graph</a></td></tr>
<tr class="separator:a57532ec0e7dba81c24a0d37352a1e218"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa807699679536a2f32b41f77479f6273"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Pileups.html#a81156712ca4dd691905d6d9884df1b55">NodePileupHash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#aa807699679536a2f32b41f77479f6273">_node_pileups</a></td></tr>
<tr class="memdesc:aa807699679536a2f32b41f77479f6273"><td class="mdescLeft">&#160;</td><td class="mdescRight">This maps from <a class="el" href="structvg_1_1Position.html">Position</a> to <a class="el" href="structvg_1_1Pileup.html" title="Bundle up Node and Edge pileups. ">Pileup</a>.  <a href="#aa807699679536a2f32b41f77479f6273">More...</a><br /></td></tr>
<tr class="separator:aa807699679536a2f32b41f77479f6273"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f3d0431209ade782e671be0ad84d4d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1Pileups.html#a78543be08ac7141b012fb89dd04d3c87">EdgePileupHash</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#af6f3d0431209ade782e671be0ad84d4d">_edge_pileups</a></td></tr>
<tr class="separator:af6f3d0431209ade782e671be0ad84d4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a848eb55fb5270a30c239df6d17bb3bbb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a848eb55fb5270a30c239df6d17bb3bbb">_min_quality</a></td></tr>
<tr class="memdesc:a848eb55fb5270a30c239df6d17bb3bbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Ignore bases with quality less than this.  <a href="#a848eb55fb5270a30c239df6d17bb3bbb">More...</a><br /></td></tr>
<tr class="separator:a848eb55fb5270a30c239df6d17bb3bbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a883fcc490157b4ce8facd6e7303510c7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a883fcc490157b4ce8facd6e7303510c7">_max_mismatches</a></td></tr>
<tr class="memdesc:a883fcc490157b4ce8facd6e7303510c7"><td class="mdescLeft">&#160;</td><td class="mdescRight">max mismatches within window_size  <a href="#a883fcc490157b4ce8facd6e7303510c7">More...</a><br /></td></tr>
<tr class="separator:a883fcc490157b4ce8facd6e7303510c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a704565fa7d0517847b207ad0ff44f1d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a704565fa7d0517847b207ad0ff44f1d9">_window_size</a></td></tr>
<tr class="memdesc:a704565fa7d0517847b207ad0ff44f1d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">number of bases to scan in each direction for mismatches  <a href="#a704565fa7d0517847b207ad0ff44f1d9">More...</a><br /></td></tr>
<tr class="separator:a704565fa7d0517847b207ad0ff44f1d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a772a6d4845989e28afc651bfdb8d039f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a772a6d4845989e28afc651bfdb8d039f">_max_depth</a></td></tr>
<tr class="memdesc:a772a6d4845989e28afc651bfdb8d039f"><td class="mdescLeft">&#160;</td><td class="mdescRight">prevent giant protobufs  <a href="#a772a6d4845989e28afc651bfdb8d039f">More...</a><br /></td></tr>
<tr class="separator:a772a6d4845989e28afc651bfdb8d039f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3257a69f673539d48d2c42124bfd28d5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a3257a69f673539d48d2c42124bfd28d5">_use_mapq</a></td></tr>
<tr class="memdesc:a3257a69f673539d48d2c42124bfd28d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">toggle whether we incorporate <a class="el" href="structvg_1_1Alignment.html#a78851a70cc8a3e8f3e71409693130230" title="The mapping quality score for the alignment, in Phreds. ">Alignment.mapping_quality</a>  <a href="#a3257a69f673539d48d2c42124bfd28d5">More...</a><br /></td></tr>
<tr class="separator:a3257a69f673539d48d2c42124bfd28d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a250b89737a7bd667f564cacfdb7d01aa"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a250b89737a7bd667f564cacfdb7d01aa">_strict_edge_support</a></td></tr>
<tr class="memdesc:a250b89737a7bd667f564cacfdb7d01aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">toggle whether we only count edges if they are not book-ended by matches in the read  <a href="#a250b89737a7bd667f564cacfdb7d01aa">More...</a><br /></td></tr>
<tr class="separator:a250b89737a7bd667f564cacfdb7d01aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8c18d3f5372b4e827f91a1f417480c"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#aab8c18d3f5372b4e827f91a1f417480c">_min_quality_count</a></td></tr>
<tr class="memdesc:aab8c18d3f5372b4e827f91a1f417480c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Keep count of bases filtered by quality.  <a href="#aab8c18d3f5372b4e827f91a1f417480c">More...</a><br /></td></tr>
<tr class="separator:aab8c18d3f5372b4e827f91a1f417480c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35303a2b5b04b80592fec8d7c6cd3fa2"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a35303a2b5b04b80592fec8d7c6cd3fa2">_max_mismatch_count</a></td></tr>
<tr class="memdesc:a35303a2b5b04b80592fec8d7c6cd3fa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">keep count of bases filtered by mismatches  <a href="#a35303a2b5b04b80592fec8d7c6cd3fa2">More...</a><br /></td></tr>
<tr class="separator:a35303a2b5b04b80592fec8d7c6cd3fa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0839051b1cbf865ed5c1252a8425f4b9"><td class="memItemLeft" align="right" valign="top">uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1Pileups.html#a0839051b1cbf865ed5c1252a8425f4b9">_bases_count</a></td></tr>
<tr class="memdesc:a0839051b1cbf865ed5c1252a8425f4b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">overall count for perspective on above  <a href="#a0839051b1cbf865ed5c1252a8425f4b9">More...</a><br /></td></tr>
<tr class="separator:a0839051b1cbf865ed5c1252a8425f4b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This is a collection of protobuf <a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> records that are indexed on their position, as well as <a class="el" href="structvg_1_1EdgePileup.html" title="Keep pileup-like record for reads that span edges. ">EdgePileup</a> records. <a class="el" href="classvg_1_1Pileups.html">Pileups</a> can be merged and streamed, and computed from Alignments. The pileup records themselves are essentially protobuf versions of lines in Samtools pileup format, with deletions represented using a graph-based notation. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a78543be08ac7141b012fb89dd04d3c87"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78543be08ac7141b012fb89dd04d3c87">&#9670;&nbsp;</a></span>EdgePileupHash</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef spp::sparse_hash_map&lt;pair&lt;<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&gt;, <a class="el" href="structvg_1_1EdgePileup.html">EdgePileup</a>*, <a class="el" href="structvg_1_1wang__hash.html">wang_hash</a>&lt;pair&lt;<a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>&gt; &gt; &gt; <a class="el" href="classvg_1_1Pileups.html#a78543be08ac7141b012fb89dd04d3c87">vg::Pileups::EdgePileupHash</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a81156712ca4dd691905d6d9884df1b55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81156712ca4dd691905d6d9884df1b55">&#9670;&nbsp;</a></span>NodePileupHash</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef spp::sparse_hash_map&lt;int64_t, <a class="el" href="structvg_1_1NodePileup.html">NodePileup</a>*, <a class="el" href="structvg_1_1wang__hash.html">wang_hash</a>&lt;int64_t&gt; &gt; <a class="el" href="classvg_1_1Pileups.html#a81156712ca4dd691905d6d9884df1b55">vg::Pileups::NodePileupHash</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a981effb71b5d6778be516e8c7c3152ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a981effb71b5d6778be516e8c7c3152ac">&#9670;&nbsp;</a></span>Pileups() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::Pileups::Pileups </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_quality</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_mismatches</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>window_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_depth</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_mapq</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>strict_edge_support</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab088376228d3e9a55614d5a7abcccd10"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab088376228d3e9a55614d5a7abcccd10">&#9670;&nbsp;</a></span>Pileups() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::Pileups::Pileups </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Pileups.html">Pileups</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy constructor </p>

</div>
</div>
<a id="a2c6b10101fcba001719273dc82bb40dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c6b10101fcba001719273dc82bb40dc">&#9670;&nbsp;</a></span>Pileups() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::Pileups::Pileups </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1Pileups.html">Pileups</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move constructor </p>

</div>
</div>
<a id="a534e99280eccd403f4b5ac6104d6cf80"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a534e99280eccd403f4b5ac6104d6cf80">&#9670;&nbsp;</a></span>~Pileups()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::Pileups::~Pileups </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>delete contents of table </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a2f998d4a10664dfe3367ca82fff85a19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f998d4a10664dfe3367ca82fff85a19">&#9670;&nbsp;</a></span>base_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Pileups::base_equal </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>c2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cfd8c66f4777b5997ac86511b63398a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cfd8c66f4777b5997ac86511b63398a">&#9670;&nbsp;</a></span>casify()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Pileups::casify </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>transform case of every character in string </p>

</div>
</div>
<a id="a1bd546a6dcbac62ab1a501ba61108c4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd546a6dcbac62ab1a501ba61108c4e">&#9670;&nbsp;</a></span>clear()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Pileups::clear </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31045fb78332c6e740d33bd14e0a2f63"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31045fb78332c6e740d33bd14e0a2f63">&#9670;&nbsp;</a></span>combined_quality()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char vg::Pileups::combined_quality </td>
          <td>(</td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>base_quality</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>map_quality</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>create combine map quality (optionally) with base quality </p>

</div>
</div>
<a id="a40423fdfa7c0dea06ed60134de7857b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40423fdfa7c0dea06ed60134de7857b9">&#9670;&nbsp;</a></span>compute_from_alignment()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Pileups::compute_from_alignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create / update all pileups from a single alignment </p>

</div>
</div>
<a id="a6e76b1bcd067e49623e2e3844ac67146"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e76b1bcd067e49623e2e3844ac67146">&#9670;&nbsp;</a></span>compute_from_edit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Pileups::compute_from_edit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> &amp;&#160;</td>
          <td class="paramname"><em>pileup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>node_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>read_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Node.html">Node</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edit.html">Edit</a> &amp;&#160;</td>
          <td class="paramname"><em>edit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Edit.html">Edit</a> *&#160;</td>
          <td class="paramname"><em>next_edit</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mismatch_counts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pair&lt; const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> *, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>last_match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pair&lt; const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> *, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>last_del</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">pair&lt; const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> *, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>open_del</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>create / update all pileups from an edit (called by above). query stores the current position (and nothing else). </p>

</div>
</div>
<a id="a9daae92b7e7954d755f834498d4934df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9daae92b7e7954d755f834498d4934df">&#9670;&nbsp;</a></span>count_mismatches()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Pileups::count_mismatches </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1VG.html">VG</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Path.html">Path</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mismatches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>skipIndels</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>do one pass to count all mismatches in read, so we can do mismatch filter efficiently in 2nd path. mismatches[i] stores number of mismatches in range (0, i) </p>

</div>
</div>
<a id="a61fb12878bae89e5d33eaef75f26d6a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61fb12878bae89e5d33eaef75f26d6a0">&#9670;&nbsp;</a></span>extend()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Pileups::extend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Pileup.html">Pileup</a> &amp;&#160;</td>
          <td class="paramname"><em>pileup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abefbe50ce820bd0e5b93578b5782a07d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abefbe50ce820bd0e5b93578b5782a07d">&#9670;&nbsp;</a></span>extract()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string vg::Pileups::extract </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get arbitrary value from offset on forward strand </p>

</div>
</div>
<a id="aa1e9892f26c161145aec4f0be3277527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa1e9892f26c161145aec4f0be3277527">&#9670;&nbsp;</a></span>extract_match()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char vg::Pileups::extract_match </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pileup value on forward strand </p>

</div>
</div>
<a id="a2d01d77749a72567f5e4a945e52c83da"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d01d77749a72567f5e4a945e52c83da">&#9670;&nbsp;</a></span>for_each_edge_pileup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Pileups::for_each_edge_pileup </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(<a class="el" href="structvg_1_1EdgePileup.html">EdgePileup</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a57d574b82b4b612858d03acac1926425"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57d574b82b4b612858d03acac1926425">&#9670;&nbsp;</a></span>for_each_node_pileup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Pileups::for_each_node_pileup </td>
          <td>(</td>
          <td class="paramtype">const function&lt; void(<a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>lambda</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>apply function to each pileup in table </p>

</div>
</div>
<a id="a349f056902aa97c602945941b78570fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a349f056902aa97c602945941b78570fa">&#9670;&nbsp;</a></span>get_base_pileup() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structvg_1_1BasePileup.html">BasePileup</a>* vg::Pileups::get_base_pileup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> &amp;&#160;</td>
          <td class="paramname"><em>np</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get ith <a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> record </p>

</div>
</div>
<a id="a627ffd6cd2e340f90b3c3d60011b137a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a627ffd6cd2e340f90b3c3d60011b137a">&#9670;&nbsp;</a></span>get_base_pileup() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const <a class="el" href="structvg_1_1BasePileup.html">BasePileup</a>* vg::Pileups::get_base_pileup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> &amp;&#160;</td>
          <td class="paramname"><em>np</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af9ea0eb777b7c9976598d4a13fb67d49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9ea0eb777b7c9976598d4a13fb67d49">&#9670;&nbsp;</a></span>get_create_base_pileup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structvg_1_1BasePileup.html">BasePileup</a>* vg::Pileups::get_create_base_pileup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> &amp;&#160;</td>
          <td class="paramname"><em>np</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get ith <a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> record, create if doesn't exist </p>

</div>
</div>
<a id="af23ee2221884522d902408671e3f843b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af23ee2221884522d902408671e3f843b">&#9670;&nbsp;</a></span>get_create_edge_pileup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1EdgePileup.html">EdgePileup</a> * vg::Pileups::get_create_edge_pileup </td>
          <td>(</td>
          <td class="paramtype">pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;&#160;</td>
          <td class="paramname"><em>sides</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>get a pileup. if it's null, create a new one and insert it. </p>

</div>
</div>
<a id="a9cac5c176e990c44c2e6d76909a7f969"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cac5c176e990c44c2e6d76909a7f969">&#9670;&nbsp;</a></span>get_create_node_pileup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1NodePileup.html">NodePileup</a>* vg::Pileups::get_create_node_pileup </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Node.html">Node</a> *&#160;</td>
          <td class="paramname"><em>node</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get a pileup. if it's null, create a new one and insert it. </p>

</div>
</div>
<a id="a0dc9a6e8a14d7848d92072a83e1b6669"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dc9a6e8a14d7848d92072a83e1b6669">&#9670;&nbsp;</a></span>get_edge_pileup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1EdgePileup.html">EdgePileup</a> * vg::Pileups::get_edge_pileup </td>
          <td>(</td>
          <td class="paramtype">pair&lt; <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a>, <a class="el" href="classvg_1_1NodeSide.html">NodeSide</a> &gt;&#160;</td>
          <td class="paramname"><em>sides</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>search hash table for edge id </p>

</div>
</div>
<a id="a3e8b9fee616eefe46c199e2a4ac0aeff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e8b9fee616eefe46c199e2a4ac0aeff">&#9670;&nbsp;</a></span>get_node_pileup()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1NodePileup.html">NodePileup</a>* vg::Pileups::get_node_pileup </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>search hash table for node id </p>

</div>
</div>
<a id="a56d273cfc5d5867e74efdf3b06e8653f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a56d273cfc5d5867e74efdf3b06e8653f">&#9670;&nbsp;</a></span>insert_edge_pileup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Pileups::insert_edge_pileup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1EdgePileup.html">EdgePileup</a> *&#160;</td>
          <td class="paramname"><em>edge_pileup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af320f1f78612b1fe0f092a44c6191a45"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af320f1f78612b1fe0f092a44c6191a45">&#9670;&nbsp;</a></span>insert_node_pileup()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Pileups::insert_node_pileup </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> *&#160;</td>
          <td class="paramname"><em>pileup</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>insert a pileup into the table. it will be deleted by <a class="el" href="classvg_1_1Pileups.html#a534e99280eccd403f4b5ac6104d6cf80" title="delete contents of table ">~Pileups()</a>!!! return true if new pileup inserted, false if merged into existing one </p>

</div>
</div>
<a id="a64fcca5a4aaf0b24cbd91d55e30d4587"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64fcca5a4aaf0b24cbd91d55e30d4587">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Pileups::load </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>in</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>read from protobuf </p>

</div>
</div>
<a id="ab2917632822b6bce5084fc3bfc24965e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2917632822b6bce5084fc3bfc24965e">&#9670;&nbsp;</a></span>make_delete() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Pileups::make_delete </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const pair&lt; const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> *, int64_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>last_match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Mapping.html">Mapping</a> &amp;&#160;</td>
          <td class="paramname"><em>mapping</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>node_offset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c6639579bc521c6ef81e33e20dfbb30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c6639579bc521c6ef81e33e20dfbb30">&#9670;&nbsp;</a></span>make_delete() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Pileups::make_delete </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>from_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>from_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>to_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>to_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a176af241b5113498330d9c3ed076adb3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176af241b5113498330d9c3ed076adb3">&#9670;&nbsp;</a></span>make_insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Pileups::make_insert </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ab1d327ef23fbc70883e9d70c931121ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1d327ef23fbc70883e9d70c931121ed">&#9670;&nbsp;</a></span>make_match()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Pileups::make_match </td>
          <td>(</td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>from_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>make the sam pileup style token </p>

</div>
</div>
<a id="a1b8b072ad1bd89a7b166e09aa385e7ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8b072ad1bd89a7b166e09aa385e7ee">&#9670;&nbsp;</a></span>merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Pileups.html">Pileups</a> &amp; vg::Pileups::merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1Pileups.html">Pileups</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>move all entries in other object into this one. if two positions collide, they are merged. other will be left empty. this is returned </p>

</div>
</div>
<a id="aae04d22ed29096e3a2b12212e06e014f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae04d22ed29096e3a2b12212e06e014f">&#9670;&nbsp;</a></span>merge_base_pileups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> &amp; vg::Pileups::merge_base_pileups </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>merge p2 into p1 and return 1. p2 is left an empty husk </p>

</div>
</div>
<a id="abb147fd284015205bd856b280ca0d58d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb147fd284015205bd856b280ca0d58d">&#9670;&nbsp;</a></span>merge_edge_pileups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1EdgePileup.html">EdgePileup</a> &amp; vg::Pileups::merge_edge_pileups </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1EdgePileup.html">EdgePileup</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1EdgePileup.html">EdgePileup</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>merge p2 into p1 and return 1. p2 is lef an empty husk </p>

</div>
</div>
<a id="ad6c6de7ba4448d281536d9aaf3a1024a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6c6de7ba4448d281536d9aaf3a1024a">&#9670;&nbsp;</a></span>merge_node_pileups()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> &amp; vg::Pileups::merge_node_pileups </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> &amp;&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structvg_1_1NodePileup.html">NodePileup</a> &amp;&#160;</td>
          <td class="paramname"><em>p2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>merge p2 into p1 and return 1. p2 is lef an empty husk </p>

</div>
</div>
<a id="a4b1652ee48a9da72594e35dde54f0233"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b1652ee48a9da72594e35dde54f0233">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Pileups.html">Pileups</a>&amp; vg::Pileups::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1Pileups.html">Pileups</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>copy assignment operator </p>

</div>
</div>
<a id="a9406946c8ffa200537354d84b11c1691"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9406946c8ffa200537354d84b11c1691">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Pileups.html">Pileups</a>&amp; vg::Pileups::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1Pileups.html">Pileups</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>move assignment operator </p>

</div>
</div>
<a id="a45c8a726bf3d3abf2546bc69a9a233d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45c8a726bf3d3abf2546bc69a9a233d3">&#9670;&nbsp;</a></span>parse_base_offsets()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Pileups::parse_base_offsets </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> &amp;&#160;</td>
          <td class="paramname"><em>bp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int64_t, int64_t &gt; &gt; &amp;&#160;</td>
          <td class="paramname"><em>offsets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>the bases string in <a class="el" href="structvg_1_1BasePileup.html">BasePileup</a> doesn't allow random access. This function will parse out all the offsets of snps, insertions, and deletions into one array, each offset is a pair of indexes in the bases and qualities arrays </p>

</div>
</div>
<a id="a59bb8031b052a628b3d9100a7ba6d2dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59bb8031b052a628b3d9100a7ba6d2dc">&#9670;&nbsp;</a></span>parse_delete()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Pileups::parse_delete </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>is_reverse</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>from_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>from_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>from_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>to_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>to_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>to_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="abfe5b378ac99c223fe1780c5e27832e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe5b378ac99c223fe1780c5e27832e2">&#9670;&nbsp;</a></span>parse_insert()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Pileups::parse_insert </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>tok</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t &amp;&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string &amp;&#160;</td>
          <td class="paramname"><em>seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>is_reverse</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9ecef785061ece0f3da8994f7b3fd9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ecef785061ece0f3da8994f7b3fd9c">&#9670;&nbsp;</a></span>pass_filter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Pileups::pass_filter </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>read_offset</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; int &gt; &amp;&#160;</td>
          <td class="paramname"><em>mismatches</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>check base quality as well as miss match filter </p>

</div>
</div>
<a id="a0db435edc597819efff5ba61258734cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0db435edc597819efff5ba61258734cd">&#9670;&nbsp;</a></span>to_json()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Pileups::to_json </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write to JSON </p>

</div>
</div>
<a id="a0585c8203f4755615d50f863ee69e4ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0585c8203f4755615d50f863ee69e4ae">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::Pileups::write </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>buffer_size</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>write to protobuf, with EOF marker </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a0839051b1cbf865ed5c1252a8425f4b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0839051b1cbf865ed5c1252a8425f4b9">&#9670;&nbsp;</a></span>_bases_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::Pileups::_bases_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>overall count for perspective on above </p>

</div>
</div>
<a id="af6f3d0431209ade782e671be0ad84d4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f3d0431209ade782e671be0ad84d4d">&#9670;&nbsp;</a></span>_edge_pileups</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Pileups.html#a78543be08ac7141b012fb89dd04d3c87">EdgePileupHash</a> vg::Pileups::_edge_pileups</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a57532ec0e7dba81c24a0d37352a1e218"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57532ec0e7dba81c24a0d37352a1e218">&#9670;&nbsp;</a></span>_graph</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1VG.html">VG</a>* vg::Pileups::_graph</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a772a6d4845989e28afc651bfdb8d039f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a772a6d4845989e28afc651bfdb8d039f">&#9670;&nbsp;</a></span>_max_depth</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::Pileups::_max_depth</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>prevent giant protobufs </p>

</div>
</div>
<a id="a35303a2b5b04b80592fec8d7c6cd3fa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a35303a2b5b04b80592fec8d7c6cd3fa2">&#9670;&nbsp;</a></span>_max_mismatch_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::Pileups::_max_mismatch_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>keep count of bases filtered by mismatches </p>

</div>
</div>
<a id="a883fcc490157b4ce8facd6e7303510c7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a883fcc490157b4ce8facd6e7303510c7">&#9670;&nbsp;</a></span>_max_mismatches</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::Pileups::_max_mismatches</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>max mismatches within window_size </p>

</div>
</div>
<a id="a848eb55fb5270a30c239df6d17bb3bbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a848eb55fb5270a30c239df6d17bb3bbb">&#9670;&nbsp;</a></span>_min_quality</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::Pileups::_min_quality</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Ignore bases with quality less than this. </p>

</div>
</div>
<a id="aab8c18d3f5372b4e827f91a1f417480c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8c18d3f5372b4e827f91a1f417480c">&#9670;&nbsp;</a></span>_min_quality_count</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint64_t vg::Pileups::_min_quality_count</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Keep count of bases filtered by quality. </p>

</div>
</div>
<a id="aa807699679536a2f32b41f77479f6273"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa807699679536a2f32b41f77479f6273">&#9670;&nbsp;</a></span>_node_pileups</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1Pileups.html#a81156712ca4dd691905d6d9884df1b55">NodePileupHash</a> vg::Pileups::_node_pileups</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This maps from <a class="el" href="structvg_1_1Position.html">Position</a> to <a class="el" href="structvg_1_1Pileup.html" title="Bundle up Node and Edge pileups. ">Pileup</a>. </p>

</div>
</div>
<a id="a250b89737a7bd667f564cacfdb7d01aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a250b89737a7bd667f564cacfdb7d01aa">&#9670;&nbsp;</a></span>_strict_edge_support</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Pileups::_strict_edge_support</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>toggle whether we only count edges if they are not book-ended by matches in the read </p>

</div>
</div>
<a id="a3257a69f673539d48d2c42124bfd28d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3257a69f673539d48d2c42124bfd28d5">&#9670;&nbsp;</a></span>_use_mapq</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::Pileups::_use_mapq</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>toggle whether we incorporate <a class="el" href="structvg_1_1Alignment.html#a78851a70cc8a3e8f3e71409693130230" title="The mapping quality score for the alignment, in Phreds. ">Alignment.mapping_quality</a> </p>

</div>
</div>
<a id="a704565fa7d0517847b207ad0ff44f1d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a704565fa7d0517847b207ad0ff44f1d9">&#9670;&nbsp;</a></span>_window_size</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::Pileups::_window_size</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>number of bases to scan in each direction for mismatches </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="pileup_8hpp.html">pileup.hpp</a></li>
<li>src/<a class="el" href="pileup_8cpp.html">pileup.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
