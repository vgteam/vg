<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>vg: vg::BaseMapper Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Friends</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(10)"><span class="SelectionMark">&#160;</span>Macros</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1BaseMapper.html">BaseMapper</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classvg_1_1BaseMapper-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::BaseMapper Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;mapper.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::BaseMapper:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1BaseMapper.png" usemap="#vg::BaseMapper_map" alt=""/>
  <map id="vg::BaseMapper_map" name="vg::BaseMapper_map">
<area href="classvg_1_1AlignerClient.html" alt="vg::AlignerClient" shape="rect" coords="68,0,195,24"/>
<area href="classvg_1_1Mapper.html" alt="vg::Mapper" shape="rect" coords="0,112,127,136"/>
<area href="classvg_1_1MultipathMapper.html" alt="vg::MultipathMapper" shape="rect" coords="137,112,264,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2c78a00c087aad130ea850ee94839022"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a2c78a00c087aad130ea850ee94839022">BaseMapper</a> (<a class="el" href="classvg_1_1XG.html">XG</a> *xidex, gcsa::GCSA *g, gcsa::LCPArray *a, <a class="el" href="classhaplo_1_1ScoreProvider.html">haplo::ScoreProvider</a> *<a class="el" href="classvg_1_1BaseMapper.html#af69ce88df203124121b71bdfdc6f3694">haplo_score_provider</a>=nullptr)</td></tr>
<tr class="separator:a2c78a00c087aad130ea850ee94839022"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a895c239d974f084e7a0a83025e104fd8"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a895c239d974f084e7a0a83025e104fd8">BaseMapper</a> (void)</td></tr>
<tr class="separator:a895c239d974f084e7a0a83025e104fd8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2884c6722e6bd9c9aab6671a85a6c3c0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a2884c6722e6bd9c9aab6671a85a6c3c0">random_match_length</a> (double chance_random)</td></tr>
<tr class="separator:a2884c6722e6bd9c9aab6671a85a6c3c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad91089ef5009359b6be8b9455e505396"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#ad91089ef5009359b6be8b9455e505396">set_fragment_length_distr_params</a> (size_t maximum_sample_size=1000, size_t reestimation_frequency=1000, double robust_estimation_fraction=0.95)</td></tr>
<tr class="separator:ad91089ef5009359b6be8b9455e505396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0552850ea91ef5c075a63690fe6e6578"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a0552850ea91ef5c075a63690fe6e6578">set_alignment_scores</a> (int8_t match, int8_t mismatch, int8_t gap_open, int8_t gap_extend, int8_t full_length_bonus, uint32_t xdrop_max_gap_length=default_xdrop_max_gap_length, double <a class="el" href="classvg_1_1BaseMapper.html#a33465e76a17e2580a6e095f3373239c5">haplotype_consistency_exponent</a>=1)</td></tr>
<tr class="memdesc:a0552850ea91ef5c075a63690fe6e6578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Override alignment score setting to support haplotype consistency exponent.  <a href="#a0552850ea91ef5c075a63690fe6e6578">More...</a><br/></td></tr>
<tr class="separator:a0552850ea91ef5c075a63690fe6e6578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a903d4be40e368c6dd1c91f6fe2ec4d67"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a903d4be40e368c6dd1c91f6fe2ec4d67">set_cache_size</a> (int new_cache_size)</td></tr>
<tr class="separator:a903d4be40e368c6dd1c91f6fe2ec4d67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a605bec54cb2bac4ce873dc7b2783cd5d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a605bec54cb2bac4ce873dc7b2783cd5d">has_fixed_fragment_length_distr</a> ()</td></tr>
<tr class="memdesc:a605bec54cb2bac4ce873dc7b2783cd5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if fragment length distribution has been fixed.  <a href="#a605bec54cb2bac4ce873dc7b2783cd5d">More...</a><br/></td></tr>
<tr class="separator:a605bec54cb2bac4ce873dc7b2783cd5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9848806a322e4a90d0aaf6f1b0407dc8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a9848806a322e4a90d0aaf6f1b0407dc8">force_fragment_length_distr</a> (double mean, double stddev)</td></tr>
<tr class="separator:a9848806a322e4a90d0aaf6f1b0407dc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af64a7b36c1880606372d0849842708b0"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#af64a7b36c1880606372d0849842708b0">find_mems_deep</a> (string::const_iterator seq_begin, string::const_iterator seq_end, double &amp;lcp_avg, double &amp;fraction_filtered, int max_mem_length=0, int <a class="el" href="classvg_1_1BaseMapper.html#a6de91c39c73a95b014b1773495985a09">min_mem_length</a>=1, int reseed_length=0, bool use_lcp_reseed_heuristic=false, bool use_diff_based_fast_reseed=false, bool include_parent_in_sub_mem_count=false, bool record_max_lcp=false, int reseed_below_count=0)</td></tr>
<tr class="separator:af64a7b36c1880606372d0849842708b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4dd3272837211543ba461472833734a9"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a4dd3272837211543ba461472833734a9">find_mems_simple</a> (string::const_iterator seq_begin, string::const_iterator seq_end, int max_mem_length=0, int <a class="el" href="classvg_1_1BaseMapper.html#a6de91c39c73a95b014b1773495985a09">min_mem_length</a>=1, int reseed_length=0)</td></tr>
<tr class="separator:a4dd3272837211543ba461472833734a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa7a71951ec7acdbf2c31ae9318ceb035"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#aa7a71951ec7acdbf2c31ae9318ceb035">rescue_high_count_order_length_mems</a> (vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, size_t max_rescue_hit_count)</td></tr>
<tr class="separator:aa7a71951ec7acdbf2c31ae9318ceb035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4372862ebd4f21da3e9ed105249a5af"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#af4372862ebd4f21da3e9ed105249a5af">precollapse_order_length_runs</a> (string::const_iterator seq_begin, vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems)</td></tr>
<tr class="separator:af4372862ebd4f21da3e9ed105249a5af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae3103b73da0ef6137ad1d1bd16e35d56"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#ae3103b73da0ef6137ad1d1bd16e35d56">prefilter_redundant_sub_mems</a> (vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, vector&lt; pair&lt; int, vector&lt; size_t &gt;&gt;&gt; &amp;sub_mem_containment_graph)</td></tr>
<tr class="separator:ae3103b73da0ef6137ad1d1bd16e35d56"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_methods_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pub_methods_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Public Member Functions inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:a0ea937755e15062c023d1b97d61814d4 inherit pub_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a0ea937755e15062c023d1b97d61814d4">set_alignment_scores</a> (int8_t match, int8_t mismatch, int8_t gap_open, int8_t gap_extend, int8_t full_length_bonus, uint32_t xdrop_max_gap_length=default_xdrop_max_gap_length)</td></tr>
<tr class="memdesc:a0ea937755e15062c023d1b97d61814d4 inherit pub_methods_classvg_1_1AlignerClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set all the aligner scoring parameters and create the stored aligner instances.  <a href="#a0ea937755e15062c023d1b97d61814d4">More...</a><br/></td></tr>
<tr class="separator:a0ea937755e15062c023d1b97d61814d4 inherit pub_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ef1e755d0886e16328eb9818ae31fb2 inherit pub_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a2ef1e755d0886e16328eb9818ae31fb2">load_scoring_matrix</a> (std::ifstream &amp;matrix_stream)</td></tr>
<tr class="memdesc:a2ef1e755d0886e16328eb9818ae31fb2 inherit pub_methods_classvg_1_1AlignerClient"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load a scoring amtrix from a file to set scores.  <a href="#a2ef1e755d0886e16328eb9818ae31fb2">More...</a><br/></td></tr>
<tr class="separator:a2ef1e755d0886e16328eb9818ae31fb2 inherit pub_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:aa08b00e5a349252d013d76651f754f8d"><td class="memItemLeft" align="right" valign="top">static double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#aa08b00e5a349252d013d76651f754f8d">estimate_gc_content</a> (const gcsa::GCSA *<a class="el" href="classvg_1_1BaseMapper.html#aa41db0eca93c379087c90b602a6ce751">gcsa</a>)</td></tr>
<tr class="separator:aa08b00e5a349252d013d76651f754f8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4e17a40bafbd8832d551acb01298403d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a4e17a40bafbd8832d551acb01298403d">sub_mem_thinning_burn_in</a> = 16</td></tr>
<tr class="separator:a4e17a40bafbd8832d551acb01298403d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d9a00e1d809346bc62f6f2c1e4fbe32"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a8d9a00e1d809346bc62f6f2c1e4fbe32">sub_mem_count_thinning</a> = 4</td></tr>
<tr class="separator:a8d9a00e1d809346bc62f6f2c1e4fbe32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6de91c39c73a95b014b1773495985a09"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a6de91c39c73a95b014b1773495985a09">min_mem_length</a></td></tr>
<tr class="separator:a6de91c39c73a95b014b1773495985a09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaea877646c1be5aea6200201d28c4cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#abaea877646c1be5aea6200201d28c4cf">mem_reseed_length</a></td></tr>
<tr class="separator:abaea877646c1be5aea6200201d28c4cf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85f811924225d6de6f0a26b168ed1df3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a85f811924225d6de6f0a26b168ed1df3">fast_reseed</a> = true</td></tr>
<tr class="separator:a85f811924225d6de6f0a26b168ed1df3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ce7cb0903b14c4b4132f504dcdc412"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a74ce7cb0903b14c4b4132f504dcdc412">fast_reseed_length_diff</a> = 0.45</td></tr>
<tr class="separator:a74ce7cb0903b14c4b4132f504dcdc412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf7556c347ea7596624700482dc58c8c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#acf7556c347ea7596624700482dc58c8c">adaptive_reseed_diff</a> = true</td></tr>
<tr class="separator:acf7556c347ea7596624700482dc58c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a653e029302e4442dbabd06a70ec4bbec"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a653e029302e4442dbabd06a70ec4bbec">adaptive_diff_exponent</a> = 0.065</td></tr>
<tr class="separator:a653e029302e4442dbabd06a70ec4bbec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29b8cec81cc68e9d90405c42fbc8ef64"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a29b8cec81cc68e9d90405c42fbc8ef64">hit_max</a> = 0</td></tr>
<tr class="separator:a29b8cec81cc68e9d90405c42fbc8ef64"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf1a0a71b2bcc7763690fed623383fb3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#abf1a0a71b2bcc7763690fed623383fb3">use_approx_sub_mem_count</a> = false</td></tr>
<tr class="separator:abf1a0a71b2bcc7763690fed623383fb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa408c8d202885a288f14ff6e2dc60e0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#afa408c8d202885a288f14ff6e2dc60e0">prefilter_redundant_hits</a> = true</td></tr>
<tr class="separator:afa408c8d202885a288f14ff6e2dc60e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12496865e23fd68ba1f579dcb050037"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#ac12496865e23fd68ba1f579dcb050037">max_sub_mem_recursion_depth</a> = 2</td></tr>
<tr class="separator:ac12496865e23fd68ba1f579dcb050037"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad20ea9a68bcaca157350595f03b4601c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#ad20ea9a68bcaca157350595f03b4601c">unpaired_penalty</a> = 17</td></tr>
<tr class="separator:ad20ea9a68bcaca157350595f03b4601c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf81156cb8c76c2e961b767a782dda59"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#aaf81156cb8c76c2e961b767a782dda59">precollapse_order_length_hits</a> = true</td></tr>
<tr class="separator:aaf81156cb8c76c2e961b767a782dda59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0e6c250a81dc74df57136242174aa54"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#af0e6c250a81dc74df57136242174aa54">recombination_penalty</a> = 20.7</td></tr>
<tr class="separator:af0e6c250a81dc74df57136242174aa54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ab4a12d44f5b17b5b6caa03ea4cd79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a34ab4a12d44f5b17b5b6caa03ea4cd79">strip_bonuses</a></td></tr>
<tr class="separator:a34ab4a12d44f5b17b5b6caa03ea4cd79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7127a75ac293b9b05093134ee8e51cd2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a7127a75ac293b9b05093134ee8e51cd2">assume_acyclic</a></td></tr>
<tr class="separator:a7127a75ac293b9b05093134ee8e51cd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b1fe81d11d92332f613d8a29dcadb37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39">MappingQualityMethod</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a0b1fe81d11d92332f613d8a29dcadb37">mapping_quality_method</a></td></tr>
<tr class="separator:a0b1fe81d11d92332f613d8a29dcadb37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a467884235c316072a1ed7136faa14be3"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a467884235c316072a1ed7136faa14be3">max_mapping_quality</a></td></tr>
<tr class="separator:a467884235c316072a1ed7136faa14be3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71be220eec4224b249a6536db70bbe5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#ac71be220eec4224b249a6536db70bbe5">exclude_unaligned</a> = false</td></tr>
<tr class="separator:ac71be220eec4224b249a6536db70bbe5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ce344e730fbb7cdc6b6d57b4ca76cf2"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a5ce344e730fbb7cdc6b6d57b4ca76cf2">debug</a> = false</td></tr>
<tr class="memdesc:a5ce344e730fbb7cdc6b6d57b4ca76cf2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set to enable debugging messages to cerr from the mapper, so a user can understand why a read maps the way it does.  <a href="#a5ce344e730fbb7cdc6b6d57b4ca76cf2">More...</a><br/></td></tr>
<tr class="separator:a5ce344e730fbb7cdc6b6d57b4ca76cf2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pub_attribs_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pub_attribs_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Public Attributes inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:a25db3953c246e94a7e08ef59fc31b82f inherit pub_attribs_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a25db3953c246e94a7e08ef59fc31b82f">adjust_alignments_for_base_quality</a> = false</td></tr>
<tr class="separator:a25db3953c246e94a7e08ef59fc31b82f inherit pub_attribs_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a77079f609cab775e59ff0750ef9e84d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a77079f609cab775e59ff0750ef9e84d9">find_sub_mems</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, int parent_layer_begin, int parent_layer_end, int mem_idx, string::const_iterator next_mem_end, int <a class="el" href="classvg_1_1BaseMapper.html#a6de91c39c73a95b014b1773495985a09">min_mem_length</a>, vector&lt; pair&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a>, vector&lt; size_t &gt;&gt;&gt; &amp;sub_mems_out)</td></tr>
<tr class="separator:a77079f609cab775e59ff0750ef9e84d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81fa3eae0321720511b1f54fa28968bb"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a81fa3eae0321720511b1f54fa28968bb">find_sub_mems_fast</a> (const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;mems, int parent_layer_begin, int parent_layer_end, int mem_idx, string::const_iterator leftmost_guaranteed_disjoint_bound, string::const_iterator leftmost_seeding_bound, int min_sub_mem_length, vector&lt; pair&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a>, vector&lt; size_t &gt;&gt;&gt; &amp;sub_mems_out)</td></tr>
<tr class="separator:a81fa3eae0321720511b1f54fa28968bb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d3cdacd0ec3e6b27ced793aeb9b561a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a3d3cdacd0ec3e6b27ced793aeb9b561a">fill_nonredundant_sub_mem_nodes</a> (vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;parent_mems, vector&lt; pair&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a>, vector&lt; size_t &gt; &gt; &gt;::iterator sub_mem_records_begin, vector&lt; pair&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a>, vector&lt; size_t &gt; &gt; &gt;::iterator sub_mem_records_end)</td></tr>
<tr class="separator:a3d3cdacd0ec3e6b27ced793aeb9b561a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26dfca3a19af4caf8746f1e28eacf646"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a26dfca3a19af4caf8746f1e28eacf646">first_hit_positions_by_index</a> (<a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;mem, vector&lt; set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&gt; &amp;positions_by_index_out)</td></tr>
<tr class="separator:a26dfca3a19af4caf8746f1e28eacf646"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a064f32d036db4774ba8802f0ade9b056"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a064f32d036db4774ba8802f0ade9b056">mem_positions_by_index</a> (<a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;mem, <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> hit_pos, vector&lt; set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&gt; &amp;positions_by_index_out)</td></tr>
<tr class="separator:a064f32d036db4774ba8802f0ade9b056"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a301ccfdf585635471e03efde26ff162a"><td class="memItemLeft" align="right" valign="top">char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a301ccfdf585635471e03efde26ff162a">pos_char</a> (<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> pos)</td></tr>
<tr class="separator:a301ccfdf585635471e03efde26ff162a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b162009930636565dbb15614d76619f"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a9b162009930636565dbb15614d76619f">next_pos_chars</a> (<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> pos)</td></tr>
<tr class="separator:a9b162009930636565dbb15614d76619f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a819df281232ae4d5f689ce8e2981b2a0"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a819df281232ae4d5f689ce8e2981b2a0">positions_bp_from</a> (<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> pos, int distance, bool rev)</td></tr>
<tr class="separator:a819df281232ae4d5f689ce8e2981b2a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fc5077e5ea4a236ddf8edcf93288eb9"><td class="memItemLeft" align="right" valign="top">set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a1fc5077e5ea4a236ddf8edcf93288eb9">sequence_positions</a> (const string &amp;seq)</td></tr>
<tr class="separator:a1fc5077e5ea4a236ddf8edcf93288eb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f693887391ddeaebf4a4a609e2ab9b3"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a7f693887391ddeaebf4a4a609e2ab9b3">get_adaptive_min_reseed_length</a> (size_t parent_mem_length)</td></tr>
<tr class="separator:a7f693887391ddeaebf4a4a609e2ab9b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a778c534cca5d7580584bba4131b65adc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a778c534cca5d7580584bba4131b65adc">apply_haplotype_consistency_scores</a> (const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> * &gt; &amp;alns)</td></tr>
<tr class="separator:a778c534cca5d7580584bba4131b65adc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="inherit_header pro_methods_classvg_1_1AlignerClient"><td colspan="2" onclick="javascript:toggleInherit('pro_methods_classvg_1_1AlignerClient')"><img src="closed.png" alt="-"/>&#160;Protected Member Functions inherited from <a class="el" href="classvg_1_1AlignerClient.html">vg::AlignerClient</a></td></tr>
<tr class="memitem:ab180631766b1e787e29dd202ad455d90 inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#ab180631766b1e787e29dd202ad455d90">AlignerClient</a> (double <a class="el" href="classvg_1_1AlignerClient.html#a65428f092aaa5d894b709e247cf0121a">gc_content_estimate</a>=vg::default_gc_content)</td></tr>
<tr class="separator:ab180631766b1e787e29dd202ad455d90 inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74e0c82ed9c61de1dfa7c45d62ac1af3 inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#a74e0c82ed9c61de1dfa7c45d62ac1af3">get_aligner</a> (bool have_qualities=true) const </td></tr>
<tr class="separator:a74e0c82ed9c61de1dfa7c45d62ac1af3 inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac39bc1b46f1ee4eb34fea4a207b5649e inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1QualAdjAligner.html">QualAdjAligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#ac39bc1b46f1ee4eb34fea4a207b5649e">get_qual_adj_aligner</a> () const </td></tr>
<tr class="separator:ac39bc1b46f1ee4eb34fea4a207b5649e inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2fe6d0c3f92c5f69baed5790675725f inherit pro_methods_classvg_1_1AlignerClient"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classvg_1_1Aligner.html">Aligner</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1AlignerClient.html#af2fe6d0c3f92c5f69baed5790675725f">get_regular_aligner</a> () const </td></tr>
<tr class="separator:af2fe6d0c3f92c5f69baed5790675725f inherit pro_methods_classvg_1_1AlignerClient"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab5e61d76c005066c43311b5edc5ba473"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1XG.html">XG</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#ab5e61d76c005066c43311b5edc5ba473">xindex</a> = nullptr</td></tr>
<tr class="separator:ab5e61d76c005066c43311b5edc5ba473"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa41db0eca93c379087c90b602a6ce751"><td class="memItemLeft" align="right" valign="top">gcsa::GCSA *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#aa41db0eca93c379087c90b602a6ce751">gcsa</a> = nullptr</td></tr>
<tr class="separator:aa41db0eca93c379087c90b602a6ce751"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4046b98185c00ff397089435d5b2b8d8"><td class="memItemLeft" align="right" valign="top">gcsa::LCPArray *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a4046b98185c00ff397089435d5b2b8d8">lcp</a> = nullptr</td></tr>
<tr class="separator:a4046b98185c00ff397089435d5b2b8d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af69ce88df203124121b71bdfdc6f3694"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classhaplo_1_1ScoreProvider.html">haplo::ScoreProvider</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#af69ce88df203124121b71bdfdc6f3694">haplo_score_provider</a> = nullptr</td></tr>
<tr class="separator:af69ce88df203124121b71bdfdc6f3694"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33465e76a17e2580a6e095f3373239c5"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a33465e76a17e2580a6e095f3373239c5">haplotype_consistency_exponent</a> = 1</td></tr>
<tr class="separator:a33465e76a17e2580a6e095f3373239c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e37826ea32c98f5ce0f6f4dd2206fd5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1FragmentLengthDistribution.html">FragmentLengthDistribution</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a8e37826ea32c98f5ce0f6f4dd2206fd5">fragment_length_distr</a></td></tr>
<tr class="separator:a8e37826ea32c98f5ce0f6f4dd2206fd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a279b5883907a56ada69b41796230b209"><td class="memItemLeft" align="right" valign="top">static thread_local vector<br class="typebreak"/>
&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1BaseMapper.html#a279b5883907a56ada69b41796230b209">adaptive_reseed_length_memo</a></td></tr>
<tr class="separator:a279b5883907a56ada69b41796230b209"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Base class for basic mapping functionality shared between the <a class="el" href="classvg_1_1Mapper.html">Mapper</a>, <a class="el" href="classvg_1_1MultipathMapper.html">MultipathMapper</a>, etc. Handles holding on to the random access and text indexes needed for mapping operations. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a2c78a00c087aad130ea850ee94839022"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::BaseMapper::BaseMapper </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1XG.html">XG</a> *&#160;</td>
          <td class="paramname"><em>xidex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gcsa::GCSA *&#160;</td>
          <td class="paramname"><em>g</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gcsa::LCPArray *&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classhaplo_1_1ScoreProvider.html">haplo::ScoreProvider</a> *&#160;</td>
          <td class="paramname"><em>haplo_score_provider</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a <a class="el" href="classvg_1_1BaseMapper.html">BaseMapper</a> that pulls from an <a class="el" href="classvg_1_1XG.html">XG</a> succinct graph and a GCSA2 kmer index + LCP array, and which can score reads against haplotypes using the given ScoreProvider.</p>
<p>If the GCSA and LCPArray are null, cannot do search, only alignment. </p>

</div>
</div>
<a class="anchor" id="a895c239d974f084e7a0a83025e104fd8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::BaseMapper::BaseMapper </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a778c534cca5d7580584bba4131b65adc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::BaseMapper::apply_haplotype_consistency_scores </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>alns</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Score all of the alignments in the vector for haplotype consistency. If all of them can be scored (i.e. none of them visit nodes/edges with no haplotypes), adjust all of their scores to reflect haplotype consistency. If one or more cannot be scored for haplotype consistency, leave the alignment scores alone. </p>

</div>
</div>
<a class="anchor" id="aa08b00e5a349252d013d76651f754f8d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::BaseMapper::estimate_gc_content </td>
          <td>(</td>
          <td class="paramtype">const gcsa::GCSA *&#160;</td>
          <td class="paramname"><em>gcsa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>We need to be able to estimate the GC content from the GCSA index in the constructor. The given index may be null. </p>

</div>
</div>
<a class="anchor" id="a3d3cdacd0ec3e6b27ced793aeb9b561a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::BaseMapper::fill_nonredundant_sub_mem_nodes </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>parent_mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a>, vector&lt; size_t &gt; &gt; &gt;::iterator&#160;</td>
          <td class="paramname"><em>sub_mem_records_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a>, vector&lt; size_t &gt; &gt; &gt;::iterator&#160;</td>
          <td class="paramname"><em>sub_mem_records_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>finds the nodes of sub MEMs that do not occur inside parent MEMs, each sub MEM should be associated with a vector of the indices of the SMEMs that contain it in the parent MEMs vector </p>

</div>
</div>
<a class="anchor" id="af64a7b36c1880606372d0849842708b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; vg::BaseMapper::find_mems_deep </td>
          <td>(</td>
          <td class="paramtype">string::const_iterator&#160;</td>
          <td class="paramname"><em>seq_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string::const_iterator&#160;</td>
          <td class="paramname"><em>seq_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>lcp_avg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>fraction_filtered</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_mem_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_mem_length</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reseed_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_lcp_reseed_heuristic</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>use_diff_based_fast_reseed</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>include_parent_in_sub_mem_count</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>record_max_lcp</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reseed_below_count</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4dd3272837211543ba461472833734a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; vg::BaseMapper::find_mems_simple </td>
          <td>(</td>
          <td class="paramtype">string::const_iterator&#160;</td>
          <td class="paramname"><em>seq_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string::const_iterator&#160;</td>
          <td class="paramname"><em>seq_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_mem_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_mem_length</em> = <code>1</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>reseed_length</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a77079f609cab775e59ff0750ef9e84d9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::BaseMapper::find_sub_mems </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent_layer_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent_layer_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mem_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string::const_iterator&#160;</td>
          <td class="paramname"><em>next_mem_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_mem_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a>, vector&lt; size_t &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_mems_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Locate the sub-MEMs contained in the last MEM of the mems vector that have ending positions before the end the next SMEM, label each of the sub-MEMs with the indices of all of the SMEMs that contain it </p>

</div>
</div>
<a class="anchor" id="a81fa3eae0321720511b1f54fa28968bb"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::BaseMapper::find_sub_mems_fast </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent_layer_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>parent_layer_end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mem_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string::const_iterator&#160;</td>
          <td class="paramname"><em>leftmost_guaranteed_disjoint_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string::const_iterator&#160;</td>
          <td class="paramname"><em>leftmost_seeding_bound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>min_sub_mem_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a>, vector&lt; size_t &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_mems_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Provides same semantics as find_sub_mems but with a different algorithm. This algorithm uses the min_mem_length as a pruning tool instead of the LCP index. It can be expected to be faster when both the min_mem_length reasonably large relative to the reseed_length (e.g. 1/2 of SMEM size or similar). </p>

</div>
</div>
<a class="anchor" id="a26dfca3a19af4caf8746f1e28eacf646"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::BaseMapper::first_hit_positions_by_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>positions_by_index_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>fills a vector where each element contains the set of positions in the graph that the MEM touches at that index for the first MEM hit in the GCSA array </p>

</div>
</div>
<a class="anchor" id="a9848806a322e4a90d0aaf6f1b0407dc8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::BaseMapper::force_fragment_length_distr </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>mean</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>stddev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the given fragment length distribution parameters instead of estimating them. </p>

</div>
</div>
<a class="anchor" id="a7f693887391ddeaebf4a4a609e2ab9b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::BaseMapper::get_adaptive_min_reseed_length </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>parent_mem_length</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a605bec54cb2bac4ce873dc7b2783cd5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::BaseMapper::has_fixed_fragment_length_distr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns true if fragment length distribution has been fixed. </p>

</div>
</div>
<a class="anchor" id="a064f32d036db4774ba8802f0ade9b056"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::BaseMapper::mem_positions_by_index </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &amp;&#160;</td>
          <td class="paramname"><em>mem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>&#160;</td>
          <td class="paramname"><em>hit_pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>positions_by_index_out</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>fills a vector where each element contains the set of positions in the graph that the MEM touches at that index starting at a given hit </p>

</div>
</div>
<a class="anchor" id="a9b162009930636565dbb15614d76619f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">map&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>, char &gt; vg::BaseMapper::next_pos_chars </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a301ccfdf585635471e03efde26ff162a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char vg::BaseMapper::pos_char </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a819df281232ae4d5f689ce8e2981b2a0"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">set&lt; <a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a> &gt; vg::BaseMapper::positions_bp_from </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>distance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rev</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af4372862ebd4f21da3e9ed105249a5af"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::BaseMapper::precollapse_order_length_runs </td>
          <td>(</td>
          <td class="paramtype">string::const_iterator&#160;</td>
          <td class="paramname"><em>seq_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>identifies hits for order-length MEMs that are actually part of longer MEMs above the GCSA's limit and merges them. for speed's sake, can have false negatives but no false positives </p>

</div>
</div>
<a class="anchor" id="ae3103b73da0ef6137ad1d1bd16e35d56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::BaseMapper::prefilter_redundant_sub_mems </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; int, vector&lt; size_t &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>sub_mem_containment_graph</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>identifies hits for sub-MEMs that are redundant hits to the parent MEMs and removes them from the hit lists. for speed's sake, can have false negatives but no false positives </p>

</div>
</div>
<a class="anchor" id="a2884c6722e6bd9c9aab6671a85a6c3c0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::BaseMapper::random_match_length </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>chance_random</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa7a71951ec7acdbf2c31ae9318ceb035"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::BaseMapper::rescue_high_count_order_length_mems </td>
          <td>(</td>
          <td class="paramtype">vector&lt; <a class="el" href="classvg_1_1MaximalExactMatch.html">MaximalExactMatch</a> &gt; &amp;&#160;</td>
          <td class="paramname"><em>mems</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_rescue_hit_count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>identifies tracts of order-length MEMs that were unfilled because their hit count was above the max and fills one MEM in the tract (the one with the smallest hit count), assumes MEMs are lexicographically ordered by read index </p>

</div>
</div>
<a class="anchor" id="a1fc5077e5ea4a236ddf8edcf93288eb9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">set&lt;<a class="el" href="namespacevg.html#a54512eefe4b0e14cb3b0057c23350240">pos_t</a>&gt; vg::BaseMapper::sequence_positions </td>
          <td>(</td>
          <td class="paramtype">const string &amp;&#160;</td>
          <td class="paramname"><em>seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0552850ea91ef5c075a63690fe6e6578"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::BaseMapper::set_alignment_scores </td>
          <td>(</td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>match</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>mismatch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>gap_open</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>gap_extend</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int8_t&#160;</td>
          <td class="paramname"><em>full_length_bonus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>xdrop_max_gap_length</em> = <code>default_xdrop_max_gap_length</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>haplotype_consistency_exponent</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Override alignment score setting to support haplotype consistency exponent. </p>

</div>
</div>
<a class="anchor" id="a903d4be40e368c6dd1c91f6fe2ec4d67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::BaseMapper::set_cache_size </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>new_cache_size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad91089ef5009359b6be8b9455e505396"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::BaseMapper::set_fragment_length_distr_params </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>maximum_sample_size</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>reestimation_frequency</em> = <code>1000</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>robust_estimation_fraction</em> = <code>0.95</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a class="anchor" id="a653e029302e4442dbabd06a70ec4bbec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::BaseMapper::adaptive_diff_exponent = 0.065</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="acf7556c347ea7596624700482dc58c8c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::BaseMapper::adaptive_reseed_diff = true</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a279b5883907a56ada69b41796230b209"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">thread_local vector&lt; size_t &gt; vg::BaseMapper::adaptive_reseed_length_memo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7127a75ac293b9b05093134ee8e51cd2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::BaseMapper::assume_acyclic</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a5ce344e730fbb7cdc6b6d57b4ca76cf2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::BaseMapper::debug = false</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set to enable debugging messages to cerr from the mapper, so a user can understand why a read maps the way it does. </p>

</div>
</div>
<a class="anchor" id="ac71be220eec4224b249a6536db70bbe5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::BaseMapper::exclude_unaligned = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a85f811924225d6de6f0a26b168ed1df3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::BaseMapper::fast_reseed = true</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a74ce7cb0903b14c4b4132f504dcdc412"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::BaseMapper::fast_reseed_length_diff = 0.45</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8e37826ea32c98f5ce0f6f4dd2206fd5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1FragmentLengthDistribution.html">FragmentLengthDistribution</a> vg::BaseMapper::fragment_length_distr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aa41db0eca93c379087c90b602a6ce751"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gcsa::GCSA* vg::BaseMapper::gcsa = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af69ce88df203124121b71bdfdc6f3694"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classhaplo_1_1ScoreProvider.html">haplo::ScoreProvider</a>* vg::BaseMapper::haplo_score_provider = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a33465e76a17e2580a6e095f3373239c5"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double vg::BaseMapper::haplotype_consistency_exponent = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a29b8cec81cc68e9d90405c42fbc8ef64"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::BaseMapper::hit_max = 0</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4046b98185c00ff397089435d5b2b8d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">gcsa::LCPArray* vg::BaseMapper::lcp = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0b1fe81d11d92332f613d8a29dcadb37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#ae8af508a4586e2447fdbf2a30a213b39">MappingQualityMethod</a> vg::BaseMapper::mapping_quality_method</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a467884235c316072a1ed7136faa14be3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::BaseMapper::max_mapping_quality</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ac12496865e23fd68ba1f579dcb050037"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::BaseMapper::max_sub_mem_recursion_depth = 2</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abaea877646c1be5aea6200201d28c4cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::BaseMapper::mem_reseed_length</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a6de91c39c73a95b014b1773495985a09"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::BaseMapper::min_mem_length</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaf81156cb8c76c2e961b767a782dda59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::BaseMapper::precollapse_order_length_hits = true</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="afa408c8d202885a288f14ff6e2dc60e0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::BaseMapper::prefilter_redundant_hits = true</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="af0e6c250a81dc74df57136242174aa54"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double vg::BaseMapper::recombination_penalty = 20.7</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a34ab4a12d44f5b17b5b6caa03ea4cd79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::BaseMapper::strip_bonuses</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8d9a00e1d809346bc62f6f2c1e4fbe32"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::BaseMapper::sub_mem_count_thinning = 4</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4e17a40bafbd8832d551acb01298403d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::BaseMapper::sub_mem_thinning_burn_in = 16</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad20ea9a68bcaca157350595f03b4601c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int vg::BaseMapper::unpaired_penalty = 17</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="abf1a0a71b2bcc7763690fed623383fb3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::BaseMapper::use_approx_sub_mem_count = false</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ab5e61d76c005066c43311b5edc5ba473"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1XG.html">XG</a>* vg::BaseMapper::xindex = nullptr</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="mapper_8hpp.html">mapper.hpp</a></li>
<li>src/<a class="el" href="mapper_8cpp.html">mapper.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.6
</small></address>
</body>
</html>
