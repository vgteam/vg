<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::MultipathAlignmentGraph Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pro-methods">Protected Member Functions</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="classvg_1_1MultipathAlignmentGraph-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::MultipathAlignmentGraph Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;multipath_alignment_graph.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a058e6120cb359e2566c1c2d7961c608e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a058e6120cb359e2566c1c2d7961c608e">MultipathAlignmentGraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, <a class="el" href="classvg_1_1MultipathMapper.html#acae95760b8750cf3b2bb48d00fe499fd">MultipathMapper::memcluster_t</a> &amp;hits, const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;project, const unordered_multimap&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;injection_trans, vector&lt; size_t &gt; &amp;path_node_provenance, size_t max_branch_trim_length=0, gcsa::GCSA *gcsa=nullptr, const <a class="el" href="classvg_1_1MultipathMapper.html#a165e5c0531ff4337ce6542da263d3fbd">MultipathMapper::match_fanouts_t</a> *fanout_breaks=nullptr)</td></tr>
<tr class="separator:a058e6120cb359e2566c1c2d7961c608e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51e7308dc1c0c96d1e576970211b7705"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a51e7308dc1c0c96d1e576970211b7705">MultipathAlignmentGraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, <a class="el" href="classvg_1_1MultipathMapper.html#acae95760b8750cf3b2bb48d00fe499fd">MultipathMapper::memcluster_t</a> &amp;hits, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;projection_trans, vector&lt; size_t &gt; &amp;path_node_provenance, size_t max_branch_trim_length=0, gcsa::GCSA *gcsa=nullptr, const <a class="el" href="classvg_1_1MultipathMapper.html#a165e5c0531ff4337ce6542da263d3fbd">MultipathMapper::match_fanouts_t</a> *fanout_breaks=nullptr)</td></tr>
<tr class="memdesc:a51e7308dc1c0c96d1e576970211b7705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the previous constructor, but construct injection_trans implicitly and temporarily.  <a href="classvg_1_1MultipathAlignmentGraph.html#a51e7308dc1c0c96d1e576970211b7705">More...</a><br /></td></tr>
<tr class="separator:a51e7308dc1c0c96d1e576970211b7705"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd75ac7afd23901c4b8f38eb126bdba0"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#afd75ac7afd23901c4b8f38eb126bdba0">MultipathAlignmentGraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, <a class="el" href="classvg_1_1MultipathMapper.html#acae95760b8750cf3b2bb48d00fe499fd">MultipathMapper::memcluster_t</a> &amp;hits, const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;project, vector&lt; size_t &gt; &amp;path_node_provenance, size_t max_branch_trim_length=0, gcsa::GCSA *gcsa=nullptr, const <a class="el" href="classvg_1_1MultipathMapper.html#a165e5c0531ff4337ce6542da263d3fbd">MultipathMapper::match_fanouts_t</a> *fanout_breaks=nullptr)</td></tr>
<tr class="separator:afd75ac7afd23901c4b8f38eb126bdba0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74eec86f754011999dc6caed5d1f6c8a"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a74eec86f754011999dc6caed5d1f6c8a">MultipathAlignmentGraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const vector&lt; pair&lt; pair&lt; string::const_iterator, string::const_iterator &gt;, <a class="el" href="classvg_1_1path__t.html">path_t</a> &gt;&gt; &amp;path_chunks, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;project, const unordered_multimap&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;injection_trans, bool realign_Ns=true, bool preserve_tail_anchors=false, vector&lt; size_t &gt; *path_node_provenance=nullptr)</td></tr>
<tr class="separator:a74eec86f754011999dc6caed5d1f6c8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a366ddb07faadad371e896d3f453e147c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a366ddb07faadad371e896d3f453e147c">MultipathAlignmentGraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const vector&lt; pair&lt; pair&lt; string::const_iterator, string::const_iterator &gt;, <a class="el" href="classvg_1_1path__t.html">path_t</a> &gt;&gt; &amp;path_chunks, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;projection_trans, bool realign_Ns=true, bool preserve_tail_anchors=false, vector&lt; size_t &gt; *path_node_provenance=nullptr)</td></tr>
<tr class="memdesc:a366ddb07faadad371e896d3f453e147c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the previous constructor, but construct injection_trans implicitly and temporarily.  <a href="classvg_1_1MultipathAlignmentGraph.html#a366ddb07faadad371e896d3f453e147c">More...</a><br /></td></tr>
<tr class="separator:a366ddb07faadad371e896d3f453e147c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4289e77bb6d76abfbb1d3c02d89a2586"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a4289e77bb6d76abfbb1d3c02d89a2586">MultipathAlignmentGraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const vector&lt; pair&lt; pair&lt; string::const_iterator, string::const_iterator &gt;, <a class="el" href="classvg_1_1path__t.html">path_t</a> &gt;&gt; &amp;path_chunks, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;project, bool realign_Ns=true, bool preserve_tail_anchors=false, vector&lt; size_t &gt; *path_node_provenance=nullptr)</td></tr>
<tr class="separator:a4289e77bb6d76abfbb1d3c02d89a2586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f4ae19921529920157bcbbf9a2f5c3"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#ac8f4ae19921529920157bcbbf9a2f5c3">MultipathAlignmentGraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *snarl_manager, SnarlDistanceIndex *dist_index, size_t max_snarl_cut_size, const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;project, const unordered_multimap&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;injection_trans)</td></tr>
<tr class="separator:ac8f4ae19921529920157bcbbf9a2f5c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10f9b18c8aa4db1b80bf54ccc5dcc09c"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a10f9b18c8aa4db1b80bf54ccc5dcc09c">MultipathAlignmentGraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *snarl_manager, SnarlDistanceIndex *dist_index, size_t max_snarl_cut_size, const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;projection_trans)</td></tr>
<tr class="memdesc:a10f9b18c8aa4db1b80bf54ccc5dcc09c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as the previous constructor, but construct injection_trans implicitly and temporarily.  <a href="classvg_1_1MultipathAlignmentGraph.html#a10f9b18c8aa4db1b80bf54ccc5dcc09c">More...</a><br /></td></tr>
<tr class="separator:a10f9b18c8aa4db1b80bf54ccc5dcc09c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b441f028fd26c177a9ce8d8188b7c1"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a89b441f028fd26c177a9ce8d8188b7c1">MultipathAlignmentGraph</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *snarl_manager, SnarlDistanceIndex *dist_index, size_t max_snarl_cut_size, const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;project)</td></tr>
<tr class="separator:a89b441f028fd26c177a9ce8d8188b7c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e2932360f805d5c6353cd25e377e5d"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a85e2932360f805d5c6353cd25e377e5d">~MultipathAlignmentGraph</a> ()</td></tr>
<tr class="separator:a85e2932360f805d5c6353cd25e377e5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565b45f37d5be97cd30bce1d29c134fc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a565b45f37d5be97cd30bce1d29c134fc">topological_sort</a> (vector&lt; size_t &gt; &amp;order_out)</td></tr>
<tr class="separator:a565b45f37d5be97cd30bce1d29c134fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca7bc3f6c3de6fc3df3adabf3161260c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#aca7bc3f6c3de6fc3df3adabf3161260c">trim_hanging_indels</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, bool trim_Ns=true, bool preserve_tail_anchors=false)</td></tr>
<tr class="separator:aca7bc3f6c3de6fc3df3adabf3161260c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb9c58b7f20245a4c400dd14e8488069"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#aeb9c58b7f20245a4c400dd14e8488069">remove_transitive_edges</a> (const vector&lt; size_t &gt; &amp;topological_order)</td></tr>
<tr class="separator:aeb9c58b7f20245a4c400dd14e8488069"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8164834df4fc94907fb96b06062c9514"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a8164834df4fc94907fb96b06062c9514">prune_to_high_scoring_paths</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *aligner, double max_suboptimal_score_ratio, const vector&lt; size_t &gt; &amp;topological_order, vector&lt; size_t &gt; &amp;path_node_provenance)</td></tr>
<tr class="separator:a8164834df4fc94907fb96b06062c9514"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af112f1a5af47cf079a163eec1c2e31f4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#af112f1a5af47cf079a163eec1c2e31f4">clear_reachability_edges</a> ()</td></tr>
<tr class="separator:af112f1a5af47cf079a163eec1c2e31f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae053f01b2505d284a43a5d0c2046c82b"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#ae053f01b2505d284a43a5d0c2046c82b">count_reachability_edges</a> () const</td></tr>
<tr class="memdesc:ae053f01b2505d284a43a5d0c2046c82b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of reachability edges in the graph.  <a href="classvg_1_1MultipathAlignmentGraph.html#ae053f01b2505d284a43a5d0c2046c82b">More...</a><br /></td></tr>
<tr class="separator:ae053f01b2505d284a43a5d0c2046c82b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3199fb5e097873e2635e3fb34a8eafe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#ac3199fb5e097873e2635e3fb34a8eafe">trim_to_branch_points</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph, size_t max_trim_length=1)</td></tr>
<tr class="separator:ac3199fb5e097873e2635e3fb34a8eafe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c49582fe16bcb4c87b95e8e3ee93319"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a9c49582fe16bcb4c87b95e8e3ee93319">resect_snarls_from_paths</a> (<a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *cutting_snarls, SnarlDistanceIndex *dist_index, const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;project, int64_t max_snarl_cut_size=5)</td></tr>
<tr class="separator:a9c49582fe16bcb4c87b95e8e3ee93319"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c34e5d02c2b81614ccd602351b81ed9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a3c34e5d02c2b81614ccd602351b81ed9">synthesize_tail_anchors</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;align_graph, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *aligner, size_t min_anchor_size, size_t max_alt_alns, bool dynamic_alt_alns, size_t max_gap, double pessimistic_tail_gap_multiplier)</td></tr>
<tr class="separator:a3c34e5d02c2b81614ccd602351b81ed9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf6b811ae4c3f0c993d3ac4a11359f0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a2bf6b811ae4c3f0c993d3ac4a11359f0">add_reachability_edges</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;vg, const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;project, const unordered_multimap&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;injection_trans, vector&lt; size_t &gt; *path_node_provenance=nullptr)</td></tr>
<tr class="memdesc:a2bf6b811ae4c3f0c993d3ac4a11359f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add edges between reachable nodes and split nodes at overlaps.  <a href="classvg_1_1MultipathAlignmentGraph.html#a2bf6b811ae4c3f0c993d3ac4a11359f0">More...</a><br /></td></tr>
<tr class="separator:a2bf6b811ae4c3f0c993d3ac4a11359f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf2a3fbebf346c3b581d553165c15a02"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#adf2a3fbebf346c3b581d553165c15a02">align</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;align_graph, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *scoring_aligner, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *dp_aligner, bool score_anchors_as_matches, size_t max_alt_alns, bool dynamic_alt_alns, size_t max_gap, double pessimistic_tail_gap_multiplier, size_t max_tail_length, bool simplify_topologies, size_t unmergeable_len, size_t band_padding, <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln_out, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *cutting_snarls=nullptr, SnarlDistanceIndex *dist_index=nullptr, const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; *project=nullptr, bool allow_negative_scores=false, bool align_in_reverse=false, uint64_t max_band_cells=std::numeric_limits&lt; uint64_t &gt;::max())</td></tr>
<tr class="separator:adf2a3fbebf346c3b581d553165c15a02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaafd4d231dde222e7dc64ff9c419ed5b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#aaafd4d231dde222e7dc64ff9c419ed5b">align</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;align_graph, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *scoring_aligner, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *dp_aligner, bool score_anchors_as_matches, size_t max_alt_alns, bool dynamic_alt_alns, size_t max_gap, double pessimistic_tail_gap_multiplier, size_t max_tail_length, bool simplify_topologies, size_t unmergeable_len, const function&lt; size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;)&gt; &amp;band_padding_function, <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln_out, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *cutting_snarls=nullptr, SnarlDistanceIndex *dist_index=nullptr, const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; *project=nullptr, bool allow_negative_scores=false, bool align_in_reverse=false, uint64_t max_band_cells=std::numeric_limits&lt; uint64_t &gt;::max())</td></tr>
<tr class="separator:aaafd4d231dde222e7dc64ff9c419ed5b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90ff13eb09622a6f5fa9238f6ec4950b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a90ff13eb09622a6f5fa9238f6ec4950b">to_dot</a> (ostream &amp;out, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> *alignment=nullptr) const</td></tr>
<tr class="separator:a90ff13eb09622a6f5fa9238f6ec4950b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4fc215d24f20c5ddc3916024c7ab62b"><td class="memItemLeft" align="right" valign="top">vector&lt; vector&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#af4fc215d24f20c5ddc3916024c7ab62b">get_connected_components</a> () const</td></tr>
<tr class="memdesc:af4fc215d24f20c5ddc3916024c7ab62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get lists of the vg node IDs that participate in each connected component in the <a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a>.  <a href="classvg_1_1MultipathAlignmentGraph.html#af4fc215d24f20c5ddc3916024c7ab62b">More...</a><br /></td></tr>
<tr class="separator:af4fc215d24f20c5ddc3916024c7ab62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91dd7a4bc802e510067ae6bcb0fc5b74"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a91dd7a4bc802e510067ae6bcb0fc5b74">empty</a> () const</td></tr>
<tr class="memdesc:a91dd7a4bc802e510067ae6bcb0fc5b74"><td class="mdescLeft">&#160;</td><td class="mdescRight">Does the multipath alignment graph have any nodes?  <a href="classvg_1_1MultipathAlignmentGraph.html#a91dd7a4bc802e510067ae6bcb0fc5b74">More...</a><br /></td></tr>
<tr class="separator:a91dd7a4bc802e510067ae6bcb0fc5b74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec09c91391cfb06c1c9eea132ce4246"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a4ec09c91391cfb06c1c9eea132ce4246">size</a> () const</td></tr>
<tr class="separator:a4ec09c91391cfb06c1c9eea132ce4246"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50ff4a1c2bc2b997c28af99527e595dd"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a50ff4a1c2bc2b997c28af99527e595dd">max_shift</a> () const</td></tr>
<tr class="separator:a50ff4a1c2bc2b997c28af99527e595dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42ef4313d4d24ab4c19532e2bd30652"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#aa42ef4313d4d24ab4c19532e2bd30652">prune_high_shift_edges</a> (size_t prune_diff, bool prohibit_new_sources, bool prohibit_new_sinks)</td></tr>
<tr class="separator:aa42ef4313d4d24ab4c19532e2bd30652"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a8cbd1429036d9f365bd361ffbc8aa855"><td class="memItemLeft" align="right" valign="top">static unordered_multimap&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a8cbd1429036d9f365bd361ffbc8aa855">create_injection_trans</a> (const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;projection_trans)</td></tr>
<tr class="separator:a8cbd1429036d9f365bd361ffbc8aa855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d9d6f3a0995aabf9d09204dd6a4ac9"><td class="memItemLeft" align="right" valign="top">static unordered_multimap&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a00d9d6f3a0995aabf9d09204dd6a4ac9">create_injection_trans</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;project)</td></tr>
<tr class="separator:a00d9d6f3a0995aabf9d09204dd6a4ac9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af626a9a7a96800aa13aa257a5781fffe"><td class="memItemLeft" align="right" valign="top">static unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#af626a9a7a96800aa13aa257a5781fffe">create_identity_projection_trans</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph)</td></tr>
<tr class="separator:af626a9a7a96800aa13aa257a5781fffe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f4f566eaf695fac8c08dc6e5c2083a7"><td class="memItemLeft" align="right" valign="top">static function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a4f4f566eaf695fac8c08dc6e5c2083a7">create_projector</a> (const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;projection_trans)</td></tr>
<tr class="memdesc:a4f4f566eaf695fac8c08dc6e5c2083a7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a lambda function that projects using a map that projects.  <a href="classvg_1_1MultipathAlignmentGraph.html#a4f4f566eaf695fac8c08dc6e5c2083a7">More...</a><br /></td></tr>
<tr class="separator:a4f4f566eaf695fac8c08dc6e5c2083a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-methods"></a>
Protected Member Functions</h2></td></tr>
<tr class="memitem:a4b53be595c1409ee4041167ec9ac9211"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a4b53be595c1409ee4041167ec9ac9211">create_path_chunk_nodes</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, const vector&lt; pair&lt; pair&lt; string::const_iterator, string::const_iterator &gt;, <a class="el" href="classvg_1_1path__t.html">path_t</a> &gt;&gt; &amp;path_chunks, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;project, const unordered_multimap&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;injection_trans, vector&lt; size_t &gt; *path_node_provenance=nullptr)</td></tr>
<tr class="memdesc:a4b53be595c1409ee4041167ec9ac9211"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add the path chunks as nodes to the connectivity graph.  <a href="classvg_1_1MultipathAlignmentGraph.html#a4b53be595c1409ee4041167ec9ac9211">More...</a><br /></td></tr>
<tr class="separator:a4b53be595c1409ee4041167ec9ac9211"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8f0e93b7dd5db8e92e7889629784c70"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#ad8f0e93b7dd5db8e92e7889629784c70">create_match_nodes</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, <a class="el" href="classvg_1_1MultipathMapper.html#acae95760b8750cf3b2bb48d00fe499fd">MultipathMapper::memcluster_t</a> &amp;hits, const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;project, const unordered_multimap&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;injection_trans, vector&lt; size_t &gt; &amp;path_node_provenance, int64_t max_branch_trim_length, const <a class="el" href="classvg_1_1MultipathMapper.html#a165e5c0531ff4337ce6542da263d3fbd">MultipathMapper::match_fanouts_t</a> *fanout_breaks)</td></tr>
<tr class="memdesc:ad8f0e93b7dd5db8e92e7889629784c70"><td class="mdescLeft">&#160;</td><td class="mdescRight">Walk out MEMs into match nodes and filter out redundant sub-MEMs.  <a href="classvg_1_1MultipathAlignmentGraph.html#ad8f0e93b7dd5db8e92e7889629784c70">More...</a><br /></td></tr>
<tr class="separator:ad8f0e93b7dd5db8e92e7889629784c70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8ca4f9936aa6abcc8681e91dae3f43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a9f8ca4f9936aa6abcc8681e91dae3f43">merge_partially_redundant_match_nodes</a> (const unordered_map&lt; int64_t, vector&lt; int64_t &gt;&gt; &amp;node_matches, vector&lt; size_t &gt; &amp;path_node_provenance)</td></tr>
<tr class="memdesc:a9f8ca4f9936aa6abcc8681e91dae3f43"><td class="mdescLeft">&#160;</td><td class="mdescRight">If path nodes partially overlap, merge the sections that overlap into a single path node.  <a href="classvg_1_1MultipathAlignmentGraph.html#a9f8ca4f9936aa6abcc8681e91dae3f43">More...</a><br /></td></tr>
<tr class="separator:a9f8ca4f9936aa6abcc8681e91dae3f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406e1b266f46b28d5d7b4e2041a9210d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a406e1b266f46b28d5d7b4e2041a9210d">jitter_homopolymer_ends</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, vector&lt; size_t &gt; &amp;path_node_provenance, const <a class="el" href="classvg_1_1MultipathMapper.html#acae95760b8750cf3b2bb48d00fe499fd">MultipathMapper::memcluster_t</a> &amp;hits, int64_t max_branch_trim_length)</td></tr>
<tr class="separator:a406e1b266f46b28d5d7b4e2041a9210d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f309bbf60941b009379bd9661cb9060"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a8f309bbf60941b009379bd9661cb9060">collapse_order_length_runs</a> (const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;graph, gcsa::GCSA *gcsa, vector&lt; size_t &gt; &amp;path_node_provenance)</td></tr>
<tr class="separator:a8f309bbf60941b009379bd9661cb9060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adba05a33bf075eb3eb7260e229245f06"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#adba05a33bf075eb3eb7260e229245f06">reorder_adjacency_lists</a> (const vector&lt; size_t &gt; &amp;order)</td></tr>
<tr class="separator:adba05a33bf075eb3eb7260e229245f06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c591d080bc48994fcdb2c9dc08d34a1"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a4c591d080bc48994fcdb2c9dc08d34a1">pessimistic_tail_gap</a> (int64_t tail_length, double multiplier)</td></tr>
<tr class="separator:a4c591d080bc48994fcdb2c9dc08d34a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44bd7328dd8ea140223226ae4da8afff"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a44bd7328dd8ea140223226ae4da8afff">into_cutting_snarl</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> node_id, bool <a class="el" href="namespacevg.html#aac725dd44bc5a8f540554d4b1882c1fe">is_rev</a>, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *snarl_manager, SnarlDistanceIndex *dist_index) const</td></tr>
<tr class="memdesc:a44bd7328dd8ea140223226ae4da8afff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if we're pointing into a snarl that we want to cut out of paths.  <a href="classvg_1_1MultipathAlignmentGraph.html#a44bd7328dd8ea140223226ae4da8afff">More...</a><br /></td></tr>
<tr class="separator:a44bd7328dd8ea140223226ae4da8afff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa64dbf4207ebe2fe75044d60be1d07e"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; size_t, size_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#aaa64dbf4207ebe2fe75044d60be1d07e">get_cut_segments</a> (<a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;path, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *cutting_snarls, SnarlDistanceIndex *dist_index, const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;project, int64_t max_snarl_cut_size) const</td></tr>
<tr class="memdesc:aaa64dbf4207ebe2fe75044d60be1d07e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the intervals of the path that lie inside of snarls.  <a href="classvg_1_1MultipathAlignmentGraph.html#aaa64dbf4207ebe2fe75044d60be1d07e">More...</a><br /></td></tr>
<tr class="separator:aaa64dbf4207ebe2fe75044d60be1d07e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac271f2ff52ff4425b2a04b80718c0df1"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; bool, unordered_map&lt; size_t, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#ac271f2ff52ff4425b2a04b80718c0df1">align_tails</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;align_graph, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *scoring_aligner, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *dp_aligner, size_t max_alt_alns, bool dynamic_alt_alns, size_t max_gap, double pessimistic_tail_gap_multiplier, size_t min_paths, size_t max_tail_length, unordered_set&lt; size_t &gt; *sources=nullptr)</td></tr>
<tr class="separator:ac271f2ff52ff4425b2a04b80718c0df1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a91aa5268618d2f4c1d7b8665108d455c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a91aa5268618d2f4c1d7b8665108d455c">reverse_alignment</a> (<a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;aln) const</td></tr>
<tr class="separator:a91aa5268618d2f4c1d7b8665108d455c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99e7522a1341bc3d5e7d0876156d0e24"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a99e7522a1341bc3d5e7d0876156d0e24">add_decomposed_tail_alignments</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;align_graph, <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;multipath_aln_out, unordered_set&lt; size_t &gt; &amp;prohibited_merges, vector&lt; pair&lt; <a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t &gt;&gt; &amp;shared_tail_alns, vector&lt; vector&lt; pair&lt; <a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t &gt;&gt;&gt; &amp;unshared_tail_alns, size_t attachment_idx, bool to_left, size_t unmergeable_len, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *aligner, <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *cutting_snarls=nullptr, SnarlDistanceIndex *dist_index=nullptr, const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; *project=nullptr)</td></tr>
<tr class="separator:a99e7522a1341bc3d5e7d0876156d0e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:a114d073d4422c085a2c5768b6f165001"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a114d073d4422c085a2c5768b6f165001">trim_and_check_for_empty</a> (const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, bool trim_Ns, <a class="el" href="classvg_1_1PathNode.html">PathNode</a> &amp;<a class="el" href="namespacevg.html#a3bd8aa63fec8b9f6c3ed5808689975e6">path_node</a>, bool preserve_tail_anchors, int64_t *removed_start_from_length=nullptr, int64_t *removed_end_from_length=nullptr)</td></tr>
<tr class="separator:a114d073d4422c085a2c5768b6f165001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acf97e6e2b5f03198f3087d7746e19b85"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#acf97e6e2b5f03198f3087d7746e19b85">deduplicate_alt_alns</a> (vector&lt; pair&lt; <a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t &gt;&gt; &amp;alt_alns, bool leftward, bool rightward)</td></tr>
<tr class="separator:acf97e6e2b5f03198f3087d7746e19b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a24f6cbdc09cf0098251f8b61baf4a"><td class="memItemLeft" align="right" valign="top">static pair&lt; <a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a96a24f6cbdc09cf0098251f8b61baf4a">zip_alignments</a> (vector&lt; pair&lt; <a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t &gt;&gt; &amp;alt_alns, bool from_left, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;align_graph, string::const_iterator begin, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *aligner)</td></tr>
<tr class="separator:a96a24f6cbdc09cf0098251f8b61baf4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e7fa26541aea68ea2c456d79c950377"><td class="memItemLeft" align="right" valign="top">static pair&lt; vector&lt; pair&lt; <a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t &gt; &gt;, vector&lt; vector&lt; pair&lt; <a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t &gt; &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a8e7fa26541aea68ea2c456d79c950377">decompose_alignments</a> (const vector&lt; pair&lt; <a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t &gt;&gt; &amp;alt_alns, const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;alignment, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;align_graph, string::const_iterator begin, const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *aligner)</td></tr>
<tr class="separator:a8e7fa26541aea68ea2c456d79c950377"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a76f9356cd0afea7dea3003caea2526eb"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1PathNode.html">PathNode</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a76f9356cd0afea7dea3003caea2526eb">path_nodes</a></td></tr>
<tr class="memdesc:a76f9356cd0afea7dea3003caea2526eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Nodes representing walked MEMs in the graph.  <a href="classvg_1_1MultipathAlignmentGraph.html#a76f9356cd0afea7dea3003caea2526eb">More...</a><br /></td></tr>
<tr class="separator:a76f9356cd0afea7dea3003caea2526eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a113d4c5b6b5ca1d7748c1b812e8d3"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a77a113d4c5b6b5ca1d7748c1b812e8d3">has_reachability_edges</a> = false</td></tr>
<tr class="separator:a77a113d4c5b6b5ca1d7748c1b812e8d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:af46ba9972db437bf66f787a9bbe6c3cd"><td class="memItemLeft" align="right" valign="top">static thread_local unordered_map&lt; double, vector&lt; int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#af46ba9972db437bf66f787a9bbe6c3cd">pessimistic_tail_gap_memo</a></td></tr>
<tr class="memdesc:af46ba9972db437bf66f787a9bbe6c3cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Memo for the transcendental pessimistic tail gap function (thread local to maintain thread-safety)  <a href="classvg_1_1MultipathAlignmentGraph.html#af46ba9972db437bf66f787a9bbe6c3cd">More...</a><br /></td></tr>
<tr class="separator:af46ba9972db437bf66f787a9bbe6c3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e62ccfd7e7adb135d169f7e2671509"><td class="memItemLeft" align="right" valign="top">static const size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a12e62ccfd7e7adb135d169f7e2671509">tail_gap_memo_max_size</a> = 1000</td></tr>
<tr class="memdesc:a12e62ccfd7e7adb135d169f7e2671509"><td class="mdescLeft">&#160;</td><td class="mdescRight">The largest size we will memoize up to.  <a href="classvg_1_1MultipathAlignmentGraph.html#a12e62ccfd7e7adb135d169f7e2671509">More...</a><br /></td></tr>
<tr class="separator:a12e62ccfd7e7adb135d169f7e2671509"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a058e6120cb359e2566c1c2d7961c608e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a058e6120cb359e2566c1c2d7961c608e">&#9670;&nbsp;</a></span>MultipathAlignmentGraph() <span class="overload">[1/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MultipathAlignmentGraph::MultipathAlignmentGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1MultipathMapper.html#acae95760b8750cf3b2bb48d00fe499fd">MultipathMapper::memcluster_t</a> &amp;&#160;</td>
          <td class="paramname"><em>hits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>project</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_multimap&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>injection_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_node_provenance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_branch_trim_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gcsa::GCSA *&#160;</td>
          <td class="paramname"><em>gcsa</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MultipathMapper.html#a165e5c0531ff4337ce6542da263d3fbd">MultipathMapper::match_fanouts_t</a> *&#160;</td>
          <td class="paramname"><em>fanout_breaks</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a graph of the reachability between MEMs in a DAG-ified graph. If a GCSA is specified, use it to collapse MEMs whose lengths bump up against the GCSA's order limit on MEM length. Produces a graph with reachability edges. Assumes that the cluster is sorted by primarily length and secondarily lexicographically by read interval. If a hit fails to be walked ouut in the graph, it is removed from hits. </p>

</div>
</div>
<a id="a51e7308dc1c0c96d1e576970211b7705"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a51e7308dc1c0c96d1e576970211b7705">&#9670;&nbsp;</a></span>MultipathAlignmentGraph() <span class="overload">[2/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MultipathAlignmentGraph::MultipathAlignmentGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1MultipathMapper.html#acae95760b8750cf3b2bb48d00fe499fd">MultipathMapper::memcluster_t</a> &amp;&#160;</td>
          <td class="paramname"><em>hits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_node_provenance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_branch_trim_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gcsa::GCSA *&#160;</td>
          <td class="paramname"><em>gcsa</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MultipathMapper.html#a165e5c0531ff4337ce6542da263d3fbd">MultipathMapper::match_fanouts_t</a> *&#160;</td>
          <td class="paramname"><em>fanout_breaks</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as the previous constructor, but construct injection_trans implicitly and temporarily. </p>

</div>
</div>
<a id="afd75ac7afd23901c4b8f38eb126bdba0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd75ac7afd23901c4b8f38eb126bdba0">&#9670;&nbsp;</a></span>MultipathAlignmentGraph() <span class="overload">[3/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MultipathAlignmentGraph::MultipathAlignmentGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1MultipathMapper.html#acae95760b8750cf3b2bb48d00fe499fd">MultipathMapper::memcluster_t</a> &amp;&#160;</td>
          <td class="paramname"><em>hits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>project</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_node_provenance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_branch_trim_length</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gcsa::GCSA *&#160;</td>
          <td class="paramname"><em>gcsa</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MultipathMapper.html#a165e5c0531ff4337ce6542da263d3fbd">MultipathMapper::match_fanouts_t</a> *&#160;</td>
          <td class="paramname"><em>fanout_breaks</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the previous constructor, but construct injection_trans implicitly and temporarily using a lambda for a projector </p>

</div>
</div>
<a id="a74eec86f754011999dc6caed5d1f6c8a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74eec86f754011999dc6caed5d1f6c8a">&#9670;&nbsp;</a></span>MultipathAlignmentGraph() <span class="overload">[4/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MultipathAlignmentGraph::MultipathAlignmentGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; pair&lt; string::const_iterator, string::const_iterator &gt;, <a class="el" href="classvg_1_1path__t.html">path_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>project</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_multimap&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>injection_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>realign_Ns</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_tail_anchors</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>path_node_provenance</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Construct a graph of the reachability between aligned chunks in a linearized path graph. Produces a graph with reachability edges. </p>

</div>
</div>
<a id="a366ddb07faadad371e896d3f453e147c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a366ddb07faadad371e896d3f453e147c">&#9670;&nbsp;</a></span>MultipathAlignmentGraph() <span class="overload">[5/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MultipathAlignmentGraph::MultipathAlignmentGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; pair&lt; string::const_iterator, string::const_iterator &gt;, <a class="el" href="classvg_1_1path__t.html">path_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>realign_Ns</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_tail_anchors</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>path_node_provenance</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as the previous constructor, but construct injection_trans implicitly and temporarily. </p>

</div>
</div>
<a id="a4289e77bb6d76abfbb1d3c02d89a2586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4289e77bb6d76abfbb1d3c02d89a2586">&#9670;&nbsp;</a></span>MultipathAlignmentGraph() <span class="overload">[6/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MultipathAlignmentGraph::MultipathAlignmentGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; pair&lt; string::const_iterator, string::const_iterator &gt;, <a class="el" href="classvg_1_1path__t.html">path_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>project</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>realign_Ns</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_tail_anchors</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>path_node_provenance</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the previous constructor, but construct injection_trans implicitly and temporarily and using a lambda for a projector </p>

</div>
</div>
<a id="ac8f4ae19921529920157bcbbf9a2f5c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8f4ae19921529920157bcbbf9a2f5c3">&#9670;&nbsp;</a></span>MultipathAlignmentGraph() <span class="overload">[7/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MultipathAlignmentGraph::MultipathAlignmentGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *&#160;</td>
          <td class="paramname"><em>snarl_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SnarlDistanceIndex *&#160;</td>
          <td class="paramname"><em>dist_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_snarl_cut_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>project</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_multimap&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>injection_trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Make a multipath alignment graph using the path of a single-path alignment. Only one of snarl_manager and dist_index need be supplied. </p>

</div>
</div>
<a id="a10f9b18c8aa4db1b80bf54ccc5dcc09c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10f9b18c8aa4db1b80bf54ccc5dcc09c">&#9670;&nbsp;</a></span>MultipathAlignmentGraph() <span class="overload">[8/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MultipathAlignmentGraph::MultipathAlignmentGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *&#160;</td>
          <td class="paramname"><em>snarl_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SnarlDistanceIndex *&#160;</td>
          <td class="paramname"><em>dist_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_snarl_cut_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_trans</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as the previous constructor, but construct injection_trans implicitly and temporarily. </p>

</div>
</div>
<a id="a89b441f028fd26c177a9ce8d8188b7c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b441f028fd26c177a9ce8d8188b7c1">&#9670;&nbsp;</a></span>MultipathAlignmentGraph() <span class="overload">[9/9]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MultipathAlignmentGraph::MultipathAlignmentGraph </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *&#160;</td>
          <td class="paramname"><em>snarl_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SnarlDistanceIndex *&#160;</td>
          <td class="paramname"><em>dist_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_snarl_cut_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>project</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Same as the previous constructor, but construct injection_trans implicitly and temporarily using a function instead of a map </p>

</div>
</div>
<a id="a85e2932360f805d5c6353cd25e377e5d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85e2932360f805d5c6353cd25e377e5d">&#9670;&nbsp;</a></span>~MultipathAlignmentGraph()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vg::MultipathAlignmentGraph::~MultipathAlignmentGraph </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a99e7522a1341bc3d5e7d0876156d0e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99e7522a1341bc3d5e7d0876156d0e24">&#9670;&nbsp;</a></span>add_decomposed_tail_alignments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::add_decomposed_tail_alignments </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>align_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_set&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>prohibited_merges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>shared_tail_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; vector&lt; pair&lt; <a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t &gt;&gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>unshared_tail_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>attachment_idx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>to_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unmergeable_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *&#160;</td>
          <td class="paramname"><em>cutting_snarls</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SnarlDistanceIndex *&#160;</td>
          <td class="paramname"><em>dist_index</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; *&#160;</td>
          <td class="paramname"><em>project</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2bf6b811ae4c3f0c993d3ac4a11359f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2bf6b811ae4c3f0c993d3ac4a11359f0">&#9670;&nbsp;</a></span>add_reachability_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::add_reachability_edges </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>vg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>project</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_multimap&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>injection_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>path_node_provenance</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add edges between reachable nodes and split nodes at overlaps. </p>
<p>Get the offset in the first visited graph node at which the given MEM starts. Does not account for orientation.</p>
<p>Get the offset in the first visited graph node at which the given MEM ends (i.e. the past-the-end offset). Does not account for orientation.</p>
<p>Get the ID of the first node visited in the graph along the path for a MEM. Does not account for orientation.</p>
<p>Get the ID of the last node visited in the graph along the path for a MEM. Does not account for orientation.</p>
<p>Get the offset in the read of either the start or past-the-end position of the given MEM, according to the end flag.</p>
<p>Get the node ID in the graph of either the start or end position of the given MEM, according to the end flag.</p>

</div>
</div>
<a id="aaafd4d231dde222e7dc64ff9c419ed5b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaafd4d231dde222e7dc64ff9c419ed5b">&#9670;&nbsp;</a></span>align() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>align_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td>
          <td class="paramname"><em>scoring_aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td>
          <td class="paramname"><em>dp_aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>score_anchors_as_matches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_alt_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dynamic_alt_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_gap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pessimistic_tail_gap_multiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_tail_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>simplify_topologies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unmergeable_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; size_t(const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;)&gt; &amp;&#160;</td>
          <td class="paramname"><em>band_padding_function</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *&#160;</td>
          <td class="paramname"><em>cutting_snarls</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SnarlDistanceIndex *&#160;</td>
          <td class="paramname"><em>dist_index</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; *&#160;</td>
          <td class="paramname"><em>project</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>align_in_reverse</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max_band_cells</em> = <code>std::numeric_limits&lt;uint64_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do intervening and tail alignments between the anchoring paths and store the result in a <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a>. Reachability edges must be in the graph. Also, choose the band padding dynamically as a function of the inter-MEM sequence and graph. The <a class="el" href="structvg_1_1Alignment.html">Alignment</a> passed <em>must</em> be the same <a class="el" href="structvg_1_1Alignment.html">Alignment</a> that owns the sequence into which iterators were passed when the <a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a> was constructed! TODO: Shouldn't the class hold a reference to the <a class="el" href="structvg_1_1Alignment.html">Alignment</a> then?</p>
<p>If dp_aligner is different from scoring_aligner, it is used for dynamic programming alignment operations, and the results are rescored with scoring_aligner. Neither may be null.</p>
<p>Note that the output alignment may NOT be in topologically-sorted order, even if this <a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a> is. You MUST sort it with <a class="el" href="namespacevg.html#a3ca9ccb5a2301ed1ce48f6334b3c4937" title="Put subpaths in topological order (assumed to be true for other algorithms)">topologically_order_subpaths()</a> before trying to run DP on it. </p>

</div>
</div>
<a id="adf2a3fbebf346c3b581d553165c15a02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf2a3fbebf346c3b581d553165c15a02">&#9670;&nbsp;</a></span>align() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::align </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>align_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td>
          <td class="paramname"><em>scoring_aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td>
          <td class="paramname"><em>dp_aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>score_anchors_as_matches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_alt_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dynamic_alt_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_gap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pessimistic_tail_gap_multiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_tail_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>simplify_topologies</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>unmergeable_len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>band_padding</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a> &amp;&#160;</td>
          <td class="paramname"><em>multipath_aln_out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *&#160;</td>
          <td class="paramname"><em>cutting_snarls</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SnarlDistanceIndex *&#160;</td>
          <td class="paramname"><em>dist_index</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; *&#160;</td>
          <td class="paramname"><em>project</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allow_negative_scores</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>align_in_reverse</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"><em>max_band_cells</em> = <code>std::numeric_limits&lt;uint64_t&gt;::max()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do intervening and tail alignments between the anchoring paths and store the result in a <a class="el" href="classvg_1_1multipath__alignment__t.html">multipath_alignment_t</a>. Reachability edges must be in the graph. The <a class="el" href="structvg_1_1Alignment.html">Alignment</a> passed <em>must</em> be the same <a class="el" href="structvg_1_1Alignment.html">Alignment</a> that owns the sequence into which iterators were passed when the <a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a> was constructed! TODO: Shouldn't the class hold a reference to the <a class="el" href="structvg_1_1Alignment.html">Alignment</a> then?</p>
<p>If dp_aligner is different from scoring_aligner, it is used for dynamic programming alignment operations, and the results are rescored with scoring_aligner. Neither may be null.</p>
<p>Note that the output alignment may NOT be in topologically-sorted order, even if this <a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a> is. You MUST sort it with <a class="el" href="namespacevg.html#a3ca9ccb5a2301ed1ce48f6334b3c4937" title="Put subpaths in topological order (assumed to be true for other algorithms)">topologically_order_subpaths()</a> before trying to run DP on it. </p>

</div>
</div>
<a id="ac271f2ff52ff4425b2a04b80718c0df1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac271f2ff52ff4425b2a04b80718c0df1">&#9670;&nbsp;</a></span>align_tails()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; bool, unordered_map&lt; size_t, vector&lt; <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &gt; &gt; &gt; vg::MultipathAlignmentGraph::align_tails </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>align_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td>
          <td class="paramname"><em>scoring_aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td>
          <td class="paramname"><em>dp_aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_alt_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dynamic_alt_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_gap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pessimistic_tail_gap_multiplier</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_paths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_tail_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unordered_set&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>sources</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Generate alignments of the tails of the query sequence, beyond the sources and sinks. The <a class="el" href="structvg_1_1Alignment.html">Alignment</a> passed <em>must</em> be the one that owns the sequence we are working on. Returns a map from tail (left=false, right=true), to a map from subpath number to all the Alignments of the tail off of that subpath. Also computes the source subpaths and adds their numbers to the given set if not null.</p>
<p>If dp_aligner is different from scoring_aligner, it is used for dynamic programming alignment operations (where its scores do not risk overflow), and the results are rescored with scoring_aligner. Neither may be null.</p>
<p>If a tail is longer than max_tail_length, produces an alignment softclipping it.</p>
<p>If dynamic alignment count is also selected, can indicate a minimum number of paths that must be in the extending graph in order to do an alignment </p>

</div>
</div>
<a id="af112f1a5af47cf079a163eec1c2e31f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af112f1a5af47cf079a163eec1c2e31f4">&#9670;&nbsp;</a></span>clear_reachability_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::clear_reachability_edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Clear reachability edges, so that add_reachability_edges can be run (possibly after modifying the graph). </p>

</div>
</div>
<a id="a8f309bbf60941b009379bd9661cb9060"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f309bbf60941b009379bd9661cb9060">&#9670;&nbsp;</a></span>collapse_order_length_runs()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::collapse_order_length_runs </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gcsa::GCSA *&#160;</td>
          <td class="paramname"><em>gcsa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_node_provenance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Identifies runs of exact matches that are sub-maximal because they hit the order of the GCSA index and merges them into a single node, assumes that match nodes are sorted by length and then lexicographically by read interval, does not update edges </p>

</div>
</div>
<a id="ae053f01b2505d284a43a5d0c2046c82b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae053f01b2505d284a43a5d0c2046c82b">&#9670;&nbsp;</a></span>count_reachability_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathAlignmentGraph::count_reachability_edges </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of reachability edges in the graph. </p>

</div>
</div>
<a id="af626a9a7a96800aa13aa257a5781fffe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af626a9a7a96800aa13aa257a5781fffe">&#9670;&nbsp;</a></span>create_identity_projection_trans()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt; &gt; vg::MultipathAlignmentGraph::create_identity_projection_trans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create an identity projection translation from a DAG that did not need to be modified during dagification. </p>

</div>
</div>
<a id="a00d9d6f3a0995aabf9d09204dd6a4ac9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d9d6f3a0995aabf9d09204dd6a4ac9">&#9670;&nbsp;</a></span>create_injection_trans() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_multimap&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt; &gt; vg::MultipathAlignmentGraph::create_injection_trans </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>project</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create the constant injection translation data from a function instead of a map </p>

</div>
</div>
<a id="a8cbd1429036d9f365bd361ffbc8aa855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8cbd1429036d9f365bd361ffbc8aa855">&#9670;&nbsp;</a></span>create_injection_trans() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_multimap&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt; &gt; vg::MultipathAlignmentGraph::create_injection_trans </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_trans</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Create the constant injection translation data, which maps a node in the original graph to every one of its occurrences in the dagified graph, by reversing the projection translation. This data is needed to construct the <a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a>, and to perform some other operations on it, but is big enough that it is worth not making it a member. </p>

</div>
</div>
<a id="ad8f0e93b7dd5db8e92e7889629784c70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad8f0e93b7dd5db8e92e7889629784c70">&#9670;&nbsp;</a></span>create_match_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::create_match_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1MultipathMapper.html#acae95760b8750cf3b2bb48d00fe499fd">MultipathMapper::memcluster_t</a> &amp;&#160;</td>
          <td class="paramname"><em>hits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>project</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_multimap&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>injection_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_node_provenance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_branch_trim_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MultipathMapper.html#a165e5c0531ff4337ce6542da263d3fbd">MultipathMapper::match_fanouts_t</a> *&#160;</td>
          <td class="paramname"><em>fanout_breaks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Walk out MEMs into match nodes and filter out redundant sub-MEMs. </p>

</div>
</div>
<a id="a4b53be595c1409ee4041167ec9ac9211"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b53be595c1409ee4041167ec9ac9211">&#9670;&nbsp;</a></span>create_path_chunk_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::create_path_chunk_nodes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; pair&lt; pair&lt; string::const_iterator, string::const_iterator &gt;, <a class="el" href="classvg_1_1path__t.html">path_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>path_chunks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>project</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const unordered_multimap&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>injection_trans</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; *&#160;</td>
          <td class="paramname"><em>path_node_provenance</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add the path chunks as nodes to the connectivity graph. </p>

</div>
</div>
<a id="a4f4f566eaf695fac8c08dc6e5c2083a7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f4f566eaf695fac8c08dc6e5c2083a7">&#9670;&nbsp;</a></span>create_projector()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; vg::MultipathAlignmentGraph::create_projector </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>projection_trans</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a lambda function that projects using a map that projects. </p>

</div>
</div>
<a id="a8e7fa26541aea68ea2c456d79c950377"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e7fa26541aea68ea2c456d79c950377">&#9670;&nbsp;</a></span>decompose_alignments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; vector&lt; pair&lt; <a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t &gt; &gt;, vector&lt; vector&lt; pair&lt; <a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t &gt; &gt; &gt; &gt; vg::MultipathAlignmentGraph::decompose_alignments </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; pair&lt; <a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>alt_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>align_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string::const_iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Identifies regions that are shared across all of the alternative alignments, and then splits those regions out into separate alignments, dividing the set of alternative alignments accordingly. Return value consists of a vector of the shared segments and a vector of vectors of the segments between. The length of the vector of shared segments is +1 of the vector of between segments, so that they are interleaved. The first and/or last of the alignments of shared segments may be empty if there is no shared prefix or suffix across all the alignments. If there are no shared segments at all, will return pair of empty vectors. Blocks of unshared paths will be sorted into descending order by score. </p>

</div>
</div>
<a id="acf97e6e2b5f03198f3087d7746e19b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acf97e6e2b5f03198f3087d7746e19b85">&#9670;&nbsp;</a></span>deduplicate_alt_alns()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::deduplicate_alt_alns </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>alt_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>leftward</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rightward</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Removes alignments that follow the same path through the graph, retaining only the highest scoring ones. If deduplicating leftward, then also removes paths that take a longer path for no greater score in the leftward direction. Vice versa for rightward. Assumes alignments are descending order by score. </p>

</div>
</div>
<a id="a91dd7a4bc802e510067ae6bcb0fc5b74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91dd7a4bc802e510067ae6bcb0fc5b74">&#9670;&nbsp;</a></span>empty()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathAlignmentGraph::empty </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Does the multipath alignment graph have any nodes? </p>

</div>
</div>
<a id="af4fc215d24f20c5ddc3916024c7ab62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4fc215d24f20c5ddc3916024c7ab62b">&#9670;&nbsp;</a></span>get_connected_components()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; vector&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt; &gt; vg::MultipathAlignmentGraph::get_connected_components </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get lists of the vg node IDs that participate in each connected component in the <a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a>. </p>

</div>
</div>
<a id="aaa64dbf4207ebe2fe75044d60be1d07e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa64dbf4207ebe2fe75044d60be1d07e">&#9670;&nbsp;</a></span>get_cut_segments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt; pair&lt; size_t, size_t &gt; &gt; vg::MultipathAlignmentGraph::get_cut_segments </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1path__t.html">path_t</a> &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *&#160;</td>
          <td class="paramname"><em>cutting_snarls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SnarlDistanceIndex *&#160;</td>
          <td class="paramname"><em>dist_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>project</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_snarl_cut_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the intervals of the path that lie inside of snarls. </p>

</div>
</div>
<a id="a44bd7328dd8ea140223226ae4da8afff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44bd7328dd8ea140223226ae4da8afff">&#9670;&nbsp;</a></span>into_cutting_snarl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathAlignmentGraph::into_cutting_snarl </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>is_rev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *&#160;</td>
          <td class="paramname"><em>snarl_manager</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SnarlDistanceIndex *&#160;</td>
          <td class="paramname"><em>dist_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if we're pointing into a snarl that we want to cut out of paths. </p>

</div>
</div>
<a id="a406e1b266f46b28d5d7b4e2041a9210d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406e1b266f46b28d5d7b4e2041a9210d">&#9670;&nbsp;</a></span>jitter_homopolymer_ends()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::jitter_homopolymer_ends </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_node_provenance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1MultipathMapper.html#acae95760b8750cf3b2bb48d00fe499fd">MultipathMapper::memcluster_t</a> &amp;&#160;</td>
          <td class="paramname"><em>hits</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_branch_trim_length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a50ff4a1c2bc2b997c28af99527e595dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50ff4a1c2bc2b997c28af99527e595dd">&#9670;&nbsp;</a></span>max_shift()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathAlignmentGraph::max_shift </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>For a graph with reachability edges, identifies the largest difference between read interval and reference distance </p>

</div>
</div>
<a id="a9f8ca4f9936aa6abcc8681e91dae3f43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f8ca4f9936aa6abcc8681e91dae3f43">&#9670;&nbsp;</a></span>merge_partially_redundant_match_nodes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::merge_partially_redundant_match_nodes </td>
          <td>(</td>
          <td class="paramtype">const unordered_map&lt; int64_t, vector&lt; int64_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>node_matches</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_node_provenance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If path nodes partially overlap, merge the sections that overlap into a single path node. </p>

</div>
</div>
<a id="a4c591d080bc48994fcdb2c9dc08d34a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c591d080bc48994fcdb2c9dc08d34a1">&#9670;&nbsp;</a></span>pessimistic_tail_gap()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t vg::MultipathAlignmentGraph::pessimistic_tail_gap </td>
          <td>(</td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>tail_length</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>multiplier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the pessimistic gap length corresponding to a certain tail length and multiplier (proportional to the square root of the tail length) </p>

</div>
</div>
<a id="aa42ef4313d4d24ab4c19532e2bd30652"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42ef4313d4d24ab4c19532e2bd30652">&#9670;&nbsp;</a></span>prune_high_shift_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::prune_high_shift_edges </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>prune_diff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prohibit_new_sources</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>prohibit_new_sinks</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8164834df4fc94907fb96b06062c9514"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8164834df4fc94907fb96b06062c9514">&#9670;&nbsp;</a></span>prune_to_high_scoring_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::prune_to_high_scoring_paths </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>max_suboptimal_score_ratio</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>topological_order</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>path_node_provenance</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes nodes and edges that are not part of any path that has an estimated score within some amount of the highest scoring path. Reachability edges must be present. </p>

</div>
</div>
<a id="aeb9c58b7f20245a4c400dd14e8488069"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb9c58b7f20245a4c400dd14e8488069">&#9670;&nbsp;</a></span>remove_transitive_edges()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::remove_transitive_edges </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>topological_order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes all transitive edges from graph (reduces to minimum equivalent graph), except for edges between path nodes that abut either on the graph or read. These edges often correspond to overlap breaks in low complexity sequence, so retaining them improves alignment in low-complexity regions like STR expansions. Note: reorders internal representation of adjacency lists. Reachability edges must be in the graph. </p>

</div>
</div>
<a id="adba05a33bf075eb3eb7260e229245f06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adba05a33bf075eb3eb7260e229245f06">&#9670;&nbsp;</a></span>reorder_adjacency_lists()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::reorder_adjacency_lists </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>order</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reorders adjacency list representation of edges so that they follow the indicated ordering of their target nodes </p>

</div>
</div>
<a id="a9c49582fe16bcb4c87b95e8e3ee93319"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c49582fe16bcb4c87b95e8e3ee93319">&#9670;&nbsp;</a></span>resect_snarls_from_paths()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::resect_snarls_from_paths </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> *&#160;</td>
          <td class="paramname"><em>cutting_snarls</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SnarlDistanceIndex *&#160;</td>
          <td class="paramname"><em>dist_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, bool &gt;(<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>project</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>max_snarl_cut_size</em> = <code>5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Cut the interior of snarls out of anchoring paths (and split alignment nodes accordingly) unless they are longer than the max cut size. Snarls can be stored either in a <a class="el" href="classvg_1_1SnarlManager.html">SnarlManager</a> or a SnarlDistanceIndex (only one need be supplied). </p>

</div>
</div>
<a id="a91aa5268618d2f4c1d7b8665108d455c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a91aa5268618d2f4c1d7b8665108d455c">&#9670;&nbsp;</a></span>reverse_alignment()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::reverse_alignment </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>aln</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4ec09c91391cfb06c1c9eea132ce4246"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec09c91391cfb06c1c9eea132ce4246">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::MultipathAlignmentGraph::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3c34e5d02c2b81614ccd602351b81ed9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c34e5d02c2b81614ccd602351b81ed9">&#9670;&nbsp;</a></span>synthesize_tail_anchors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::synthesize_tail_anchors </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>align_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>min_anchor_size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_alt_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>dynamic_alt_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_gap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>pessimistic_tail_gap_multiplier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Do some exploratory alignments of the tails of the graph, outside the outermost existing anchors, and define new anchoring paths from them. After this, you can call resect_snarls_from_paths, in order to get better coverage of possible combinations of snarl traversals in parts of the alignment that didn't originally have anchors. Produces <em>only</em> perfect match anchors, so it is still safe to use score_anchors_as_matches. The <a class="el" href="structvg_1_1Alignment.html">Alignment</a> passed <em>must</em> be the same <a class="el" href="structvg_1_1Alignment.html">Alignment</a> that owns the sequence into which iterators were passed when the <a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a> was constructed! TODO: Shouldn't the class hold a reference to the <a class="el" href="structvg_1_1Alignment.html">Alignment</a> then? </p>

</div>
</div>
<a id="a90ff13eb09622a6f5fa9238f6ec4950b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90ff13eb09622a6f5fa9238f6ec4950b">&#9670;&nbsp;</a></span>to_dot()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::to_dot </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> *&#160;</td>
          <td class="paramname"><em>alignment</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts a <a class="el" href="classvg_1_1MultipathAlignmentGraph.html">MultipathAlignmentGraph</a> to a GraphViz Dot representation, output to the given ostream. If given the <a class="el" href="structvg_1_1Alignment.html">Alignment</a> query we are working on, can produce information about subpath iterators. </p>

</div>
</div>
<a id="a565b45f37d5be97cd30bce1d29c134fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565b45f37d5be97cd30bce1d29c134fc">&#9670;&nbsp;</a></span>topological_sort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::topological_sort </td>
          <td>(</td>
          <td class="paramtype">vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>order_out</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fills input vector with node indices of a topological sort. Reachability edges must be in the graph. </p>

</div>
</div>
<a id="a114d073d4422c085a2c5768b6f165001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a114d073d4422c085a2c5768b6f165001">&#9670;&nbsp;</a></span>trim_and_check_for_empty()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathAlignmentGraph::trim_and_check_for_empty </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trim_Ns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1PathNode.html">PathNode</a> &amp;&#160;</td>
          <td class="paramname"><em>path_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_tail_anchors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>removed_start_from_length</em> = <code>nullptr</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t *&#160;</td>
          <td class="paramname"><em>removed_end_from_length</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Trim down the given <a class="el" href="classvg_1_1PathNode.html">PathNode</a> of everything except softclips. Return true if it all gets trimmed away and should be removed. Fills in removed_start_from_length and/or removed_end_from_length with the bases in the graph removed from the path on each end during trimming, if set. If preserve tail anchors is true, then a null anchor (no bases and no path) will be preserved if the read segment corresponds to the beginning or end of the alignment sequence. </p>

</div>
</div>
<a id="aca7bc3f6c3de6fc3df3adabf3161260c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca7bc3f6c3de6fc3df3adabf3161260c">&#9670;&nbsp;</a></span>trim_hanging_indels()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::trim_hanging_indels </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>trim_Ns</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>preserve_tail_anchors</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Removes non-softclip indels from path nodes. Does not update edges&ndash;should be called prior to adding computing edges. If preserve tail anchors is true, then a null anchor (no bases and no path) will be preserved if the read segment orresponds to the beginning or end of the alignment sequence. </p>

</div>
</div>
<a id="ac3199fb5e097873e2635e3fb34a8eafe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3199fb5e097873e2635e3fb34a8eafe">&#9670;&nbsp;</a></span>trim_to_branch_points()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::MultipathAlignmentGraph::trim_to_branch_points </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_trim_length</em> = <code>1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Remove the ends of paths, up to a maximum length, if they cause the path to extend past a branch point in the graph. </p>

</div>
</div>
<a id="a96a24f6cbdc09cf0098251f8b61baf4a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96a24f6cbdc09cf0098251f8b61baf4a">&#9670;&nbsp;</a></span>zip_alignments()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">pair&lt; <a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t &gt; vg::MultipathAlignmentGraph::zip_alignments </td>
          <td>(</td>
          <td class="paramtype">vector&lt; pair&lt; <a class="el" href="classvg_1_1path__t.html">path_t</a>, int32_t &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>alt_alns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>from_left</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structvg_1_1Alignment.html">Alignment</a> &amp;&#160;</td>
          <td class="paramname"><em>alignment</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> &amp;&#160;</td>
          <td class="paramname"><em>align_graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">string::const_iterator&#160;</td>
          <td class="paramname"><em>begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1GSSWAligner.html">GSSWAligner</a> *&#160;</td>
          <td class="paramname"><em>aligner</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If a list of aligned subsequences are identifical in a prefix/suffix, remove that prefix/suffix from all of the alignments and return it as a separate alignment. If there is no shared prefix/suffix, returns an empty path with 0 score. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a77a113d4c5b6b5ca1d7748c1b812e8d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77a113d4c5b6b5ca1d7748c1b812e8d3">&#9670;&nbsp;</a></span>has_reachability_edges</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::MultipathAlignmentGraph::has_reachability_edges = false</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>We keep a flag for whether the reachability edges are set. This is for error checking, and is kind of a forgery (you should just check the actual edge records), but the state system we use is confusing so we want to make sure we have lots of asserts to enforce it. If this is set and you want it unset, use <a class="el" href="classvg_1_1MultipathAlignmentGraph.html#af112f1a5af47cf079a163eec1c2e31f4">clear_reachability_edges()</a>. If this is unset and you want it set, use <a class="el" href="classvg_1_1MultipathAlignmentGraph.html#a2bf6b811ae4c3f0c993d3ac4a11359f0" title="Add edges between reachable nodes and split nodes at overlaps.">add_reachability_edges()</a>. </p>

</div>
</div>
<a id="a76f9356cd0afea7dea3003caea2526eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76f9356cd0afea7dea3003caea2526eb">&#9670;&nbsp;</a></span>path_nodes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="classvg_1_1PathNode.html">PathNode</a>&gt; vg::MultipathAlignmentGraph::path_nodes</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Nodes representing walked MEMs in the graph. </p>

</div>
</div>
<a id="af46ba9972db437bf66f787a9bbe6c3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af46ba9972db437bf66f787a9bbe6c3cd">&#9670;&nbsp;</a></span>pessimistic_tail_gap_memo</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">thread_local unordered_map&lt; double, vector&lt; int64_t &gt; &gt; vg::MultipathAlignmentGraph::pessimistic_tail_gap_memo</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Memo for the transcendental pessimistic tail gap function (thread local to maintain thread-safety) </p>

</div>
</div>
<a id="a12e62ccfd7e7adb135d169f7e2671509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e62ccfd7e7adb135d169f7e2671509">&#9670;&nbsp;</a></span>tail_gap_memo_max_size</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const size_t vg::MultipathAlignmentGraph::tail_gap_memo_max_size = 1000</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The largest size we will memoize up to. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="multipath__alignment__graph_8hpp.html">multipath_alignment_graph.hpp</a></li>
<li>src/<a class="el" href="multipath__alignment__graph_8cpp.html">multipath_alignment_graph.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
