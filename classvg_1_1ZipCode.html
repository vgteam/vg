<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::ZipCode Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1ZipCode.html">ZipCode</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-attribs">Public Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-attribs">Static Private Attributes</a> &#124;
<a href="classvg_1_1ZipCode-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::ZipCode Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;zip_code.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ZipCode_1_1chain__code__t.html">chain_code_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ZipCode_1_1decoder__t.html">decoder_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ZipCode_1_1node__code__t.html">node_code_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structvg_1_1ZipCode_1_1snarl__code__t.html">snarl_code_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3a7913620a6b9e7988e14c210c51e9c3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a3a7913620a6b9e7988e14c210c51e9c3">code_type_t</a> { <br />
&#160;&#160;<a class="el" href="classvg_1_1ZipCode.html#a3a7913620a6b9e7988e14c210c51e9c3a2995e7f61da600fe7b67e5fd40d4b319">NODE</a> = 1, 
<a class="el" href="classvg_1_1ZipCode.html#a3a7913620a6b9e7988e14c210c51e9c3a0fadb599003438c0ef1ebccfab78b8d6">CHAIN</a>, 
<a class="el" href="classvg_1_1ZipCode.html#a3a7913620a6b9e7988e14c210c51e9c3a857cb70dc6bd3383a768a8696e67689c">REGULAR_SNARL</a>, 
<a class="el" href="classvg_1_1ZipCode.html#a3a7913620a6b9e7988e14c210c51e9c3a96d1de8b0fd352dc3449d17eab32f6f4">IRREGULAR_SNARL</a>, 
<br />
&#160;&#160;<a class="el" href="classvg_1_1ZipCode.html#a3a7913620a6b9e7988e14c210c51e9c3a5fb7cef86123c58871519b0a317708d0">CYCLIC_SNARL</a>, 
<a class="el" href="classvg_1_1ZipCode.html#a3a7913620a6b9e7988e14c210c51e9c3a438bae58eb821bbbc90b1b4bc486d682">ROOT_SNARL</a>, 
<a class="el" href="classvg_1_1ZipCode.html#a3a7913620a6b9e7988e14c210c51e9c3a3350f37a328be806a1a8bb7534d7fb8c">ROOT_CHAIN</a>, 
<a class="el" href="classvg_1_1ZipCode.html#a3a7913620a6b9e7988e14c210c51e9c3a3c192049eca2f2b4aafe984ff4a965d3">ROOT_NODE</a>, 
<br />
&#160;&#160;<a class="el" href="classvg_1_1ZipCode.html#a3a7913620a6b9e7988e14c210c51e9c3add89c8b2a06030b4a1d698a011538aaa">EMPTY</a>
<br />
 }</td></tr>
<tr class="separator:a3a7913620a6b9e7988e14c210c51e9c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930c205d47f41592d63fd98aefddd336"><td class="memItemLeft" align="right" valign="top">typedef std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a930c205d47f41592d63fd98aefddd336">code_type</a></td></tr>
<tr class="separator:a930c205d47f41592d63fd98aefddd336"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ac232fe003bd30dfbba804cf0bc81b580"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#ac232fe003bd30dfbba804cf0bc81b580">fill_in_zipcode</a> (const SnarlDistanceIndex &amp;distance_index, const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">vg::pos_t</a> &amp;pos, bool fill_in_decoder=true)</td></tr>
<tr class="separator:ac232fe003bd30dfbba804cf0bc81b580"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad53005c4c44463b1226835f7f7da83e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#ad53005c4c44463b1226835f7f7da83e0">fill_in_zipcode_from_payload</a> (const gbwtgraph::Payload &amp;payload)</td></tr>
<tr class="separator:ad53005c4c44463b1226835f7f7da83e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05895f989a23d97b08bd0c1c56bbc3bc"><td class="memItemLeft" align="right" valign="top">gbwtgraph::Payload&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a05895f989a23d97b08bd0c1c56bbc3bc">get_payload_from_zip</a> () const</td></tr>
<tr class="separator:a05895f989a23d97b08bd0c1c56bbc3bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36fb166e87c595d4e513b5e6a7676958"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a36fb166e87c595d4e513b5e6a7676958">byte_count</a> () const</td></tr>
<tr class="memdesc:a36fb166e87c595d4e513b5e6a7676958"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many bytes were used to store this zipcode?  <a href="classvg_1_1ZipCode.html#a36fb166e87c595d4e513b5e6a7676958">More...</a><br /></td></tr>
<tr class="separator:a36fb166e87c595d4e513b5e6a7676958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b983931fc8219fafc6cde9357b553b0"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a0b983931fc8219fafc6cde9357b553b0">operator==</a> (const <a class="el" href="classvg_1_1ZipCode.html">ZipCode</a> &amp;other) const</td></tr>
<tr class="memdesc:a0b983931fc8219fafc6cde9357b553b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Equality operator.  <a href="classvg_1_1ZipCode.html#a0b983931fc8219fafc6cde9357b553b0">More...</a><br /></td></tr>
<tr class="separator:a0b983931fc8219fafc6cde9357b553b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43c4b30e62f754722d730d47306e76cd"><td class="memItemLeft" align="right" valign="top">std::vector&lt; size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a43c4b30e62f754722d730d47306e76cd">to_vector</a> () const</td></tr>
<tr class="memdesc:a43c4b30e62f754722d730d47306e76cd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dump to a normal vector.  <a href="classvg_1_1ZipCode.html#a43c4b30e62f754722d730d47306e76cd">More...</a><br /></td></tr>
<tr class="separator:a43c4b30e62f754722d730d47306e76cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbad7130678653add25cc79639b0f886"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#acbad7130678653add25cc79639b0f886">from_vector</a> (const std::vector&lt; size_t &gt; &amp;values)</td></tr>
<tr class="memdesc:acbad7130678653add25cc79639b0f886"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load from a normal vector.  <a href="classvg_1_1ZipCode.html#acbad7130678653add25cc79639b0f886">More...</a><br /></td></tr>
<tr class="separator:acbad7130678653add25cc79639b0f886"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e7cd0b16ad1b9ac447b6eb0458f289d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ZipCode_1_1node__code__t.html">node_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a7e7cd0b16ad1b9ac447b6eb0458f289d">unpack_node_code</a> (size_t zipcode_level) const</td></tr>
<tr class="separator:a7e7cd0b16ad1b9ac447b6eb0458f289d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e91c21e0b8a818b6de6a620ee0bdf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ZipCode_1_1chain__code__t.html">chain_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a66e91c21e0b8a818b6de6a620ee0bdf5">unpack_chain_code</a> (size_t zipcode_level) const</td></tr>
<tr class="separator:a66e91c21e0b8a818b6de6a620ee0bdf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b76c5d63d72f9938352327e6d7b06c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ZipCode_1_1snarl__code__t.html">snarl_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a4b76c5d63d72f9938352327e6d7b06c0">unpack_snarl_code</a> (size_t zipcode_level) const</td></tr>
<tr class="separator:a4b76c5d63d72f9938352327e6d7b06c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea9e1d42e1a0b31941401212fd87d76a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#aea9e1d42e1a0b31941401212fd87d76a">fill_in_full_decoder</a> ()</td></tr>
<tr class="memdesc:aea9e1d42e1a0b31941401212fd87d76a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Go through the entire zipcode and fill in the decoder.  <a href="classvg_1_1ZipCode.html#aea9e1d42e1a0b31941401212fd87d76a">More...</a><br /></td></tr>
<tr class="separator:aea9e1d42e1a0b31941401212fd87d76a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a020fef499f038a3dac191667b2fb8e16"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a020fef499f038a3dac191667b2fb8e16">fill_in_next_decoder</a> ()</td></tr>
<tr class="separator:a020fef499f038a3dac191667b2fb8e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa9b8e3ee702697e3692a83e2307d9084"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#aa9b8e3ee702697e3692a83e2307d9084">max_depth</a> () const</td></tr>
<tr class="memdesc:aa9b8e3ee702697e3692a83e2307d9084"><td class="mdescLeft">&#160;</td><td class="mdescRight">What is the maximum depth of this zipcode?  <a href="classvg_1_1ZipCode.html#aa9b8e3ee702697e3692a83e2307d9084">More...</a><br /></td></tr>
<tr class="separator:aa9b8e3ee702697e3692a83e2307d9084"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5cc414a3fa14b68799c93fa61486a31"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#ab5cc414a3fa14b68799c93fa61486a31">decoder_length</a> () const</td></tr>
<tr class="memdesc:ab5cc414a3fa14b68799c93fa61486a31"><td class="mdescLeft">&#160;</td><td class="mdescRight">How many codes in the zipcode have been decoded?  <a href="classvg_1_1ZipCode.html#ab5cc414a3fa14b68799c93fa61486a31">More...</a><br /></td></tr>
<tr class="separator:ab5cc414a3fa14b68799c93fa61486a31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac91d59c7100fefc2011cda07996ed71a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1ZipCode.html#a3a7913620a6b9e7988e14c210c51e9c3">ZipCode::code_type_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#ac91d59c7100fefc2011cda07996ed71a">get_code_type</a> (const size_t &amp;depth) const</td></tr>
<tr class="memdesc:ac91d59c7100fefc2011cda07996ed71a"><td class="mdescLeft">&#160;</td><td class="mdescRight">What type of snarl tree node is at the given depth (index into the zipcode)  <a href="classvg_1_1ZipCode.html#ac91d59c7100fefc2011cda07996ed71a">More...</a><br /></td></tr>
<tr class="separator:ac91d59c7100fefc2011cda07996ed71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8a5fd40be34ed83736e027a3ca6d9889"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a8a5fd40be34ed83736e027a3ca6d9889">get_length</a> (const size_t &amp;depth, bool get_chain_component_length=false) const</td></tr>
<tr class="separator:a8a5fd40be34ed83736e027a3ca6d9889"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32750209d049ac9e5fea67c97be1f151"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a32750209d049ac9e5fea67c97be1f151">get_rank_in_snarl</a> (const size_t &amp;depth) const</td></tr>
<tr class="memdesc:a32750209d049ac9e5fea67c97be1f151"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the rank of a node/snarl in a snarl. Throw an exception if it isn't the child of a snarl.  <a href="classvg_1_1ZipCode.html#a32750209d049ac9e5fea67c97be1f151">More...</a><br /></td></tr>
<tr class="separator:a32750209d049ac9e5fea67c97be1f151"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d78deca4d723ac8d5ede306abd5578"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#ad6d78deca4d723ac8d5ede306abd5578">get_snarl_child_count</a> (const size_t &amp;depth, const SnarlDistanceIndex *distance_index=nullptr) const</td></tr>
<tr class="memdesc:ad6d78deca4d723ac8d5ede306abd5578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the number of children in a snarl. Throw an exception if it isn't a snarl.  <a href="classvg_1_1ZipCode.html#ad6d78deca4d723ac8d5ede306abd5578">More...</a><br /></td></tr>
<tr class="separator:ad6d78deca4d723ac8d5ede306abd5578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d8b333ee954fa9a513b6190e1910843"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a5d8b333ee954fa9a513b6190e1910843">get_offset_in_chain</a> (const size_t &amp;depth, const SnarlDistanceIndex *distance_index=nullptr) const</td></tr>
<tr class="separator:a5d8b333ee954fa9a513b6190e1910843"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af85179af0d75add0b10023343c2a407a"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#af85179af0d75add0b10023343c2a407a">get_chain_component</a> (const size_t &amp;depth) const</td></tr>
<tr class="separator:af85179af0d75add0b10023343c2a407a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf980083db4440866ee59d2a1b89e957"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#aaf980083db4440866ee59d2a1b89e957">get_last_chain_component</a> (const size_t &amp;depth, bool get_end=false) const</td></tr>
<tr class="separator:aaf980083db4440866ee59d2a1b89e957"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c0fa7d7130b57bee9b557750eb97eab"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a2c0fa7d7130b57bee9b557750eb97eab">get_is_looping_chain</a> (const size_t &amp;depth) const</td></tr>
<tr class="separator:a2c0fa7d7130b57bee9b557750eb97eab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af27a1ca0026e32e588d0bb3b62a5bade"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#af27a1ca0026e32e588d0bb3b62a5bade">get_is_reversed_in_parent</a> (const size_t &amp;depth) const</td></tr>
<tr class="memdesc:af27a1ca0026e32e588d0bb3b62a5bade"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the snarl tree node backwards relative to its parent.  <a href="classvg_1_1ZipCode.html#af27a1ca0026e32e588d0bb3b62a5bade">More...</a><br /></td></tr>
<tr class="separator:af27a1ca0026e32e588d0bb3b62a5bade"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a051a9144646b660f213fe44d5b123d77"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a051a9144646b660f213fe44d5b123d77">get_net_handle</a> (const size_t &amp;depth, const SnarlDistanceIndex *distance_index) const</td></tr>
<tr class="separator:a051a9144646b660f213fe44d5b123d77"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1d40ef72bc5fa0f9e0e933add4265a2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#ad1d40ef72bc5fa0f9e0e933add4265a2">get_net_handle_slow</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, const size_t &amp;depth, const SnarlDistanceIndex *distance_index, const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> *child_handle=nullptr) const</td></tr>
<tr class="separator:ad1d40ef72bc5fa0f9e0e933add4265a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6cc3964efc186615dab6bdd8bc52fbfb"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a6cc3964efc186615dab6bdd8bc52fbfb">get_distance_index_address</a> (const size_t &amp;depth) const</td></tr>
<tr class="separator:a6cc3964efc186615dab6bdd8bc52fbfb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad39662d894fe714c1d8596b0343557f6"><td class="memItemLeft" align="right" valign="top">size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#ad39662d894fe714c1d8596b0343557f6">get_distance_to_snarl_bound</a> (const size_t &amp;depth, bool snarl_start, bool left_side) const</td></tr>
<tr class="memdesc:ad39662d894fe714c1d8596b0343557f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">The minimum distance from start or end of the snarl to the left or right side of the child.  <a href="classvg_1_1ZipCode.html#ad39662d894fe714c1d8596b0343557f6">More...</a><br /></td></tr>
<tr class="separator:ad39662d894fe714c1d8596b0343557f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28d318606661f6e99b2374b5a87f370f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a28d318606661f6e99b2374b5a87f370f">is_externally_start_end_connected</a> (const size_t &amp;depth) const</td></tr>
<tr class="separator:a28d318606661f6e99b2374b5a87f370f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a842b8118dd218d6451199c1fd5f2e04b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a842b8118dd218d6451199c1fd5f2e04b">is_externally_start_start_connected</a> (const size_t &amp;depth) const</td></tr>
<tr class="separator:a842b8118dd218d6451199c1fd5f2e04b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac59bc5911574a1fa356cac4f90471324"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#ac59bc5911574a1fa356cac4f90471324">is_externally_end_end_connected</a> (const size_t &amp;depth) const</td></tr>
<tr class="separator:ac59bc5911574a1fa356cac4f90471324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae9095d31b64aa151d6d30e246ee4561"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#aae9095d31b64aa151d6d30e246ee4561">dump</a> (std::ostream &amp;out) const</td></tr>
<tr class="separator:aae9095d31b64aa151d6d30e246ee4561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9a95e07dd615b3692fe7742990c6c8b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1MIPayload.html">MIPayload</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#ae9a95e07dd615b3692fe7742990c6c8b">get_payload_from_zipcode</a> (<a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>, const SnarlDistanceIndex &amp;distance_index, <a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; size_t, <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &gt; *component_to_net_handle=nullptr) const</td></tr>
<tr class="separator:ae9a95e07dd615b3692fe7742990c6c8b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9cb3141131af81b42741bc9e7349e58b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#a064c859d9612d9c2b240b9c0d01f8a85">net_identifier_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a9cb3141131af81b42741bc9e7349e58b">get_identifier</a> (size_t depth) const</td></tr>
<tr class="separator:a9cb3141131af81b42741bc9e7349e58b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3f0f330d338d949d04dbe14fd606e838"><td class="memItemLeft" align="right" valign="top">static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a3f0f330d338d949d04dbe14fd606e838">minimum_distance_between</a> (<a class="el" href="classvg_1_1ZipCode.html">ZipCode</a> &amp;zip1, const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;pos1, <a class="el" href="classvg_1_1ZipCode.html">ZipCode</a> &amp;zip2, const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;pos2, const SnarlDistanceIndex &amp;distance_index, size_t distance_limit=std::numeric_limits&lt; size_t &gt;::max(), bool undirected_distance=false, const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *graph=nullptr)</td></tr>
<tr class="separator:a3f0f330d338d949d04dbe14fd606e838"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a967a3c40a7c49674c6d14883b6b02e71"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a967a3c40a7c49674c6d14883b6b02e71">is_farther_than</a> (const <a class="el" href="classvg_1_1ZipCode.html">ZipCode</a> &amp;zip1, const <a class="el" href="classvg_1_1ZipCode.html">ZipCode</a> &amp;zip2, const size_t &amp;limit)</td></tr>
<tr class="separator:a967a3c40a7c49674c6d14883b6b02e71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a304ce8419239ce69dfb69e85e50d3c8c"><td class="memItemLeft" align="right" valign="top">static tuple&lt; size_t, size_t, size_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a304ce8419239ce69dfb69e85e50d3c8c">get_top_level_chain_offset</a> ()</td></tr>
<tr class="separator:a304ce8419239ce69dfb69e85e50d3c8c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38f2c794e04f2ad21447358fd7b93665"><td class="memItemLeft" align="right" valign="top">const static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a38f2c794e04f2ad21447358fd7b93665">is_equal</a> (const <a class="el" href="classvg_1_1ZipCode.html">ZipCode</a> &amp;zip1, const <a class="el" href="classvg_1_1ZipCode.html">ZipCode</a> &amp;zip2, const size_t &amp;depth)</td></tr>
<tr class="separator:a38f2c794e04f2ad21447358fd7b93665"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a487d7a307e6b728df95581d6d261d526"><td class="memItemLeft" align="right" valign="top">const static <a class="el" href="namespacevg.html#a064c859d9612d9c2b240b9c0d01f8a85">net_identifier_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a487d7a307e6b728df95581d6d261d526">get_parent_identifier</a> (const <a class="el" href="namespacevg.html#a064c859d9612d9c2b240b9c0d01f8a85">net_identifier_t</a> &amp;child)</td></tr>
<tr class="separator:a487d7a307e6b728df95581d6d261d526"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Public Attributes</h2></td></tr>
<tr class="memitem:a4d8456b4edb18c6c6d812b05b5e4783e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1varint__vector__t.html">varint_vector_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a4d8456b4edb18c6c6d812b05b5e4783e">zipcode</a></td></tr>
<tr class="separator:a4d8456b4edb18c6c6d812b05b5e4783e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca73fa641d8bb6c33cb98dc1873cb263"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="structvg_1_1ZipCode_1_1decoder__t.html">decoder_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#aca73fa641d8bb6c33cb98dc1873cb263">decoder</a></td></tr>
<tr class="separator:aca73fa641d8bb6c33cb98dc1873cb263"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5baffcb4fe80bf3c0968b18217e14ea5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a5baffcb4fe80bf3c0968b18217e14ea5">finished_decoding</a> = false</td></tr>
<tr class="separator:a5baffcb4fe80bf3c0968b18217e14ea5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a1a37e35bfbd8910f64b95906f2930e28"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ZipCode_1_1node__code__t.html">node_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a1a37e35bfbd8910f64b95906f2930e28">get_node_code</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;node, const SnarlDistanceIndex &amp;distance_index)</td></tr>
<tr class="separator:a1a37e35bfbd8910f64b95906f2930e28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0f40a265733bd4adfb920006fd9f57a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ZipCode_1_1chain__code__t.html">chain_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#aa0f40a265733bd4adfb920006fd9f57a">get_chain_code</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;chain, const SnarlDistanceIndex &amp;distance_index)</td></tr>
<tr class="separator:aa0f40a265733bd4adfb920006fd9f57a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c0515e594e7da8c54e29314b1af6a6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ZipCode_1_1snarl__code__t.html">snarl_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a13c0515e594e7da8c54e29314b1af6a6">get_regular_snarl_code</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;snarl, const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;snarl_child, const SnarlDistanceIndex &amp;distance_index)</td></tr>
<tr class="separator:a13c0515e594e7da8c54e29314b1af6a6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2057ff4f25f04aa76066c3c5a83239fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structvg_1_1ZipCode_1_1snarl__code__t.html">snarl_code_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a2057ff4f25f04aa76066c3c5a83239fc">get_irregular_snarl_code</a> (const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;snarl, const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;snarl_child, const SnarlDistanceIndex &amp;distance_index)</td></tr>
<tr class="separator:a2057ff4f25f04aa76066c3c5a83239fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-attribs"></a>
Static Private Attributes</h2></td></tr>
<tr class="memitem:aa2cdcd63b1ac93b431e0e4d5d25df346"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#aa2cdcd63b1ac93b431e0e4d5d25df346">ROOT_SNARL_SIZE</a> = 2</td></tr>
<tr class="separator:aa2cdcd63b1ac93b431e0e4d5d25df346"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fcb55636a3bd5e25d6592952880662b"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a9fcb55636a3bd5e25d6592952880662b">ROOT_IS_CHAIN_OFFSET</a> = 0</td></tr>
<tr class="separator:a9fcb55636a3bd5e25d6592952880662b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9320699634e827ab9c91ade7b39220a9"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a9320699634e827ab9c91ade7b39220a9">ROOT_IDENTIFIER_OFFSET</a> = 1</td></tr>
<tr class="separator:a9320699634e827ab9c91ade7b39220a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af83f8e5c14d24fd45ad2318e229299d0"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#af83f8e5c14d24fd45ad2318e229299d0">ROOT_CHAIN_SIZE</a> = 4</td></tr>
<tr class="separator:af83f8e5c14d24fd45ad2318e229299d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79816fb11ec20354e677a6b1acd17905"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a79816fb11ec20354e677a6b1acd17905">ROOT_CHAIN_COMPONENT_COUNT_OFFSET</a> = 2</td></tr>
<tr class="separator:a79816fb11ec20354e677a6b1acd17905"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa760e19cc391b5de5adba6b4ca3cdb0"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#afa760e19cc391b5de5adba6b4ca3cdb0">ROOT_NODE_OR_CHAIN_CONNECTIVITY_OR_LENGTH_OFFSET</a> = 3</td></tr>
<tr class="separator:afa760e19cc391b5de5adba6b4ca3cdb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa378af1f64a51675d658d2c4ecb5d95"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#afa378af1f64a51675d658d2c4ecb5d95">ROOT_NODE_SIZE</a> = 4</td></tr>
<tr class="separator:afa378af1f64a51675d658d2c4ecb5d95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97232d726929bf2ebb8fb7fdfbde94fd"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a97232d726929bf2ebb8fb7fdfbde94fd">ROOT_NODE_LENGTH_OFFSET</a> = 2</td></tr>
<tr class="separator:a97232d726929bf2ebb8fb7fdfbde94fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd9eacafb083235372fdaf423d80f0ab"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#afd9eacafb083235372fdaf423d80f0ab">CHAIN_SIZE</a> = 3</td></tr>
<tr class="memdesc:afd9eacafb083235372fdaf423d80f0ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offsets for chain codes.  <a href="classvg_1_1ZipCode.html#afd9eacafb083235372fdaf423d80f0ab">More...</a><br /></td></tr>
<tr class="separator:afd9eacafb083235372fdaf423d80f0ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2743aa5e6e6311cca7ecae55060fcca0"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a2743aa5e6e6311cca7ecae55060fcca0">CHAIN_RANK_IN_SNARL_OFFSET</a> = 0</td></tr>
<tr class="separator:a2743aa5e6e6311cca7ecae55060fcca0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a757ad6220e506eab844abfb8cba7708d"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a757ad6220e506eab844abfb8cba7708d">CHAIN_LENGTH_OFFSET</a> = 1</td></tr>
<tr class="separator:a757ad6220e506eab844abfb8cba7708d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab40504f6209a6f30cb7e378fbf33f0de"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#ab40504f6209a6f30cb7e378fbf33f0de">CHAIN_COMPONENT_COUNT_OFFSET</a> = 2</td></tr>
<tr class="separator:ab40504f6209a6f30cb7e378fbf33f0de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14c19ec53976a951ef9a16f9202ac19e"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a14c19ec53976a951ef9a16f9202ac19e">REGULAR_SNARL_SIZE</a> = 6</td></tr>
<tr class="memdesc:a14c19ec53976a951ef9a16f9202ac19e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offsets for snarl codes.  <a href="classvg_1_1ZipCode.html#a14c19ec53976a951ef9a16f9202ac19e">More...</a><br /></td></tr>
<tr class="separator:a14c19ec53976a951ef9a16f9202ac19e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ec98e693ea6d5c1972479f9066ef405"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a8ec98e693ea6d5c1972479f9066ef405">IRREGULAR_SNARL_SIZE</a> = 10</td></tr>
<tr class="separator:a8ec98e693ea6d5c1972479f9066ef405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad56c1879d223a2151795d2532932d1c8"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#ad56c1879d223a2151795d2532932d1c8">SNARL_IS_REGULAR_OFFSET</a> = 0</td></tr>
<tr class="separator:ad56c1879d223a2151795d2532932d1c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65ff5123c5439118b1b390179cffd818"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a65ff5123c5439118b1b390179cffd818">SNARL_OFFSET_IN_CHAIN_OFFSET</a> = 1</td></tr>
<tr class="separator:a65ff5123c5439118b1b390179cffd818"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2f247378ce48537e06399e215013d5"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#ade2f247378ce48537e06399e215013d5">SNARL_LENGTH_OFFSET</a> = 2</td></tr>
<tr class="separator:ade2f247378ce48537e06399e215013d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37503629f90af0de452b6bc534ad43f5"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a37503629f90af0de452b6bc534ad43f5">SNARL_CHILD_COUNT_OFFSET</a> = 3</td></tr>
<tr class="separator:a37503629f90af0de452b6bc534ad43f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a807c487a518301d1726f87f7eda443a4"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a807c487a518301d1726f87f7eda443a4">SNARL_CHAIN_COMPONENT_OFFSET</a> = 4</td></tr>
<tr class="separator:a807c487a518301d1726f87f7eda443a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40ebd5bef9b1916bbe944baaaff0b122"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a40ebd5bef9b1916bbe944baaaff0b122">REGULAR_SNARL_IS_REVERSED_OFFSET</a> = 5</td></tr>
<tr class="separator:a40ebd5bef9b1916bbe944baaaff0b122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f5228bda68297b861a839396970f5bc"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a8f5228bda68297b861a839396970f5bc">IRREGULAR_SNARL_RECORD_OFFSET</a> = 5</td></tr>
<tr class="separator:a8f5228bda68297b861a839396970f5bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81836246de1e66c3febd653cd0525988"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a81836246de1e66c3febd653cd0525988">IRREGULAR_SNARL_DISTANCE_LEFT_START_OFFSET</a> = 6</td></tr>
<tr class="separator:a81836246de1e66c3febd653cd0525988"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c43ecf172f0ddde09366b3facdad4f9"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a0c43ecf172f0ddde09366b3facdad4f9">IRREGULAR_SNARL_DISTANCE_LEFT_END_OFFSET</a> = 7</td></tr>
<tr class="separator:a0c43ecf172f0ddde09366b3facdad4f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdcb0967e1dd6d01833a7fc66f6ef64b"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#acdcb0967e1dd6d01833a7fc66f6ef64b">IRREGULAR_SNARL_DISTANCE_RIGHT_START_OFFSET</a> = 8</td></tr>
<tr class="separator:acdcb0967e1dd6d01833a7fc66f6ef64b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cccc444095b38bd7e73ff6e55f930be"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a2cccc444095b38bd7e73ff6e55f930be">IRREGULAR_SNARL_DISTANCE_RIGHT_END_OFFSET</a> = 9</td></tr>
<tr class="separator:a2cccc444095b38bd7e73ff6e55f930be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0237b30c6e57eb94d71e67af989cbf03"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a0237b30c6e57eb94d71e67af989cbf03">NODE_SIZE</a> = 4</td></tr>
<tr class="memdesc:a0237b30c6e57eb94d71e67af989cbf03"><td class="mdescLeft">&#160;</td><td class="mdescRight">Offsets for nodes.  <a href="classvg_1_1ZipCode.html#a0237b30c6e57eb94d71e67af989cbf03">More...</a><br /></td></tr>
<tr class="separator:a0237b30c6e57eb94d71e67af989cbf03"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23f1322b4bb418f265261d790a5477ae"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a23f1322b4bb418f265261d790a5477ae">NODE_OFFSET_OFFSET</a> = 0</td></tr>
<tr class="separator:a23f1322b4bb418f265261d790a5477ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94d890670c72b9e6639b55200cac921c"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a94d890670c72b9e6639b55200cac921c">NODE_LENGTH_OFFSET</a> = 1</td></tr>
<tr class="separator:a94d890670c72b9e6639b55200cac921c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26bad855c31c5f57abbadbc681c08803"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#a26bad855c31c5f57abbadbc681c08803">NODE_IS_REVERSED_OFFSET</a> = 2</td></tr>
<tr class="separator:a26bad855c31c5f57abbadbc681c08803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4fb1284d9b1da36db4e87fb5f8a1510"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1ZipCode.html#aa4fb1284d9b1da36db4e87fb5f8a1510">NODE_CHAIN_COMPONENT_OFFSET</a> = 3</td></tr>
<tr class="separator:aa4fb1284d9b1da36db4e87fb5f8a1510"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a930c205d47f41592d63fd98aefddd336"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a930c205d47f41592d63fd98aefddd336">&#9670;&nbsp;</a></span>code_type</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef std::uint64_t <a class="el" href="classvg_1_1ZipCode.html#a930c205d47f41592d63fd98aefddd336">vg::ZipCode::code_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a3a7913620a6b9e7988e14c210c51e9c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a7913620a6b9e7988e14c210c51e9c3">&#9670;&nbsp;</a></span>code_type_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classvg_1_1ZipCode.html#a3a7913620a6b9e7988e14c210c51e9c3">vg::ZipCode::code_type_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The type of codes that can be stored in the zipcode Trivial chains that are children of snarls get saved as a chain with no child node EMPTY doesn't actually mean anything, it's used to catch errors Snarls can be regular, irregular, or cyclic. Regular snarls are bubbles. Irregular snarls are snarls that aren't bubbles but are dags Cyclic snarls are non-dags. They are stored the same as irregular snarls. Only the type is different </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a3a7913620a6b9e7988e14c210c51e9c3a2995e7f61da600fe7b67e5fd40d4b319"></a>NODE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3a7913620a6b9e7988e14c210c51e9c3a0fadb599003438c0ef1ebccfab78b8d6"></a>CHAIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3a7913620a6b9e7988e14c210c51e9c3a857cb70dc6bd3383a768a8696e67689c"></a>REGULAR_SNARL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3a7913620a6b9e7988e14c210c51e9c3a96d1de8b0fd352dc3449d17eab32f6f4"></a>IRREGULAR_SNARL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3a7913620a6b9e7988e14c210c51e9c3a5fb7cef86123c58871519b0a317708d0"></a>CYCLIC_SNARL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3a7913620a6b9e7988e14c210c51e9c3a438bae58eb821bbbc90b1b4bc486d682"></a>ROOT_SNARL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3a7913620a6b9e7988e14c210c51e9c3a3350f37a328be806a1a8bb7534d7fb8c"></a>ROOT_CHAIN&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3a7913620a6b9e7988e14c210c51e9c3a3c192049eca2f2b4aafe984ff4a965d3"></a>ROOT_NODE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a3a7913620a6b9e7988e14c210c51e9c3add89c8b2a06030b4a1d698a011538aaa"></a>EMPTY&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a36fb166e87c595d4e513b5e6a7676958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36fb166e87c595d4e513b5e6a7676958">&#9670;&nbsp;</a></span>byte_count()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCode::byte_count </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How many bytes were used to store this zipcode? </p>

</div>
</div>
<a id="ab5cc414a3fa14b68799c93fa61486a31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5cc414a3fa14b68799c93fa61486a31">&#9670;&nbsp;</a></span>decoder_length()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCode::decoder_length </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>How many codes in the zipcode have been decoded? </p>

</div>
</div>
<a id="aae9095d31b64aa151d6d30e246ee4561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae9095d31b64aa151d6d30e246ee4561">&#9670;&nbsp;</a></span>dump()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCode::dump </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Dump a <a class="el" href="classvg_1_1ZipCode.html">ZipCode</a> to a stream so that it can be reconstructed for a unit test from the resulting information. </p>

</div>
</div>
<a id="aea9e1d42e1a0b31941401212fd87d76a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea9e1d42e1a0b31941401212fd87d76a">&#9670;&nbsp;</a></span>fill_in_full_decoder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCode::fill_in_full_decoder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Go through the entire zipcode and fill in the decoder. </p>

</div>
</div>
<a id="a020fef499f038a3dac191667b2fb8e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a020fef499f038a3dac191667b2fb8e16">&#9670;&nbsp;</a></span>fill_in_next_decoder()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCode::fill_in_next_decoder </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill in one more item in the decoder Returns true if this is the last thing in the zipcode and false if there is more to decode </p>

</div>
</div>
<a id="ac232fe003bd30dfbba804cf0bc81b580"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac232fe003bd30dfbba804cf0bc81b580">&#9670;&nbsp;</a></span>fill_in_zipcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCode::fill_in_zipcode </td>
          <td>(</td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">vg::pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fill_in_decoder</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad53005c4c44463b1226835f7f7da83e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad53005c4c44463b1226835f7f7da83e0">&#9670;&nbsp;</a></span>fill_in_zipcode_from_payload()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCode::fill_in_zipcode_from_payload </td>
          <td>(</td>
          <td class="paramtype">const gbwtgraph::Payload &amp;&#160;</td>
          <td class="paramname"><em>payload</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acbad7130678653add25cc79639b0f886"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbad7130678653add25cc79639b0f886">&#9670;&nbsp;</a></span>from_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vg::ZipCode::from_vector </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; size_t &gt; &amp;&#160;</td>
          <td class="paramname"><em>values</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load from a normal vector. </p>

</div>
</div>
<a id="aa0f40a265733bd4adfb920006fd9f57a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0f40a265733bd4adfb920006fd9f57a">&#9670;&nbsp;</a></span>get_chain_code()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ZipCode_1_1chain__code__t.html">ZipCode::chain_code_t</a> vg::ZipCode::get_chain_code </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af85179af0d75add0b10023343c2a407a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af85179af0d75add0b10023343c2a407a">&#9670;&nbsp;</a></span>get_chain_component()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCode::get_chain_component </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the chain component of a chain child. For snarls, this will be the component of the start node </p>

</div>
</div>
<a id="ac91d59c7100fefc2011cda07996ed71a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac91d59c7100fefc2011cda07996ed71a">&#9670;&nbsp;</a></span>get_code_type()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1ZipCode.html#a3a7913620a6b9e7988e14c210c51e9c3">ZipCode::code_type_t</a> vg::ZipCode::get_code_type </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>What type of snarl tree node is at the given depth (index into the zipcode) </p>

</div>
</div>
<a id="a6cc3964efc186615dab6bdd8bc52fbfb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6cc3964efc186615dab6bdd8bc52fbfb">&#9670;&nbsp;</a></span>get_distance_index_address()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCode::get_distance_index_address </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the information that was stored to get the address in the distance index This is the connected component number for a root structure, or the address of an irregular snarl. Throws an error for anything else This is used for checking equality without looking at the distance index. Use get_net_handle for getting the actual handle </p>

</div>
</div>
<a id="ad39662d894fe714c1d8596b0343557f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad39662d894fe714c1d8596b0343557f6">&#9670;&nbsp;</a></span>get_distance_to_snarl_bound()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCode::get_distance_to_snarl_bound </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>snarl_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>left_side</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The minimum distance from start or end of the snarl to the left or right side of the child. </p>

</div>
</div>
<a id="a9cb3141131af81b42741bc9e7349e58b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9cb3141131af81b42741bc9e7349e58b">&#9670;&nbsp;</a></span>get_identifier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#a064c859d9612d9c2b240b9c0d01f8a85">net_identifier_t</a> vg::ZipCode::get_identifier </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get an identifier for the snarl tree node at this depth. If the snarl tree node at this depth would be the node, also include the node id </p>

</div>
</div>
<a id="a2057ff4f25f04aa76066c3c5a83239fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2057ff4f25f04aa76066c3c5a83239fc">&#9670;&nbsp;</a></span>get_irregular_snarl_code()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ZipCode_1_1snarl__code__t.html">ZipCode::snarl_code_t</a> vg::ZipCode::get_irregular_snarl_code </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl_child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2c0fa7d7130b57bee9b557750eb97eab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c0fa7d7130b57bee9b557750eb97eab">&#9670;&nbsp;</a></span>get_is_looping_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCode::get_is_looping_chain </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af27a1ca0026e32e588d0bb3b62a5bade"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af27a1ca0026e32e588d0bb3b62a5bade">&#9670;&nbsp;</a></span>get_is_reversed_in_parent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCode::get_is_reversed_in_parent </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Is the snarl tree node backwards relative to its parent. </p>

</div>
</div>
<a id="aaf980083db4440866ee59d2a1b89e957"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf980083db4440866ee59d2a1b89e957">&#9670;&nbsp;</a></span>get_last_chain_component()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCode::get_last_chain_component </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>get_end</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the chain component of the last node in the chain This behaves like the distance index get_chain_component- for looping chains it returns the last component if get_end is true, and 0 if it is false </p>

</div>
</div>
<a id="a8a5fd40be34ed83736e027a3ca6d9889"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8a5fd40be34ed83736e027a3ca6d9889">&#9670;&nbsp;</a></span>get_length()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCode::get_length </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>get_chain_component_length</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the length of a snarl tree node given the depth in the snarl tree If get_chain_component_length is true, then return the length of the last component of the multicomponent chain. If get_chain_component_length is false for a multi-cmponent chain, return <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">max()</a> </p>

</div>
</div>
<a id="a051a9144646b660f213fe44d5b123d77"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a051a9144646b660f213fe44d5b123d77">&#9670;&nbsp;</a></span>get_net_handle()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> vg::ZipCode::get_net_handle </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex *&#160;</td>
          <td class="paramname"><em>distance_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the handle of the thing at the given depth. This can only be used for Root-level structures or irregular snarls </p>

</div>
</div>
<a id="ad1d40ef72bc5fa0f9e0e933add4265a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad1d40ef72bc5fa0f9e0e933add4265a2">&#9670;&nbsp;</a></span>get_net_handle_slow()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> vg::ZipCode::get_net_handle_slow </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex *&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> *&#160;</td>
          <td class="paramname"><em>child_handle</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the handle of the thing at the given depth. This can be used for anything but is slow, even for roots and irregular/cyclic snarls. It's a separate function to make sure I remember that it's slow If the child handle is given, get the net handle as the parent of the child, if the address isn't stored </p>

</div>
</div>
<a id="a1a37e35bfbd8910f64b95906f2930e28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a37e35bfbd8910f64b95906f2930e28">&#9670;&nbsp;</a></span>get_node_code()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ZipCode_1_1node__code__t.html">ZipCode::node_code_t</a> vg::ZipCode::get_node_code </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5d8b333ee954fa9a513b6190e1910843"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d8b333ee954fa9a513b6190e1910843">&#9670;&nbsp;</a></span>get_offset_in_chain()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCode::get_offset_in_chain </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex *&#160;</td>
          <td class="paramname"><em>distance_index</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the prefix sum of a child of a chain This requires the distance index for irregular snarls (except for a top-level snarl) Throws an exception if the distance index is not given when it is needed Doesn't use a given distance index if it isn't needed </p>

</div>
</div>
<a id="a487d7a307e6b728df95581d6d261d526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a487d7a307e6b728df95581d6d261d526">&#9670;&nbsp;</a></span>get_parent_identifier()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="namespacevg.html#a064c859d9612d9c2b240b9c0d01f8a85">net_identifier_t</a> vg::ZipCode::get_parent_identifier </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a064c859d9612d9c2b240b9c0d01f8a85">net_identifier_t</a> &amp;&#160;</td>
          <td class="paramname"><em>child</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a05895f989a23d97b08bd0c1c56bbc3bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05895f989a23d97b08bd0c1c56bbc3bc">&#9670;&nbsp;</a></span>get_payload_from_zip()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">gbwtgraph::Payload vg::ZipCode::get_payload_from_zip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae9a95e07dd615b3692fe7742990c6c8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae9a95e07dd615b3692fe7742990c6c8b">&#9670;&nbsp;</a></span>get_payload_from_zipcode()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1MIPayload.html">MIPayload</a> vg::ZipCode::get_payload_from_zipcode </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#a26f660292f00451f15d1c95d9b8c6ffb">nid_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1hash__map.html">hash_map</a>&lt; size_t, <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &gt; *&#160;</td>
          <td class="paramname"><em>component_to_net_handle</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Fill in a payload with values from the zipcode Remember how to get the net handle from the connected component number. </p>

</div>
</div>
<a id="a32750209d049ac9e5fea67c97be1f151"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32750209d049ac9e5fea67c97be1f151">&#9670;&nbsp;</a></span>get_rank_in_snarl()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCode::get_rank_in_snarl </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the rank of a node/snarl in a snarl. Throw an exception if it isn't the child of a snarl. </p>

</div>
</div>
<a id="a13c0515e594e7da8c54e29314b1af6a6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13c0515e594e7da8c54e29314b1af6a6">&#9670;&nbsp;</a></span>get_regular_snarl_code()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ZipCode_1_1snarl__code__t.html">ZipCode::snarl_code_t</a> vg::ZipCode::get_regular_snarl_code </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structhandlegraph_1_1net__handle__t.html">net_handle_t</a> &amp;&#160;</td>
          <td class="paramname"><em>snarl_child</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad6d78deca4d723ac8d5ede306abd5578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d78deca4d723ac8d5ede306abd5578">&#9670;&nbsp;</a></span>get_snarl_child_count()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCode::get_snarl_child_count </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex *&#160;</td>
          <td class="paramname"><em>distance_index</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the number of children in a snarl. Throw an exception if it isn't a snarl. </p>

</div>
</div>
<a id="a304ce8419239ce69dfb69e85e50d3c8c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a304ce8419239ce69dfb69e85e50d3c8c">&#9670;&nbsp;</a></span>get_top_level_chain_offset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static tuple&lt;size_t, size_t, size_t&gt; vg::ZipCode::get_top_level_chain_offset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a38f2c794e04f2ad21447358fd7b93665"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38f2c794e04f2ad21447358fd7b93665">&#9670;&nbsp;</a></span>is_equal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const bool vg::ZipCode::is_equal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1ZipCode.html">ZipCode</a> &amp;&#160;</td>
          <td class="paramname"><em>zip1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1ZipCode.html">ZipCode</a> &amp;&#160;</td>
          <td class="paramname"><em>zip2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Are the two decoders pointing to the same snarl tree node at the given depth This only checks if the values in the zipcode are the same at the given depth, so if the preceeding snarl tree nodes are different, then this might actually refer to different things </p>

</div>
</div>
<a id="ac59bc5911574a1fa356cac4f90471324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac59bc5911574a1fa356cac4f90471324">&#9670;&nbsp;</a></span>is_externally_end_end_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCode::is_externally_end_end_connected </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a28d318606661f6e99b2374b5a87f370f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28d318606661f6e99b2374b5a87f370f">&#9670;&nbsp;</a></span>is_externally_start_end_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCode::is_externally_start_end_connected </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a842b8118dd218d6451199c1fd5f2e04b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a842b8118dd218d6451199c1fd5f2e04b">&#9670;&nbsp;</a></span>is_externally_start_start_connected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCode::is_externally_start_start_connected </td>
          <td>(</td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>depth</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a967a3c40a7c49674c6d14883b6b02e71"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a967a3c40a7c49674c6d14883b6b02e71">&#9670;&nbsp;</a></span>is_farther_than()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCode::is_farther_than </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1ZipCode.html">ZipCode</a> &amp;&#160;</td>
          <td class="paramname"><em>zip1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classvg_1_1ZipCode.html">ZipCode</a> &amp;&#160;</td>
          <td class="paramname"><em>zip2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const size_t &amp;&#160;</td>
          <td class="paramname"><em>limit</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa9b8e3ee702697e3692a83e2307d9084"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9b8e3ee702697e3692a83e2307d9084">&#9670;&nbsp;</a></span>max_depth()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCode::max_depth </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>What is the maximum depth of this zipcode? </p>

</div>
</div>
<a id="a3f0f330d338d949d04dbe14fd606e838"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f0f330d338d949d04dbe14fd606e838">&#9670;&nbsp;</a></span>minimum_distance_between()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">size_t vg::ZipCode::minimum_distance_between </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1ZipCode.html">ZipCode</a> &amp;&#160;</td>
          <td class="paramname"><em>zip1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classvg_1_1ZipCode.html">ZipCode</a> &amp;&#160;</td>
          <td class="paramname"><em>zip2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="namespacevg.html#a8232142f432c4dd8e7cfe96e1f50e039">pos_t</a> &amp;&#160;</td>
          <td class="paramname"><em>pos2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SnarlDistanceIndex &amp;&#160;</td>
          <td class="paramname"><em>distance_index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>distance_limit</em> = <code>std::numeric_limits&lt;size_t&gt;::max()</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>undirected_distance</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classhandlegraph_1_1HandleGraph.html">HandleGraph</a> *&#160;</td>
          <td class="paramname"><em>graph</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0b983931fc8219fafc6cde9357b553b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b983931fc8219fafc6cde9357b553b0">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCode::operator== </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1ZipCode.html">ZipCode</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Equality operator. </p>

</div>
</div>
<a id="a43c4b30e62f754722d730d47306e76cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a43c4b30e62f754722d730d47306e76cd">&#9670;&nbsp;</a></span>to_vector()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; size_t &gt; vg::ZipCode::to_vector </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Dump to a normal vector. </p>

</div>
</div>
<a id="a66e91c21e0b8a818b6de6a620ee0bdf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a66e91c21e0b8a818b6de6a620ee0bdf5">&#9670;&nbsp;</a></span>unpack_chain_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ZipCode_1_1chain__code__t.html">ZipCode::chain_code_t</a> vg::ZipCode::unpack_chain_code </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>zipcode_level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7e7cd0b16ad1b9ac447b6eb0458f289d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e7cd0b16ad1b9ac447b6eb0458f289d">&#9670;&nbsp;</a></span>unpack_node_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ZipCode_1_1node__code__t.html">ZipCode::node_code_t</a> vg::ZipCode::unpack_node_code </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>zipcode_level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4b76c5d63d72f9938352327e6d7b06c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b76c5d63d72f9938352327e6d7b06c0">&#9670;&nbsp;</a></span>unpack_snarl_code()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1ZipCode_1_1snarl__code__t.html">ZipCode::snarl_code_t</a> vg::ZipCode::unpack_snarl_code </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>zipcode_level</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab40504f6209a6f30cb7e378fbf33f0de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab40504f6209a6f30cb7e378fbf33f0de">&#9670;&nbsp;</a></span>CHAIN_COMPONENT_COUNT_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::CHAIN_COMPONENT_COUNT_OFFSET = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a757ad6220e506eab844abfb8cba7708d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a757ad6220e506eab844abfb8cba7708d">&#9670;&nbsp;</a></span>CHAIN_LENGTH_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::CHAIN_LENGTH_OFFSET = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2743aa5e6e6311cca7ecae55060fcca0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2743aa5e6e6311cca7ecae55060fcca0">&#9670;&nbsp;</a></span>CHAIN_RANK_IN_SNARL_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::CHAIN_RANK_IN_SNARL_OFFSET = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afd9eacafb083235372fdaf423d80f0ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd9eacafb083235372fdaf423d80f0ab">&#9670;&nbsp;</a></span>CHAIN_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::CHAIN_SIZE = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Offsets for chain codes. </p>

</div>
</div>
<a id="aca73fa641d8bb6c33cb98dc1873cb263"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca73fa641d8bb6c33cb98dc1873cb263">&#9670;&nbsp;</a></span>decoder</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;<a class="el" href="structvg_1_1ZipCode_1_1decoder__t.html">decoder_t</a>&gt; vg::ZipCode::decoder</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5baffcb4fe80bf3c0968b18217e14ea5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5baffcb4fe80bf3c0968b18217e14ea5">&#9670;&nbsp;</a></span>finished_decoding</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vg::ZipCode::finished_decoding = false</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Did we fill in the entire decoder TODO: I'm making it fill in the decoder automatically because it seems to be faster that way, instead of waiting to see which parts are actually needed </p>

</div>
</div>
<a id="a0c43ecf172f0ddde09366b3facdad4f9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c43ecf172f0ddde09366b3facdad4f9">&#9670;&nbsp;</a></span>IRREGULAR_SNARL_DISTANCE_LEFT_END_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::IRREGULAR_SNARL_DISTANCE_LEFT_END_OFFSET = 7</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a81836246de1e66c3febd653cd0525988"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81836246de1e66c3febd653cd0525988">&#9670;&nbsp;</a></span>IRREGULAR_SNARL_DISTANCE_LEFT_START_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::IRREGULAR_SNARL_DISTANCE_LEFT_START_OFFSET = 6</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a2cccc444095b38bd7e73ff6e55f930be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cccc444095b38bd7e73ff6e55f930be">&#9670;&nbsp;</a></span>IRREGULAR_SNARL_DISTANCE_RIGHT_END_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::IRREGULAR_SNARL_DISTANCE_RIGHT_END_OFFSET = 9</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="acdcb0967e1dd6d01833a7fc66f6ef64b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdcb0967e1dd6d01833a7fc66f6ef64b">&#9670;&nbsp;</a></span>IRREGULAR_SNARL_DISTANCE_RIGHT_START_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::IRREGULAR_SNARL_DISTANCE_RIGHT_START_OFFSET = 8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8f5228bda68297b861a839396970f5bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f5228bda68297b861a839396970f5bc">&#9670;&nbsp;</a></span>IRREGULAR_SNARL_RECORD_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::IRREGULAR_SNARL_RECORD_OFFSET = 5</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a8ec98e693ea6d5c1972479f9066ef405"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ec98e693ea6d5c1972479f9066ef405">&#9670;&nbsp;</a></span>IRREGULAR_SNARL_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::IRREGULAR_SNARL_SIZE = 10</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa4fb1284d9b1da36db4e87fb5f8a1510"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4fb1284d9b1da36db4e87fb5f8a1510">&#9670;&nbsp;</a></span>NODE_CHAIN_COMPONENT_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::NODE_CHAIN_COMPONENT_OFFSET = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a26bad855c31c5f57abbadbc681c08803"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26bad855c31c5f57abbadbc681c08803">&#9670;&nbsp;</a></span>NODE_IS_REVERSED_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::NODE_IS_REVERSED_OFFSET = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a94d890670c72b9e6639b55200cac921c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94d890670c72b9e6639b55200cac921c">&#9670;&nbsp;</a></span>NODE_LENGTH_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::NODE_LENGTH_OFFSET = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a23f1322b4bb418f265261d790a5477ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23f1322b4bb418f265261d790a5477ae">&#9670;&nbsp;</a></span>NODE_OFFSET_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::NODE_OFFSET_OFFSET = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a0237b30c6e57eb94d71e67af989cbf03"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0237b30c6e57eb94d71e67af989cbf03">&#9670;&nbsp;</a></span>NODE_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::NODE_SIZE = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Offsets for nodes. </p>

</div>
</div>
<a id="a40ebd5bef9b1916bbe944baaaff0b122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40ebd5bef9b1916bbe944baaaff0b122">&#9670;&nbsp;</a></span>REGULAR_SNARL_IS_REVERSED_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::REGULAR_SNARL_IS_REVERSED_OFFSET = 5</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a14c19ec53976a951ef9a16f9202ac19e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14c19ec53976a951ef9a16f9202ac19e">&#9670;&nbsp;</a></span>REGULAR_SNARL_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::REGULAR_SNARL_SIZE = 6</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Offsets for snarl codes. </p>

</div>
</div>
<a id="a79816fb11ec20354e677a6b1acd17905"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79816fb11ec20354e677a6b1acd17905">&#9670;&nbsp;</a></span>ROOT_CHAIN_COMPONENT_COUNT_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::ROOT_CHAIN_COMPONENT_COUNT_OFFSET = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af83f8e5c14d24fd45ad2318e229299d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af83f8e5c14d24fd45ad2318e229299d0">&#9670;&nbsp;</a></span>ROOT_CHAIN_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::ROOT_CHAIN_SIZE = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9320699634e827ab9c91ade7b39220a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9320699634e827ab9c91ade7b39220a9">&#9670;&nbsp;</a></span>ROOT_IDENTIFIER_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::ROOT_IDENTIFIER_OFFSET = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9fcb55636a3bd5e25d6592952880662b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fcb55636a3bd5e25d6592952880662b">&#9670;&nbsp;</a></span>ROOT_IS_CHAIN_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::ROOT_IS_CHAIN_OFFSET = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a97232d726929bf2ebb8fb7fdfbde94fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97232d726929bf2ebb8fb7fdfbde94fd">&#9670;&nbsp;</a></span>ROOT_NODE_LENGTH_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::ROOT_NODE_LENGTH_OFFSET = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa760e19cc391b5de5adba6b4ca3cdb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa760e19cc391b5de5adba6b4ca3cdb0">&#9670;&nbsp;</a></span>ROOT_NODE_OR_CHAIN_CONNECTIVITY_OR_LENGTH_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::ROOT_NODE_OR_CHAIN_CONNECTIVITY_OR_LENGTH_OFFSET = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="afa378af1f64a51675d658d2c4ecb5d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa378af1f64a51675d658d2c4ecb5d95">&#9670;&nbsp;</a></span>ROOT_NODE_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::ROOT_NODE_SIZE = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aa2cdcd63b1ac93b431e0e4d5d25df346"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2cdcd63b1ac93b431e0e4d5d25df346">&#9670;&nbsp;</a></span>ROOT_SNARL_SIZE</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::ROOT_SNARL_SIZE = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Offsets of values in a root chain or snarl code Roots have a bool for is_chain and an identifier, which is the connected component number from the distance index </p>

</div>
</div>
<a id="a807c487a518301d1726f87f7eda443a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a807c487a518301d1726f87f7eda443a4">&#9670;&nbsp;</a></span>SNARL_CHAIN_COMPONENT_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::SNARL_CHAIN_COMPONENT_OFFSET = 4</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a37503629f90af0de452b6bc534ad43f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37503629f90af0de452b6bc534ad43f5">&#9670;&nbsp;</a></span>SNARL_CHILD_COUNT_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::SNARL_CHILD_COUNT_OFFSET = 3</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad56c1879d223a2151795d2532932d1c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad56c1879d223a2151795d2532932d1c8">&#9670;&nbsp;</a></span>SNARL_IS_REGULAR_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::SNARL_IS_REGULAR_OFFSET = 0</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ade2f247378ce48537e06399e215013d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ade2f247378ce48537e06399e215013d5">&#9670;&nbsp;</a></span>SNARL_LENGTH_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::SNARL_LENGTH_OFFSET = 2</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a65ff5123c5439118b1b390179cffd818"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65ff5123c5439118b1b390179cffd818">&#9670;&nbsp;</a></span>SNARL_OFFSET_IN_CHAIN_OFFSET</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::ZipCode::SNARL_OFFSET_IN_CHAIN_OFFSET = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a4d8456b4edb18c6c6d812b05b5e4783e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d8456b4edb18c6c6d812b05b5e4783e">&#9670;&nbsp;</a></span>zipcode</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structvg_1_1varint__vector__t.html">varint_vector_t</a> vg::ZipCode::zipcode</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="zip__code_8hpp.html">zip_code.hpp</a></li>
<li>src/<a class="el" href="zip__code_8cpp.html">zip_code.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
