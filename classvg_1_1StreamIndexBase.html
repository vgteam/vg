<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::StreamIndexBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="classvg_1_1StreamIndexBase.html">StreamIndexBase</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pro-static-methods">Static Protected Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#pro-static-attribs">Static Protected Attributes</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="classvg_1_1StreamIndexBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::StreamIndexBase Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;stream_index.hpp&gt;</code></p>
<div class="dynheader">
Inheritance diagram for vg::StreamIndexBase:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classvg_1_1StreamIndexBase.png" usemap="#vg::StreamIndexBase_map" alt=""/>
  <map id="vg::StreamIndexBase_map" name="vg::StreamIndexBase_map">
<area href="classvg_1_1StreamIndex.html" alt="vg::StreamIndex&lt; vg::algorithms::Graph &gt;" shape="rect" coords="0,56,243,80"/>
<area href="classvg_1_1StreamIndex.html" alt="vg::StreamIndex&lt; Message &gt;" shape="rect" coords="253,56,496,80"/>
  </map>
</div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1de6fb384732cab26d21f38f133bc9e9"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#a1de6fb384732cab26d21f38f133bc9e9">bin_t</a> = make_unsigned&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt;::type</td></tr>
<tr class="separator:a1de6fb384732cab26d21f38f133bc9e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad94010282265d6d8743f31ed5b3e98ce"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#ad94010282265d6d8743f31ed5b3e98ce">window_t</a> = make_unsigned&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt;::type</td></tr>
<tr class="separator:ad94010282265d6d8743f31ed5b3e98ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a2df03d2ee53e9f171e4aa519a079901e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#a2df03d2ee53e9f171e4aa519a079901e">StreamIndexBase</a> ()=default</td></tr>
<tr class="separator:a2df03d2ee53e9f171e4aa519a079901e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af30b1923f99ff4946103625f90ea1d9c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#af30b1923f99ff4946103625f90ea1d9c">load</a> (istream &amp;from)</td></tr>
<tr class="separator:af30b1923f99ff4946103625f90ea1d9c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a99761d4d917dc5ba1db1e08a36ceb312"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#a99761d4d917dc5ba1db1e08a36ceb312">save</a> (ostream &amp;to) const</td></tr>
<tr class="memdesc:a99761d4d917dc5ba1db1e08a36ceb312"><td class="mdescLeft">&#160;</td><td class="mdescRight">Save an index to a file.  <a href="classvg_1_1StreamIndexBase.html#a99761d4d917dc5ba1db1e08a36ceb312">More...</a><br /></td></tr>
<tr class="separator:a99761d4d917dc5ba1db1e08a36ceb312"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c332ce59d0a99ac7c2ef69d77b0f749"><td class="memItemLeft" align="right" valign="top">vector&lt; pair&lt; int64_t, int64_t &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#a7c332ce59d0a99ac7c2ef69d77b0f749">find</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> node_id) const</td></tr>
<tr class="separator:a7c332ce59d0a99ac7c2ef69d77b0f749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad520b5b3241ee162ffd02c2cac5bd702"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#ad520b5b3241ee162ffd02c2cac5bd702">find</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> node_id, const function&lt; bool(int64_t, int64_t)&gt; scan_callback) const</td></tr>
<tr class="separator:ad520b5b3241ee162ffd02c2cac5bd702"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6448cab1126089223a17c2ed6d943a97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#a6448cab1126089223a17c2ed6d943a97">find</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> min_node, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> max_node, const function&lt; bool(int64_t, int64_t)&gt; scan_callback) const</td></tr>
<tr class="separator:a6448cab1126089223a17c2ed6d943a97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addb451cabccc43915ae629925b3ed3ee"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#addb451cabccc43915ae629925b3ed3ee">scan_backward</a> (const function&lt; bool(int64_t, int64_t)&gt; scan_callback) const</td></tr>
<tr class="separator:addb451cabccc43915ae629925b3ed3ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad54626f7e5eb2587d4a5d5f514c82f75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#ad54626f7e5eb2587d4a5d5f514c82f75">add_group</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> min_id, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> max_id, int64_t virtual_start, int64_t virtual_past_end)</td></tr>
<tr class="separator:ad54626f7e5eb2587d4a5d5f514c82f75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94777b19236dfb74d66ba8c484bf663f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#a94777b19236dfb74d66ba8c484bf663f">used_bins_of_range</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> min_id, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> max_id, const function&lt; bool(<a class="el" href="classvg_1_1StreamIndexBase.html#a1de6fb384732cab26d21f38f133bc9e9">bin_t</a>)&gt; &amp;iteratee) const</td></tr>
<tr class="separator:a94777b19236dfb74d66ba8c484bf663f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:ac4e243c64474f83800e3f9baa9894eea"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvg_1_1BitString.html">BitString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#ac4e243c64474f83800e3f9baa9894eea">bin_to_prefix</a> (<a class="el" href="classvg_1_1StreamIndexBase.html#a1de6fb384732cab26d21f38f133bc9e9">bin_t</a> bin)</td></tr>
<tr class="memdesc:ac4e243c64474f83800e3f9baa9894eea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the ID prefix bits corresponding to a bin.  <a href="classvg_1_1StreamIndexBase.html#ac4e243c64474f83800e3f9baa9894eea">More...</a><br /></td></tr>
<tr class="separator:ac4e243c64474f83800e3f9baa9894eea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b0e44b8cb40b33c5ef4db47a8a89272"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvg_1_1BitString.html">BitString</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#a4b0e44b8cb40b33c5ef4db47a8a89272">id_to_prefix</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="memdesc:a4b0e44b8cb40b33c5ef4db47a8a89272"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the given ID as a bit string.  <a href="classvg_1_1StreamIndexBase.html#a4b0e44b8cb40b33c5ef4db47a8a89272">More...</a><br /></td></tr>
<tr class="separator:a4b0e44b8cb40b33c5ef4db47a8a89272"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8486253e2bf627ef07fbb2eec5614bd3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvg_1_1StreamIndexBase.html#a1de6fb384732cab26d21f38f133bc9e9">bin_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#a8486253e2bf627ef07fbb2eec5614bd3">common_bin</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> a, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> b)</td></tr>
<tr class="memdesc:a8486253e2bf627ef07fbb2eec5614bd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the most specific bin that contains both of the given node IDs.  <a href="classvg_1_1StreamIndexBase.html#a8486253e2bf627ef07fbb2eec5614bd3">More...</a><br /></td></tr>
<tr class="separator:a8486253e2bf627ef07fbb2eec5614bd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a320b27d89fbc1a74574cc00befe1e7fe"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classvg_1_1StreamIndexBase.html#ad94010282265d6d8743f31ed5b3e98ce">window_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#a320b27d89fbc1a74574cc00befe1e7fe">window_of_id</a> (<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="separator:a320b27d89fbc1a74574cc00befe1e7fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:aa497c1ad37621af86f5f40d45e0f30b2"><td class="memItemLeft" align="right" valign="top">const static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#aa497c1ad37621af86f5f40d45e0f30b2">MAX_INPUT_VERSION</a> = 1</td></tr>
<tr class="memdesc:aa497c1ad37621af86f5f40d45e0f30b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">What's the maximum index version number we can read with this code?  <a href="classvg_1_1StreamIndexBase.html#aa497c1ad37621af86f5f40d45e0f30b2">More...</a><br /></td></tr>
<tr class="separator:aa497c1ad37621af86f5f40d45e0f30b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5ce82f31552d36c073e65ced2af529e"><td class="memItemLeft" align="right" valign="top">const static uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#ad5ce82f31552d36c073e65ced2af529e">OUTPUT_VERSION</a> = 1</td></tr>
<tr class="memdesc:ad5ce82f31552d36c073e65ced2af529e"><td class="mdescLeft">&#160;</td><td class="mdescRight">What's the version we serialize?  <a href="classvg_1_1StreamIndexBase.html#ad5ce82f31552d36c073e65ced2af529e">More...</a><br /></td></tr>
<tr class="separator:ad5ce82f31552d36c073e65ced2af529e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bbb2b0134f0e831fc2ec5db056b7397"><td class="memItemLeft" align="right" valign="top">const static string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#a9bbb2b0134f0e831fc2ec5db056b7397">MAGIC_BYTES</a> = &quot;GAI!&quot;</td></tr>
<tr class="separator:a9bbb2b0134f0e831fc2ec5db056b7397"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-methods"></a>
Static Protected Member Functions</h2></td></tr>
<tr class="memitem:ab2b832d8cca9dee3c38d452dc47da0e3"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#ab2b832d8cca9dee3c38d452dc47da0e3">is_in_range</a> (const vector&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt;&gt; &amp;ranges, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> <a class="el" href="namespacevg.html#a9f6602b7e7a46c19819c8f362147b315">id</a>)</td></tr>
<tr class="separator:ab2b832d8cca9dee3c38d452dc47da0e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:a4801a54e202c9214718c71db7cea12a9"><td class="memItemLeft" align="right" valign="top">unordered_map&lt; <a class="el" href="classvg_1_1StreamIndexBase.html#a1de6fb384732cab26d21f38f133bc9e9">bin_t</a>, vector&lt; pair&lt; int64_t, int64_t &gt; &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#a4801a54e202c9214718c71db7cea12a9">bin_to_ranges</a></td></tr>
<tr class="separator:a4801a54e202c9214718c71db7cea12a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19b9a91061212bfd558a384fa19d4854"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1BitStringTree.html">BitStringTree</a>&lt; <a class="el" href="classvg_1_1StreamIndexBase.html#a1de6fb384732cab26d21f38f133bc9e9">bin_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#a19b9a91061212bfd558a384fa19d4854">bins_by_id_prefix</a></td></tr>
<tr class="separator:a19b9a91061212bfd558a384fa19d4854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47fab2baab7953595105558d0fcba4e2"><td class="memItemLeft" align="right" valign="top">map&lt; <a class="el" href="classvg_1_1StreamIndexBase.html#ad94010282265d6d8743f31ed5b3e98ce">window_t</a>, int64_t &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#a47fab2baab7953595105558d0fcba4e2">window_to_start</a></td></tr>
<tr class="separator:a47fab2baab7953595105558d0fcba4e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef3a7bd46aeb49185a8cd6a9a261e883"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#aef3a7bd46aeb49185a8cd6a9a261e883">last_group_min_id</a> = numeric_limits&lt;<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&gt;::min()</td></tr>
<tr class="separator:aef3a7bd46aeb49185a8cd6a9a261e883"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-static-attribs"></a>
Static Protected Attributes</h2></td></tr>
<tr class="memitem:a1f8223f4ff9ca3d9892d13d2708aff73"><td class="memItemLeft" align="right" valign="top">const static size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#a1f8223f4ff9ca3d9892d13d2708aff73">WINDOW_SHIFT</a> = 8</td></tr>
<tr class="separator:a1f8223f4ff9ca3d9892d13d2708aff73"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a85207efd00788e14df4df717d88233b7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#a85207efd00788e14df4df717d88233b7">StreamIndexBase</a> (const <a class="el" href="classvg_1_1StreamIndexBase.html">StreamIndexBase</a> &amp;other)=delete</td></tr>
<tr class="separator:a85207efd00788e14df4df717d88233b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0ac239e55d7748226a6a2d08480e026"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1StreamIndexBase.html">StreamIndexBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1StreamIndexBase.html#ab0ac239e55d7748226a6a2d08480e026">operator=</a> (const <a class="el" href="classvg_1_1StreamIndexBase.html">StreamIndexBase</a> &amp;other)=delete</td></tr>
<tr class="separator:ab0ac239e55d7748226a6a2d08480e026"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An index for a node-ID-sorted VPKG-formatted Protobuf file, such as GAM or <a class="el" href="classvg_1_1VG.html">VG</a>.</p>
<p>Works on a BAI-like concept of bins partitioning node ID space.</p>
<p>Files are serialized as count-prefixed groups of Protobuf messages. These groups are the smallest unit that can be deserialized.</p>
<p>Every <em>group</em> of messages gets assigned to a bin which is the longest bin that completely contains the ID range used in the group.</p>
<p>We define <em>runs</em> of adjacent groups which have the same bin, which are the basic subject of the index.</p>
<p>We then store an index from bin to the virtual offset ranges (start and past-the-end), in order, of runs that are assigned to the bin.</p>
<p>You will get non-contiguous virtual offset ranges for a node ID range when some messages run into the range from the left, then messages that start later don't, and then messages that start even later do again.</p>
<p>We also have a BAI-style linear index, mapping from tiling windows in node ID space to the lowest virtual offset of a group that overlaps the window.</p>
<p>The bin structure is that we partition all of node ID space into bins of power-of-2 size, starting with size 2 nodes. We number the bins such that 0 is the whole-ID-space bin, divided into 1 and 2, then into 3, 4, 5, and 6, then into 7, 8, 9, 10, 11, 12, 13, and 14, and so on.</p>
<p>The tiling windows are just the node IDs down-shifted by a few bits.</p>
<p>Messages that use no nodes (i.e. unmapped reads) are considered to visit node ID 0. The maximum and minimum id_t values are used as sentinels, so they can't be real nodes.</p>
<p>All find operations are thread-safe with respect to each other. Simultaneous adds or finds and adds are prohibited.</p>
<p>Most of the basic index API doesn't depend on the message type. So we put it in this base class and inherit form it in templates that provide the high-level interface in terms of message instances. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a1de6fb384732cab26d21f38f133bc9e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1de6fb384732cab26d21f38f133bc9e9">&#9670;&nbsp;</a></span>bin_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1StreamIndexBase.html#a1de6fb384732cab26d21f38f133bc9e9">vg::StreamIndexBase::bin_t</a> =  make_unsigned&lt;<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad94010282265d6d8743f31ed5b3e98ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad94010282265d6d8743f31ed5b3e98ce">&#9670;&nbsp;</a></span>window_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1StreamIndexBase.html#ad94010282265d6d8743f31ed5b3e98ce">vg::StreamIndexBase::window_t</a> =  make_unsigned&lt;<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&gt;::type</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a2df03d2ee53e9f171e4aa519a079901e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2df03d2ee53e9f171e4aa519a079901e">&#9670;&nbsp;</a></span>StreamIndexBase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::StreamIndexBase::StreamIndexBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a85207efd00788e14df4df717d88233b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85207efd00788e14df4df717d88233b7">&#9670;&nbsp;</a></span>StreamIndexBase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vg::StreamIndexBase::StreamIndexBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1StreamIndexBase.html">StreamIndexBase</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ad54626f7e5eb2587d4a5d5f514c82f75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad54626f7e5eb2587d4a5d5f514c82f75">&#9670;&nbsp;</a></span>add_group()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::StreamIndexBase::add_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>min_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>max_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>virtual_start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t&#160;</td>
          <td class="paramname"><em>virtual_past_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add a group into the index, based on its minimum and maximum (inclusive) used node IDs. Must be called for all groups in virtual offset order. </p>

</div>
</div>
<a id="ac4e243c64474f83800e3f9baa9894eea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac4e243c64474f83800e3f9baa9894eea">&#9670;&nbsp;</a></span>bin_to_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::StreamIndexBase::bin_to_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1StreamIndexBase.html#a1de6fb384732cab26d21f38f133bc9e9">bin_t</a>&#160;</td>
          <td class="paramname"><em>bin</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the ID prefix bits corresponding to a bin. </p>
<p>Subtract out the offset to get the bin index, and use it as a prefix with the appropriate number of bits based on what the offset was.</p>

</div>
</div>
<a id="a8486253e2bf627ef07fbb2eec5614bd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8486253e2bf627ef07fbb2eec5614bd3">&#9670;&nbsp;</a></span>common_bin()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::StreamIndexBase::common_bin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the most specific bin that contains both of the given node IDs. </p>

</div>
</div>
<a id="a6448cab1126089223a17c2ed6d943a97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6448cab1126089223a17c2ed6d943a97">&#9670;&nbsp;</a></span>find() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::StreamIndexBase::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>min_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>max_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(int64_t, int64_t)&gt;&#160;</td>
          <td class="paramname"><em>scan_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find all the ranges of run virtual offsets to check for reads visiting the given inclusive node ID range. Relies on a scanning callback, which will be called repeatedly with the start and past-the-end virtual offsets of runs which may contain groups touching the given node ID. When called, the callback should scan the run and return either true if it wants the next run, or false if it encountered a group with an out-of-range start and wants to stop iteration. Runs will be emitted in order, and truncated on the left to either the appropriate lower bound from the linear index, or the past-the-end of the previous run scanned. </p>

</div>
</div>
<a id="a7c332ce59d0a99ac7c2ef69d77b0f749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c332ce59d0a99ac7c2ef69d77b0f749">&#9670;&nbsp;</a></span>find() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::StreamIndexBase::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find all the ranges of run virtual offsets from the first position that might be relevant for the given node ID to the ends of all the bins it is in. Trims ranges by the linear index on the low end, and returns a series of potentially abutting but non-overlapping virtual offset ranges. Does not stop early (because it has no access to the actual reads to tell when it should stop looking at runs in a bin). So you will get ranges covering all runs in a bin that follow the runs you are interested in as well. </p>

</div>
</div>
<a id="ad520b5b3241ee162ffd02c2cac5bd702"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad520b5b3241ee162ffd02c2cac5bd702">&#9670;&nbsp;</a></span>find() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::StreamIndexBase::find </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>node_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(int64_t, int64_t)&gt;&#160;</td>
          <td class="paramname"><em>scan_callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Find all the ranges of run virtual offsets to check for reads visiting the given node ID. Relies on a scanning callback, which will be called repeatedly with the start and past-the-end virtual offsets of runs which may contain groups touching the given node ID. When called, the callback should scan the run and return either true if it wants the next run, or false if it encountered a group with an out-of-range start and wants to stop iteration. Runs will be emitted in order, and truncated on the left to either the appropriate lower bound from the linear index, or the past-the-end of the previous run scanned (which should be moot, because runs should not overlap in the index). </p>

</div>
</div>
<a id="a4b0e44b8cb40b33c5ef4db47a8a89272"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b0e44b8cb40b33c5ef4db47a8a89272">&#9670;&nbsp;</a></span>id_to_prefix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::StreamIndexBase::id_to_prefix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the given ID as a bit string. </p>

</div>
</div>
<a id="ab2b832d8cca9dee3c38d452dc47da0e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2b832d8cca9dee3c38d452dc47da0e3">&#9670;&nbsp;</a></span>is_in_range()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::StreamIndexBase::is_in_range </td>
          <td>(</td>
          <td class="paramtype">const vector&lt; pair&lt; <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>, <a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>ranges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return true if the given ID is in any of the sorted, coalesced, inclusive ranges in the vector, and false otherwise. TODO: Is repeated binary search on the ranges going to be better than an unordered_set of all the individual IDs? </p>

</div>
</div>
<a id="af30b1923f99ff4946103625f90ea1d9c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af30b1923f99ff4946103625f90ea1d9c">&#9670;&nbsp;</a></span>load()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::StreamIndexBase::load </td>
          <td>(</td>
          <td class="paramtype">istream &amp;&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Load an index from a file. File holds the index, not the actual data being indexed. Index file format doesn't care what type of message is being indexed. </p>

</div>
</div>
<a id="ab0ac239e55d7748226a6a2d08480e026"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0ac239e55d7748226a6a2d08480e026">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1StreamIndexBase.html">StreamIndexBase</a>&amp; vg::StreamIndexBase::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1StreamIndexBase.html">StreamIndexBase</a> &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a99761d4d917dc5ba1db1e08a36ceb312"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99761d4d917dc5ba1db1e08a36ceb312">&#9670;&nbsp;</a></span>save()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::StreamIndexBase::save </td>
          <td>(</td>
          <td class="paramtype">ostream &amp;&#160;</td>
          <td class="paramname"><em>to</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Save an index to a file. </p>

</div>
</div>
<a id="addb451cabccc43915ae629925b3ed3ee"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addb451cabccc43915ae629925b3ed3ee">&#9670;&nbsp;</a></span>scan_backward()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::StreamIndexBase::scan_backward </td>
          <td>(</td>
          <td class="paramtype">const function&lt; bool(int64_t, int64_t)&gt;&#160;</td>
          <td class="paramname"><em>scan_callback</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over ranges of virtual offsets from the end of the file to the start. The ranges to <em>not</em> necessarily correspond to runs. The ending VO of the first range iterated may be <a class="el" href="namespacestd.html#a032e2e35689ce96dfb488db853f83334" title="Allow maxing TracedScore.">numeric_limits&lt;int64_t&gt;::max()</a>. The start VO of each range is guaranteed to be a valid VO of a group. The past-end VO may be the start of the previously iterated range. We have no scan_forward because you can just do that with a cursor. Stops when the callback returns false. </p>

</div>
</div>
<a id="a94777b19236dfb74d66ba8c484bf663f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94777b19236dfb74d66ba8c484bf663f">&#9670;&nbsp;</a></span>used_bins_of_range()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::StreamIndexBase::used_bins_of_range </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>min_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>max_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const function&lt; bool(<a class="el" href="classvg_1_1StreamIndexBase.html#a1de6fb384732cab26d21f38f133bc9e9">bin_t</a>)&gt; &amp;&#160;</td>
          <td class="paramname"><em>iteratee</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Iterate over the <em>populated</em> bins in the index, in in-order bin tree traversal order, that any of the node IDs in the given inclusive range occur in. Returns false if asked to stop. </p>

</div>
</div>
<a id="a320b27d89fbc1a74574cc00befe1e7fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a320b27d89fbc1a74574cc00befe1e7fe">&#9670;&nbsp;</a></span>window_of_id()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto vg::StreamIndexBase::window_of_id </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Get the linear index window that the given node ID falls in. The window range for a group is its min nodes' window through its max node's window. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a4801a54e202c9214718c71db7cea12a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4801a54e202c9214718c71db7cea12a9">&#9670;&nbsp;</a></span>bin_to_ranges</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unordered_map&lt;<a class="el" href="classvg_1_1StreamIndexBase.html#a1de6fb384732cab26d21f38f133bc9e9">bin_t</a>, vector&lt;pair&lt;int64_t, int64_t&gt; &gt; &gt; vg::StreamIndexBase::bin_to_ranges</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps from bin number to all the ranges of virtual offsets, in order, for runs that land in the given bin. A run lands in a bin if that bin is the most specific bin that includes both its lowest and highest nodes it uses. </p>

</div>
</div>
<a id="a19b9a91061212bfd558a384fa19d4854"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a19b9a91061212bfd558a384fa19d4854">&#9670;&nbsp;</a></span>bins_by_id_prefix</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1BitStringTree.html">BitStringTree</a>&lt;<a class="el" href="classvg_1_1StreamIndexBase.html#a1de6fb384732cab26d21f38f133bc9e9">bin_t</a>&gt; vg::StreamIndexBase::bins_by_id_prefix</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps from the bit string representing the prefix of node IDs that a bin matches to the bin's bin number. Only contains entries for nonempty bins. </p>

</div>
</div>
<a id="aef3a7bd46aeb49185a8cd6a9a261e883"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef3a7bd46aeb49185a8cd6a9a261e883">&#9670;&nbsp;</a></span>last_group_min_id</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a> vg::StreamIndexBase::last_group_min_id = numeric_limits&lt;<a class="el" href="namespacevg.html#afaa15fd8bdfd688d48561e1b12aee821">id_t</a>&gt;::min()</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>What was the minimum node ID of the last group added? If this isn't strictly increasing, we're trying to index data that is not sorted. </p>

</div>
</div>
<a id="a9bbb2b0134f0e831fc2ec5db056b7397"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bbb2b0134f0e831fc2ec5db056b7397">&#9670;&nbsp;</a></span>MAGIC_BYTES</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const string vg::StreamIndexBase::MAGIC_BYTES = &quot;GAI!&quot;</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>What magic value do we embed in the compressed index data? TODO: Make this depend on type of message being indexed so we can't mix up index files. </p>

</div>
</div>
<a id="aa497c1ad37621af86f5f40d45e0f30b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa497c1ad37621af86f5f40d45e0f30b2">&#9670;&nbsp;</a></span>MAX_INPUT_VERSION</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static uint32_t vg::StreamIndexBase::MAX_INPUT_VERSION = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What's the maximum index version number we can read with this code? </p>

</div>
</div>
<a id="ad5ce82f31552d36c073e65ced2af529e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ce82f31552d36c073e65ced2af529e">&#9670;&nbsp;</a></span>OUTPUT_VERSION</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static uint32_t vg::StreamIndexBase::OUTPUT_VERSION = 1</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>What's the version we serialize? </p>

</div>
</div>
<a id="a1f8223f4ff9ca3d9892d13d2708aff73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f8223f4ff9ca3d9892d13d2708aff73">&#9670;&nbsp;</a></span>WINDOW_SHIFT</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const static size_t vg::StreamIndexBase::WINDOW_SHIFT = 8</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a47fab2baab7953595105558d0fcba4e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47fab2baab7953595105558d0fcba4e2">&#9670;&nbsp;</a></span>window_to_start</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">map&lt;<a class="el" href="classvg_1_1StreamIndexBase.html#ad94010282265d6d8743f31ed5b3e98ce">window_t</a>, int64_t&gt; vg::StreamIndexBase::window_to_start</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Maps from linear index window to the virtual offset of the first group that overlaps that window (taking the group as a min-to-max node range). If you are looking for reads that visit a node, they can't possibly occur in a group before the first offset stored for the node's window (or any greater window). TODO: Should we make this a vector instead and hope nobody uses high/sparse node IDs? </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="stream__index_8hpp.html">stream_index.hpp</a></li>
<li>src/<a class="el" href="stream__index_8cpp.html">stream_index.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
