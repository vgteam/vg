<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>vg: vg::io::ProtobufEmitter&lt; T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">vg
   </div>
   <div id="projectbrief">tools for working with variation graphs</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacevg.html">vg</a></li><li class="navelem"><a class="el" href="namespacevg_1_1io.html">io</a></li><li class="navelem"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a> &#124;
<a href="classvg_1_1io_1_1ProtobufEmitter-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">vg::io::ProtobufEmitter&lt; T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;protobuf_emitter.hpp&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a3fdef59aeb9c688e752463a2257ebbfd"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a3fdef59aeb9c688e752463a2257ebbfd">group_listener_t</a> = std::function&lt; void(int64_t, int64_t)&gt;</td></tr>
<tr class="separator:a3fdef59aeb9c688e752463a2257ebbfd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735167dc9e644a83d0e9fd206b241ce1"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a735167dc9e644a83d0e9fd206b241ce1">message_listener_t</a> = std::function&lt; void(const T &amp;)&gt;</td></tr>
<tr class="separator:a735167dc9e644a83d0e9fd206b241ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:ab9d133fa3604ba677c12337ccf609ba7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#ab9d133fa3604ba677c12337ccf609ba7">ProtobufEmitter</a> (std::ostream &amp;out, bool compress=true, size_t max_group_size=1000)</td></tr>
<tr class="separator:ab9d133fa3604ba677c12337ccf609ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1994a31484b9a52710a38315adb2bcc"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#ab1994a31484b9a52710a38315adb2bcc">~ProtobufEmitter</a> ()</td></tr>
<tr class="memdesc:ab1994a31484b9a52710a38315adb2bcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor that finishes the file.  <a href="classvg_1_1io_1_1ProtobufEmitter.html#ab1994a31484b9a52710a38315adb2bcc">More...</a><br /></td></tr>
<tr class="separator:ab1994a31484b9a52710a38315adb2bcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1adf66f9c9242369dcdd38746f925855"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a1adf66f9c9242369dcdd38746f925855">ProtobufEmitter</a> (const <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a> &amp;other)=delete</td></tr>
<tr class="separator:a1adf66f9c9242369dcdd38746f925855"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad81cc27d627747dc34683bb2e0500ff6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#ad81cc27d627747dc34683bb2e0500ff6">operator=</a> (const <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a> &amp;other)=delete</td></tr>
<tr class="separator:ad81cc27d627747dc34683bb2e0500ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accd8d7c57bffcfdc48ba7085f7a53561"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#accd8d7c57bffcfdc48ba7085f7a53561">ProtobufEmitter</a> (<a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:accd8d7c57bffcfdc48ba7085f7a53561"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d4c3a9c587971479a5b9a2a6c50db74"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a7d4c3a9c587971479a5b9a2a6c50db74">operator=</a> (<a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a> &amp;&amp;other)=default</td></tr>
<tr class="separator:a7d4c3a9c587971479a5b9a2a6c50db74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2956417dd81044bd5134794693942fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#af2956417dd81044bd5134794693942fd">write</a> (T &amp;&amp;item)</td></tr>
<tr class="separator:af2956417dd81044bd5134794693942fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05abdc0c51cc62b21c849c2ef13e81e0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a05abdc0c51cc62b21c849c2ef13e81e0">write_many</a> (vector&lt; T &gt; &amp;&amp;ordered_items)</td></tr>
<tr class="separator:a05abdc0c51cc62b21c849c2ef13e81e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ded624b6ba6d5dddf1abe668214ce7e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a8ded624b6ba6d5dddf1abe668214ce7e">write_copy</a> (const T &amp;item)</td></tr>
<tr class="separator:a8ded624b6ba6d5dddf1abe668214ce7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af22328bc428af2be817a7a0d097ca370"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#af22328bc428af2be817a7a0d097ca370">on_group</a> (<a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a3fdef59aeb9c688e752463a2257ebbfd">group_listener_t</a> &amp;&amp;listener)</td></tr>
<tr class="separator:af22328bc428af2be817a7a0d097ca370"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a3a16550dcd7dd7a320109125d4e2a1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a6a3a16550dcd7dd7a320109125d4e2a1">on_message</a> (<a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a735167dc9e644a83d0e9fd206b241ce1">message_listener_t</a> &amp;&amp;listener)</td></tr>
<tr class="memdesc:a6a3a16550dcd7dd7a320109125d4e2a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add an event listener that will be called every time a message is emitted.  <a href="classvg_1_1io_1_1ProtobufEmitter.html#a6a3a16550dcd7dd7a320109125d4e2a1">More...</a><br /></td></tr>
<tr class="separator:a6a3a16550dcd7dd7a320109125d4e2a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b19615de43ba7ef0fc38487fe7e811"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a55b19615de43ba7ef0fc38487fe7e811">emit_group</a> ()</td></tr>
<tr class="separator:a55b19615de43ba7ef0fc38487fe7e811"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefba5ddea6beff54f293b95f7549d944"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#aefba5ddea6beff54f293b95f7549d944">flush</a> ()</td></tr>
<tr class="separator:aefba5ddea6beff54f293b95f7549d944"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:afb457287f96e5ed57d53f91fd5247ec7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#afb457287f96e5ed57d53f91fd5247ec7">handle</a> (bool ok)</td></tr>
<tr class="memdesc:afb457287f96e5ed57d53f91fd5247ec7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make sure the given Protobuf-library bool return value is true, and fail otherwise with a message.  <a href="classvg_1_1io_1_1ProtobufEmitter.html#afb457287f96e5ed57d53f91fd5247ec7">More...</a><br /></td></tr>
<tr class="separator:afb457287f96e5ed57d53f91fd5247ec7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:acb50db8c0f33135ae2e246ae26efb9d0"><td class="memItemLeft" align="right" valign="top">mutex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#acb50db8c0f33135ae2e246ae26efb9d0">out_mutex</a></td></tr>
<tr class="separator:acb50db8c0f33135ae2e246ae26efb9d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bdc1e48041d69eeca45745580af19f3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classvg_1_1io_1_1MessageEmitter.html">MessageEmitter</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a1bdc1e48041d69eeca45745580af19f3">message_emitter</a></td></tr>
<tr class="memdesc:a1bdc1e48041d69eeca45745580af19f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">We wrap a <a class="el" href="classvg_1_1io_1_1MessageEmitter.html">MessageEmitter</a> that handles tagged message IO.  <a href="classvg_1_1io_1_1ProtobufEmitter.html#a1bdc1e48041d69eeca45745580af19f3">More...</a><br /></td></tr>
<tr class="separator:a1bdc1e48041d69eeca45745580af19f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17e22f4ea8e69209b9aff2c00deb9ba4"><td class="memItemLeft" align="right" valign="top">string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a17e22f4ea8e69209b9aff2c00deb9ba4">tag</a></td></tr>
<tr class="memdesc:a17e22f4ea8e69209b9aff2c00deb9ba4"><td class="mdescLeft">&#160;</td><td class="mdescRight">And a single precomputed copy of the tag string to use.  <a href="classvg_1_1io_1_1ProtobufEmitter.html#a17e22f4ea8e69209b9aff2c00deb9ba4">More...</a><br /></td></tr>
<tr class="separator:a17e22f4ea8e69209b9aff2c00deb9ba4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a176d09f4d40ef21965c7a66abc546dbd"><td class="memItemLeft" align="right" valign="top">list&lt; <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a3fdef59aeb9c688e752463a2257ebbfd">group_listener_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a176d09f4d40ef21965c7a66abc546dbd">group_handlers</a></td></tr>
<tr class="separator:a176d09f4d40ef21965c7a66abc546dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73231a5a45811c280d1a6d346abc75eb"><td class="memItemLeft" align="right" valign="top">vector&lt; <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a735167dc9e644a83d0e9fd206b241ce1">message_listener_t</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a73231a5a45811c280d1a6d346abc75eb">message_handlers</a></td></tr>
<tr class="memdesc:a73231a5a45811c280d1a6d346abc75eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">These we invoke ourselves per message.  <a href="classvg_1_1io_1_1ProtobufEmitter.html#a73231a5a45811c280d1a6d346abc75eb">More...</a><br /></td></tr>
<tr class="separator:a73231a5a45811c280d1a6d346abc75eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename T&gt;<br />
class vg::io::ProtobufEmitter&lt; T &gt;</h3>

<p>Class that wraps an output stream and allows emitting groups of Protobuf objects to it, with internal buffering. Handles finishing the file on its own, and allows tracking of BGZF virtual offsets within a non-seekable stream (as long as the entire stream is controlled by one instance). Cannot be copied, but can be moved.</p>
<p>Can call callbacks with the groups emitted and their virtual offsets, for indexing purposes.</p>
<p>Note that the callbacks may be called by the <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a>'s destructor, so anything they reference needs to outlive the <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a>.</p>
<p>Writes compressed <a class="el" href="classvg_1_1io_1_1VPKG.html">VPKG</a> data by default.</p>
<p>May be more efficient than repeated write/write_buffered calls because a single BGZF stream can be used.</p>
<p>Thread-safe to call into. Serialization is done before locking. If a particular order is needed between objects, use the multi-object write functions. Listeners will be called inside the lock, so only one will be in progress at a time. </p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a id="a3fdef59aeb9c688e752463a2257ebbfd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdef59aeb9c688e752463a2257ebbfd">&#9670;&nbsp;</a></span>group_listener_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::<a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a3fdef59aeb9c688e752463a2257ebbfd">group_listener_t</a> =  std::function&lt;void(int64_t, int64_t)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define a type for group emission event listeners. The arguments are the start virtual offset and the past-end virtual offset. </p>

</div>
</div>
<a id="a735167dc9e644a83d0e9fd206b241ce1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735167dc9e644a83d0e9fd206b241ce1">&#9670;&nbsp;</a></span>message_listener_t</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::<a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a735167dc9e644a83d0e9fd206b241ce1">message_listener_t</a> =  std::function&lt;void(const T&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Define a type for message emission event listeners. This gets called for every message we emit, and then the group listeners get called for the whole group. </p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ab9d133fa3604ba677c12337ccf609ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab9d133fa3604ba677c12337ccf609ba7">&#9670;&nbsp;</a></span>ProtobufEmitter() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::<a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a> </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>out</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>compress</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_group_size</em> = <code>1000</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><a class="el" href="classvg_1_1Constructor.html">Constructor</a>. Writes type-tagged Protobuf data to the given output stream. If compress is true, data will be BGZF-compressed. The maximum number of Protobuf messages in a tagged group is controlled by max_group_size. </p>

</div>
</div>
<a id="ab1994a31484b9a52710a38315adb2bcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1994a31484b9a52710a38315adb2bcc">&#9670;&nbsp;</a></span>~ProtobufEmitter()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::~<a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor that finishes the file. </p>

</div>
</div>
<a id="a1adf66f9c9242369dcdd38746f925855"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1adf66f9c9242369dcdd38746f925855">&#9670;&nbsp;</a></span>ProtobufEmitter() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::<a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="accd8d7c57bffcfdc48ba7085f7a53561"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accd8d7c57bffcfdc48ba7085f7a53561">&#9670;&nbsp;</a></span>ProtobufEmitter() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::<a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a55b19615de43ba7ef0fc38487fe7e811"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b19615de43ba7ef0fc38487fe7e811">&#9670;&nbsp;</a></span>emit_group()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::emit_group</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Actually write out everything in the buffer. Doesn't actually flush the underlying streams to disk. Assumes that no more than one group's worth of items are in the buffer. </p>

</div>
</div>
<a id="aefba5ddea6beff54f293b95f7549d944"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefba5ddea6beff54f293b95f7549d944">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::flush</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Write out anything in the buffer, and flush the backing BGZF and the backing stream. After this function is called, a complete BGZF block has been output (unless another thead has written something). </p>

</div>
</div>
<a id="afb457287f96e5ed57d53f91fd5247ec7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb457287f96e5ed57d53f91fd5247ec7">&#9670;&nbsp;</a></span>handle()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::handle </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ok</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Make sure the given Protobuf-library bool return value is true, and fail otherwise with a message. </p>

</div>
</div>
<a id="af22328bc428af2be817a7a0d097ca370"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af22328bc428af2be817a7a0d097ca370">&#9670;&nbsp;</a></span>on_group()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::on_group </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a3fdef59aeb9c688e752463a2257ebbfd">group_listener_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Add an event listener that listens for emitted groups. The listener will be called with the start virtual offset, and the past-end virtual offset. Moves the function passed in. Anything the function uses by reference must outlive this object! </p>

</div>
</div>
<a id="a6a3a16550dcd7dd7a320109125d4e2a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a3a16550dcd7dd7a320109125d4e2a1">&#9670;&nbsp;</a></span>on_message()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::on_message </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a735167dc9e644a83d0e9fd206b241ce1">message_listener_t</a> &amp;&amp;&#160;</td>
          <td class="paramname"><em>listener</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add an event listener that will be called every time a message is emitted. </p>

</div>
</div>
<a id="ad81cc27d627747dc34683bb2e0500ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad81cc27d627747dc34683bb2e0500ff6">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a>&amp; <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a>&lt; T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">delete</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d4c3a9c587971479a5b9a2a6c50db74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d4c3a9c587971479a5b9a2a6c50db74">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a>&amp; <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">ProtobufEmitter</a>&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af2956417dd81044bd5134794693942fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2956417dd81044bd5134794693942fd">&#9670;&nbsp;</a></span>write()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::write </td>
          <td>(</td>
          <td class="paramtype">T &amp;&amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Emit the given item. TODO: May not really be any more efficient. We serialize to string right away in either case. </p>

</div>
</div>
<a id="a8ded624b6ba6d5dddf1abe668214ce7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ded624b6ba6d5dddf1abe668214ce7e">&#9670;&nbsp;</a></span>write_copy()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::write_copy </td>
          <td>(</td>
          <td class="paramtype">const T &amp;&#160;</td>
          <td class="paramname"><em>item</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Emit a copy of the given item. To use when you have something you can't move. </p>

</div>
</div>
<a id="a05abdc0c51cc62b21c849c2ef13e81e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05abdc0c51cc62b21c849c2ef13e81e0">&#9670;&nbsp;</a></span>write_many()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">auto <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::write_many </td>
          <td>(</td>
          <td class="paramtype">vector&lt; T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>ordered_items</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Emit the given collection of items in order, with no other intervening items between them. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="a176d09f4d40ef21965c7a66abc546dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a176d09f4d40ef21965c7a66abc546dbd">&#9670;&nbsp;</a></span>group_handlers</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">list&lt;<a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a3fdef59aeb9c688e752463a2257ebbfd">group_listener_t</a>&gt; <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::group_handlers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>And all the group handler functions. These need to never move; they are captured by reference to listeners in our <a class="el" href="classvg_1_1io_1_1MessageEmitter.html">MessageEmitter</a>. </p>

</div>
</div>
<a id="a1bdc1e48041d69eeca45745580af19f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bdc1e48041d69eeca45745580af19f3">&#9670;&nbsp;</a></span>message_emitter</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classvg_1_1io_1_1MessageEmitter.html">MessageEmitter</a> <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::message_emitter</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>We wrap a <a class="el" href="classvg_1_1io_1_1MessageEmitter.html">MessageEmitter</a> that handles tagged message IO. </p>

</div>
</div>
<a id="a73231a5a45811c280d1a6d346abc75eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73231a5a45811c280d1a6d346abc75eb">&#9670;&nbsp;</a></span>message_handlers</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">vector&lt;<a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html#a735167dc9e644a83d0e9fd206b241ce1">message_listener_t</a>&gt; <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::message_handlers</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>These we invoke ourselves per message. </p>

</div>
</div>
<a id="acb50db8c0f33135ae2e246ae26efb9d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb50db8c0f33135ae2e246ae26efb9d0">&#9670;&nbsp;</a></span>out_mutex</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">mutex <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::out_mutex</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Mutex to controll access to the backing <a class="el" href="classvg_1_1io_1_1MessageEmitter.html">MessageEmitter</a>. Also needs to control access to the listener lists. </p>

</div>
</div>
<a id="a17e22f4ea8e69209b9aff2c00deb9ba4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17e22f4ea8e69209b9aff2c00deb9ba4">&#9670;&nbsp;</a></span>tag</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">string <a class="el" href="classvg_1_1io_1_1ProtobufEmitter.html">vg::io::ProtobufEmitter</a>&lt; T &gt;::tag</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>And a single precomputed copy of the tag string to use. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>deps/libvgio/include/vg/io/<a class="el" href="protobuf__emitter_8hpp.html">protobuf_emitter.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.9.1-->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.9.1
</small></address>
</body>
</html>
